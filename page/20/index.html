
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 20 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--EightQueen/">EightQueen</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T09:54:44.000Z"> <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--EightQueen/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="eightqueen">EightQueen</h1>
<h1 id="-algorithm-gossip-"><a href="">Algorithm Gossip: 八个皇后</a></h1>
<h2 id="-">说明</h2>
<p>西洋棋中的皇后可以直线前进，吃掉遇到的所有棋子，如果棋盘上有八个皇后，则这八个皇后如何相安无事的放置在棋盘上，1970年与1971年， E.W.Dijkstra与N.Wirth曾经用这个问题来讲解程式设计之技巧。</p>
<h2 id="-">解法</h2>
<p>关于棋盘的问题，都可以用递回求解，然而如何减少递回的次数？在八个皇后的问题中，不必要所有的格子都检查过，例如若某列检查过，该该列的其它格子就不用再检查了，这个方法称为分支修剪。
<img src="&quot;八个皇后&quot;" alt="八个皇后">
所以检查时，先判断是否在已放置皇后的可行进方向上，如果没有再行放置下一个皇后，如此就可大大减少递回的次数，例如以下为修剪过后的递回检查行进路径：
<img src="&quot;八个皇后&quot;" alt="八个皇后">
八个皇后的话，会有92个解答，如果考虑棋盘的旋转，则旋转后扣去对称的，会有12组基本解。 </p>
<h2 id="-">实作</h2>
<ul>
<li><p>C
/#include <stdio.h>
/#include <stdlib.h>
/#define N 8
int column[N+1]; // 同栏是否有皇后，1表示有
int rup[2/<em>N+1]; // 右上至左下是否有皇后
int lup[2/</em>N+1]; // 左上至右下是否有皇后
int queen[N+1] = {0};
int num; // 解答编号
void backtrack(int); // 递回求解
int main(void) {
int i;
num = 0;
for(i = 1; i &lt;= N; i++)
column[i] = 1;
for(i = 1; i &lt;= 2/*N; i++)
rup[i] = lup[i] = 1;
backtrack(1);
return 0;
}
void showAnswer() {
int x, y;
printf(&quot;\n解答 %d\n&quot;, ++num);
for(y = 1; y &lt;= N; y++) {
for(x = 1; x &lt;= N; x++) {
if(queen[y] == x) {
printf(&quot; Q&quot;);
}
else {
printf(&quot; .&quot;);
}
}
printf(&quot;\n&quot;);
}
}
void backtrack(int i) {
int j;
if(i &gt; N) {
showAnswer();
}
else {
for(j = 1; j &lt;= N; j++) {
if(column[j] == 1 &amp;&amp;
rup[i+j] == 1 &amp;&amp; lup[i-j+N] == 1) {
queen[i] = j;
// 设定为占用
column[j] = rup[i+j] = lup[i-j+N] = 0;
backtrack(i+1);
column[j] = rup[i+j] = lup[i-j+N] = 1;
}
}
}
}</p>
</li>
<li><p>Java
public class Queen {
// 同栏是否有皇后，1表示有
private int[] column;
// 右上至左下是否有皇后
private int[] rup;
// 左上至右下是否有皇后
private int[] lup;
// 解答
private int[] queen;
// 解答编号
private int num;
public Queen() {
column = new int[8+1];
rup = new int[2/<em>8+1];
lup = new int[2/</em>8+1];
for(int i = 1; i &lt;= 8; i++)
column[i] = 1;
for(int i = 1; i &lt;= 2/*8; i++)
rup[i] = lup[i] = 1;
queen = new int[8+1];
}
public void backtrack(int i) {
if(i &gt; 8) {
showAnswer();
}
else {
for(int j = 1; j &lt;= 8; j++) {
if(column[j] == 1 &amp;&amp;
rup[i+j] == 1 &amp;&amp;
lup[i-j+8] == 1) {
queen[i] = j;
// 设定为占用
column[j] = rup[i+j] = lup[i-j+8] = 0;
backtrack(i+1);
column[j] = rup[i+j] = lup[i-j+8] = 1;
}
}
}
}
protected void showAnswer() {
num++;
System.out.println(&quot;\n解答 &quot; + num);
for(int y = 1; y &lt;= 8; y++) {
for(int x = 1; x &lt;= 8; x++) {
if(queen[y] == x) {
System.out.print(&quot; Q&quot;);
}
else {
System.out.print(&quot; .&quot;);
}
}
System.out.println();
}
}
public static void main(String[] args) {
Queen queen = new Queen();
queen.backtrack(1);
}
}</p>
</li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/AlgorithmGossip/">AlgorithmGossip</a></li></span></span> | <span class="tags">Tagged <a href="/tags/AlgorithmGossip/" class="label label-primary">AlgorithmGossip</a></span> | <span class="time">recent updated:<time title="2014-03-07 02:38:11"datetime="2014-03-07 02:38:11"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--EightQueen/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-AlgorithmGossip-AlgorithmGossip--EightQueen" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-xml-xstream--使用XStream序列化、反序列化XML数据时遇到的各种问题/">使用XStream序列化、反序列化XML数据时遇到的各种问题</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T09:54:44.000Z"> <a href="/2014/02/02/2014-02-02-xml-xstream--使用XStream序列化、反序列化XML数据时遇到的各种问题/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-xstream-xml-">使用XStream序列化、反序列化XML数据时遇到的各种问题</h1>
<p>现在参与的项目是一个纯Application Server，整个Server都是自己搭建的，使用JMS消息实现客户端和服务器的交互，交互的数据格式采用XML。说来惭愧，开始为了赶进度，所有XML消息都是使用字符串拼接的，而XML的解析则是使用DOM方式查找的。我很早就看这些代码不爽了，可惜一直没有时间去重构，最近项目加了几个人，而且美国那边也开始渐渐的把这个项目开发的控制权交给我们了，所以我开始有一些按自己的方式开发的机会了。因而最近动手开始重构这些字符串拼接的代码。</p>
<p>对XML到Java Bean的解析框架，熟悉一点的只有Digester和XStream，Digester貌似只能从XML文件解析成Java Bean对象，所以只能选择XStream来做了，而且同组的其他项目也有在用XStream。一直听说XStream的使用比较简单，而且我对ThoughtWorks这家公司一直比较有好感，所以还以为引入XStream不会花太多时间，然而使用以后才发现XStream并没有想象的你那么简单。不过这个也有可能是因为我不想改变原来的XML数据格式，而之前的XML数据格式的设计自然不会考虑到如何便利的使用XStream。因而记录在使用过程中遇到的问题，供后来人参考，也为自己以后如果打算开其源码提供参考。废话就到这里了，接下来步入正题。</p>
<p>首先对于简单的引用，XStream使用起来确实比较简单，比如自定义标签的属性、使用属性和使用子标签的定义等：
@XStreamAlias(&quot;request&quot;)
public class XmlRequest1 {
    private static XStream xstream;
    static {
        xstream = new XStream();
        xstream.autodetectAnnotations(true);
    }</p>
<pre><code>@XStreamAsAttribute
private String from;

@XStreamAsAttribute
@XStreamAlias(&quot;calculate-method&quot;)
private String calculateMethod;

@XStreamAlias(&quot;request-time&quot;)
private Date requestTime;

@XStreamAlias(&quot;input-files&quot;)
private List&lt;InputFileInfo&gt; inputFiles;

public static String toXml(XmlRequest1 request) {
    StringWriter writer = new StringWriter();
    writer.append(Constants.XML_HEADER);
    xstream.toXML(request, writer);
    return writer.toString();
}
public static XmlRequest1 toInstance(String xmlContent) {
    return (XmlRequest1)xstream.fromXML(xmlContent);
</code></pre><p>}
<img src="" alt="">
    @XStreamAlias(&quot;input-file&quot;)
    public static class InputFileInfo {
        private String type;
        private String fileName;
        <img src="" alt="">
    }
    public static void main(String[] args) {
        XmlRequest1 request = buildXmlRequest();
        System.out.println(XmlRequest1.toXml(request));
    }
    private static XmlRequest1 buildXmlRequest() {
        <img src="" alt="">
    }
}</p>
<p> 对以上Request定义，我们可以得到如下结果：</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</p>
<request from="levin@host" calculate-method="advanced">
 <request-time>2012-11-28 17:11:54.664 UTC</request-time>
 <input-files>
    <input-file>
      <type>DATA</type>
      <fileName>data.2012.11.29.dat</fileName>
    </input-file>
    <input-file>
      <type>CALENDAR</type>
      <fileName>calendar.2012.11.29.dat</fileName>
    </input-file>
 </input-files>
</request>

<p>可惜这个世界不会那么清净，这个格式有些时候貌似并不符合要求，比如request-time的格式、input-files的格式，我们实际需要的格式是这样的：</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</p>
<request from="levin@host" calculate-method="advanced">
 <request-time>20121128T17:51:05</request-time>
 <input-file type="DATA">data.2012.11.29.dat</input-file>
 <input-file type="CALENDAR">calendar.2012.11.29.dat</input-file>
</request>

<p>对不同Date格式的支持可以是用Converter实现，在XStream中默认使用自己实现的DateConverter，它支持的格式是：yyyy-MM-dd HH:mm:ss.S &#39;UTC&#39;，然而我们现在需要的格式是yyyy-MM-dd’T’HH:mm:ss，如果使用XStream直接注册DateConverter，可以使用配置自己的DateConverter，但是由于DateConverter的构造函数的定义以及@XStreamConverter的构造函数参数的支持方式的限制，貌似DateConverter不能很好的支持注解方式的注册，因而我时间了一个自己的DateConverter以支持注解：</p>
<p>public class LevinDateConverter extends DateConverter {
    public LevinDateConverter(String dateFormat) {
        super(dateFormat, new String[] { dateFormat });
    }
}</p>
<p>在requestTime字段中需要加入以下注解定义：</p>
<p>@XStreamConverter(value=LevinDateConverter.class, strings={&quot;yyyyMMdd&#39;T&#39;HH:mm:ss&quot;})
@XStreamAlias(&quot;request-time&quot;)
private Date requestTime;</p>
<p>对集合类，XStream提供了@XStreamImplicit注解，以将集合中的内容摊平到上一层XML元素中，其中itemFieldName的值为其使用的标签名，此时InputFileInfo类中不需要@XStreamAlias标签的定义：</p>
<p>@XStreamImplicit(itemFieldName=&quot;input-file&quot;)
private List<InputFileInfo> inputFiles;</p>
<p>对InputFileInfo中的字段，type作为属性很容易，只要为它加上@XStreamAsAttribute注解即可，而将fileName作为input-file标签的一个内容字符串，则需要使用ToAttributedValueConverter，其中Converter的参数为需要作为字符串内容的字段名：</p>
<p>@XStreamConverter(value=ToAttributedValueConverter.class, strings={&quot;fileName&quot;})
public static class InputFileInfo {
    @XStreamAsAttribute
    private String type;
private String fileName;
<img src="" alt="">
}</p>
<p>XStream对枚举类型的支持貌似不怎么好，默认注册的EnumSingleValueConverter只是使用了Enum提供的name()和静态的valueOf()方法将enum转换成String或将String转换回enum。然而有些时候XML的字符串和类定义的enum值并不完全匹配，最常见的就是大小写的不匹配，此时需要写自己的Converter。在这种情况下，我一般会在enum中定义一个name属性，这样就可以自定义enum的字符串表示。比如有TimePeriod的enum：</p>
<p>public enum TimePeriod {
    MONTHLY(&quot;monthly&quot;), WEEKLY(&quot;weekly&quot;), DAILY(&quot;daily&quot;);</p>
<pre><code>private String name;

public String getName() {
    return name;
}

private TimePeriod(String name) {
    this.name = name;
}

public static TimePeriod toEnum(String timePeriod) {
    try {
        return Enum.valueOf(TimePeriod.class, timePeriod);
    } catch(Exception ex) {
        for(TimePeriod period : TimePeriod.values()) {
            if(period.getName().equalsIgnoreCase(timePeriod)) {
                return period;
            }
        }
        throw new IllegalArgumentException(&quot;Cannot convert &lt;&quot; + timePeriod + &quot;&gt; to TimePeriod enum&quot;);
    }
}
</code></pre><p>}</p>
<p>我们可以编写以下Converter以实现对枚举类型的更宽的容错性：</p>
<p>public class LevinEnumSingleNameConverter extends EnumSingleValueConverter {
    private static final String CUSTOM_ENUM_NAME_METHOD = &quot;getName&quot;;
    private static final String CUSTOM_ENUM_VALUE_OF_METHOD = &quot;toEnum&quot;;</p>
<pre><code>private Class&lt;? extends Enum&lt;?&gt;&gt; enumType;

public LevinEnumSingleNameConverter(Class&lt;? extends Enum&lt;?&gt;&gt; type) {
    super(type);
    this.enumType = type;
}

@Override
public String toString(Object obj) {
    Method method = getCustomEnumNameMethod();
    if(method == null) {
        return super.toString(obj);
    } else {
        try {
            return (String)method.invoke(obj, (Object[])null);
        } catch(Exception ex) {
            return super.toString(obj);
        }
    }
}

@Override
public Object fromString(String str) {
    Method method = getCustomEnumStaticValueOfMethod();
    if(method == null) {
        return enhancedFromString(str);
    }
    try {
        return method.invoke(null, str);
    } catch(Exception ex) {
        return enhancedFromString(str);
    }
}

private Method getCustomEnumNameMethod() {
    try {
        return enumType.getMethod(CUSTOM_ENUM_NAME_METHOD, (Class&lt;?&gt;[])null);
    } catch(Exception ex) {
        return null;
    }
}

private Method getCustomEnumStaticValueOfMethod() {
    try {
        Method method = enumType.getMethod(CUSTOM_ENUM_VALUE_OF_METHOD, (Class&lt;?&gt;[])null);
        if(method.getModifiers() == Modifier.STATIC) {
            return method;
        }
        return null;
    } catch(Exception ex) {
        return null;
    }
}

private Object enhancedFromString(String str) {
    try {
        return super.fromString(str);
    } catch(Exception ex) {
        for(Enum&lt;?&gt; item : enumType.getEnumConstants()) {
            if(item.name().equalsIgnoreCase(str)) {
                return item;
            }
        }
        throw new IllegalStateException(&quot;Cannot converter &lt;&quot; + str + &quot;&gt; to enum &lt;&quot; + enumType + &quot;&gt;&quot;);
    }
}
</code></pre><p>}</p>
<p>如下方式使用即可：</p>
<p>@XStreamAsAttribute
@XStreamAlias(&quot;time-period&quot;)
@XStreamConverter(value=LevinEnumSingleNameConverter.class)
private TimePeriod timePeriod;</p>
<p>对double类型，貌似默认的DoubleConverter实现依然不给力，它不支持自定义的格式，比如我们想在序列化的时候用一下格式：” /#/#/#,/#/#0.0/#/#/#/#/#/#/#/#”，此时又需要编写自己的Converter：</p>
<p>public class FormatableDoubleConverter extends DoubleConverter {
    private String pattern;
    private DecimalFormat formatter;</p>
<pre><code>public FormatableDoubleConverter(String pattern) {
    this.pattern = pattern;
    this.formatter = new DecimalFormat(pattern);
}

@Override
public String toString(Object obj) {
    if(formatter == null) {
        return super.toString(obj);
    } else {
        return formatter.format(obj);
    }
}

@Override
public Object fromString(String str) {
    try {
        return super.fromString(str);
    } catch(Exception ex) {
        if(formatter != null) {
            try {
                return formatter.parse(str);
            } catch(Exception e) {
                throw new IllegalArgumentException(&quot;Cannot parse &lt;&quot; + str + &quot;&gt; to double value&quot;, e);
            }
        }
        throw new IllegalArgumentException(&quot;Cannot parse &lt;&quot; + str + &quot;&gt; to double value&quot;, ex);
    }
}

public String getPattern() {
    return pattern;
}
</code></pre><p>}</p>
<p>使用方式和之前的Converter类似：</p>
<p>@XStreamAsAttribute
@XStreamConverter(value=FormatableDoubleConverter.class, strings={&quot;/#/#/#,/#/#0.0/#/#/#/#/#/#/#/#&quot;})
private double value;</p>
<p>最后，还有两个XStream没法实现的，或者说我没有找到一个更好的实现方式的场景。<strong>第一种场景是**</strong>XStream<strong>**不能很好的处理对象组合问题：</strong></p>
<p>在面向对象编程中，一般尽量的倾向于抽取相同的数据成一个类，而通过组合的方式构建整个数据结构。比如Student类中有name、address，Address是一个类，它包含city、code、street等信息，此时如果要对Student对象做如下格式序列化：</p>
<student name=”Levin”>
 <city>shanghai</city>
 <street>zhangjiang</street>
 <code>201203</code>
</student>

<p>貌似我没有找到可以实现的方式，XStream能做是在中间加一层address标签。对这种场景的解决方案，一种是将Address中的属性平摊到Student类中，另一种是让Student继承自Address类。不过貌似这两种都不是比较理想的办法。</p>
<p><strong>第二种场景是XStream**</strong>不能很好的处理多态问题：**</p>
<p>比如我们有一个Trade类，它可能表示不同的产品：
public class Trade {
    private String tradeId;
    private Product product;
<img src="" alt="">
}
abstract class Product {
    private String name;
    public Product(String name) {
        this.name = name;
}
<img src="" alt="">
}
class FX extends Product {
    private double ratio;
    public FX() {
        super(&quot;fx&quot;);
    }
    <img src="" alt="">
}
class Future extends Product {
    private double maturity;
    public Future() {
        super(&quot;future&quot;);
    }
    <img src="" alt="">
}</p>
<p>通过一些简单的设置，我们能得到如下XML格式：</p>
<trades>
 <trade trade-id="001">
    <product class="levin.xstream.blog.FX" name="fx" ratio="0.59"/>
 </trade>
 <trade trade-id="002">
    <product class="levin.xstream.blog.Future" name="future" maturity="2.123"/>
 </trade>
</trades>

<p>作为数据文件，对Java类的定义显然是不合理的，因而简单一些，我们可以编写自己的Converter将class属性从product中去除：</p>
<p>xstream.registerConverter(new ProductConverter(
        xstream.getMapper(), xstream.getReflectionProvider()));</p>
<pre><code>public ProductConverter(Mapper mapper, ReflectionProvider reflectionProvider) {
    super(mapper, reflectionProvider);
}

@Override
public boolean canConvert(@SuppressWarnings(&quot;rawtypes&quot;) Class type) {
    return Product.class.isAssignableFrom(type);
}

@Override
protected Object instantiateNewInstance(HierarchicalStreamReader reader, UnmarshallingContext context) {
    Object currentObject = context.currentObject();
    if(currentObject != null) {
        return currentObject;
    }

    String name = reader.getAttribute(&quot;name&quot;);
    if(&quot;fx&quot;.equals(name)) {
        return reflectionProvider.newInstance(FX.class);
    } else if(&quot;future&quot;.equals(name)) {
        return reflectionProvider.newInstance(Future.class);
    }
    throw new IllegalStateException(&quot;Cannot convert &lt;&quot; + name + &quot;&gt; product&quot;);
}
</code></pre><p>}</p>
<p>在所有Production上定义@XStreamAlias(“product”)注解。这时的XML输出结果为：</p>
<trades>
 <trade trade-id="001">
    <product name="fx" ratio="0.59"/>
 </trade>
 <trade trade-id="002">
    <product name="future" maturity="2.123"/>
 </trade>
</trades>

<p>然而如果有人希望XML的输出结果如下呢?</p>
<trades>
 <trade trade-id="001">
    <fx ratio="0.59"/>
 </trade>
 <trade trade-id="002">
    <future maturity="2.123"/>
 </trade>
</trades>

<p>大概找了一下，可能可以定义自己的Mapper来解决，不过XStream的源码貌似比较复杂，没有时间深究这个问题，留着以后慢慢解决吧。</p>
<p><strong>补充：</strong></p>
<p>对Map类型数据，XStream默认使用以下格式显示：</p>
<map class="linked-hash-map">
    <entry>
      <string>key1</string>
      <string>value1</string>
    </entry>
    <entry>
      <string>key2</string>
      <string>value2</string>
    </entry>
 </map>



<p>但是对一些简单的Map，我们希望如下显示：
 <map>
    <entry key="key1" value="value1"/>
    <entry key="key2" value="value2"/>
 </map></p>
<p>对这种需求需要通过编写Converter解决，继承自MapConverter，覆盖以下函数，这里的Map默认key和value都是String类型，如果他们不是String类型，需要另外添加逻辑：
@SuppressWarnings(&quot;rawtypes&quot;)
@Override
public void marshal(Object source, HierarchicalStreamWriter writer,
        MarshallingContext context) {
    Map map = (Map) source;
    for (Iterator iterator = map.entrySet().iterator(); iterator.hasNext();) {
        Entry entry = (Entry) iterator.next();
        ExtendedHierarchicalStreamWriterHelper.startNode(writer, mapper()
                .serializedClass(Map.Entry.class), entry.getClass());</p>
<pre><code>    writer.addAttribute(&quot;key&quot;, entry.getKey().toString());
    writer.addAttribute(&quot;value&quot;, entry.getValue().toString());
    writer.endNode();
}
</code></pre><p>}</p>
<p>@Override
@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
protected void putCurrentEntryIntoMap(HierarchicalStreamReader reader,
        UnmarshallingContext context, Map map, Map target) {
    Object key = reader.getAttribute(&quot;key&quot;);
    Object value = reader.getAttribute(&quot;value&quot;);</p>
<pre><code>target.put(key, value);
</code></pre><p>}</p>
<p>但是只是使用Converter，得到的结果多了一个class属性：
 <map class="linked-hash-map">
    <entry key="key1" value="value1"/>
    <entry key="key2" value="value2"/>
 </map></p>
<p>在XStream中，如果定义的字段是一个父类或接口，在序列化是会默认加入class属性以确定反序列化时用的类，为了去掉这个class属性，可以定义默认的实现类来解决（虽然感觉这种解决方案不太好，但是目前还没有找到更好的解决方案）。</p>
<p><em>*
</em>xstream.addDefaultImplementation(LinkedHashMap.class, Map.class);*</p>
<p>来源： <a href="[http://www.blogjava.net/DLevin/archive/2012/11/30/392240.html](http://www.blogjava.net/DLevin/archive/2012/11/30/392240.html)">[http://www.blogjava.net/DLevin/archive/2012/11/30/392240.html](http://www.blogjava.net/DLevin/archive/2012/11/30/392240.html)</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/xml/">xml</a></li></span><span class="breadcrumb"><li><a href="/categories/xml/">xml</a></li><li><a href="/categories/xml/xstream/">xstream</a></li></span></span> | <span class="tags">Tagged <a href="/tags/xml/" class="label label-primary">xml</a><a href="/tags/xstream/" class="label label-success">xstream</a></span> | <span class="time">recent updated:<time title="2014-03-07 01:54:44"datetime="2014-03-07 01:54:44"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-xml-xstream--使用XStream序列化、反序列化XML数据时遇到的各种问题/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-xml-xstream--使用XStream序列化、反序列化XML数据时遇到的各种问题" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-Flex--wmode属性的Opaque参数/">wmode属性的Opaque参数</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T09:54:44.000Z"> <a href="/2014/02/02/2014-02-02-Flex--wmode属性的Opaque参数/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="wmode-opaque-">wmode属性的Opaque参数</h1>
<h1 id="-http-blog-csdn-net-accp_2008123456-"><a href="http://blog.csdn.net/ACCP_2008123456" target="_blank">低调的华丽 专栏</a></h1>
<h1 id="-">#</h1>
<ul>
<li><a href="http://hi.csdn.net/space-notice.html" target="_blank">条新通知</a></li>
<li><a href="http://passport.csdn.net/UserLogin.aspx" target="_blank">登录</a></li>
<li><a href="http://passport.csdn.net/CSDNUserRegister.aspx" target="_blank">注册</a></li>
<li><a href="http://hi.csdn.net/" target="_blank">欢迎</a></li>
<li><a href="http://writeblog.csdn.net/Signout.aspx" target="_blank">退出</a></li>
<li><a href="http://blog.csdn.net/" target="_blank">我的博客</a></li>
<li><a href="http://writeblog.csdn.net/configure.aspx" target="_blank">配置</a></li>
<li><a href="http://writeblog.csdn.net/PostEdit.aspx" target="_blank">写文章</a></li>
<li><a href="http://writeblog.csdn.net/PostList.aspx" target="_blank">文章管理</a></li>
<li><a href="http://blog.csdn.net/" target="_blank">博客首页</a></li>
</ul>
<p>*</p>
<ul>
<li><p>全站 当前博客
*</p>
</li>
<li><p><a href="http://hi.csdn.net/ACCP_2008123456" target="_blank">空间</a></p>
</li>
<li><a href="http://blog.csdn.net/ACCP_2008123456" target="_blank">博客</a></li>
<li><a href="http://hi.csdn.net/!s/friend/list/ACCP_2008123456" target="_blank">好友</a></li>
<li><a href="http://hi.csdn.net/!s/album/list/ACCP_2008123456" target="_blank">相册</a></li>
<li><a href="http://hi.csdn.net/!s/wall/to/ACCP_2008123456" target="_blank">留言</a></li>
</ul>
<p>用户操作<a href="http://hi.csdn.net/!s/wall/to/ACCP_2008123456" target="_blank">[留言]</a>  <a href="http://hi.csdn.net/!s/msg/to/ACCP_2008123456" target="_blank">[发消息]</a>  <a href="http://hi.csdn.net/!s/friend/add/ACCP_2008123456" target="_blank">[加为好友]</a> 订阅我的博客<a href="http://feeds.feedsky.com/csdn.net/ACCP_2008123456" target="_blank"><img src="" alt="XML聚合"></a>   <a href="http://feeds.feedsky.com/csdn.net/ACCP_2008123456" target="_blank"><img src="" alt="FeedSky"></a><a href="http://www.xianguo.com/subscribe.php?url=http://feeds.feedsky.com/csdn.net/ACCP_2008123456" target="_blank"><img src="" alt="订阅到鲜果"></a><a href="http://fusion.google.com/add?feedurl=http://feeds.feedsky.com/csdn.net/ACCP_2008123456" target="_blank"><img src="" alt="订阅到Google"></a><a href="http://www.zhuaxia.com/add_channel.php?url=http://feeds.feedsky.com/csdn.net/ACCP_2008123456" target="_blank"><img src="" alt="订阅到抓虾"></a><a href="http://writeblog.csdn.net/configure.aspx" target="_blank">[编辑]</a>ACCP_2008123456的公告<a href="http://writeblog.csdn.net/EditCategories.aspx?catID=1" target="_blank">[编辑]</a>文章分类* <a href="http://blog.csdn.net/ACCP_2008123456/category/655568.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/ACCP_2008123456/category/655568.aspx" target="_blank">C/C++</a></p>
<ul>
<li><a href="http://blog.csdn.net/ACCP_2008123456/category/605837.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/ACCP_2008123456/category/605837.aspx" target="_blank">Cairngorm flex</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/category/630978.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/ACCP_2008123456/category/630978.aspx" target="_blank">css</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/category/633297.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/ACCP_2008123456/category/633297.aspx" target="_blank">eclipse</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/category/609296.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/ACCP_2008123456/category/609296.aspx" target="_blank">ewebeditor</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/category/605416.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/ACCP_2008123456/category/605416.aspx" target="_blank">flex</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/category/605832.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/ACCP_2008123456/category/605832.aspx" target="_blank">hibernate</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/category/630977.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/ACCP_2008123456/category/630977.aspx" target="_blank">html</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/category/605831.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/ACCP_2008123456/category/605831.aspx" target="_blank">java</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/category/605829.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/ACCP_2008123456/category/605829.aspx" target="_blank">js</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/category/625849.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/ACCP_2008123456/category/625849.aspx" target="_blank">jsp</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/category/632290.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/ACCP_2008123456/category/632290.aspx" target="_blank">mysql</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/category/690178.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/ACCP_2008123456/category/690178.aspx" target="_blank">Qt 嵌入式开发</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/category/605833.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/ACCP_2008123456/category/605833.aspx" target="_blank">spring</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/category/633426.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/ACCP_2008123456/category/633426.aspx" target="_blank">文章 感悟 生活</a>存档* <a href="http://blog.csdn.net/ACCP_2008123456/archive/2010/08.aspx" target="_blank">2010年08月(2)</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/archive/2010/07.aspx" target="_blank">2010年07月(1)</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/archive/2010/05.aspx" target="_blank">2010年05月(4)</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/archive/2010/04.aspx" target="_blank">2010年04月(2)</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/archive/2010/03.aspx" target="_blank">2010年03月(2)</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/archive/2010/02.aspx" target="_blank">2010年02月(13)</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/archive/2010/01.aspx" target="_blank">2010年01月(4)</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/archive/2009/12.aspx" target="_blank">2009年12月(12)</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/archive/2009/11.aspx" target="_blank">2009年11月(2)</a></li>
<li><a href="http://blog.csdn.net/ACCP_2008123456/archive/2009/10.aspx" target="_blank">2009年10月(8)</a><h3 id="-http-forum-csdn-net-slist-blogsupport-http-blog-csdn-net-blogdevteam-">公告： <a href="http://forum.csdn.net/SList/blogSupport" target="_blank">[意见反馈]</a><a href="http://blog.csdn.net/blogdevteam" target="_blank">[官方博客]</a></h3>
</li>
</ul>
<h1 id="-wmode-opaque-"><img src="" alt="转载">  wmode属性的Opaque参数 <a href="&quot;收藏到我的网摘中，并分享给我的朋友&quot;">收藏</a></h1>
<p>在制作Chat Union系统时，有一个功能暂时不打算使用Flash实现，但这个功能又必须出现在Flash中。因此考虑使用一个 <div>，让其漂浮在Flash动画上方，提供这个暂时不用Flash实现的功能。</p>
<p>但是默认情况下，Flash影片是处于最上层的，无法将 <div>置于其上。查阅Flash的帮助文件，发现这样一段描述：
wmode 属性/参数
值
Window | Opaque | Transparent</p>
<p>模板变量：$WM</p>
<p>说明
（可选）使您可以使用 Internet Explorer 4.0 中的透明 Flash 内容、绝对定位和分层显示的功能。此标记/属性仅在带有 Flash Player ActiveX 控件的 Windows 中有效。</p>
<p>“Window”在 Web 页上用影片自己的矩形窗口来播放应用程序。“Window”表明 Flash 应用程序与 HTML 层没有任何交互，并且始终位于最顶层。</p>
<p>“Opaque” 使应用程序隐藏页面上位于它后面的所有内容。</p>
<p>“Transparent”使 HTML 页的背景可以透过应用程序的所有透明部分进行显示，这样可能会降低动画性能。</p>
<p>“Opaque windowless”和“Transparent windowless” 都可与 HTML 层交互，并允许 SWF 文件上方的层遮蔽应用程序。这两种选项之间的差异在于“Transparent”允许透明，因此，如果 SWF 文件的某一部分是透明的，则 SWF 文件下方的 HTML 层可以透过该部分显示出来。</p>
<p>如果忽略此属性，默认值为 Window。仅适用于 object。</p>
<p>因此，在HTML中将 <object> 的wmode参数设成这样：</p>
<param name="wmode" value="Opaque">

<p>然后将一个HTML的 <div>置于Flash影片之上，测试成功。</p>
<p>但是，问题随之出现。许多客人在聊天室中打字的时候发现，输入法的选字框会跑到页面的左上角，而且会影响网页的排版，将Flash影片挤到下面。有时甚至无法将文字输入到Flash中。为了还原错误，我使用了多款输入法，发现微软的所有输入法都有这个问题。因为微软输入法在选字的时候都有一个虚线选择，我怀疑是这个虚线选择功能出现问题所致。</p>
<p>可是，不能单单怀疑微软输入法的兼容性不好。因为，同样的程序，在昨天就没有出现这个情况。和开发伙伴测试了其他输入法，发现智能ABC输入法也存在这个问题，只是在我的计算机上没有出现。</p>
<p>开始怀疑加入的 <div>，将其屏蔽，问题仍然存在。</p>
<p>继续怀疑到<strong>wmode</strong>属性的头上。删除 &lt; param name=”wmode” value=”Opaque” &gt; 语句，问题消失。</p>
<p>仔细思考，因为<strong>“Opaque” 使应用程序隐藏页面上位于它后面的所有内容</strong>，也就是说使用了这个参数之后，在网页中不是Flash位于最上而是<div>位于最上了，某些输入法会将焦点设定为网页中位于最上的对象（也就是 <div>中）。而这个 <div>又是使用绝对定位“漂浮”在网页上的，这就造成了输入法的选字框定位不准确，也就发生了刚才的问题了。</p>
<p>从帮助文件中看来，使用“Opaque windowless”参数应该会好一些，不过，我们实在不愿意再试</p>
<p>转载<a href="http://www.zengrong.net/" target="_blank">zrong&#39;s Blog</a></p>
<p>发表于 @ 2009年10月16日　09:45:00 | <a href="http://blog.csdn.net/ACCP_2008123456/archive/2009/10/16/4678642.aspx#FeedBack" title="评论" target="_blank">评论( loading...  )</a>| <a href="http://writeblog.csdn.net/PostEdit.aspx?entryId=4678642" title="编辑" target="_blank">编辑</a>| <a href="mailto:webmaster@csdn.net?subject=Article Report!!!&amp;body=Author:ACCP_2008123456URL:http://blog.csdn.net/ArticleContent.aspx?UserName=ACCP_2008123456&amp;Entryid=4678642">举报</a>| <a href="&quot;收藏到我的网摘中，并分享给我的朋友&quot;">收藏</a></p>
<h3 id="-flex-iframe-html-http-blog-csdn-net-accp_2008123456-archive-2009-10-16-4678665-aspx-"><a href="http://blog.csdn.net/ACCP_2008123456/archive/2009/10/16/4678665.aspx" target="_blank">新一篇:在Flex中用Iframe嵌入HTML网页</a></h3>
<p><a href="http://blog.csdn.net/" target="_blank">查看最新精华文章 请访问博客首页</a>相关文章<a href=""></a></p>
<ul>
<li><p>发表评论</p>
</li>
<li><p>表 情：</p>
</li>
<li><p><a href="http://blog.csdn.net/ACCP_2008123456/archive/2009/10/16/4678642.aspx#" target="_blank"><img src="&quot;顶&quot;" alt="顶"></a> <a href="http://blog.csdn.net/ACCP_2008123456/archive/2009/10/16/4678642.aspx#" target="_blank"><img src="&quot;砸&quot;" alt="砸"></a> <a href="http://blog.csdn.net/ACCP_2008123456/archive/2009/10/16/4678642.aspx#" target="_blank"><img src="&quot;棒&quot;" alt="棒"></a> <a href="http://blog.csdn.net/ACCP_2008123456/archive/2009/10/16/4678642.aspx#" target="_blank"><img src="&quot;大笑&quot;" alt="大笑"></a> <a href="http://blog.csdn.net/ACCP_2008123456/archive/2009/10/16/4678642.aspx#" target="_blank"><img src="&quot;愤怒&quot;" alt="愤怒"></a> <a href="http://blog.csdn.net/ACCP_2008123456/archive/2009/10/16/4678642.aspx#" target="_blank"><img src="&quot;大哭&quot;" alt="大哭"></a> <a href="http://blog.csdn.net/ACCP_2008123456/archive/2009/10/16/4678642.aspx#" target="_blank"><img src="&quot;疑问&quot;" alt="疑问"></a> <a href="http://blog.csdn.net/ACCP_2008123456/archive/2009/10/16/4678642.aspx#" target="_blank"><img src="&quot;汗&quot;" alt="汗"></a> <a href="http://blog.csdn.net/ACCP_2008123456/archive/2009/10/16/4678642.aspx#" target="_blank"><img src="&quot;呕吐&quot;" alt="呕吐"></a> <a href="http://blog.csdn.net/ACCP_2008123456/archive/2009/10/16/4678642.aspx#" target="_blank"><img src="&quot;送花&quot;" alt="送花"></a></p>
</li>
<li><p>评论内容：
*</p>
</li>
<li>用 户 名：</li>
<li><p><a href="">登录</a> <a href="http://passport.csdn.net/CSDNUserRegister.aspx" target="_blank">注册</a> 匿名评论</p>
</li>
<li><p>验 证 码：</p>
</li>
<li><a href=""><img src="" alt="验证码"></a> <a href="">重新获得验证码</a></li>
</ul>
<p><em>
</em></p>
<h3 id="-">热门招聘职位<img src="" alt=""></h3>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Flex/">Flex</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Flex/" class="label label-primary">Flex</a></span> | <span class="time">recent updated:<time title="2014-03-07 01:54:44"datetime="2014-03-07 01:54:44"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-Flex--wmode属性的Opaque参数/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-Flex--wmode属性的Opaque参数" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-xml-xstream--xStream完美转换XML、JSON/">xStream完美转换XML、JSON</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T09:54:44.000Z"> <a href="/2014/02/02/2014-02-02-xml-xstream--xStream完美转换XML、JSON/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="xstream-xml-json">xStream完美转换XML、JSON</h1>
<p><strong>xStream**</strong>框架<strong>**</strong></p>
<p>xStream可以轻易的将Java对象和xml文档相互转换，而且可以修改某个特定的属性和节点名称，而且也支持json的转换；</p>
<p>前面有介绍过json-lib这个框架，在线博文：<a href="http://www.cnblogs.com/hoojo/archive/2011/04/21/2023805.html" target="_blank"><a href="http://www.cnblogs.com/hoojo/archive/2011/04/21/2023805.html">http://www.cnblogs.com/hoojo/archive/2011/04/21/2023805.html</a></a></p>
<p>以及Jackson这个框架，在线博文：<a href="http://www.cnblogs.com/hoojo/archive/2011/04/22/2024628.html" target="_blank"><a href="http://www.cnblogs.com/hoojo/archive/2011/04/22/2024628.html">http://www.cnblogs.com/hoojo/archive/2011/04/22/2024628.html</a></a></p>
<p>它们都完美支持JSON，但是对xml的支持还不是很好。一定程度上限制了对Java对象的描述，不能让xml完全体现到对Java对象的描述。这里将会介绍xStream对JSON、XML的完美支持。xStream不仅对XML的转换非常友好，而且提供annotation注解，可以在JavaBean中完成对xml节点、属性的描述。以及对JSON也支持，只需要提供相关的JSONDriver就可以完成转换。</p>
<p><strong>一、**</strong>准备工作<strong>**</strong></p>
<p>1、 下载jar包、及官方资源</p>
<p>xStream的jar下载地址：</p>
<p><a href="https://nexus.codehaus.org/content/repositories/releases/com/thoughtworks/xstream/xstream-distribution/1.3.1/xstream-distribution-1.3.1-bin.zip" target="_blank"><a href="https://nexus.codehaus.org/content/repositories/releases/com/thoughtworks/xstream/xstream-distribution/1.3.1/xstream-distribution-1.3.1-bin.zip">https://nexus.codehaus.org/content/repositories/releases/com/thoughtworks/xstream/xstream-distribution/1.3.1/xstream-distribution-1.3.1-bin.zip</a></a></p>
<p>官方的示例很全，官方参考示例：<a href="http://xstream.codehaus.org/tutorial.html" target="_blank"><a href="http://xstream.codehaus.org/tutorial.html">http://xstream.codehaus.org/tutorial.html</a></a></p>
<p>添加xstream-1.3.1.jar文件到工程中，就可以开始下面的工作；需要的jar如下：</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/hoojo/201104/201104221846024160.jpg" target="_blank"><img src="&quot;clip_image002&quot;" alt="clip_image002"></a></p>
<p>2、 测试用例代码
package com.hoo.test;</p>
<p>import java.io.IOException;
import java.io.ObjectInputStream;</p>
<p>import java.io.ObjectOutputStream;
import java.io.StringReader;</p>
<p>import java.io.Writer;
import java.util.ArrayList;</p>
<p>import java.util.HashMap;
import java.util.Iterator;</p>
<p>import java.util.List;
import java.util.Map;</p>
<p>import java.util.Set;
import org.codehaus.jettison.json.JSONException;</p>
<p>import org.junit.After;
import org.junit.Before;</p>
<p>import org.junit.Test;
import com.hoo.entity.Birthday;</p>
<p>import com.hoo.entity.Classes;
import com.hoo.entity.ListBean;</p>
<p>import com.hoo.entity.Student;
import com.thoughtworks.xstream.XStream;</p>
<p>import com.thoughtworks.xstream.io.HierarchicalStreamWriter;
import com.thoughtworks.xstream.io.json.JettisonMappedXmlDriver;</p>
<p>import com.thoughtworks.xstream.io.json.JsonHierarchicalStreamDriver;
import com.thoughtworks.xstream.io.json.JsonWriter;</p>
<p>//<em>/</em>
/* <b>function:</b>Java对象和XML字符串的相互转换</p>
<p>/<em> jar-lib-version: xstream-1.3.1
/</em> @author hoojo</p>
<p>/<em> @createDate Nov 27, 2010 12:15:15 PM
/</em> @file XStreamTest.java</p>
<p>/<em> @package com.hoo.test
/</em> @project WebHttpUtils</p>
<p>/<em> @blog <a href="http://blog.csdn.net/IBM_hoojo" target="_blank">http://blog.csdn.net/IBM_hoojo</a>
/</em> @email hoojo_@126.com</p>
<p>/<em> @version 1.0
/</em>/</p>
<p>@SuppressWarnings(&quot;unchecked&quot;)
public class XStreamTest {</p>
<p>private XStream xstream = null;
private ObjectOutputStream out = null;</p>
<p>private ObjectInputStream in = null;
private Student bean = null;</p>
<p>//<em>/</em>
/* <b>function:</b>初始化资源准备</p>
<p>/<em> @author hoojo
/</em> @createDate Nov 27, 2010 12:16:28 PM</p>
<p>/*/
@Before</p>
<p>public void init() {
try {</p>
<p>xstream = new XStream();
//xstream = new XStream(new DomDriver()); // 需要xpp3 jar</p>
<p>} catch (Exception e) {
e.printStackTrace();</p>
<p>}
bean = new Student();</p>
<p>bean.setAddress(&quot;china&quot;);
bean.setEmail(&quot;jack@email.com&quot;);</p>
<p>bean.setId(1);
bean.setName(&quot;jack&quot;);</p>
<p>Birthday day = new Birthday();
day.setBirthday(&quot;2010-11-22&quot;);</p>
<p>bean.setBirthday(day);
}</p>
<p>//<em>/</em>
/* <b>function:</b>释放对象资源</p>
<p>/<em> @author hoojo
/</em> @createDate Nov 27, 2010 12:16:38 PM</p>
<p>/*/
@After</p>
<p>public void destory() {
xstream = null;</p>
<p>bean = null;
try {</p>
<p>if (out != null) {
out.flush();</p>
<p>out.close();
}</p>
<p>if (in != null) {
in.close();</p>
<p>}
} catch (IOException e) {</p>
<p>e.printStackTrace();
}</p>
<p>System.gc();
}</p>
<p>public final void fail(String string) {
System.out.println(string);</p>
<p>}
public final void failRed(String string) {</p>
<p>System.err.println(string);
}</p>
<p>}</p>
<p>通过XStream对象的toXML方法就可以完成Java对象到XML的转换，toXML方法还有2个相同签名的方法，需要传递一个流。然后通过流来完成xml信息的输出。</p>
<p>3、 需要的JavaBean
package com.hoo.entity;</p>
<p>public class Student {
private int id;</p>
<p>private String name;
private String email;</p>
<p>private String address;
private Birthday birthday;</p>
<p>//getter、setter
public String toString() {</p>
<p>return this.name + &quot;/#&quot; + this.id + &quot;/#&quot; + this.address + &quot;/#&quot; + this.birthday + &quot;/#&quot; + this.email;
}</p>
<p>}</p>
<hr>
<p><strong>二、**</strong>Java<strong><strong>转换成</strong></strong>XML**</p>
<p>1、 JavaBean转换XM
//<em>/</em></p>
<p>/<em> <b>function:</b>Java对象转换成XML字符串
/</em> @author hoojo</p>
<p>/<em> @createDate Nov 27, 2010 12:19:01 PM
/</em>/</p>
<p>@Test
public void writeBean2XML() {</p>
<p>try {
fail(&quot;------------Bean-&gt;XML------------&quot;);</p>
<p>fail(xstream.toXML(bean));
fail(&quot;重命名后的XML&quot;);</p>
<p>//类重命名
//xstream.alias(&quot;account&quot;, Student.class);</p>
<p>//xstream.alias(&quot;生日&quot;, Birthday.class);
//xstream.aliasField(&quot;生日&quot;, Student.class, &quot;birthday&quot;);</p>
<p>//xstream.aliasField(&quot;生日&quot;, Birthday.class, &quot;birthday&quot;);
//fail(xstream.toXML(bean));</p>
<p>//属性重命名
xstream.aliasField(&quot;邮件&quot;, Student.class, &quot;email&quot;);</p>
<p>//包重命名
xstream.aliasPackage(&quot;hoo&quot;, &quot;com.hoo.entity&quot;);</p>
<p>fail(xstream.toXML(bean));
} catch (Exception e) {</p>
<p>e.printStackTrace();
}</p>
<p>}</p>
<p>看结果中的第一份xml内容，是没有经过然后修改或重命名的文档，按照原样输出。文档中的第二份文档的package经过重命名，email属性也经过重命名以及类名也可以进行重命名的。</p>
<p>运行后结果如下：
------------Bean-&gt;XML------------</p>
<p><com.hoo.entity.Student></p>
<id>1</id>

<name>jack</name>
<email>jack@email.com</email>

<address>china</address>
<birthday>

<birthday>2010-11-22</birthday>
</birthday>

</com.hoo.entity.Student>
重命名后的XML

<hoo.Student>
<id>1</id>

<name>jack</name>
&lt;邮件&gt;jack@email.com&lt;/邮件&gt;

<address>china</address>
<birthday>

<birthday>2010-11-22</birthday>
</birthday>

</hoo.Student>

2、 将List集合转换成xml文档

//<em>/</em>

/<em> <b>function:</b>将Java的List集合转换成XML对象
/</em> @author hoojo

/<em> @createDate Nov 27, 2010 12:20:07 PM
/</em>/

@Test
public void writeList2XML() {

try {
//修改元素名称

xstream.alias(&quot;beans&quot;, ListBean.class);
xstream.alias(&quot;student&quot;, Student.class);

fail(&quot;----------List--&gt;XML----------&quot;);
ListBean listBean = new ListBean();

listBean.setName(&quot;this is a List Collection&quot;);
List<Object> list = new ArrayList<Object>();

list.add(bean);
list.add(bean);//引用bean

//list.add(listBean);//引用listBean，父元素
bean = new Student();

bean.setAddress(&quot;china&quot;);
bean.setEmail(&quot;tom@125.com&quot;);

bean.setId(2);
bean.setName(&quot;tom&quot;);

Birthday day = new Birthday(&quot;2010-11-22&quot;);
bean.setBirthday(day);

list.add(bean);
listBean.setList(list);

//将ListBean中的集合设置空元素，即不显示集合元素标签
//xstream.addImplicitCollection(ListBean.class, &quot;list&quot;);

//设置reference模型
//xstream.setMode(XStream.NO_REFERENCES);//不引用

xstream.setMode(XStream.ID_REFERENCES);//id引用
//xstream.setMode(XStream.XPATH_ABSOLUTE_REFERENCES);//绝对路径引用

//将name设置为父类（Student）的元素的属性
xstream.useAttributeFor(Student.class, &quot;name&quot;);

xstream.useAttributeFor(Birthday.class, &quot;birthday&quot;);
//修改属性的name

xstream.aliasAttribute(&quot;姓名&quot;, &quot;name&quot;);
xstream.aliasField(&quot;生日&quot;, Birthday.class, &quot;birthday&quot;);

fail(xstream.toXML(listBean));
} catch (Exception e) {

e.printStackTrace();
}

}

上面的代码运行后，结果如下：

----------List--&gt;XML----------

<beans id="1">
<name>this is a List Collection</name>

<p><list id="2"></p>
<student id="3" 姓名="jack">

<id>1</id>
<email>jack@email.com</email>

<address>china</address>
<birthday id="4" 生日="2010-11-22"/>

</student>
<student reference="3"/>

<student id="5" 姓名="tom">
<id>2</id>

<email>tom@125.com</email>
<address>china</address>

<birthday id="6" 生日="2010-11-22"/>
</student>

<p></list>
</beans></p>
<p>如果不加xstream.addImplicitCollection(ListBean.<strong>class</strong>, &quot;list&quot;);</p>
<p>这个设置的话，会出现一个List节点包裹着Student节点元素。添加addImplicitCollection可以忽略这个list节点元素。那么上面的list节点就不存在，只会在beans元素中出现name、student这2个xml元素标签；</p>
<p>setMode是设置相同的对象的引用方式，如果设置XStream.NO_REFERENCES就是不引用，会输出2分相同的Student元素。如果是XStream.ID_REFERENCES会引用相同的那个对象的id属性，如果是XStream.XPATH_ABSOLUTE_REFERENCES引用，那么它将显示xpath路径。上面采用的id引用，<student reference="3"/>这个引用了id=3的那个student标签元素；</p>
<p>useAttributeFor是设置某个节点显示到父节点的属性中，也就是将指定class中的指定属性，在这个class元素节点的属性中显示。</p>
<p>如：<student><name>hoojo</name></student></p>
<p>设置好后就是这样的结果：<student name=”hoojo”></student></p>
<p>aliasAttribute是修改属性名称。</p>
<p>3、 在JavaBean中添加Annotation注解进行重命名设置</p>
<p>先看看JavaBean的代码
package com.hoo.entity;</p>
<p>import java.util.Arrays;
import java.util.Calendar;</p>
<p>import java.util.GregorianCalendar;
import java.util.List;</p>
<p>import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;</p>
<p>import com.thoughtworks.xstream.annotations.XStreamConverter;
import com.thoughtworks.xstream.annotations.XStreamImplicit;</p>
<p>import com.thoughtworks.xstream.annotations.XStreamOmitField;
@XStreamAlias(&quot;class&quot;)</p>
<p>public class Classes {
//*</p>
<p>/<em> 设置属性显示
/</em>/</p>
<p>@XStreamAsAttribute
@XStreamAlias(&quot;名称&quot;)</p>
<p>private String name;
//*</p>
<p>/<em> 忽略
/</em>/</p>
<p>@XStreamOmitField
private int number;</p>
<p>@XStreamImplicit(itemFieldName = &quot;Students&quot;)
private List<Student> students;</p>
<p>@SuppressWarnings(&quot;unused&quot;)
@XStreamConverter(SingleValueCalendarConverter.class)</p>
<p>private Calendar created = new GregorianCalendar();
public Classes(){}</p>
<p>public Classes(String name, Student... stu) {
this.name = name;</p>
<p>this.students = Arrays.asList(stu);
}</p>
<p>//getter、setter
}</p>
<p>SingleValueCalendarConverter.java这个是一个类型转换器</p>
<p>package com.hoo.entity;</p>
<p>import java.util.Calendar;
import java.util.Date;</p>
<p>import java.util.GregorianCalendar;
import com.thoughtworks.xstream.converters.Converter;</p>
<p>import com.thoughtworks.xstream.converters.MarshallingContext;
import com.thoughtworks.xstream.converters.UnmarshallingContext;</p>
<p>import com.thoughtworks.xstream.io.HierarchicalStreamReader;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;</p>
<p>public class SingleValueCalendarConverter implements Converter {
public void marshal(Object source, HierarchicalStreamWriter writer,</p>
<p>MarshallingContext context) {
Calendar calendar = (Calendar) source;</p>
<p>writer.setValue(String.valueOf(calendar.getTime().getTime()));
}</p>
<p>public Object unmarshal(HierarchicalStreamReader reader,
UnmarshallingContext context) {</p>
<p>GregorianCalendar calendar = new GregorianCalendar();
calendar.setTime(new Date(Long.parseLong(reader.getValue())));</p>
<p>return calendar;
}</p>
<p>@SuppressWarnings(&quot;unchecked&quot;)
public boolean canConvert(Class type) {</p>
<p>return type.equals(GregorianCalendar.class);
}</p>
<p>}</p>
<p>再看看测试用例代码</p>
<p>@Test</p>
<p>public void writeList2XML4Annotation() {
try {</p>
<p>failRed(&quot;---------annotation Bean --&gt; XML---------&quot;);
Student stu = new Student();</p>
<p>stu.setName(&quot;jack&quot;);
Classes c = new Classes(&quot;一班&quot;, bean, stu);</p>
<p>c.setNumber(2);
//对指定的类使用Annotation</p>
<p>//xstream.processAnnotations(Classes.class);
//启用Annotation</p>
<p>//xstream.autodetectAnnotations(true);
xstream.alias(&quot;student&quot;, Student.class);</p>
<p>fail(xstream.toXML(c));
} catch (Exception e) {</p>
<p>e.printStackTrace();
}</p>
<p>}</p>
<p>当启用annotation或是对某个特定的类启用annotation时，上面的classes这个类才有效果。如果不启用annotation，运行后结果如下：</p>
<p>---------annotation Bean --&gt; XML---------</p>
<p><com.hoo.entity.Classes></p>
<name>一班</name>

<p><number>2</number></p>
<students class="java.util.Arrays$ArrayList">

<a class="student-array">
<student>

<id>1</id>
<name>jack</name>

<email>jack@email.com</email>
<address>china</address>

<birthday>
<birthday>2010-11-22</birthday>

</birthday>
</student>

<student>
<id>0</id>

<name>jack</name>
</student>

</a>
</students>

<created>
<time>1303292056718</time>

<timezone>Asia/Shanghai</timezone>
</created>

<p></com.hoo.entity.Classes></p>
<p>当启用annotation后xstream.processAnnotations(Classes.class)，结果如下：</p>
<p>---------annotation Bean --&gt; XML---------</p>
<class 名称="一班">
<Students>

<id>1</id>
<name>jack</name>

<email>jack@email.com</email>
<address>china</address>

<birthday>
<birthday>2010-11-22</birthday>

</birthday>
</Students>

<Students>
<id>0</id>

<name>jack</name>
</Students>

<created>1303292242937</created>
</class>

<p>4、 Map集合转换xml文档</p>
<p>//<em>/</em></p>
<p>/<em> <b>function:</b>Java Map集合转XML
/</em> @author hoojo</p>
<p>/<em> @createDate Nov 27, 2010 1:13:26 PM
/</em>/</p>
<p>@Test
public void writeMap2XML() {</p>
<p>try {
failRed(&quot;---------Map --&gt; XML---------&quot;);</p>
<p>Map<String, Student> map = new HashMap<String, Student>();
map.put(&quot;No.1&quot;, bean);//put</p>
<p>bean = new Student();
bean.setAddress(&quot;china&quot;);</p>
<p>bean.setEmail(&quot;tom@125.com&quot;);
bean.setId(2);</p>
<p>bean.setName(&quot;tom&quot;);
Birthday day = new Birthday(&quot;2010-11-22&quot;);</p>
<p>bean.setBirthday(day);
map.put(&quot;No.2&quot;, bean);//put</p>
<p>bean = new Student();
bean.setName(&quot;jack&quot;);</p>
<p>map.put(&quot;No.3&quot;, bean);//put
xstream.alias(&quot;student&quot;, Student.class);</p>
<p>xstream.alias(&quot;key&quot;, String.class);
xstream.useAttributeFor(Student.class, &quot;id&quot;);</p>
<p>xstream.useAttributeFor(&quot;birthday&quot;, String.class);
fail(xstream.toXML(map));</p>
<p>} catch (Exception e) {
e.printStackTrace();</p>
<p>}
}</p>
<p>运行后结果如下：</p>
<p>---------Map --&gt; XML---------</p>
<map>
<entry>

<key>No.3</key>
<student id="0">

<name>jack</name>
</student>

</entry>
<entry>

<key>No.1</key>
<student id="1">

<name>jack</name>
<email>jack@email.com</email>

<address>china</address>
<birthday birthday="2010-11-22"/>

</student>
</entry>

<entry>
<key>No.2</key>

<student id="2">
<name>tom</name>

<email>tom@125.com</email>
<address>china</address>

<birthday birthday="2010-11-22"/>
</student>

</entry>
</map>

<p>5、 用OutStream输出流写XML</p>
<p>//<em>/</em></p>
<p>/<em> <b>function:</b>用OutStream输出流写XML
/</em> @author hoojo</p>
<p>/<em> @createDate Nov 27, 2010 1:13:48 PM
/</em>/</p>
<p>@Test
public void writeXML4OutStream() {</p>
<p>try {
out = xstream.createObjectOutputStream(System.out);</p>
<p>Student stu = new Student();
stu.setName(&quot;jack&quot;);</p>
<p>Classes c = new Classes(&quot;一班&quot;, bean, stu);
c.setNumber(2);</p>
<p>failRed(&quot;---------ObjectOutputStream /# JavaObject--&gt; XML---------&quot;);
out.writeObject(stu);</p>
<p>out.writeObject(new Birthday(&quot;2010-05-33&quot;));
out.write(22);//byte</p>
<p>out.writeBoolean(true);
out.writeFloat(22.f);</p>
<p>out.writeUTF(&quot;hello&quot;);
} catch (Exception e) {</p>
<p>e.printStackTrace();
}</p>
<p>}</p>
<p>使用输出流后，可以通过流对象完成xml的构建，即使没有JavaBean对象，你可以用流来构建一个复杂的xml文档，运行后结果如下：</p>
<p>---------ObjectOutputStream /# JavaObject--&gt; XML---------</p>
<p><object-stream></p>
<com.hoo.entity.Student>

<p><id>0</id></p>
<name>jack</name>

<p></com.hoo.entity.Student></p>
<com.hoo.entity.Birthday>

<p><birthday>2010-05-33</birthday>
</com.hoo.entity.Birthday></p>
<p><byte>22</byte></p>
<boolean>true</boolean>

<p><float>22.0</float></p>
<string>hello</string>

<p></object-stream></p>
<hr>
<p><strong>三、**</strong>XML<strong><strong>内容转换</strong></strong>Java<strong><strong>对象**</strong></strong></p>
<p>1、 用InputStream将XML文档转换成java对象
//<em>/</em></p>
<p>/<em> <b>function:</b>用InputStream将XML文档转换成java对象
/</em> 需要额外的jar xpp3-main.jar</p>
<p>/<em> @author hoojo
/</em> @createDate Nov 27, 2010 1:14:52 PM</p>
<p>/*/
@Test</p>
<p>public void readXML4InputStream() {
try {</p>
<p>String s = &quot;<object-stream><com.hoo.entity.Student><id>0</id><name>jack</name>&quot; +
&quot;</com.hoo.entity.Student><com.hoo.entity.Birthday><birthday>2010-05-33</birthday>&quot; +</p>
<p>&quot;</com.hoo.entity.Birthday><byte>22</byte><boolean>true</boolean><float>22.0</float>&quot; +
&quot;<string>hello</string></object-stream>&quot;;</p>
<p>failRed(&quot;---------ObjectInputStream/#/# XML --&gt; javaObject---------&quot;);
StringReader reader = new StringReader(s);</p>
<p>in = xstream.createObjectInputStream(reader);
Student stu = (Student) in.readObject();</p>
<p>Birthday b = (Birthday) in.readObject();
byte i = in.readByte();</p>
<p>boolean bo = in.readBoolean();
float f = in.readFloat();</p>
<p>String str = in.readUTF();
System.out.println(stu);</p>
<p>System.out.println(b);
System.out.println(i);</p>
<p>System.out.println(bo);
System.out.println(f);</p>
<p>System.out.println(str);
} catch (Exception e) {</p>
<p>e.printStackTrace();
}</p>
<p>}</p>
<p>读取后，转换的Java对象，结果如下：</p>
<p>---------ObjectInputStream/#/# XML --&gt; javaObject---------</p>
<p>jack/#0/#null/#null/#null
2010-05-33</p>
<p>22
true</p>
<p>22.0
hello</p>
<p>2、 将xml文档转换成Java对象</p>
<p>//<em>/</em></p>
<p>/<em> <b>function:</b>将XML字符串转换成Java对象
/</em> @author hoojo</p>
<p>/<em> @createDate Nov 27, 2010 2:39:06 PM
/</em>/</p>
<p>@Test
public void readXml2Object() {</p>
<p>try {
failRed(&quot;-----------Xml &gt;&gt;&gt; Bean--------------&quot;);</p>
<p>Student stu = (Student) xstream.fromXML(xstream.toXML(bean));
fail(stu.toString());</p>
<p>List<Student> list = new ArrayList<Student>();
list.add(bean);//add</p>
<p>Map<String, Student> map = new HashMap<String, Student>();
map.put(&quot;No.1&quot;, bean);//put</p>
<p>bean = new Student();
bean.setAddress(&quot;china&quot;);</p>
<p>bean.setEmail(&quot;tom@125.com&quot;);
bean.setId(2);</p>
<p>bean.setName(&quot;tom&quot;);
Birthday day = new Birthday(&quot;2010-11-22&quot;);</p>
<p>bean.setBirthday(day);
list.add(bean);//add</p>
<p>map.put(&quot;No.2&quot;, bean);//put
bean = new Student();</p>
<p>bean.setName(&quot;jack&quot;);
list.add(bean);//add</p>
<p>map.put(&quot;No.3&quot;, bean);//put
failRed(&quot;==========XML &gt;&gt;&gt; List===========&quot;);</p>
<p>List<Student> studetns = (List<Student>) xstream.fromXML(xstream.toXML(list));
fail(&quot;size:&quot; + studetns.size());//3</p>
<p>for (Student s : studetns) {
fail(s.toString());</p>
<p>}
failRed(&quot;==========XML &gt;&gt;&gt; Map===========&quot;);</p>
<p>Map<String, Student> maps = (Map<String, Student>) xstream.fromXML(xstream.toXML(map));
fail(&quot;size:&quot; + maps.size());//3</p>
<p>Set<String> key = maps.keySet();
Iterator<String> iter = key.iterator();</p>
<p>while (iter.hasNext()) {
String k = iter.next();</p>
<p>fail(k + &quot;:&quot; + map.get(k));
}</p>
<p>} catch (Exception e) {
e.printStackTrace();</p>
<p>}
}</p>
<p>运行后结果如下：</p>
<p>-----------Xml &gt;&gt;&gt; Bean--------------</p>
<p>jack/#1/#china/#2010-11-22/#jack@email.com
==========XML &gt;&gt;&gt; List===========</p>
<p>size:3
jack/#1/#china/#2010-11-22/#jack@email.com</p>
<p>tom/#2/#china/#2010-11-22/#tom@125.com
jack/#0/#null/#null/#null</p>
<p>==========XML &gt;&gt;&gt; Map===========
size:3</p>
<p>No.3:jack/#0/#null/#null/#null
No.1:jack/#1/#china/#2010-11-22/#jack@email.com</p>
<p>No.2:tom/#2/#china/#2010-11-22/#tom@125.com</p>
<p>怎么样，成功的完成XML到JavaBean、List、Map的转换，更多对象转换还需要大家一一尝试。用法类似~这里就不一样赘述。</p>
<p><strong>四、**</strong>XStream<strong><strong>对</strong></strong>JSON<strong><strong>的支持**</strong></strong></p>
<p>xStream对JSON也有非常好的支持，它提供了2个模型驱动。用这2个驱动可以完成Java对象到JSON的相互转换。使用JettisonMappedXmlDriver驱动，将Java对象转换成json，需要添加jettison.jar</p>
<p>1、 用JettisonMappedXmlDriver完成Java对象到JSON的转换
//<em>/</em></p>
<p>/<em> <b>function:</b>XStream结合JettisonMappedXmlDriver驱动，转换Java对象到JSON
/</em> 需要添加jettison jar</p>
<p>/<em> @author hoojo
/</em> @createDate Nov 27, 2010 1:23:18 PM</p>
<p>/*/
@Test</p>
<p>public void writeEntity2JETTSON() {
failRed(&quot;=======JettisonMappedXmlDriver===JavaObject &gt;&gt;&gt;&gt; JaonString=========&quot;);</p>
<p>xstream = new XStream(new JettisonMappedXmlDriver());
xstream.setMode(XStream.NO_REFERENCES);</p>
<p>xstream.alias(&quot;student&quot;, Student.class);
fail(xstream.toXML(bean));</p>
<p>}</p>
<p>运行后结果如下：</p>
<p>=======JettisonMappedXmlDriver===JavaObject &gt;&gt;&gt;&gt; JaonString=========</p>
<p>{&quot;student&quot;:{&quot;id&quot;:1,&quot;name&quot;:&quot;jack&quot;,&quot;email&quot;:&quot;jack@email.com&quot;,&quot;address&quot;:&quot;china&quot;,&quot;birthday&quot;:[{},&quot;2010-11-22&quot;]}}</p>
<p>JSON的转换和XML的转换用法一样，只是创建XStream需要传递一个参数，这个参数就是xml到JSON映射转换的驱动。这里会降到两个驱动，分别是JettisonMappedXmlDriver、JsonHierarchicalStreamDriver。</p>
<p>2、 JsonHierarchicalStreamDriver完成Java对象到JSON的转换
//<em>/</em></p>
<p>/<em> <b>function:</b>用XStream结合JsonHierarchicalStreamDriver驱动
/</em> 转换java对象为JSON字符串</p>
<p>/<em> @author hoojo
/</em> @createDate Nov 27, 2010 1:16:46 PM</p>
<p>/*/
@Test</p>
<p>public void writeEntiry2JSON() {
failRed(&quot;======JsonHierarchicalStreamDriver====JavaObject &gt;&gt;&gt;&gt; JaonString=========&quot;);</p>
<p>xstream = new XStream(new JsonHierarchicalStreamDriver());
//xstream.setMode(XStream.NO_REFERENCES);</p>
<p>xstream.alias(&quot;student&quot;, Student.class);
failRed(&quot;-------Object &gt;&gt;&gt;&gt; JSON---------&quot;);</p>
<p>fail(xstream.toXML(bean));
//failRed(&quot;========JsonHierarchicalStreamDriver==删除根节点=========&quot;);</p>
<p>//删除根节点
xstream = new XStream(new JsonHierarchicalStreamDriver() {</p>
<p>public HierarchicalStreamWriter createWriter(Writer out) {
return new JsonWriter(out, JsonWriter.DROP_ROOT_MODE);</p>
<p>}
});</p>
<p>//xstream.setMode(XStream.NO_REFERENCES);
xstream.alias(&quot;student&quot;, Student.class);</p>
<p>fail(xstream.toXML(bean));
}</p>
<p>运行后结果如下：</p>
<p>======JsonHierarchicalStreamDriver====JavaObject &gt;&gt;&gt;&gt; JaonString=========</p>
<p>-------Object &gt;&gt;&gt;&gt; JSON---------
{&quot;student&quot;: {</p>
<p>&quot;id&quot;: 1,
&quot;name&quot;: &quot;jack&quot;,</p>
<p>&quot;email&quot;: &quot;jack@email.com&quot;,
&quot;address&quot;: &quot;china&quot;,</p>
<p>&quot;birthday&quot;: {
&quot;birthday&quot;: &quot;2010-11-22&quot;</p>
<p>}
}}</p>
<p>{
&quot;id&quot;: 1,</p>
<p>&quot;name&quot;: &quot;jack&quot;,
&quot;email&quot;: &quot;jack@email.com&quot;,</p>
<p>&quot;address&quot;: &quot;china&quot;,
&quot;birthday&quot;: {</p>
<p>&quot;birthday&quot;: &quot;2010-11-22&quot;
}</p>
<p>}</p>
<p>使用JsonHierarchicalStreamDriver转换默认会给转换后的对象添加一个根节点，但是在构建JsonHierarchicalStreamDriver驱动的时候，你可以重写createWriter方法，删掉根节点。</p>
<p>看上面的结果，一个是默认带根节点的JSON对象，它只是将类名作为一个属性，将对象作为该属性的一个值。而另一个没有带根属性的JSON就是通过重写createWriter方法完成的。</p>
<p>3、 将List集合转换成JSON字符串
@Test</p>
<p>public void writeList2JSON() {
failRed(&quot;======JsonHierarchicalStreamDriver====JavaObject &gt;&gt;&gt;&gt; JaonString=========&quot;);</p>
<p>JsonHierarchicalStreamDriver driver = new JsonHierarchicalStreamDriver();
xstream = new XStream(driver);</p>
<p>//xstream = new XStream(new JettisonMappedXmlDriver());//转换错误
//xstream.setMode(XStream.NO_REFERENCES);</p>
<p>xstream.alias(&quot;student&quot;, Student.class);
List<Student> list = new ArrayList<Student>();</p>
<p>list.add(bean);//add
bean = new Student();</p>
<p>bean.setAddress(&quot;china&quot;);
bean.setEmail(&quot;tom@125.com&quot;);</p>
<p>bean.setId(2);
bean.setName(&quot;tom&quot;);</p>
<p>Birthday day = new Birthday(&quot;2010-11-22&quot;);
bean.setBirthday(day);</p>
<p>list.add(bean);//add
bean = new Student();</p>
<p>bean.setName(&quot;jack&quot;);
list.add(bean);//add</p>
<p>fail(xstream.toXML(list));
//failRed(&quot;========JsonHierarchicalStreamDriver==删除根节点=========&quot;);</p>
<p>//删除根节点
xstream = new XStream(new JsonHierarchicalStreamDriver() {</p>
<p>public HierarchicalStreamWriter createWriter(Writer out) {
return new JsonWriter(out, JsonWriter.DROP_ROOT_MODE);</p>
<p>}
});</p>
<p>xstream.alias(&quot;student&quot;, Student.class);
fail(xstream.toXML(list));</p>
<p>}</p>
<p>运行后结果如下</p>
<p>======JsonHierarchicalStreamDriver====JavaObject &gt;&gt;&gt;&gt; JaonString=========</p>
<p>/#/#{&quot;list&quot;: [
{</p>
<p>&quot;id&quot;: 1,
&quot;name&quot;: &quot;jack&quot;,</p>
<p>&quot;email&quot;: &quot;jack@email.com&quot;,
&quot;address&quot;: &quot;china&quot;,</p>
<p>&quot;birthday&quot;: {
&quot;birthday&quot;: &quot;2010-11-22&quot;</p>
<p>}
},</p>
<p>{
&quot;id&quot;: 2,</p>
<p>&quot;name&quot;: &quot;tom&quot;,
&quot;email&quot;: &quot;tom@125.com&quot;,</p>
<p>&quot;address&quot;: &quot;china&quot;,
&quot;birthday&quot;: {</p>
<p>&quot;birthday&quot;: &quot;2010-11-22&quot;
}</p>
<p>},
{</p>
<p>&quot;id&quot;: 0,
&quot;name&quot;: &quot;jack&quot;</p>
<p>}
]}</p>
<p>/#[
{</p>
<p>&quot;id&quot;: 1,
&quot;name&quot;: &quot;jack&quot;,</p>
<p>&quot;email&quot;: &quot;jack@email.com&quot;,
&quot;address&quot;: &quot;china&quot;,</p>
<p>&quot;birthday&quot;: {
&quot;birthday&quot;: &quot;2010-11-22&quot;</p>
<p>}
},</p>
<p>{
&quot;id&quot;: 2,</p>
<p>&quot;name&quot;: &quot;tom&quot;,
&quot;email&quot;: &quot;tom@125.com&quot;,</p>
<p>&quot;address&quot;: &quot;china&quot;,
&quot;birthday&quot;: {</p>
<p>&quot;birthday&quot;: &quot;2010-11-22&quot;
}</p>
<p>},
{</p>
<p>&quot;id&quot;: 0,
&quot;name&quot;: &quot;jack&quot;</p>
<p>}
]</p>
<p>上面的list1是使用JsonHierarchicalStreamDriver 转换的，当然你也可以使用JettisonMappedXmlDriver驱动进行转换；用JettisonMappedXmlDriver转换后，你会发现格式不同而且没有根属性。</p>
<p>4、 Map转换json
@Test</p>
<p>public void writeMap2JSON() {
failRed(&quot;======JsonHierarchicalStreamDriver==== Map &gt;&gt;&gt;&gt; JaonString=========&quot;);</p>
<p>xstream = new XStream(new JsonHierarchicalStreamDriver());
//xstream = new XStream(new JettisonMappedXmlDriver());</p>
<p>xstream.alias(&quot;student&quot;, Student.class);
Map<String, Student> map = new HashMap<String, Student>();</p>
<p>map.put(&quot;No.1&quot;, bean);//put
bean = new Student();</p>
<p>bean.setAddress(&quot;china&quot;);
bean.setEmail(&quot;tom@125.com&quot;);</p>
<p>bean.setId(2);
bean.setName(&quot;tom&quot;);</p>
<p>bean.setBirthday(new Birthday(&quot;2010-11-21&quot;));
map.put(&quot;No.2&quot;, bean);//put</p>
<p>bean = new Student();
bean.setName(&quot;jack&quot;);</p>
<p>map.put(&quot;No.3&quot;, bean);//put
fail(xstream.toXML(map));</p>
<p>//failRed(&quot;========JsonHierarchicalStreamDriver==删除根节点=========&quot;);
//删除根节点</p>
<p>xstream = new XStream(new JsonHierarchicalStreamDriver() {
public HierarchicalStreamWriter createWriter(Writer out) {</p>
<p>return new JsonWriter(out, JsonWriter.DROP_ROOT_MODE);
}</p>
<p>});
xstream.alias(&quot;student&quot;, Student.class);</p>
<p>fail(xstream.toXML(map));
}</p>
<p>运行后结果如下：</p>
<p>======JsonHierarchicalStreamDriver==== Map &gt;&gt;&gt;&gt; JaonString=========</p>
<p>{&quot;map&quot;: [
[</p>
<p>&quot;No.3&quot;,
{</p>
<p>&quot;id&quot;: 0,
&quot;name&quot;: &quot;jack&quot;</p>
<p>}
],</p>
<p>[
&quot;No.1&quot;,</p>
<p>{
&quot;id&quot;: 1,</p>
<p>&quot;name&quot;: &quot;jack&quot;,
&quot;email&quot;: &quot;jack@email.com&quot;,</p>
<p>&quot;address&quot;: &quot;china&quot;,
&quot;birthday&quot;: {</p>
<p>&quot;birthday&quot;: &quot;2010-11-22&quot;
}</p>
<p>}
],</p>
<p>[
&quot;No.2&quot;,</p>
<p>{
&quot;id&quot;: 2,</p>
<p>&quot;name&quot;: &quot;tom&quot;,
&quot;email&quot;: &quot;tom@125.com&quot;,</p>
<p>&quot;address&quot;: &quot;china&quot;,
&quot;birthday&quot;: {</p>
<p>&quot;birthday&quot;: &quot;2010-11-21&quot;
}</p>
<p>}
]</p>
<p>]}
[</p>
<p>[
&quot;No.3&quot;,</p>
<p>{
&quot;id&quot;: 0,</p>
<p>&quot;name&quot;: &quot;jack&quot;
}</p>
<p>],
[</p>
<p>&quot;No.1&quot;,
{</p>
<p>&quot;id&quot;: 1,
&quot;name&quot;: &quot;jack&quot;,</p>
<p>&quot;email&quot;: &quot;jack@email.com&quot;,
&quot;address&quot;: &quot;china&quot;,</p>
<p>&quot;birthday&quot;: {
&quot;birthday&quot;: &quot;2010-11-22&quot;</p>
<p>}
}</p>
<p>],
[</p>
<p>&quot;No.2&quot;,
{</p>
<p>&quot;id&quot;: 2,
&quot;name&quot;: &quot;tom&quot;,</p>
<p>&quot;email&quot;: &quot;tom@125.com&quot;,
&quot;address&quot;: &quot;china&quot;,</p>
<p>&quot;birthday&quot;: {
&quot;birthday&quot;: &quot;2010-11-21&quot;</p>
<p>}
}</p>
<p>]
]</p>
<p>5、 将JSON转换java对象</p>
<p>//<em>/</em></p>
<p>/<em> <b>function:</b>JsonHierarchicalStreamDriver可以将简单的json字符串转换成java对象，list、map转换不成功；
/</em> JsonHierarchicalStreamDriver读取JSON字符串到java对象出错</p>
<p>/<em> @author hoojo
/</em> @createDate Nov 27, 2010 1:22:26 PM</p>
<p>/<em> @throws JSONException
/</em>/</p>
<p>@Test
public void readJSON2Object() throws JSONException {</p>
<p>String json = &quot;{\&quot;student\&quot;: {&quot; +
&quot;\&quot;id\&quot;: 1,&quot; +</p>
<p>&quot;\&quot;name\&quot;: \&quot;haha\&quot;,&quot; +
&quot;\&quot;email\&quot;: \&quot;email\&quot;,&quot; +</p>
<p>&quot;\&quot;address\&quot;: \&quot;address\&quot;,&quot; +
&quot;\&quot;birthday\&quot;: {&quot; +</p>
<p>&quot;\&quot;birthday\&quot;: \&quot;2010-11-22\&quot;&quot; +
&quot;}&quot; +</p>
<p>&quot;}}&quot;;
//JsonHierarchicalStreamDriver读取JSON字符串到java对象出错，但JettisonMappedXmlDriver可以</p>
<p>xstream = new XStream(new JettisonMappedXmlDriver());
xstream.alias(&quot;student&quot;, Student.class);</p>
<p>fail(xstream.fromXML(json).toString());
//JettisonMappedXmlDriver转换List集合出错，但JsonHierarchicalStreamDriver可以转换正确</p>
<p>//JettisonMappedXmlDriver 转换的字符串 {&quot;list&quot;:{&quot;student&quot;:[{&quot;id&quot;:1,&quot;name&quot;:&quot;haha&quot;,&quot;email&quot;:&quot;email&quot;,&quot;address&quot;:&quot;address&quot;,&quot;birthday&quot;:[{},&quot;2010-11-22&quot;]}]},&quot;student&quot;:{&quot;id&quot;:2,&quot;name&quot;:&quot;tom&quot;,&quot;email&quot;:&quot;tom@125.com&quot;,&quot;address&quot;:&quot;china&quot;,&quot;birthday&quot;:[{},&quot;2010-11-22&quot;]}}
json = &quot;{\&quot;list\&quot;: [{&quot; +</p>
<p>&quot;\&quot;id\&quot;: 1,&quot; +
&quot;\&quot;name\&quot;: \&quot;haha\&quot;,&quot; +</p>
<p>&quot;\&quot;email\&quot;: \&quot;email\&quot;,&quot; +
&quot;\&quot;address\&quot;: \&quot;address\&quot;,&quot; +</p>
<p>&quot;\&quot;birthday\&quot;: {&quot; +
&quot;\&quot;birthday\&quot;: \&quot;2010-11-22\&quot;&quot; +</p>
<p>&quot;}&quot; +
&quot;},{&quot; +</p>
<p>&quot;\&quot;id\&quot;: 2,&quot; +
&quot;\&quot;name\&quot;: \&quot;tom\&quot;,&quot; +</p>
<p>&quot;\&quot;email\&quot;: \&quot;tom@125.com\&quot;,&quot; +
&quot;\&quot;address\&quot;: \&quot;china\&quot;,&quot; +</p>
<p>&quot;\&quot;birthday\&quot;: {&quot; +
&quot;\&quot;birthday\&quot;: \&quot;2010-11-22\&quot;&quot; +</p>
<p>&quot;}&quot; +
&quot;}]}&quot;;</p>
<p>System.out.println(json);//用js转换成功
List list = (List) xstream.fromXML(json);</p>
<p>System.out.println(list.size());//0好像转换失败
}</p>
<p>运行后结果如下：</p>
<p>haha/#1/#address/#2010-11-22/#email</p>
<p>{&quot;list&quot;: [{&quot;id&quot;: 1,&quot;name&quot;: &quot;haha&quot;,&quot;email&quot;: &quot;email&quot;,&quot;address&quot;: &quot;address&quot;,&quot;birthday&quot;: {&quot;birthday&quot;: &quot;2010-11-22&quot;}},
{&quot;id&quot;: 2,&quot;name&quot;: &quot;tom&quot;,&quot;email&quot;: &quot;tom@125.com&quot;,&quot;address&quot;: &quot;china&quot;,&quot;birthday&quot;: {&quot;birthday&quot;: &quot;2010-11-22&quot;}}]}</p>
<p>0</p>
<p>JSON到Java的转换是fromXML方法。</p>
<p>作者：<a href="http://hoojo.cnblogs.com/" target="_blank">hoojo</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/xml/">xml</a></li></span><span class="breadcrumb"><li><a href="/categories/xml/">xml</a></li><li><a href="/categories/xml/xstream/">xstream</a></li></span></span> | <span class="tags">Tagged <a href="/tags/xml/" class="label label-primary">xml</a><a href="/tags/xstream/" class="label label-success">xstream</a></span> | <span class="time">recent updated:<time title="2014-04-07 08:47:11"datetime="2014-04-07 08:47:11"> abr. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-xml-xstream--xStream完美转换XML、JSON/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-xml-xstream--xStream完美转换XML、JSON" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-xml-xstream--XStream学习笔记-枫情的Blog-BlogJava/">XStream 学习笔记</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T09:54:44.000Z"> <a href="/2014/02/02/2014-02-02-xml-xstream--XStream学习笔记-枫情的Blog-BlogJava/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="xstream-">XStream 学习笔记</h1>
<p>  <a href="http://www.blogjava.net/zlkn2005/" target="_blank">枫情的Blog</a></p>
<p><strong>XStream</strong></p>
<p><strong>使用XStream**</strong>的初衷**</p>
<p>研究和使用XStream的原因是我在项目中的一个预研。在项目中需要应用到对XML文件的管理和配置，因此需要一个能够将对象保存为XML的工具库，在这里有多种方法实现，我也研究并进行了比对，比如与Zeus工具的比对，与Java自身的XML工具库的比对等。在这里，我就描述下我的XStream学习过程和研究结果。</p>
<p><strong>XStream**</strong>简单介绍**</p>
<p>XStream是一个开源项目，一套简单实用的类库，用于序列化对象与XML对象之间的相互转换。将XML文件内容解析为一个对象或将一个对象序列化为XML文件。</p>
<p>XStream可以用于JDK1.3以上的版本使用，我是在JDK1.5下使用它的。</p>
<p>XStream的相关信息可以到<a href="http://xstream.codehaus.org/下查看，它有专门的JavaDoc，可以方便的阅读Xstream的函数及方法。" target="_blank">http://xstream.codehaus.org/下查看，它有专门的JavaDoc，可以方便的阅读Xstream的函数及方法。</a></p>
<p>XStream中主要的类为XStream，它用于序列化对象与XML 对象之间的相互转换。简单的使用它就可以解决很多问题。</p>
<p>XStream中主要的方法也是我用的比较多的是fromXML()和toXML()。</p>
<p>fromXML用于从XML中将对象解析出来。</p>
<p>toXML用于将对象序列化为XML文件。</p>
<p>在XStream中我还使用HierarchicalStreamWriter，HierarchicalStreamReader，createObjectInputStream()，createObjectOutputStream()，主要是用于对象的输入输出。</p>
<p>下面我们来研究下XStream的工作方式。</p>
<p><strong>XStream**</strong>的实例——将一个序列化对象转化为XML<strong>**对象。</strong></p>
<p>一，创建XStream对象。</p>
<p>XStream xstream=new XStream();</p>
<p>用默认构造器构造了一个名为xstream的XStream的对象。默认构造器所使用XML解析库为Xpp3库，XPP3是一种运行效率非常高的XML全解析实现。</p>
<p>二，创建需要序列化的对象。</p>
<p>比如这个类就叫PrintUnit。</p>
<p>构造也比较简单，一个简单的JavaBean</p>
<pre><code>   public class PrintUnit

   {

          Private String a;

          Private String b;

          Private String c;



          Public PrintUnit(){}



          Public setA(String a)

          {

                 this.a=a;

          }



          Public getA()

          {

                 return a;

          }



          Public setB(String b)

          {

                 this.b=b;

          }



          Public getB()

          {

                 return b;

          }



          Public setC(String c)

          {

                 This.c=c;

          }



          Public getC()

          {

                 Return c;

          }

   }
</code></pre><p>在例子中使用这个JavaBean。</p>
<p>创建并初始化PrintUnit。</p>
<p>PrintUnit pu=new PrintUnit();</p>
<p>pu.setA(&quot;A11&quot;);</p>
<p>pu.setB(&quot;B22&quot;);</p>
<p>pu.setC(&quot;C33&quot;);</p>
<p>三，创建Writer。</p>
<p>创建一个输出流，至于怎么输出我发现可以使用多种方法，其实原理是一样的。</p>
<p>在这里就不得不提到HierarchicalStreamWriter,HierarchicalStreamWriter是一个接口，从字面上意思来说它是有等级的输入流。同样在XStream中也有不少这个接口的实现类用于输出。我现在所用过的有CompactWriter和PrettyPrintWriter这2个。</p>
<p>我是这样做的：</p>
<p>String str=&quot;stream.xml&quot;; //本目录下的一个名为stream的XML文件</p>
<p>PrintWriter pw=new PrintWriter(str);//创建一个PrintWriter对象，用于输出。</p>
<p>之后选用一个HierarchicalStreamWriter的实现类来创建输出。</p>
<p>选用CompactWriter创建：</p>
<p>CompactWriter cw=new CompactWriter(pw);</p>
<p>选用PrettyPrintWriter创建：</p>
<p>PrettyPrintWriter ppw=new PrettyPrintWriter(pw);</p>
<p>两者所使用的方法都是很简单的。</p>
<p>CompactWriter与PrettyPrintWriter的区别在于，以CompactWriter方法输出的为连续的没有分隔的XML文件，而用PrettyPrintWriter方法输出的为有分隔有一定格式的XML文件。</p>
<p>以CompactWriter方式生成的XML文件：</p>
<object-stream><PrintUnit><a>A11</a><b>B22</b><c>C33</c></PrintUnit></object-stream>



以PrettyPrintWriter方式生成的XML文件：

       <object-stream>

             <PrintUnit>

                  <a>A11</a>

                  <b>B22</b>

                  <c>C33</c>

             </PrintUnit>

       </object-stream>



       我想大家能很容易的分辨出它们的差异。



       四，输出操作<br>
以上步骤完成后就可以做输出操作了，XStream的输出方式有多种：toXML方式，ObjectOutputStream方式，marshal方式以及一些我尚未发现的一些其它方式。

先说下我所使用的方式它们各自的不同点，从工作原理上说它们是相似的，但是做法各不相同。

toXML()方法，本身toXML的方法就有2种：

第一种:java.lang.String toXML(java.lang.Object obj)

将对象序列化为XML格式并保存到一个String对象中。

第二种:void toXML(java.lang.Object obj, java.io.Writer out)

将对象序列化为XML格式后以Writer输出到某个地方存储。

我所使用的是第二种方式，使用前面已经做好的Pw就可以实现输出，它其实很简单不需要再去做其它定义，只需要一个PrintWriter对象和需要序列化的Object即可。

直接调用xstream.toXML(printUnit,pw);就能输出XML文件,在这里是输出到该目录下的stream.xml中。这里的输出都是覆盖性的，不是末尾添加形式。

使用ObjectOutputStream方式，简单说它就是生成一个对象输出流。

ObjectOutputStream obj<em>out = xstream.createObjectOutputStream(ppw);

使用XStream的createObjectOutputStream方法创建一个ObjectOutputStream对象，用于XML的输出。这里使用的是PrettyPrintWriter的方式。   之后调用writerObject方法既可，使用方法与其它输出流类似。

obj_out.writeObject(pu);

obj_out.close();

使用marshal方式，其实marshal方法和toXML方法是相同的。在调用toXML方法进行输出时，在XStream内部是需要调用marshal方法的，然后它再去调用对象marshallingStrategy的marshal方法。所以做toXML其实和marshal是相同的，在这里只是想更加说明它的工作方式。



使用 void marshal(java.lang.Object obj, HierarchicalStreamWriter writer)方法。

延续上面的例子，在这里可以这样写：xstream.marshal(pu,ppw);



需要注意的是，和toXML不同的是参数，一个是PrintWriter对象一个则是PrettyPrintWriter对象。因为marshal中需要

HierarchicalStreamWriter，而PrettyPrintWriter则是实现了HierarchicalStreamWriter接口的实现类。



结果和toXML是相同的。



五，结果：

       <object-stream>

             <PrintUnit>

                  <a>A11</a>

                  <b>B22</b>

                  <c>C33</c>

             </PrintUnit>

       </object-stream>



经过以上5步的操作既可将一个序列化对象转化为XML对象。





<strong>toXML**</strong>内部调用图：<strong>

</strong> <strong>

<img src="" alt="XStream.gif">toXML操作时的内部调用图，自己随意画的。有些没有详细说明。





</strong>XStream<strong><strong>的实例——将XML</strong></strong>文件转化为一个对象<strong>



通过上面的一个例子不难看出XStream简便性，既然有了输出就一定会有输入。

输入方我们将会使用ObjectInputStream。

与输出相同我们需要有一个XStream对象，暂且名为xstream。之后需要读取的XML文件地址目录信息。沿用上面的例子。

String inputStr=&quot;xstream.xml&quot;;

XStream xstream=new XStream();

我们需要通过对象流进行输入操作，所以需要FileReader和BufferedReader。

FileReader fr=new FileReader(inputStr);

BufferedReader br=new BufferedReader(fr);

创建对象输入流

ObjectInputStream obj_input=xstream.createObjectInputStream(br);

创建对象，还是使用PrintUnit这个对象。

PrintUnit pu2;

通过ObjectInputStream中的readObject()方法将对象从XML文件中读取出来。

pu2=(PrintUnit)obj_input.readObject();

获取值：

System.out.println(pu2.getB());

控制台：

B22 



从整个输入的过程来看，是一个文件的读取，将其中的对象数据取出来，然后再对这个对象数据进行操作。内容也比较简单通过ObjectInputStream输入对象。

通过以上的输入输出例子，我想大家应该很容易就能理解XStream是如何实现的。



</strong>FomXML<strong>



上面使用的是以ObjectInputStream的方式进行XML与对象之间进行转换的。下面我将使用XStream中的fromXML（）方法进行转换。

首先在使用fromXML我发现一个问题，它必须使用正确的解析方式或输出方式对应的输入方式才可以正常解析读取文件，这个问题有点怪，不过确实存在，当我使用前面ObjectOutputStream方式输出的XML文件,用fromXML（）解析读取时，它会报错。

错误信息：

Exception in thread &quot;main&quot; com.thoughtworks.xstream.alias.CannotResolveClassException: object$stream : object$stream

信息内容为：不能解析这个文件。我认为它和输出方式有关，因为上面例子中使用的是ObjectOutputStream，当我反过来做了一个实验后也证明了这一点。

实验大致内容：使用toXML()方法输出XML文件，使用ObjectInputStream解析，发现会在读取的时候抛出CannotResolveClassException异常。

错误信息：

Exception in thread &quot;main&quot; com.thoughtworks.xstream.alias.CannotResolveClassException:

a : a

       因此我认为在解析文件的时候必须先要确定这个文件是由什么方式生成的，然后在解析它，对于使用Dom,Dom4j,XPP等不同方式解析尚未尝试。以上测试是在默认的基础上实验的，默认为XPP3的解析器。



       使用fromXML的方法。



       public java.lang.Object fromXML(java.lang.String xml)

       public java.lang.Object fromXML(java.io.Reader xml)

public java.lang.Object fromXML(java.lang.String xml,java.lang.Object root)

public java.lang.Object fromXML(java.io.Reader xml,java.lang.Object root)



例子：

       PrintUnit puTwo=(PrintUnit)xstream.fromXML(xml);



这里的xml必须是使用toXML()生成出来的。对于Reader没有太多的要求。





</strong>XStream<strong><strong>与</strong></strong>Java.Bean<strong><strong>中</strong></strong>XML<strong><strong>工具的比较**</strong></strong>



       XStream主要作用是将序列化的对象转化为一个XML文件或将XML文件解析为一个对象。当然并非只有它可以做到，很多其它工具一样可以，在Java中存在这样两个类XMLDecoder和XMLEncoder，它们是在Java.Bean包下的，它们的作用是将JavaBean转化为XML或将XML文件转化为一个Java Bean。

       XMLDecoder是通过一个输入流将对象从输入流中取出并转化为一个实例的方法。它所需要的就是一个输入流及一个转化过程。



       XMLDecoder的实例：



       String fileStr=”xstream.xml”;//XML文件，在本目录下，延用上次使用文件。

       ObjectInputStream in=new ObjectInputStream(new FileInputStream(fileStr));//创建一个ObjectInputStream用于输入。

       XMLDecoder xmld=new XMLDecoder(in);//创建一个XMLDecoder对象。

       延用前面所使用PrintUnit这个Bean。

       PrintUnit pu=(PrintUnit)xmld.readObject();//通过XMLDecoder中的readObject方法获得PrintUnit对象。

如果获取到了这个对象那么pu中将有它的值a=A11,b=B22,c=C33。整个过程最好放try

…catch中去，能够捕获一些如：文件不存在等异常。

       从操作方式上看XMLDecoder似乎不比XStream差多少，同样是可以通过ObjectInputStream获取XML文件中的对象。它们的差异就是解析的方式不同，XMLDecoder是使用Java自带的XML解析方式，而XStream则是可以自定义的，它可以使用多中方式进行解析。这些是我个人所发现的一些不同点。



       XMLEncoder是通过一个输出流将对象序列化并输出为XML文件。它所需要的是一个输出流及一个输出方式。



       XMLEncoder的实例：



       String fileStr=”xstream.xml”;//定义一个输入的目标文件。

       ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(fileStr));//创建一个对象输出流。

       XMLEncoder xmle=new XMLEncoder(out);//创建一个XMLEncoder对象。

       延用前面所使用PrintUnit这个Bean。

//创建并初始化PrintUnit对象。

PrintUnit pu=new PrintUnit();

pu.setA(“AAA”);

pu.setB(“BBB”);

pu.setC(“CCC”);



       xmle.writeObject(pu);//使用XMLEncode的writeObject方法输出pu

       xmle.flush();//刷新

       xmle.close();//关闭输出流



       从上面的代码不难看出，使用XMLEncode方式将对象序列化并输出也是很方便的，简单调用writeObject方法能将普通Bean输出为XML文件。



       XML文件的内容：



�</em> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

<java version="1.5.0" class="java.beans.XMLDecoder">

 <object class="test.PrintUnit">

  <void property="a">

   <string>AAA</string>

  </void>

  <void property="b">

   <string>BBB</string>

  </void>

  <void property="c">

   <string>CCC</string>

  </void>

 </object>

<p>w   </java></p>
<pre><code>   不知道是我哪里没有处理，还是实际并不是像我想象的哪么简单，使用XMLEncoder所输出的XML文件中有一定的问题，虽然它很详细，比起XStream所生成的更多，包括了XML和Java的版本看上去更像是个完整的XML文件，不过再细看它们两生成的XML格式内容，完全不同，这个我想就是它们最大的区别。这让我想到了很多内容：工作方式，解析器，转换方式等。大家有没发现在开始和结束都存在一些乱码数据，难道在XMLEncoder输出过程中或数据转换中内容已经存在“脏”数据了？还是我所使用的输出方式存在问题？哎…一个又一个问题出现了。我想我需要再进一步的研究和学习才能得到答案。

   不过尽管有这个那个的问题，使用Java本身自带的XML工具还是一样很实用的，读取和输出一样可用，操作也很灵活。因此我觉得在某些场合使用特定的工具可能会更好，利用XMLEncoder和XMLDecoder同样可以解决一些问题。
</code></pre><p>我的这个使用XMLDecoder和XMLEncoder的序列化格式输出暂研究到这里。
枫情·太子爷
2005年12月16日</p>
<p>发表于 2005-12-16 16:22 <a href="http://www.blogjava.net/zlkn2005/" target="_blank">枫情·太子爷</a> 阅读(3625) <a href="http://www.blogjava.net/zlkn2005/archive/2005/12/16/24240.html#Post" target="_blank">评论(4)</a>  <a href="http://www.blogjava.net/zlkn2005/admin/EditPosts.aspx?postid=24240" target="_blank">编辑</a>  <a href="http://www.blogjava.net/zlkn2005/AddToFavorite.aspx?id=24240" target="_blank">收藏</a></p>
<p><img src="" alt=""></p>
<p><a href=""></a></p>
<p><a href=""></a></p>
<p><a href="">评论</a></p>
<p><a href=""></a></p>
<p><a href=""></a></p>
<p><a href=""></a><a href="http://www.blogjava.net/zlkn2005/archive/2005/12/16/24240.html#24242" title="permalink: re: XStream 学习笔记">/#</a> <a href=""></a>re: XStream 学习笔记  <a href="http://www.blogjava.net/zlkn2005/archive/2005/12/16/24240.html#post">回复</a>  <a href="http://www.blogjava.net/comment?author=fanta" title="查看该作者发表过的评论" target="_blank">更多评论</a>  <a href=""></a>  <a href=""></a>
好</p>
<p><a href="http://www.blogjava.net/fanscial/" target="_blank">fanta</a> 评论于 2005-12-16 16:45
<a href="http://www.blogjava.net/zlkn2005/archive/2005/12/16/24240.html#24616" title="permalink: re: XStream 学习笔记" target="_blank">/#</a> <a href=""></a>re: XStream 学习笔记  <a href="http://www.blogjava.net/zlkn2005/archive/2005/12/16/24240.html#post">回复</a>  <a href="http://www.blogjava.net/comment?author=xmlspy2004" title="查看该作者发表过的评论" target="_blank">更多评论</a>  <a href=""></a>  <a href=""></a></p>
<p>还有很多问题，比如：
当bean的字段为int类型，如果这个字段没有值，它默认输出是0
而实际应用中我们需要的是<intField></intField>.
类似的问题还很多，都需要你去处理。
但处理来处理去，你会发现，自己做的修改很多，还不如自己手动写xml的String。
<a href="">xmlspy2004</a> 评论于 2005-12-19 12:42</p>
<p><a href="http://www.blogjava.net/zlkn2005/archive/2005/12/16/24240.html#183462" title="permalink: re: XStream 学习笔记" target="_blank">/#</a> <a href=""></a>re: XStream 学习笔记  <a href="http://www.blogjava.net/zlkn2005/archive/2005/12/16/24240.html#post">回复</a>  <a href="http://www.blogjava.net/comment?author=%e5%bf%83%e6%97%a0%e7%97%95" title="查看该作者发表过的评论" target="_blank">更多评论</a>  <a href=""></a>  <a href=""></a></p>
<p>呵呵.在JAVA里面,INT类型的变量本来默认值就是0,你没有给它值,它也会默认将0作为这个变量的初始值....@xmlspy2004
<a href="http://www.blogjava.net/xinwuhen/" target="_blank">心无痕</a> 评论于 2008-03-03 14:39
<a href="http://www.blogjava.net/zlkn2005/archive/2005/12/16/24240.html#200051" title="permalink: re: XStream 学习笔记" target="_blank">/#</a> <a href=""></a>re: XStream 学习笔记<a href=""></a>  <a href="http://www.blogjava.net/zlkn2005/archive/2005/12/16/24240.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=jadar" title="查看该作者发表过的评论" target="_blank">更多评论</a>  <a href=""></a>  <a href=""></a></p>
<p>出现：Exception in thread &quot;main&quot; com.thoughtworks.xstream.alias.CannotResolveClassException:
的可能原因是:调用xStream.alias(&quot;PrintUnit &quot;,PrintUnit.class) 时写错了，
尤其是第一个参数，要跟xml中的大小写一致！
good Luck！
<a href="">jadar</a> 评论于 2008-05-12 16:52</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/xml/">xml</a></li></span><span class="breadcrumb"><li><a href="/categories/xml/">xml</a></li><li><a href="/categories/xml/xstream/">xstream</a></li></span></span> | <span class="tags">Tagged <a href="/tags/xml/" class="label label-primary">xml</a><a href="/tags/xstream/" class="label label-success">xstream</a></span> | <span class="time">recent updated:<time title="2014-04-07 08:47:00"datetime="2014-04-07 08:47:00"> abr. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-xml-xstream--XStream学习笔记-枫情的Blog-BlogJava/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-xml-xstream--XStream学习笔记-枫情的Blog-BlogJava" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/19/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/17/">17</a></li><li><a class="page-number" href="/page/18/">18</a></li><li><a class="page-number" href="/page/19/">19</a></li><li class="active"><li><span class="page-number current">20</span></li><li><a class="page-number" href="/page/21/">21</a></li><li><a class="page-number" href="/page/22/">22</a></li><li><a class="page-number" href="/page/23/">23</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/161/">161</a></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="extend next" href="/page/21/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?eaa92c12166944fd3a160103e6c4a8cf"});
</script>


</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-04-14 12:45:07</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
