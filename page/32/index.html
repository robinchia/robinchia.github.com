
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 32 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-gitgithub--Git详解之四：服务器上的Git/">Git详解之四：服务器上的Git</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-gitgithub--Git详解之四：服务器上的Git/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="git-git">Git详解之四：服务器上的Git</h1>
<p>原文：<a href="http://git-scm.com/book/zh" target="_blank">《Pro Git》</a></p>
<p><strong>服务器上的 Git</strong></p>
<p>到目前为止，你应该已经学会了使用 Git 来完成日常工作。然而，如果想与他人合作，还需要一个远程的 Git 仓库。尽管技术上可以从个人的仓库里推送和拉取修改内容，但我们不鼓励这样做，因为一不留心就很容易弄混其他人的进度。另外，你也一定希望合作者们即使在 自己不开机的时候也能从仓库获取数据 — 拥有一个更稳定的公共仓库十分有用。因此，更好的合作方式是建立一个大家都可以访问的共享仓库，从那里推送和拉取数据。我们将把这个仓库称为 “Git 服务器”；代理一个 Git 仓库只需要花费很少的资源，几乎从不需要整个服务器来支持它的运行。（<a href="http://www.jobbole.com/" title="1" target="_blank">伯乐</a>在线注：如果你对Git还不了解，建议从本<a href="http://blog.jobbole.com/25775/" target="_blank">Git</a>系列<a href="http://blog.jobbole.com/25775/" target="_blank">第一篇文章</a>开始阅读）</p>
<p>架设一台 Git 服务器并不难。第一步是选择与服务器通讯的协议。本章第一节将介绍可用的协议以及各自优缺点。下面一节将介绍一些针对各个协议典型的设置以及如何在服务器 上实施。最后，如果你不介意在他人服务器上保存你的代码，又想免去自己架设和维护服务器的麻烦，倒可以试试我们介绍的几个仓库托管服务。</p>
<p>如果你对架设自己的服务器没兴趣，可以跳到本章最后一节去看看如何申请一个代码托管服务的账户然后继续下一章，我们会在那里讨论分布式源码控制环境的林林总总。</p>
<p>远程仓库通常只是一个<em>裸仓库（bare repository）</em> — 即一个没有当前工作目录的仓库。因为该仓库只是一个合作媒介，所以不需要从硬盘上取出最新版本的快照；仓库里存放的仅仅是 Git 的数据。简单地说，裸仓库就是你工作目录中.git 子目录内的内容。</p>
<p><strong>4.1 协议</strong></p>
<p>Git 可以使用四种主要的协议来传输数据：本地传输，SSH 协议，Git 协议和 HTTP 协议。下面分别介绍一下哪些情形应该使用（或避免使用）这些协议。</p>
<p>值得注意的是，除了 HTTP 协议外，其他所有协议都要求在服务器端安装并运行 Git。</p>
<p><strong>本地协议</strong></p>
<p>最基本的就是<em>本地协议（Local protocol）</em>，所谓的远程仓库在该协议中的表示，就是硬盘上的另一个目录。这常见于团队每一个成员都对一个共享的文件系统（例如 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。后面一种情况并不安全，因为所有代码仓库实例都储存在同一台电脑里，增加了灾难性数据损失 的可能性。</p>
<p>如果你使用一个共享的文件系统，就可以在一个本地文件系统中克隆仓库，推送和获取。克隆的时候只需要将远程仓库的路径作为 URL 使用，比如下面这样：
1$ git clone</p>
<p>/opt/git/project</p>
<p>.git</p>
<p>或者这样：</p>
<p>1$ git clone</p>
<p>file</p>
<p>:</p>
<p>///opt/git/project</p>
<p>.git</p>
<p>如果在 URL 开头明确使用 file:// ，那么 Git 会以一种略微不同的方式运行。如果你只给出路径，Git 会尝试使用硬链接或直接复制它所需要的文件。如果使用了file:// ，Git 会调用它平时通过网络来传输数据的工序，而这种方式的效率相对较低。使用 file:// 前缀的主要原因是当你需要一个不包含无关引用或对象的干净仓库副本的时候 — 一般指从其他版本控制系统导入的，或类似情形（参见第 9 章的维护任务）。我们这里仅仅使用普通路径，这样更快。</p>
<p>要添加一个本地仓库作为现有 Git 项目的远程仓库，可以这样做：
1$ git remote add local_proj</p>
<p>/opt/git/project</p>
<p>.git</p>
<p>然后就可以像在网络上一样向这个远程仓库推送和获取数据了。</p>
<p><strong>优点</strong></p>
<p>基于文件仓库的优点在于它的简单，同时保留了现存文件的权限和网络访问权限。如果你的团队已经有一个全体共享的文件系统，建立仓库就十分容易了。你 只需把一份裸仓库的副本放在大家都能访问的地方，然后像对其他共享目录一样设置读写权限就可以了。我们将在下一节“在服务器上部署 Git ”中讨论如何导出一个裸仓库的副本。</p>
<p>这也是从别人工作目录中获取工作成果的快捷方法。假如你和你的同事在一个项目中合作，他们想让你检出一些东西的时候，运行类似 git pull /home/john/project 通常会比他们推送到服务器，而你再从服务器获取简单得多。</p>
<p><strong>缺点</strong></p>
<p>这种方法的缺点是，与基本的网络连接访问相比，难以控制从不同位置来的访问权限。如果你想从家里的笔记本电脑上推送，就要先挂载远程硬盘，这和基于网络连接的访问相比更加困难和缓慢。</p>
<p>另一个很重要的问题是该方法不一定就是最快的，尤其是对于共享挂载的文件系统。本地仓库只有在你对数据访问速度快的时候才快。在同一个服务器上，如果二者同时允许 Git 访问本地硬盘，通过 NFS 访问仓库通常会比 SSH 慢。</p>
<p><strong>SSH 协议</strong></p>
<p>‘Git 使用的传输协议中最常见的可能就是 SSH 了。这是因为大多数环境已经支持通过 SSH 对服务器的访问 — 即便还没有，架设起来也很容易。SSH 也是唯一一个同时支持读写操作的网络协议。另外两个网络协议（HTTP 和 Git）通常都是只读的，所以虽然二者对大多数人都可用，但执行写操作时还是需要 SSH。SSH 同时也是一个验证授权的网络协议；而因为其普遍性，一般架设和使用都很容易。</p>
<p>通过 SSH 克隆一个 Git 仓库，你可以像下面这样给出 ssh:// 的 URL：
1$ git clone</p>
<p>ssh</p>
<p>:</p>
<p>//user</p>
<p>@server:project.git</p>
<p>或者不指明某个协议 — 这时 Git 会默认使用 SSH ：</p>
<p>1$ git clone user@server:project.git</p>
<p>如果不指明用户，Git 会默认使用当前登录的用户名连接服务器。</p>
<p><strong>优点</strong></p>
<p>使用 SSH 的好处有很多。首先，如果你想拥有对网络仓库的写权限，基本上不可能不使用 SSH。其次，SSH 架设相对比较简单 — SSH 守护进程很常见，很多网络管理员都有一些使用经验，而且很多操作系统都自带了它或者相关的管理工具。再次，通过 SSH 进行访问是安全的 — 所有数据传输都是加密和授权的。最后，和 Git 及本地协议一样，SSH 也很高效，会在传输之前尽可能压缩数据。</p>
<p><strong>缺点</strong></p>
<p>SSH 的限制在于你不能通过它实现仓库的匿名访问。即使仅为读取数据，人们也必须在能通过 SSH 访问主机的前提下才能访问仓库，这使得 SSH 不利于开源的项目。如果你仅仅在公司网络里使用，SSH 可能是你唯一需要使用的协议。如果想允许对项目的匿名只读访问，那么除了为自己推送而架设 SSH 协议之外，还需要支持其他协议以便他人访问读取。</p>
<p><strong>Git 协议</strong></p>
<p>接下来是 Git 协议。这是一个包含在 Git 软件包中的特殊守护进程； 它会监听一个提供类似于 SSH 服务的特定端口（9418），而无需任何授权。打算支持 Git 协议的仓库，需要先创建git-export-daemon-ok 文件 — 它是协议进程提供仓库服务的必要条件 — 但除此之外该服务没有什么安全措施。要么所有人都能克隆 Git 仓库，要么谁也不能。这也意味着该协议通常不能用来进行推送。你可以允许推送操作；然而由于没有授权机制，一旦允许该操作，网络上任何一个知道项目 URL 的人将都有推送权限。不用说，这是十分罕见的情况。</p>
<p><strong>优点</strong></p>
<p>Git 协议是现存最快的传输协议。如果你在提供一个有很大访问量的公共项目，或者一个不需要对读操作进行授权的庞大项目，架设一个 Git 守护进程来供应仓库是个不错的选择。它使用与 SSH 协议相同的数据传输机制，但省去了加密和授权的开销。</p>
<p><strong>缺点</strong></p>
<p>Git 协议消极的一面是缺少授权机制。用 Git 协议作为访问项目的唯一方法通常是不可取的。一般的做法是，同时提供 SSH 接口，让几个开发者拥有推送（写）权限，其他人通过git:// 拥有只读权限。Git 协议可能也是最难架设的协议。它要求有单独的守护进程，需要定制 — 我们将在本章的 “Gitosis” 一节详细介绍它的架设 — 需要设定xinetd 或类似的程序，而这些工作就没那么轻松了。该协议还要求防火墙开放 9418 端口，而企业级防火墙一般不允许对这个非标准端口的访问。大型企业级防火墙通常会封锁这个少见的端口。</p>
<p><strong>HTTP/S 协议</strong></p>
<p>最后还有 HTTP 协议。HTTP 或 HTTPS 协议的优美之处在于架设的简便性。基本上，只需要把 Git 的裸仓库文件放在 HTTP 的根目录下，配置一个特定的post-update 挂钩（hook）就可以<a href="http://www.amazon.cn/gp/product/B007XPTAIS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;linkCode=as2&amp;camp=536&amp;creative=3200&amp;creativeASIN=B007XPTAIS" title="搞定(套装共3册) " target="_blank">搞定</a>（Git 挂钩的细节见第 7 章）。此后，每个能访问 Git 仓库所在服务器上 web 服务的人都可以进行克隆操作。下面的操作可以允许通过 HTTP 对仓库进行读取：
1</p>
<p>2
3</p>
<p>4
5$</p>
<p>cd</p>
<p>/var/www/htdocs/</p>
<p>$ git clone --bare</p>
<p>/path/to/git_project</p>
<p>gitproject.git</p>
<p>$</p>
<p>cd</p>
<p>gitproject.git</p>
<p>$</p>
<p>mv</p>
<p>hooks</p>
<p>/post-update</p>
<p>.sample hooks</p>
<p>/post-update</p>
<p>$</p>
<p>chmod</p>
<p>a+x hooks</p>
<p>/post-update</p>
<p>这样就可以了。Git 附带的 post-update 挂钩会默认运行合适的命令（git update-server-info）来确保通过 HTTP 的获取和克隆正常工作。这条命令在你用 SSH 向仓库推送内容时运行；之后，其他人就可以用下面的命令来克隆仓库：</p>
<p>1$ git clone http:</p>
<p>//example</p>
<p>.com</p>
<p>/gitproject</p>
<p>.git</p>
<p>在本例中，我们使用了 Apache 设定中常用的 /var/www/htdocs 路径，不过你可以使用任何静态 web 服务 — 把裸仓库放在它的目录里就行。 Git 的数据是以最基本的静态文件的形式提供的（关于如何提供文件的详情见第 9 章）。</p>
<p>通过 HTTP 进行推送操作也是可能的，不过这种做法不太常见，并且牵扯到复杂的 WebDAV 设定。由于很少用到，本书将略过对该内容的讨论。如果对 HTTP 推送协议感兴趣，不妨打开这个地址看一下操作方法：<a href="http://www.kernel.org/pub/software/scm/git/docs/howto/setup-git-server-over-http.txt" target="_blank">http://www.kernel.org/pub/software/scm/git/docs/howto/setup-git-server-over-http.txt</a> 。通过 HTTP 推送的好处之一是你可以使用任何 WebDAV 服务器，不需要为 Git 设定特殊环境；所以如果主机提供商支持通过 WebDAV 更新网站内容，你也可以使用这项功能。</p>
<p><strong>优点</strong></p>
<p>使用 HTTP 协议的好处是易于架设。几条必要的命令就可以让全世界读取到仓库的内容。花费不过几分钟。HTTP 协议不会占用过多服务器资源。因为它一般只用到静态的 HTTP 服务提供所有数据，普通的 Apache 服务器平均每秒能支撑数千个文件的并发访问 — 哪怕让一个小型服务器超载都很难。</p>
<p>你也可以通过 HTTPS 提供只读的仓库，这意味着你可以加密传输内容；你甚至可以要求客户端使用特定签名的 SSL 证书。一般情况下，如果到了这一步，使用 SSH 公共密钥可能是更简单的方案；不过也存在一些特殊情况，这时通过 HTTPS 使用带签名的 SSL 证书或者其他基于 HTTP 的只读连接授权方式是更好的解决方案。</p>
<p>HTTP 还有个额外的好处：HTTP 是一个如此常见的协议，以至于企业级防火墙通常都允许其端口的通信。</p>
<p><strong>缺点</strong></p>
<p>HTTP 协议的消极面在于，相对来说客户端效率更低。克隆或者下载仓库内容可能会花费更多时间，而且 HTTP 传输的体积和网络开销比其他任何一个协议都大。因为它没有按需供应的能力 — 传输过程中没有服务端的动态计算 — 因而 HTTP 协议经常会被称为<em>傻瓜（dumb）</em>协议。更多 HTTP 协议和其他协议效率上的差异见第 9 。</p>
<p><strong>4.2 在服务器上部署 Git</strong></p>
<p>开始架设 Git 服务器前，需要先把现有仓库导出为裸仓库 — 即一个不包含当前工作目录的仓库。做法直截了当，克隆时用 –bare 选项即可。裸仓库的目录名一般以.git 结尾，像这样：
1</p>
<p>2
$ git clone --bare my_project my_project.git</p>
<p>Initialized empty Git repository</p>
<p>in</p>
<p>/opt/projects/my_project</p>
<p>.git/</p>
<p>该命令的输出或许会让人有些不解。其实 clone 操作基本上相当于 git init 加 git fetch，所以这里出现的其实是git init 的输出，先由它建立一个空目录，而之后传输数据对象的操作并无任何输出，只是悄悄在幕后执行。现在 my_project.git 目录中已经有了一份 Git 目录数据的副本。</p>
<p>整体上的效果大致相当于：
1$</p>
<p>cp</p>
<p>-Rf my_project/.git my_project.git</p>
<p>但在配置文件中有若干小改动，不过对用户来讲，使用方式都一样，不会有什么影响。它仅取出 Git 仓库的必要原始数据，存放在该目录中，而不会另外创建工作目录。</p>
<p><strong>把裸仓库移到服务器上</strong></p>
<p>有了裸仓库的副本后，剩下的就是把它放到服务器上并设定相关协议。假设一个域名为 git.example.com 的服务器已经架设好，并可以通过 SSH 访问，我们打算把所有 Git 仓库储存在/opt/git 目录下。只要把裸仓库复制过去：
1$</p>
<p>scp</p>
<p>-r my_project.git user@ git.example.com:</p>
<p>/opt/git</p>
<p>现在，所有对该服务器有 SSH 访问权限，并可读取 /opt/git 目录的用户都可以用下面的命令克隆该项目：</p>
<p>1$ git clone user@ git.example.com:</p>
<p>/opt/git/my_project</p>
<p>.git</p>
<p>如果某个 SSH 用户对 /opt/git/my_project.git 目录有写权限，那他就有推送权限。如果到该项目目录中运行 git init 命令，并加上 –shared 选项，那么 Git 会自动修改该仓库目录的组权限为可写（译注：实际上 –shared 可以指定其他行为，只是默认为将组权限改为可写并执行 g+sx，所以最后会得到 rws。）。</p>
<p>1</p>
<p>2
3$</p>
<p>ssh</p>
<p>user@ git.example.com</p>
<p>$</p>
<p>cd</p>
<p>/opt/git/my_project</p>
<p>.git</p>
<p>$ git init --bare --shared</p>
<p>由此可见，根据现有的 Git 仓库创建一个裸仓库，然后把它放上你和同事都有 SSH 访问权的服务器是多么容易。现在已经可以开始在同一项目上密切合作了。</p>
<p>值得注意的是，这的的确确是架设一个少数人具有连接权的 Git 服务的全部 — 只要在服务器上加入可以用 SSH 登录的帐号，然后把裸仓库放在大家都有读写权限的地方。一切都准备停当，无需更多。</p>
<p>下面的几节中，你会了解如何扩展到更复杂的设定。这些内容包含如何避免为每一个用户建立一个账户，给仓库添加公共读取权限，架设网页界面，使用 Gitosis 工具等等。然而，只是和几个人在一个不公开的项目上合作的话，仅仅是一个 SSH 服务器和裸仓库就足够了，记住这点就可以了。</p>
<p><strong>小型安装</strong></p>
<p>如果设备较少或者你只想在小型开发团队里尝试 Git ，那么一切都很简单。架设 Git 服务最复杂的地方在于账户管理。如果需要仓库对特定的用户可读，而给另一部分用户读写权限，那么访问和许可的安排就比较困难。</p>
<p><strong>SSH 连接</strong></p>
<p>如果已经有了一个所有开发成员都可以用 SSH 访问的服务器，架设第一个服务器将变得异常简单，几乎什么都不用做（正如上节中介绍的那样）。如果需要对仓库进行更复杂的访问控制，只要使用服务器操作系统的本地文件访问许可机制就行了。</p>
<p>如果需要团队里的每个人都对仓库有写权限，又不能给每个人在服务器上建立账户，那么提供 SSH 连接就是唯一的选择了。我们假设用来共享仓库的服务器已经安装了 SSH 服务，而且你通过它访问服务器。</p>
<p>有好几个办法可以让团队的每个人都有访问权。第一个办法是给每个人建立一个账户，直截了当但略过繁琐。反复运行 adduser 并给所有人设定临时密码可不是好玩的。</p>
<p>第二个办法是在主机上建立一个 git 账户，让每个需要写权限的人发送一个 SSH 公钥，然后将其加入 git 账户的~/.ssh/authorized_keys 文件。这样一来，所有人都将通过 git 账户访问主机。这丝毫不会影响提交的数据 — 访问主机用的身份不会影响提交对象的提交者信息。</p>
<p>另一个办法是让 SSH 服务器通过某个 LDAP 服务，或者其他已经设定好的集中授权机制，来进行授权。只要每个人都能获得主机的 shell 访问权，任何可用的 SSH 授权机制都能达到相同效果。</p>
<p><strong>4.3 生成 SSH 公钥</strong></p>
<p>大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先先确认一下是否已经有一个公钥了。SSH 公钥默认储存在账户的主目录下的~/.ssh 目录。进去看看：
1</p>
<p>2
3</p>
<p>4
$</p>
<p>cd</p>
<p>~/.</p>
<p>ssh</p>
<p>$</p>
<p>ls</p>
<p>authorized_keys2 id_dsa known_hosts</p>
<p>config id_dsa.pub</p>
<p>关键是看有没有用 something 和 something.pub 来命名的一对文件，这个 something 通常就是 id_dsa 或 id_rsa。有 .pub 后缀的文件就是公钥，另一个文件则是密钥。假如没有这些文件，或者干脆连.ssh 目录都没有，可以用 ssh-keygen 来创建。该程序在 Linux/Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9$</p>
<p>ssh</p>
<p>-keygen</p>
<p>Generating public</p>
<p>/private</p>
<p>rsa key pair.</p>
<p>Enter</p>
<p>file</p>
<p>in</p>
<p>which</p>
<p>to save the key (</p>
<p>/Users/schacon/</p>
<p>.</p>
<p>ssh</p>
<p>/id_rsa</p>
<p>):</p>
<p>Enter passphrase (empty</p>
<p>for</p>
<p>no passphrase):</p>
<p>Enter same passphrase again:</p>
<p>Your identification has been saved</p>
<p>in</p>
<p>/Users/schacon/</p>
<p>.</p>
<p>ssh</p>
<p>/id_rsa</p>
<p>.</p>
<p>Your public key has been saved</p>
<p>in</p>
<p>/Users/schacon/</p>
<p>.</p>
<p>ssh</p>
<p>/id_rsa</p>
<p>.pub.</p>
<p>The key fingerprint is:</p>
<p>43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a schacon@ agadorlaptop.</p>
<p>local</p>
<p>它先要求你确认保存公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空。</p>
<p>现在，所有做过这一步的用户都得把它们的公钥给你或者 Git 服务器的管理员（假设 SSH 服务被设定为使用公钥机制）。他们只需要复制 .pub 文件的内容然后发邮件给管理员。公钥的样子大致如下：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7$</p>
<p>cat</p>
<p>~/.</p>
<p>ssh</p>
<p>/id_rsa</p>
<p>.pub</p>
<p>ssh</p>
<p>-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom</p>
<p>/BWDSU</p>
<p>GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3</p>
<p>Pbv7kOdJ</p>
<p>/MTyBlWXFCR</p>
<p>+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK</p>
<p>/7XA</p>
<p>t3FaoJoAsncM1Q9x5+3V0Ww68</p>
<p>/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En</p>
<p>mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z</p>
<p>/il8b</p>
<p>+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx</p>
<p>NrRFi9wrf+M7Q== schacon@ agadorlaptop.</p>
<p>local</p>
<p>关于在多个操作系统上设立相同 SSH 公钥的教程，可以查阅 <a href="http://blog.jobbole.com/6492/" title="GitHub如何运作：时间并不决定一切" target="_blank">GitHub</a> 上有关 SSH 公钥的向导：<a href="http://github.com/guides/providing-your-ssh-key。" target="_blank">http://github.com/guides/providing-your-ssh-key。</a></p>
<p><strong>4.4 架设服务器</strong></p>
<p>现在我们过一边服务器端架设 SSH 访问的流程。本例将使用 authorized_keys 方法来给用户授权。我们还将假定使用类似 Ubuntu 这样的标准 Linux 发行版。首先，创建一个名为 ‘git’ 的用户，并为其创建一个.ssh 目录。
1</p>
<p>2
3</p>
<p>4
$</p>
<p>sudo</p>
<p>adduser git</p>
<p>$</p>
<p>su</p>
<p>git</p>
<p>$</p>
<p>cd</p>
<p>$</p>
<p>mkdir</p>
<p>.</p>
<p>ssh</p>
<p>接下来，把开发者的 SSH 公钥添加到这个用户的 authorized_keys 文件中。假设你通过电邮收到了几个公钥并存到了临时文件里。重复一下，公钥大致看起来是这个样子：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7$</p>
<p>cat</p>
<p>/tmp/id_rsa</p>
<p>.john.pub</p>
<p>ssh</p>
<p>-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n</p>
<p>/ww</p>
<p>+ouN4gSLKssMxXnBOvf9LGt4L</p>
<p>ojG6rs6hPB09j9R</p>
<p>/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK</p>
<p>+4k</p>
<p>Yjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9Ez</p>
<p>Sdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC</p>
<p>/nLF6JLtPofwFBlgc</p>
<p>+myiv</p>
<p>O7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPq</p>
<p>dAv8JggJICUvax2T9va5 gsg-keypair</p>
<p>只要把它们逐个追加到 authorized_keys 文件尾部即可：</p>
<p>1</p>
<p>2
3$</p>
<p>cat</p>
<p>/tmp/id_rsa</p>
<p>.john.pub &gt;&gt; ~/.</p>
<p>ssh</p>
<p>/authorized_keys</p>
<p>$</p>
<p>cat</p>
<p>/tmp/id_rsa</p>
<p>.josie.pub &gt;&gt; ~/.</p>
<p>ssh</p>
<p>/authorized_keys</p>
<p>$</p>
<p>cat</p>
<p>/tmp/id_rsa</p>
<p>.jessica.pub &gt;&gt; ~/.</p>
<p>ssh</p>
<p>/authorized_keys</p>
<p>现在可以用 –bare 选项运行 git init 来建立一个裸仓库，这会初始化一个不包含工作目录的仓库。</p>
<p>1</p>
<p>2
3</p>
<p>4
$</p>
<p>cd</p>
<p>/opt/git</p>
<p>$</p>
<p>mkdir</p>
<p>project.git</p>
<p>$</p>
<p>cd</p>
<p>project.git</p>
<p>$ git --bare init</p>
<p>这时，Join，Josie 或者 Jessica 就可以把它加为远程仓库，推送一个分支，从而把第一个版本的项目文件上传到仓库里了。值得注意的是，每次添加一个新项目都需要通过 shell 登入主机并创建一个裸仓库目录。我们不妨以gitserver 作为 git 用户及项目仓库所在的主机名。如果在网络内部运行该主机，并在 DNS 中设定 gitserver 指向该主机，那么以下这些命令都是可用的：</p>
<p>/# 在 John 的电脑上
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
$</p>
<p>cd</p>
<p>myproject</p>
<p>$ git init</p>
<p>$ git add .</p>
<p>$ git commit -m</p>
<p>&#39;initial commit&#39;</p>
<p>$ git remote add origin git@gitserver:</p>
<p>/opt/git/project</p>
<p>.git</p>
<p>$ git push origin master</p>
<p>这样，其他人的克隆和推送也一样变得很简单：</p>
<p>1</p>
<p>2
3</p>
<p>4
$ git clone git@gitserver:</p>
<p>/opt/git/project</p>
<p>.git</p>
<p>$ vim README</p>
<p>$ git commit -am</p>
<p>&#39;fix for the README file&#39;</p>
<p>$ git push origin master</p>
<p>用这个方法可以很快捷地为少数几个开发者架设一个可读写的 Git 服务。</p>
<p>作为一个额外的防范措施，你可以用 Git 自带的 git-shell 工具限制 git 用户的活动范围。只要把它设为git 用户登入的 shell，那么该用户就无法使用普通的 bash 或者 csh 什么的 shell 程序。编辑 /etc/passwd 文件：
1$</p>
<p>sudo</p>
<p>vim</p>
<p>/etc/passwd</p>
<p>在文件末尾，你应该能找到类似这样的行：</p>
<p>1git:x:1000:1000::</p>
<p>/home/git</p>
<p>:</p>
<p>/bin/sh</p>
<p>把 bin/sh 改为 /usr/bin/git-shell （或者用 which git-shell 查看它的实际安装路径）。该行修改后的样子如下：</p>
<p>1git:x:1000:1000::</p>
<p>/home/git</p>
<p>:</p>
<p>/usr/bin/git-shell</p>
<p>现在 git 用户只能用 SSH 连接来推送和获取 Git 仓库，而不能直接使用主机 shell。尝试普通 SSH 登录的话，会看到下面这样的拒绝信息：</p>
<p>1</p>
<p>2
3$</p>
<p>ssh</p>
<p>git@gitserver</p>
<p>fatal: What</p>
<p>do</p>
<p>you think I am? A shell?</p>
<p>Connection to gitserver closed.</p>
<p><strong>4.5 公共访问</strong></p>
<p>匿名的读取权限该怎么实现呢？也许除了内部私有的项目之外，你还需要托管一些开源项目。或者因为要用一些自动化的服务器来进行编译，或者有一些经常变化的服务器群组，而又不想整天生成新的 SSH 密钥 — 总之，你需要简单的匿名读取权限。</p>
<p>或许对小型的配置来说最简单的办法就是运行一个静态 web 服务，把它的根目录设定为 Git 仓库所在的位置，然后开启本章第一节提到的 post-update 挂钩。这里继续使用之前的例子。假设仓库处于/opt/git 目录，主机上运行着 Apache 服务。重申一下，任何 web 服务程序都可以达到相同效果；作为范例，我们将用一些基本的 Apache 设定来展示大体需要的步骤。</p>
<p>首先，开启挂钩：
1</p>
<p>2
3$</p>
<p>cd</p>
<p>project.git</p>
<p>$</p>
<p>mv</p>
<p>hooks</p>
<p>/post-update</p>
<p>.sample hooks</p>
<p>/post-update</p>
<p>$</p>
<p>chmod</p>
<p>a+x hooks</p>
<p>/post-update</p>
<p>如果用的是 Git 1.6 之前的版本，则可以省略 mv 命令 — Git 是从较晚的版本才开始在挂钩实例的结尾添加 .sample 后缀名的。</p>
<p>post-update 挂钩是做什么的呢？其内容大致如下：
1</p>
<p>2
3$</p>
<p>cat</p>
<p>.git</p>
<p>/hooks/post-update</p>
<p>/#!/bin/sh</p>
<p>exec</p>
<p>git-update-server-info</p>
<p>意思是当通过 SSH 向服务器推送时，Git 将运行这个 git-update-server-info 命令来更新匿名 HTTP 访问获取数据时所需要的文件。</p>
<p>接下来，在 Apache 配置文件中添加一个 VirtualHost 条目，把文档根目录设为 Git 项目所在的根目录。这里我们假定 DNS 服务已经配置好，会把对.gitserver 的请求发送到这台主机：</p>
<p>1</p>
<p>2
3</p>
<p>4
ServerName git.gitserver</p>
<p>DocumentRoot</p>
<p>/opt/git
Order allow, deny</p>
<p>allow from all</p>
<p>另外，需要把 /opt/git 目录的 Unix 用户组设定为 www-data ，这样 web 服务才可以读取仓库内容，因为运行 CGI 脚本的 Apache 实例进程默认就是以该用户的身份起来的：
1$</p>
<p>chgrp</p>
<p>-R www-data</p>
<p>/opt/git</p>
<p>重启 Apache 之后，就可以通过项目的 URL 来克隆该目录下的仓库了。</p>
<p>1$ git clone http:</p>
<p>//git</p>
<p>.gitserver</p>
<p>/project</p>
<p>.git</p>
<p>这一招可以让你在几分钟内为相当数量的用户架设好基于 HTTP 的读取权限。另一个提供非授权访问的简单方法是开启一个 Git 守护进程，不过这将要求该进程作为后台进程常驻 — 接下来的这一节就要讨论这方面的细节。</p>
<p><strong>4.6 GitWeb</strong></p>
<p>现在我们的项目已经有了可读可写和只读的连接方式，不过如果能有一个简单的 web 界面访问就更好了。Git 自带一个叫做 GitWeb 的 CGI 脚本，运行效果可以到<a href="http://git.kernel.org" target="_blank">http://git.kernel.org</a> 这样的站点体验下（见图 4-1）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-on-the-server1.png" title="Git详解之四：服务器上的Git" target="_blank"><img src="&quot;Git详解之四：服务器上的Git&quot;" alt="Git详解之四：服务器上的Git"></a></p>
<p>Figure 4-1. 基于网页的 GitWeb 用户界面</p>
<p>如果想看看自己项目的效果，不妨用 Git 自带的一个命令，可以使用类似 lighttpd 或 webrick 这样轻量级的服务器启动一个临时进程。如果是在 Linux 主机上，通常都预装了lighttpd ，可以到项目目录中键入 git instaweb 来启动。如果用的是 Mac ，Leopard 预装了 Ruby，所以webrick 应该是最好的选择。如果要用 lighttpd 以外的程序来启动 git instaweb，可以通过–httpd 选项指定：
1</p>
<p>2
3$ git instaweb --httpd=webrick</p>
<p>[2009-02-21 10:02:21] INFO WEBrick 1.3.1</p>
<p>[2009-02-21 10:02:21] INFO ruby 1.8.6 (2008-03-03) [universal-darwin9.0]</p>
<p>这会在 1234 端口开启一个 HTTPD 服务，随之在<a href="http://blog.jobbole.com/12749/" title="浏览器" target="_blank">浏览器</a>中显示该页，十分简单。关闭服务时，只需在原来的命令后面加上 –stop 选项就可以了：</p>
<p>1$ git instaweb --httpd=webrick --stop</p>
<p>如果需要为团队或者某个开源项目长期运行 GitWeb，那么 CGI 脚本就要由正常的网页服务来运行。一些 Linux 发行版可以通过 apt 或yum 安装一个叫做 gitweb 的软件包，不妨首先尝试一下。我们将快速介绍一下手动安装 GitWeb 的流程。首先，你需要 Git 的源码，其中带有 GitWeb，并能生成定制的 CGI 脚本：</p>
<p>1</p>
<p>2
3</p>
<p>4
5$ git clone git:</p>
<p>//git</p>
<p>.kernel.org</p>
<p>/pub/scm/git/git</p>
<p>.git</p>
<p>$</p>
<p>cd</p>
<p>git/</p>
<p>$</p>
<p>make</p>
<p>GITWEB_PROJECTROOT=</p>
<p>&quot;/opt/git&quot;</p>
<p>\</p>
<p>prefix=</p>
<p>/usr</p>
<p>gitweb</p>
<p>/gitweb</p>
<p>.cgi</p>
<p>$</p>
<p>sudo</p>
<p>cp</p>
<p>-Rf gitweb</p>
<p>/var/www/</p>
<p>注意，通过指定 GITWEB_PROJECTROOT 变量告诉编译命令 Git 仓库的位置。然后，设置 Apache 以 CGI 方式运行该脚本，添加一个 VirtualHost 配置：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
ServerName gitserver</p>
<p>DocumentRoot</p>
<p>/var/www/gitweb
Options ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch</p>
<p>AllowOverride All</p>
<p>order allow,deny</p>
<p>Allow from all</p>
<p>AddHandler cgi-script cgi</p>
<p>DirectoryIndex gitweb.cgi</p>
<p>不难想象，GitWeb 可以使用任何兼容 CGI 的网页服务来运行；如果偏向使用其他 web 服务器，配置也不会很麻烦。现在，通过 <a href="http://gitserver" target="_blank">http://gitserver</a> 就可以在线访问仓库了，在<a href="http://git.server" target="_blank">http://git.server</a> 上还可以通过 HTTP 克隆和获取仓库的内容。</p>
<p><strong>4.7 Gitosis</strong></p>
<p>把所有用户的公钥保存在 authorized_keys 文件的做法，只能凑和一阵子，当用户数量达到几百人的规模时，管理起来就会十分痛苦。每次改删用户都必须登录服务器不去说，这种做法还缺少必要的权限管理 — 每个人都对所有项目拥有完整的读写权限。</p>
<p>幸好我们还可以选择应用广泛的 Gitosis 项目。简单地说，Gitosis 就是一套用来管理 authorized_keys 文件和实现简单连接限制的脚本。有趣的是，用来添加用户和设定权限的并非通过网页程序，而只是管理一个特殊的 Git 仓库。你只需要在这个特殊仓库内做好相应的设定，然后推送到服务器上，Gitosis 就会随之改变运行策略，听起来就很酷，对吧？</p>
<p>Gitosis 的安装算不上傻瓜化，但也不算太难。用 Linux 服务器架设起来最简单 — 以下例子中，我们使用装有 Ubuntu 8.10 系统的服务器。</p>
<p>Gitosis 的工作依赖于某些 Python 工具，所以首先要安装 Python 的 setuptools 包，在 Ubuntu 上称为 python-setuptools：
1$ apt-get</p>
<p>install</p>
<p>python-setuptools</p>
<p>接下来，从 Gitosis 项目主页克隆并安装：</p>
<p>1</p>
<p>2
3$ git clone git:</p>
<p>//eagain</p>
<p>.net</p>
<p>/gitosis</p>
<p>.git</p>
<p>$</p>
<p>cd</p>
<p>gitosis</p>
<p>$</p>
<p>sudo</p>
<p>python setup.py</p>
<p>install</p>
<p>这会安装几个供 Gitosis 使用的工具。默认 Gitosis 会把 /home/git 作为存储所有 Git 仓库的根目录，这没什么不好，不过我们之前已经把项目仓库都放在/opt/git 里面了，所以为方便起见，我们可以做一个符号连接，直接划转过去，而不必重新配置：</p>
<p>1$</p>
<p>ln</p>
<p>-s</p>
<p>/opt/git</p>
<p>/home/git/repositories</p>
<p>Gitosis 将会帮我们管理用户公钥，所以先把当前控制文件改名备份，以便稍后重新添加，准备好让 Gitosis 自动管理 authorized_keys 文件：</p>
<p>1$</p>
<p>mv</p>
<p>/home/git/</p>
<p>.</p>
<p>ssh</p>
<p>/authorized_keys</p>
<p>/home/git/</p>
<p>.</p>
<p>ssh</p>
<p>/ak</p>
<p>.bak</p>
<p>接下来，如果之前把 git 用户的登录 shell 改为 git-shell 命令的话，先恢复 ‘git’ 用户的登录 shell。改过之后，大家仍然无法通过该帐号登录（译注：因为authorized_keys 文件已经没有了。），不过不用担心，这会交给 Gitosis 来实现。所以现在先打开 /etc/passwd 文件，把这行：</p>
<p>1git:x:1000:1000::</p>
<p>/home/git</p>
<p>:</p>
<p>/usr/bin/git-shell</p>
<p>改回:</p>
<p>1git:x:1000:1000::</p>
<p>/home/git</p>
<p>:</p>
<p>/bin/sh</p>
<p>好了，现在可以初始化 Gitosis 了。你可以用自己的公钥执行 </p>
<p>gitosis-init
 命令，要是公钥不在服务器上，先临时复制一份：</p>
<p>1</p>
<p>2
3$</p>
<p>sudo</p>
<p>-H -u git gitosis-init &lt;</p>
<p>/tmp/id_dsa</p>
<p>.pub</p>
<p>Initialized empty Git repository</p>
<p>in</p>
<p>/opt/git/gitosis-admin</p>
<p>.git/
Reinitialized existing Git repository</p>
<p>in</p>
<p>/opt/git/gitosis-admin</p>
<p>.git/</p>
<p>这样该公钥的拥有者就能修改用于配置 Gitosis 的那个特殊 Git 仓库了。接下来，需要手工对该仓库中的 </p>
<p>post-update
 脚本加上可执行权限：</p>
<p>1$</p>
<p>sudo</p>
<p>chmod</p>
<p>755</p>
<p>/opt/git/gitosis-admin</p>
<p>.git</p>
<p>/hooks/post-update</p>
<p>基本上就算是好了。如果设定过程没出什么差错，现在可以试一下用初始化 Gitosis 的公钥的拥有者身份 SSH 登录服务器，应该会看到类似下面这样：</p>
<p>1</p>
<p>2
3</p>
<p>4
$</p>
<p>ssh</p>
<p>git@gitserver</p>
<p>PTY allocation request failed on channel 0
fatal: unrecognized</p>
<p>command</p>
<p>&#39;gitosis-serve schacon@quaternion&#39;</p>
<p>Connection to gitserver closed.</p>
<p>说明 Gitosis 认出了该用户的身份，但由于没有运行任何 Git 命令，所以它切断了连接。那么，现在运行一个实际的 Git 命令 — 克隆 Gitosis 的控制仓库：</p>
<p>/# 在你本地计算机上</p>
<p>$ git clone git@gitserver:gitosis-admin.git</p>
<p>这会得到一个名为 </p>
<p>gitosis-admin
 的工作目录，主要由两部分组成：
$ cd gitosis-admin</p>
<p>$ find .
./gitosis.conf</p>
<p>./keydir
./keydir/scott.pub</p>
<p>gitosis.conf
 文件是用来设置用户、仓库和权限的控制文件。</p>
<p>keydir
 目录则是保存所有具有访问权限用户公钥的地方— 每人一个。在</p>
<p>keydir
 里的文件名（比如上面的 </p>
<p>scott.pub
）应该跟你的不一样 — Gitosis 会自动从使用 </p>
<p>gitosis-init
 脚本导入的公钥尾部的描述中获取该名字。</p>
<p>看一下 </p>
<p>gitosis.conf
 文件的内容，它应该只包含与刚刚克隆的 </p>
<p>gitosis-admin
 相关的信息：
$ cat gitosis.conf</p>
<p>[gitosis]
[group gitosis-admin]</p>
<p>writable = gitosis-admin
members = scott</p>
<p>它显示用户 </p>
<p>scott
 — 初始化 Gitosis 公钥的拥有者 — 是唯一能管理 </p>
<p>gitosis-admin
 项目的人。</p>
<p>现在我们来添加一个新项目。为此我们要建立一个名为 </p>
<p>mobile
 的新段落，在其中罗列手机开发团队的开发者，以及他们拥有写权限的项目。由于 ‘scott’ 是系统中的唯一用户，我们把他设为唯一用户，并允许他读写名为</p>
<p>iphone_project
 的新项目：
[group mobile]</p>
<p>writable = iphone_project
members = scott</p>
<p>修改完之后，提交 </p>
<p>gitosis-admin
 里的改动，并推送到服务器使其生效：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
$ git commit -am</p>
<p>&#39;add iphone_project and mobile group&#39;</p>
<p>[master]: created 8962da8:</p>
<p>&quot;changed name&quot;</p>
<p>1 files changed, 4 insertions(+), 0 deletions(-)</p>
<p>$ git push
Counting objects: 5,</p>
<p>done</p>
<p>.</p>
<p>Compressing objects: 100% (2</p>
<p>/2</p>
<p>),</p>
<p>done</p>
<p>.
Writing objects: 100% (3</p>
<p>/3</p>
<p>), 272 bytes,</p>
<p>done</p>
<p>.</p>
<p>Total 3 (delta 1), reused 0 (delta 0)
To git@gitserver:</p>
<p>/opt/git/gitosis-admin</p>
<p>.git</p>
<p>fb27aec..8962da8  master -&gt; master</p>
<p>在新工程 </p>
<p>iphone_project
 里首次推送数据到服务器前，得先设定该服务器地址为远程仓库。但你不用事先到服务器上手工创建该项目的裸仓库— Gitosis 会在第一次遇到推送时自动创建：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
$ git remote add origin git@gitserver:iphone_project.git</p>
<p>$ git push origin master</p>
<p>Initialized empty Git repository</p>
<p>in</p>
<p>/opt/git/iphone_project</p>
<p>.git/</p>
<p>Counting objects: 3,</p>
<p>done</p>
<p>.</p>
<p>Writing objects: 100% (3</p>
<p>/3</p>
<p>), 230 bytes,</p>
<p>done</p>
<p>.</p>
<p>Total 3 (delta 0), reused 0 (delta 0)</p>
<p>To git@gitserver:iphone_project.git</p>
<p>/* [new branch] master -&gt; master</p>
<p>请注意，这里不用指明完整路径（实际上，如果加上反而没用），只需要一个冒号加项目名字即可 — Gitosis 会自动帮你映射到实际位置。</p>
<p>要和朋友们在一个项目上协同工作，就得重新添加他们的公钥。不过这次不用在服务器上一个一个手工添加到 ~/.ssh/authorized_keys 文件末端，而只需管理keydir 目录中的公钥文件。文件的命名将决定在 gitosis.conf 中对用户的标识。现在我们为 John，Josie 和 Jessica 添加公钥：
1</p>
<p>2
3$</p>
<p>cp</p>
<p>/tmp/id_rsa</p>
<p>.john.pub keydir</p>
<p>/john</p>
<p>.pub</p>
<p>$</p>
<p>cp</p>
<p>/tmp/id_rsa</p>
<p>.josie.pub keydir</p>
<p>/josie</p>
<p>.pub</p>
<p>$</p>
<p>cp</p>
<p>/tmp/id_rsa</p>
<p>.jessica.pub keydir</p>
<p>/jessica</p>
<p>.pub</p>
<p>然后把他们都加进 ‘mobile’ 团队，让他们对 iphone_project 具有读写权限：</p>
<p>1</p>
<p>2
3[group mobile]</p>
<p>writable = iphone_project</p>
<p>members = scott john josie jessica</p>
<p>如果你提交并推送这个修改，四个用户将同时具有该项目的读写权限。</p>
<p>Gitosis 也具有简单的访问控制功能。如果想让 John 只有读权限，可以这样做：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
[group mobile]</p>
<p>writable = iphone_project</p>
<p>members = scott josie jessica</p>
<p>[group mobile_ro]</p>
<p>readonly</p>
<p>= iphone_project</p>
<p>members = john</p>
<p>现在 John 可以克隆和获取更新，但 Gitosis 不会允许他向项目推送任何内容。像这样的组可以随意创建，多少不限，每个都可以包含若干不同的用户和项目。甚至还可以指定某个组为成员之一（在组名前加上@ 前缀），自动继承该组的成员：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
[group mobile_committers]</p>
<p>members = scott josie jessica
[group mobile]</p>
<p>writable = iphone_project</p>
<p>members = @mobile_committers</p>
<p>[group mobile_2]</p>
<p>writable = another_iphone_project</p>
<p>members = @mobile_committers john</p>
<p>如果遇到意外问题，试试看把 loglevel=DEBUG 加到 [gitosis] 的段落（译注：把日志设置为调试级别，记录更详细的运行信息。）。如果一不小心搞错了配置，失去了推送权限，也可以手工修改服务器上的/home/git/.gitosis.conf 文件 — Gitosis 实际是从该文件读取信息的。它在得到推送数据时，会把新的 gitosis.conf 存到该路径上。所以如果你手工编辑该文件的话，它会一直保持到下次向 gitosis-admin 推送新版本的配置内容为止。</p>
<p><strong>4.8 Gitolite</strong></p>
<p>Note: the latest copy of this section of the ProGit book is always available within thegitolite documentation. The author would also like to humbly state that, while this section is accurate, andcan (and often has) been used to install gitolite without reading any other documentation, it is of necessity not complete, and cannot completely replace the enormous amount of documentation that gitolite comes with.</p>
<p>Git has started to become very popular in corporate environments, which tend to have some additional requirements in terms of access control. Gitolite was originally created to help with those requirements, but it turns out that it’s equally useful in the open source world: the Fedora Project controls access to their package management repositories (over 10,000 of them!) using gitolite, and this is probably the largest gitolite installation anywhere too.</p>
<p>Gitolite allows you to specify permissions not just by repository, but also by branch or tag names within each repository. That is, you can specify that certain people (or groups of people) can only push certain “refs” (branches or tags) but not others.</p>
<p><strong>Installing</strong></p>
<p>Installing Gitolite is very easy, even if you don’t read the extensive documentation that comes with it. You need an account on a Unix server of some kind; various Linux flavours, and Solaris 10, have been tested. You do not need root access, assuming git, perl, and an openssh compatible ssh server are already installed. In the examples below, we will use thegitolite account on a host called gitserver.</p>
<p>Gitolite is somewhat unusual as far as “server” software goes – access is via ssh, and so every userid on the server is a potential “gitolite host”. As a result, there is a notion of “installing” the software itself, and then “setting up” a user as a “gitolite host”.</p>
<p>Gitolite has 4 methods of installation. People using Fedora or Debian systems can obtain an RPM or a DEB and install that. People with root access can install it manually. In these two methods, any user on the system can then become a “gitolite host”.</p>
<p>People without root access can install it within their own userids. And finally, gitolite can be installed by running a scripton the workstation, from a bash shell. (Even the bash that comes with msysgit will do, in case you’re wondering.)</p>
<p>We will describe this last method in this article; for the other methods please see the documentation.</p>
<p>You start by obtaining public key based access to your server, so that you can log in from your workstation to the server without getting a password prompt. The following method works on Linux; for other workstation OSs you may have to do this manually. We assume you already had a key pair generated using ssh-keygen.
1$</p>
<p>ssh</p>
<p>-copy-</p>
<p>id</p>
<p>-i ~/.</p>
<p>ssh</p>
<p>/id_rsa</p>
<p>gitolite@gitserver</p>
<p>This will ask you for the password to the gitolite account, and then set up public key access. This isessential for the install script, so check to make sure you can run a command without getting a password prompt:</p>
<p>1</p>
<p>2
$</p>
<p>ssh</p>
<p>gitolite@gitserver</p>
<p>pwd</p>
<p>/home/gitolite</p>
<p>Next, you clone Gitolite from the project’s main site and run the “easy install” script (the third argument is your name as you would like it to appear in the resulting gitolite-admin repository):</p>
<p>1</p>
<p>2
3$ git clone git:</p>
<p>//github</p>
<p>.com</p>
<p>/sitaramc/gitolite</p>
<p>$</p>
<p>cd</p>
<p>gitolite</p>
<p>/src</p>
<p>$ .</p>
<p>/gl-easy-install</p>
<p>-q gitolite gitserver sitaram</p>
<p>And you’re done! Gitolite has now been installed on the server, and you now have a brand new repository calledgitolite-admin in the home directory of your workstation. You administer your gitolite setup by making changes to this repository and pushing.</p>
<p>That last command does produce a fair amount of output, which might be interesting to read. Also, the first time you run this, a new keypair is created; you will have to choose a passphrase or hit enter for none. Why a second keypair is needed, and how it is used, is explained in the “ssh troubleshooting” document that comes with Gitolite. (Hey the documentation has to be good forsomething!)</p>
<p>Repos named gitolite-admin and testing are created on the server by default. If you wish to clone either of these locally (from an account that has SSH console access to the gitolite account viaauthorized_keys), type:
1</p>
<p>2
$ git clone gitolite:gitolite-admin</p>
<p>$ git clone gitolite:testing</p>
<p>To clone these same repos from any other account:</p>
<p>1</p>
<p>2
$ git clone gitolite@servername:gitolite-admin</p>
<p>$ git clone gitolite@servername:testing</p>
<p><strong>Customising the Install</strong></p>
<p>While the default, quick, install works for most people, there are some ways to customise the install if you need to. If you omit the-q argument, you get a “verbose” mode install – detailed information on what the install is doing at each step. The verbose mode also allows you to change certain server-side parameters, such as the location of the actual repositories, by editing an “rc” file that the server uses. This “rc” file is liberally commented so you should be able to make any changes you need quite easily, save it, and continue. This file also contains various settings that you can change to enable or disable some of gitolite’s advanced features.</p>
<p>Config File and Access Control Rules
Once the install is done, you switch to the gitolite-admin repository (placed in your HOME directory) and poke around to see what you got:</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11</p>
<p>12
13$</p>
<p>cd</p>
<p>~</p>
<p>/gitolite-admin/</p>
<p>$</p>
<p>ls</p>
<p>conf/ keydir/</p>
<p>$</p>
<p>find</p>
<p>conf keydir -</p>
<p>type</p>
<p>f</p>
<p>conf</p>
<p>/gitolite</p>
<p>.conf</p>
<p>keydir</p>
<p>/sitaram</p>
<p>.pub</p>
<p>$</p>
<p>cat</p>
<p>conf</p>
<p>/gitolite</p>
<p>.conf</p>
<p>/#gitolite conf</p>
<p>/# please see conf/example.conf for details on syntax and features</p>
<p>repo gitolite-admin</p>
<p>RW+ = sitaram</p>
<p>repo testing</p>
<p>RW+ = @all</p>
<p>Notice that “sitaram” (the last argument in the gl-easy-install command you gave earlier) has read-write permissions on thegitolite-admin repository as well as a public key file of the same name.</p>
<p>The config file syntax for gitolite is liberally documented in conf/example.conf, so we’ll only mention some highlights here.</p>
<p>You can group users or repos for convenience. The group names are just like macros; when defining them, it doesn’t even matter whether they are projects or users; that distinction is only made when youuse the “macro”.</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
@oss_repos = linux perl rakudo git gitolite</p>
<p>@secret_repos = fenestra pear
@admins = scott</p>
<p>/# Adams, not Chacon, sorry <img src="http://blog.jobbole.com/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley"></p>
<p>@interns = ashok</p>
<p>/# get the spelling right, Scott!</p>
<p>@engineers = sitaram dilbert wally alice</p>
<p>@staff = @admins @engineers @interns</p>
<p>You can control permissions at the “ref” level. In the following example, interns can only push the “int” branch. Engineers can push any branch whose name starts with “eng-“, and tags that start with “rc” followed by a digit. And the admins can do anything (including rewind) to any ref.</p>
<p>1</p>
<p>2
3</p>
<p>4
5repo @oss_repos</p>
<p>RW int$ = @interns</p>
<p>RW eng- = @engineers</p>
<p>RW refs</p>
<p>/tags/rc</p>
<p>[0-9] = @engineers</p>
<p>RW+ = @admins</p>
<p>The expression after the RW or RW+ is a regular expression (regex) that the refname (ref) being pushed is matched against. So we call it a “refex”! Of course, a refex can be far more powerful than shown here, so don’t overdo it if you’re not comfortable with perl regexes.</p>
<p>Also, as you probably guessed, Gitolite prefixes refs/heads/ as a syntactic convenience if the refex does not begin withrefs/.</p>
<p>An important feature of the config file’s syntax is that all the rules for a repository need not be in one place. You can keep all the common stuff together, like the rules for alloss_repos shown above, then add specific rules for specific cases later on, like so:
1</p>
<p>2
repo gitolite</p>
<p>RW+ = sitaram</p>
<p>That rule will just get added to the ruleset for the gitolite repository.</p>
<p>At this point you might be wondering how the access control rules are actually applied, so let’s go over that briefly.</p>
<p>There are two levels of access control in gitolite. The first is at the repository level; if you have read (or write) access toany ref in the repository, then you have read (or write) access to the repository.</p>
<p>The second level, applicable only to “write” access, is by branch or tag within a repository. The username, the access being attempted (W or+), and the refname being updated are known. The access rules are checked in order of appearance in the config file, looking for a match for this combination (but remember that the refname is regex-matched, not merely string-matched). If a match is found, the push succeeds. A fallthrough results in access being denied.</p>
<p><strong>Advanced Access Control with “deny” rules</strong></p>
<p>So far, we’ve only seen permissions to be one or R, RW, orRW+. However, gitolite allows another permission: -, standing for “deny”. This gives you a lot more power, at the expense of some complexity, because now fallthrough is not theonly way for access to be denied, so the order of the rules now matters!</p>
<p>Let us say, in the situation above, we want engineers to be able to rewind any branchexcept master and integ. Here’s how to do that:
1</p>
<p>2
3RW master integ = @engineers</p>
<ul>
<li>master integ = @engineers</li>
</ul>
<p>RW+ = @engineers</p>
<p>Again, you simply follow the rules top down until you hit a match for your access mode, or a deny. Non-rewind push to master or integ is allowed by the first rule. A rewind push to those refs does not match the first rule, drops down to the second, and is therefore denied. Any push (rewind or non-rewind) to refs other than master or integ won’t match the first two rules anyway, and the third rule allows it.</p>
<p><strong>Restricting pushes by files changed</strong></p>
<p>In addition to restricting what branches a user can push changes to, you can also restrict what files they are allowed to touch. For example, perhaps the Makefile (or some other program) is really not supposed to be changed by just anyone, because a lot of things depend on it or would break if the changes are not done just right. You can tell gitolite:</p>
<p>1</p>
<p>2
3</p>
<p>4
5repo foo</p>
<p>RW = @junior_devs @senior_devs
RW NAME/ = @senior_devs</p>
<ul>
<li>NAME</li>
</ul>
<p>/Makefile</p>
<p>= @junior_devs</p>
<p>RW NAME/ = @junior_devs</p>
<p>This powerful feature is documented in conf/example.conf.</p>
<p><strong>Personal Branches</strong></p>
<p>Gitolite also has a feature called “personal branches” (or rather, “personal branch namespace”) that can be very useful in a corporate environment.</p>
<p>A lot of code exchange in the git world happens by “please pull” requests. In a corporate environment, however, unauthenticated access is a no-no, and a developer workstation cannot do authentication, so you have to push to the central server and ask someone to pull from there.</p>
<p>This would normally cause the same branch name clutter as in a centralised VCS, plus setting up permissions for this becomes a chore for the admin.</p>
<p>Gitolite lets you define a “personal” or “scratch” namespace prefix for each developer (for example,refs/personal/ //* ); see the “personal branches” section in doc/3-faq-tips-etc.mkd for details.</p>
<p><strong>“Wildcard” repositories</strong></p>
<p>Gitolite allows you to specify repositories with wildcards (actually perl regexes), like, for exampleassignments/s[0-9][0-9]/a[0-9][0-9], to pick a random example. This is avery powerful feature, which has to be enabled by setting $GL_WILDREPOS = 1; in the rc file. It allows you to assign a new permission mode (”C”) which allows users to create repositories based on such wild cards, automatically assigns ownership to the specific user who created it, allows him/her to hand out R and RW permissions to other users to collaborate, etc. This feature is documented indoc/4-wildcard-repositories.mkd.</p>
<p><strong>Other Features</strong></p>
<p>We’ll round off this discussion with a sampling of other features, all of which, and many more, are described in great detail in the “faqs, tips, etc” and other documents.</p>
<p>Logging: Gitolite logs all successful accesses. If you were somewhat relaxed about giving people rewind permissions (RW+) and some kid blew away “master”, the log file is a life saver, in terms of easily and quickly finding the SHA that got hosed.</p>
<p>Git outside normal PATH: One extremely useful convenience feature in gitolite is support for git installed outside the normal$PATH (this is more common than you think; some corporate environments or even some hosting providers refuse to install things system-wide and you end up putting them in your own directories). Normally, you are forced to make theclient-side git aware of this non-standard location of the git binaries in some way. With gitolite, just choose a verbose install and set$GIT_PATH in the “rc” files. No client-side changes are required after that <img src="" alt=":-)"></p>
<p>Access rights reporting: Another convenient feature is what happens when you try and just ssh to the server. Gitolite shows you what repos you have access to, and what that access may be. Here’s an example:
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9hello sitaram, the gitolite version here is v1.5.4-19-ga3397d4</p>
<p>the gitolite config gives you the following access:</p>
<p>R anu-wsd</p>
<p>R entrans</p>
<p>R W git-notes</p>
<p>R W gitolite</p>
<p>R W gitolite-admin</p>
<p>R indic_web_input</p>
<p>R shreelipi_converter</p>
<p>Delegation: For really large installations, you can delegate responsibility for groups of repositories to various people and have them manage those pieces independently. This reduces the load on the main admin, and makes him less of a bottleneck. This feature has its own documentation file in the doc/ directory.</p>
<p>Gitweb support: Gitolite supports gitweb in several ways. You can specify which repos are visible via gitweb. You can set the “owner” and “description” for gitweb from the gitolite config file. Gitweb has a mechanism for you to implement access control based on HTTP authentication, so you can make it use the “compiled” config file that gitolite produces, which means the same access control rules (for read access) apply for gitweb and gitolite.</p>
<p>Mirroring: Gitolite can help you maintain multiple mirrors, and switch between them easily if the primary server goes down.</p>
<p><strong>4.9 Git 守护进程</strong></p>
<p>对于提供公共的，非授权的只读访问，我们可以抛弃 HTTP 协议，改用 Git 自己的协议，这主要是出于性能和速度的考虑。Git 协议远比 HTTP 协议高效，因而访问速度也快，所以它能节省很多用户的时间。</p>
<p>重申一下，这一点只适用于非授权的只读访问。如果建在防火墙之外的服务器上，那么它所提供的服务应该只是那些公开的只读项目。如果是在防火墙之内的 服务器上，可用于支撑大量参与人员或自动系统（用于<a href="http://www.amazon.cn/gp/product/B008AY9XCY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B008AY9XCY&amp;linkCode=as2&amp;tag=vastwork-23" title="持续集成:软件质量改进和风险降低之道" target="_blank">持续集成</a>或编译的主机）只读访问的项目，这样可以省去逐一配置 SSH 公钥的麻烦。</p>
<p>但不管哪种情形，Git 协议的配置设定都很简单。基本上，只要以守护进程的形式运行该命令即可：
1git daemon --reuseaddr --base-path=</p>
<p>/opt/git/</p>
<p>/opt/git/</p>
<p>这里的 –reuseaddr 选项表示在重启服务前，不等之前的连接超时就立即重启。而 –base-path 选项则允许克隆项目时不必给出完整路径。最后面的路径告诉 Git 守护进程允许开放给用户访问的仓库目录。假如有防火墙，则需要为该主机的 9418 端口设置为允许通信。</p>
<p>以守护进程的形式运行该进程的方法有很多，但主要还得看用的是什么操作系统。在 Ubuntu 主机上，可以用 Upstart 脚本达成。编辑该文件：
1/etc/event</p>
<p>.d</p>
<p>/local-git-daemon</p>
<p>加入以下内容：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
start on startup</p>
<p>stop on</p>
<p>shutdown</p>
<p>exec</p>
<p>/usr/bin/git</p>
<p>daemon \</p>
<p>--user=git --group=git \</p>
<p>--reuseaddr \</p>
<p>--base-path=</p>
<p>/opt/git/</p>
<p>\</p>
<p>/opt/git/</p>
<p>respawn</p>
<p>出于安全考虑，强烈建议用一个对仓库只有读取权限的用户身份来运行该进程 — 只需要简单地新建一个名为 git-ro 的用户（译注：新建用户默认对仓库文件不具备写权限，但这取决于仓库目录的权限设定。务必确认git-ro 对仓库只能读不能写。），并用它的身份来启动进程。这里为了简化，后面我们还是用之前运行 Gitosis 的用户 ‘git’。</p>
<p>这样一来，当你重启计算机时，Git 进程也会自动启动。要是进程意外退出或者被杀掉，也会自行重启。在设置完成后，不重启计算机就启动该守护进程，可以运行：
1initctl start</p>
<p>local</p>
<p>-git-daemon</p>
<p>而在其他操作系统上，可以用 xinetd，或者 sysvinit 系统的脚本，或者其他类似的脚本 — 只要能让那个命令变为守护进程并可监控。</p>
<p>接下来，我们必须告诉 Gitosis 哪些仓库允许通过 Git 协议进行匿名只读访问。如果每个仓库都设有各自的段落，可以分别指定是否允许 Git 进程开放给用户匿名读取。比如允许通过 Git 协议访问 iphone_project，可以把下面两行加到gitosis.conf 文件的末尾：
1</p>
<p>2
[repo iphone_project]</p>
<p>daemon =</p>
<p>yes</p>
<p>在提交和推送完成后，运行中的 Git 守护进程就会响应来自 9418 端口对该项目的访问请求。</p>
<p>如果不考虑 Gitosis，单单起了 Git 守护进程的话，就必须到每一个允许匿名只读访问的仓库目录内，创建一个特殊名称的空文件作为标志：
1</p>
<p>2
$</p>
<p>cd</p>
<p>/path/to/project</p>
<p>.git</p>
<p>$</p>
<p>touch</p>
<p>git-daemon-</p>
<p>export</p>
<p>-ok</p>
<p>该文件的存在，表明允许 Git 守护进程开放对该项目的匿名只读访问。</p>
<p>Gitosis 还能设定哪些项目允许放在 GitWeb 上显示。先打开 GitWeb 的配置文件 /etc/gitweb.conf，添加以下四行：
1</p>
<p>2
3</p>
<p>4
$projects_list =</p>
<p>&quot;/home/git/gitosis/projects.list&quot;</p>
<p>;</p>
<p>$projectroot =</p>
<p>&quot;/home/git/repositories&quot;</p>
<p>;</p>
<p>$export_ok =</p>
<p>&quot;git-daemon-export-ok&quot;</p>
<p>;</p>
<p>@git_base_url_list = (</p>
<p>&#39;git://gitserver&#39;</p>
<p>);</p>
<p>接下来，只要配置各个项目在 Gitosis 中的 gitweb 参数，便能达成是否允许 GitWeb 用户浏览该项目。比如，要让 iphone_project 项目在 GitWeb 里出现，把repo 的设定改成下面的样子：</p>
<p>1</p>
<p>2
3[repo iphone_project]</p>
<p>daemon =</p>
<p>yes</p>
<p>gitweb =</p>
<p>yes</p>
<p>在提交并推送过之后，GitWeb 就会自动开始显示 iphone_project 项目的细节和历史。</p>
<p><strong>4.10 Git 托管服务</strong></p>
<p>如果不想经历自己架设 Git 服务器的麻烦，网络上有几个专业的仓库托管服务可供选择。这样做有几大优点：托管账户的建立通常比较省时，方便项目的启动，而且不涉及服务器的维护和监 控。即使内部创建并运行着自己的服务器，同时为开源项目提供一个公共托管站点还是有好处的 — 让开源社区更方便地找到该项目，并给予帮助。</p>
<p>目前，可供选择的托管服务数量繁多，各有利弊。在 Git 官方 wiki 上的 Githosting 页面有一个最新的托管服务列表：
1http:</p>
<p>//git</p>
<p>.or.cz</p>
<p>/gitwiki/GitHosting</p>
<p>由于本书无法全部一一介绍，而本人（译注：指本书作者 Scott Chacon。）刚好在其中一家公司工作，所以接下来我们将会介绍如何在 GitHub 上建立新账户并启动项目。至于其他托管服务大体也是这么一个过程，基本的想法都是差不多的。</p>
<p>GitHub 是目前为止最大的开源 Git 托管服务，并且还是少数同时提供公共代码和私有代码托管服务的站点之一，所以你可以在上面同时保存开源和商业代码。事实上，本书就是放在 GitHub 上合作编著的。（译注：本书的翻译也是放在 GitHub 上广泛协作的。）</p>
<p><strong>GitHub</strong></p>
<p>GitHub 和大多数的代码托管站点在处理项目命名空间的方式上略有不同。GitHub 的设计更侧重于用户，而不是完全基于项目。也就是说，如果我在 GitHub 上托管一个名为grit 的项目的话，它的地址不会是 github.com/grit，而是按在用户底下 github.com/shacon/grit （译注：本书作者 Scott Chacon 在 GitHub 上的用户名是shacon。）。不存在所谓某个项目的官方版本，所以假如第一作者放弃了某个项目，它可以无缝转移到其它用户的名下。</p>
<p>GitHub 同时也是一个向使用私有仓库的用户收取费用的商业公司，但任何人都可以方便快捷地申请到一个免费账户，并在上面托管数量不限的开源项目。接下来我们快速介绍一下 GitHub 的基本使用。</p>
<p><strong>建立新账户</strong></p>
<p>首先注册一个免费账户。访问 Pricing and Signup 页面 <a href="http://github.com/plans" target="_blank">http://github.com/plans</a> 并点击 Free acount 里的 Sign Up 按钮（见图 4-2），进入注册页面。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-on-the-server2.png" title="Git详解之四：服务器上的Git" target="_blank"><img src="&quot;Git详解之四：服务器上的Git&quot;" alt="Git详解之四：服务器上的Git"></a></p>
<p>图 4-2. GitHub 服务简介页面</p>
<p>选择一个系统中尚未使用的用户名，提供一个与之相关联的电邮地址，并输入密码（见图 4-3）：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-on-the-server3.png" title="Git详解之四：服务器上的Git" target="_blank"><img src="&quot;Git详解之四：服务器上的Git&quot;" alt="Git详解之四：服务器上的Git"></a></p>
<p>图 4-3. GitHub 用户注册表单</p>
<p>如果方便，现在就可以提供你的 SSH 公钥。我们在前文的”小型安装” 一节介绍过生成新公钥的方法。把新生成的公钥复制粘贴到 SSH Public Key 文本框中即可。要是对生成公钥的步骤不太清楚，也可以点击 “explain ssh keys” 链接，会显示各个主流操作系统上完成该步骤的介绍。点击 “I agree，sign me up” 按钮完成用户注册，并转到该用户的 dashboard 页面（见图 4-4）:</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-on-the-server4.png" title="Git详解之四：服务器上的Git" target="_blank"><img src="&quot;Git详解之四：服务器上的Git&quot;" alt="Git详解之四：服务器上的Git"></a></p>
<p>图 4-4. GitHub 的用户面板</p>
<p>接下来就可以建立新仓库了。</p>
<p><strong>建立新仓库</strong></p>
<p>点击用户面板上仓库旁边的 “create a new one” 链接，显示 Create a New Repository 的表单（见图 4-5）：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-on-the-server5.png" title="Git详解之四：服务器上的Git" target="_blank"><img src="&quot;Git详解之四：服务器上的Git&quot;" alt="Git详解之四：服务器上的Git"></a></p>
<p>图 4-5. 在 GitHub 上建立新仓库</p>
<p>当然，项目名称是必不可少的，此外也可以适当描述一下项目的情况或者给出官方站点的地址。然后点击 “Create Repository” 按钮，新仓库就建立起来了（见图 4-6）：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-on-the-server6.png" title="Git详解之四：服务器上的Git" target="_blank"><img src="&quot;Git详解之四：服务器上的Git&quot;" alt="Git详解之四：服务器上的Git"></a></p>
<p>图 4-6. GitHub 上各个项目的概要信息</p>
<p>由于尚未提交代码，点击项目地址后 GitHub 会显示一个简要的指南，告诉你如何新建一个项目并推送上来，如何从现有项目推送，以及如何从一个公共的 Subversion 仓库导入项目（见图 4-7）：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-on-the-server7.png" title="Git详解之四：服务器上的Git" target="_blank"><img src="&quot;Git详解之四：服务器上的Git&quot;" alt="Git详解之四：服务器上的Git"></a></p>
<p>图 4-7. 新仓库指南</p>
<p>该指南和本书前文介绍的类似，对于新的项目，需要先在本地初始化为 Git 项目，添加要管理的文件并作首次提交：
1</p>
<p>2
3$ git init</p>
<p>$ git add .</p>
<p>$ git commit -m</p>
<p>&#39;initial commit&#39;</p>
<p>然后在这个本地仓库内把 GitHub 添加为远程仓库，并推送 master 分支上来：</p>
<p>1</p>
<p>2
$ git remote add origin git@ github.com:testinguser</p>
<p>/iphone_project</p>
<p>.git</p>
<p>$ git push origin master</p>
<p>现在该项目就托管在 GitHub 上了。你可以把它的 URL 分享给每位对此项目感兴趣的人。本例的 URL 是 <a href="http://github.com/testinguser/iphone_project。而在项目页面的摘要部分，你会发现有两个" target="_blank">http://github.com/testinguser/iphone_project。而在项目页面的摘要部分，你会发现有两个</a> Git URL 地址（见图 4-8）：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-on-the-server8.png" title="Git详解之四：服务器上的Git" target="_blank"><img src="&quot;Git详解之四：服务器上的Git&quot;" alt="Git详解之四：服务器上的Git"></a></p>
<p>图 4-8. 项目摘要中的公共 URL 和私有 URL</p>
<p>Public Clone URL 是一个公开的，只读的 Git URL，任何人都可以通过它克隆该项目。可以随意散播这个 URL，比如发布到个人网站之类的地方等等。</p>
<p>Your Clone URL 是一个基于 SSH 协议的可读可写 URL，只有使用与上传的 SSH 公钥对应的密钥来连接时，才能通过它进行读写操作。其他用户访问该项目页面时只能看到之前那个公共的 URL，看不到这个私有的 URL。</p>
<p><strong>从 Subversion 导入项目</strong></p>
<p>如果想把某个公共 Subversion 项目导入 Git，GitHub 可以帮忙。在指南的最后有一个指向导入 Subversion 页面的链接。点击它会看到一个表单，包含有关导入流程的信息以及一个用来粘贴公共 Subversion 项目连接的文本框（见图 4-9）：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-on-the-server9.png" title="Git详解之四：服务器上的Git" target="_blank"><img src="&quot;Git详解之四：服务器上的Git&quot;" alt="Git详解之四：服务器上的Git"></a></p>
<p>图 4-9. Subversion 导入界面</p>
<p>如果项目很大，采用非标准结构，或者是私有的，那就无法借助该工具实现导入。到第 7 章，我们会介绍如何手工导入复杂工程的具体方法。</p>
<p><strong>添加协作开发者</strong></p>
<p>现在把团队里的其他人也加进来。如果 John，Josie 和 Jessica 都在 GitHub 注册了账户，要赋予他们对该仓库的推送权限，可以把他们加为项目协作者。这样他们就可以通过各自的公钥访问我的这个仓库了。</p>
<p>点击项目页面上方的 “edit” 按钮或者顶部的 Admin 标签，进入该项目的管理页面（见图 4-10）：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-on-the-server10.png" title="Git详解之四：服务器上的Git" target="_blank"><img src="&quot;Git详解之四：服务器上的Git&quot;" alt="Git详解之四：服务器上的Git"></a></p>
<p>图 4-10. GitHub 的项目管理页面</p>
<p>为了给另一个用户添加项目的写权限，点击 “Add another collaborator” 链接，出现一个用于输入用户名的表单。在输入的同时，它会自动跳出一个符合条件的候选名单。找到正确用户名之后，点 Add 按钮，把该用户设为项目协作者（见图 4-11）：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-on-the-server11.png" title="Git详解之四：服务器上的Git" target="_blank"><img src="&quot;Git详解之四：服务器上的Git&quot;" alt="Git详解之四：服务器上的Git"></a></p>
<p>图 4-11. 为项目添加协作者</p>
<p>添加完协作者之后，就可以在 Repository Collaborators 区域看到他们的名单（见图 4-12）：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-on-the-server12.png" title="Git详解之四：服务器上的Git" target="_blank"><img src="&quot;Git详解之四：服务器上的Git&quot;" alt="Git详解之四：服务器上的Git"></a></p>
<p>图 4-12. 项目协作者名单</p>
<p>如果要取消某人的访问权，点击 “revoke” 即可取消他的推送权限。对于将来的项目，你可以从现有项目复制协作者名单，或者直接借用协作者群组。</p>
<p><strong>项目页面</strong></p>
<p>在推送或从 Subversion 导入项目之后，你会看到一个类似图 4-13 的项目主页：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-on-the-server13.png" title="Git详解之四：服务器上的Git" target="_blank"><img src="&quot;Git详解之四：服务器上的Git&quot;" alt="Git详解之四：服务器上的Git"></a></p>
<p>图 4-13. GitHub 上的项目主页</p>
<p>别人访问你的项目时看到的就是这个页面。它有若干导航标签，Commits 标签用于显示提交历史，最新的提交位于最上方，这和 git log 命令的输出类似。Network 标签展示所有派生了该项目并做出贡献的用户的关系图谱。Downloads 标签允许你上传项目的二进制文件，提供下载该项目各个版本的 tar/zip 包。Wiki 标签提供了一个用于撰写文档或其他项目相关信息的 wiki 站点。Graphs 标签包含了一些可视化的项目信息与数据。默认打开的 Source 标签页面，则列出了该项目的目录结构和概要信息，并在下方自动展示 README 文件的内容（如果该文件存在的话），此外还会显示最近一次提交的相关信息。</p>
<p><strong>派生项目</strong></p>
<p>如果要为一个自己没有推送权限的项目贡献代码，GitHub 鼓励使用派生（fork）。到那个感兴趣的项目主页上，点击页面上方的 “fork” 按钮，GitHub 就会为你复制一份该项目的副本到你的仓库中，这样你就可以向自己的这个副本推送数据了。</p>
<p>采取这种办法的好处是，项目拥有者不必忙于应付赋予他人推送权限的工作。随便谁都可以通过派生得到一个项目副本并在其中展开工作，事后只需要项目维护者将这些副本仓库加为远程仓库，然后提取更新合并即可。</p>
<p>要派生一个项目，到原始项目的页面（本例中是 mojombo/chronic）点击 “fork” 按钮（见图 4-14）：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-on-the-server14.png" title="Git详解之四：服务器上的Git" target="_blank"><img src="&quot;Git详解之四：服务器上的Git&quot;" alt="Git详解之四：服务器上的Git"></a></p>
<p>图 4-14. 点击 “fork” 按钮获得任意项目的可写副本</p>
<p>几秒钟之后，你将进入新建的项目页面，会显示该项目派生自哪一个项目（见图 4-15）：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-on-the-server16.png" title="Git详解之四：服务器上的Git" target="_blank"><img src="&quot;Git详解之四：服务器上的Git&quot;" alt="Git详解之四：服务器上的Git"></a></p>
<p>图 4-15. 派生后得到的项目副本</p>
<p><strong>GitHub 小结</strong></p>
<p>关于 GitHub 就先介绍这么多，能够快速达成这些事情非常重要（译注：门槛的降低和完成基本任务的简单高效，对于推动开源项目的协作发展有着举足轻重的意义。）。短短几 分钟内，你就能创建一个新账户，添加一个项目并开始推送。如果项目是开源的，整个庞大的开发者社区都可以立即访问它，提供各式各样的帮助和贡献。最起码， 这也是一种 Git 新手立即体验尝试 Git 的捷径。</p>
<p><strong>4.11 小结</strong></p>
<p>我们讨论并介绍了一些建立远程 Git 仓库的方法，接下来你可以通过这些仓库同他人分享或合作。</p>
<p>运行自己的服务器意味着更多的控制权以及在防火墙内部操作的可能性，当然这样的服务器通常需要投入一定的时间精力来架设维护。如果直接托管，虽然能免去这部分工作，但有时出于安全或版权的考虑，有些公司禁止将商业代码托管到第三方服务商。</p>
<p>所以究竟采取哪种方案，并不是个难以取舍的问题，或者其一，或者相互配合，哪种合适就用哪种。</p>
<p><img src="&quot;1 vote, average: 4.00 out of 5&quot;" alt="1 vote, average: 4.00 out of 5"><img src="&quot;1 vote, average: 4.00 out of 5&quot;" alt="1 vote, average: 4.00 out of 5"><img src="&quot;1 vote, average: 4.00 out of 5&quot;" alt="1 vote, average: 4.00 out of 5"><img src="&quot;1 vote, average: 4.00 out of 5&quot;" alt="1 vote, average: 4.00 out of 5"><img src="&quot;1 vote, average: 4.00 out of 5&quot;" alt="1 vote, average: 4.00 out of 5"> (<strong>*1</strong> 个评分，平均: <strong>4.00*</strong>)</p>
<p><img src="&quot;Loading ...&quot;" alt="Loading ..."> Loading ...</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/git&github/">git&github</a></li></span></span> | <span class="tags">Tagged <a href="/tags/git&github/" class="label label-primary">git&github</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-gitgithub--Git详解之四：服务器上的Git/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-gitgithub--Git详解之四：服务器上的Git" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-gitgithub--Markdown语法说明简体中文版/">Markdown 语法说明(简体中文版)</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-gitgithub--Markdown语法说明简体中文版/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="markdown-">Markdown 语法说明(简体中文版)</h1>
<p>&lt;&lt; <a href="http://wowubuntu.com/" target="_blank">访问 Wow!Ubuntu</a></p>
<p><strong>NOTE:</strong> This is Simplelified Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to <a href="http://daringfireball.net/projects/markdown/syntax" target="_blank">Markdown: Syntax</a>.</p>
<p><strong>声明：</strong> 这份文档派生(fork)于<a href="http://markdown.tw/" target="_blank">繁体中文版</a>，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里<a href="http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md" target="_blank">查看它的源文件</a>。「繁体中文版的原始文件可以<a href="https://github.com/othree/markdown-syntax-zhtw/blob/master/syntax.md" target="_blank">查看这里</a> 。」--By @<a href="http://twitter.com/riku" target="_blank">riku</a></p>
<p><strong>注：</strong> 本项目托管于 <a href="http://gitcafe.com/riku/Markdown-Syntax-CN/" target="_blank">GitCafe</a>上，请通过&quot;派生&quot;和&quot;合并请求&quot;来帮忙改进本项目。</p>
<h1 id="markdown-http-wowubuntu-com-markdown-basic-html-">Markdown 语法说明 (简体中文版) / (<a href="http://wowubuntu.com/markdown/basic.html" target="_blank">点击查看快速入门</a>)</h1>
<ul>
<li><p><a href="http://wowubuntu.com/markdown/#overview" target="_blank">概述</a></p>
</li>
<li><p><a href="http://wowubuntu.com/markdown/#philosophy" target="_blank">宗旨</a></p>
</li>
<li><a href="http://wowubuntu.com/markdown/#html" target="_blank">兼容 HTML</a></li>
<li><a href="http://wowubuntu.com/markdown/#autoescape" target="_blank">特殊字符自动转换</a></li>
<li><p><a href="http://wowubuntu.com/markdown/#block" target="_blank">区块元素</a></p>
</li>
<li><p><a href="http://wowubuntu.com/markdown/#p" target="_blank">段落和换行</a></p>
</li>
<li><a href="http://wowubuntu.com/markdown/#header" target="_blank">标题</a></li>
<li><a href="http://wowubuntu.com/markdown/#blockquote" target="_blank">区块引用</a></li>
<li><a href="http://wowubuntu.com/markdown/#list" target="_blank">列表</a></li>
<li><a href="http://wowubuntu.com/markdown/#precode" target="_blank">代码区块</a></li>
<li><a href="http://wowubuntu.com/markdown/#hr" target="_blank">分隔线</a></li>
<li><p><a href="http://wowubuntu.com/markdown/#span" target="_blank">区段元素</a></p>
</li>
<li><p><a href="http://wowubuntu.com/markdown/#link" target="_blank">链接</a></p>
</li>
<li><a href="http://wowubuntu.com/markdown/#em" target="_blank">强调</a></li>
<li><a href="http://wowubuntu.com/markdown/#code" target="_blank">代码</a></li>
<li><a href="http://wowubuntu.com/markdown/#img" target="_blank">图片</a></li>
<li><p><a href="http://wowubuntu.com/markdown/#misc" target="_blank">其它</a></p>
</li>
<li><p><a href="http://wowubuntu.com/markdown/#backslash" target="_blank">反斜杠</a></p>
</li>
<li><a href="http://wowubuntu.com/markdown/#autolink" target="_blank">自动链接</a></li>
<li><a href="http://wowubuntu.com/markdown/#acknowledgement" target="_blank">感谢</a></li>
<li><a href="http://wowubuntu.com/markdown/#editor" target="_blank">Markdown 免费编辑器</a></li>
</ul>
<h2 id="-">概述</h2>
<h3 id="-">宗旨</h3>
<p>Markdown 的目标是实现「易读易写」。</p>
<p>可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/" target="_blank">atx</a>、<a href="http://textism.com/tools/textile/" target="_blank">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html" target="_blank">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html" target="_blank">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/" target="_blank">EtText</a>，而最大灵感来源其实是纯文本电子邮件的格式。</p>
<p>总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像/<em>强调/</em>。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。</p>
<h3 id="-html">兼容 HTML</h3>
<p>Markdown 语法的目标是：成为一种适用于网络的<em>书写</em>语言。</p>
<p>Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想<em>不是</em>要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种<em>发布</em>的格式，Markdown 是一种<em>书写</em>的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。</p>
<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p>
<p>要制约的只有一些 HTML 区块元素――比如</p>
<div>
、

<table>
、

<pre>
、

<p>
等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的

<p>
标签。

例子如下，在 Markdown 文件里加上一段 HTML 表格：
这是一个普通段落。 <table> <tr> <td>Foo</td> </tr> </table> 这是另一个普通段落。

请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的

/<em>强调/</em>
会没有效果。

HTML 的区段（行内）标签如

<span>
、

<cite>
、

<del>
可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的

<a>
或

<img>
标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。

和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。

### 特殊字符自动转换

在 HTML 文件中，有两个字符需要特殊处理：

&lt;
和

&amp;
。

&lt;
符号用于起始标签，

&amp;
符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是

&lt;
和

&amp;
。

&amp;
字符尤其让网络文档编写者受折磨，如果你要打「

AT&amp;T
」 ，你必须要写成「

AT&amp;T
」。而网址中的

&amp;
字符也要转换。比如你要链接到：
<a href="http://images.google.com/images?num=30&amp;q=larry+bird" target="_blank">http://images.google.com/images?num=30&amp;q=larry+bird</a>

你必须要把网址转换写为：

<a href="http://images.google.com/images?num=30&amp;q=larry+bird" target="_blank">http://images.google.com/images?num=30&amp;q=larry+bird</a>

才能放到链接标签的

href
属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。

Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的

&amp;
字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成

&amp;amp
;。

所以你如果要在文档中插入一个版权符号

©
，你可以这样写：
&copy;

Markdown 会保留它不动。而若你写：

AT&amp;T

Markdown 就会将它转为：

AT&amp;T

类似的状况也会发生在

&lt;
符号上，因为 Markdown 允许 <a href="http://wowubuntu.com/markdown/#html" target="_blank">兼容 HTML</a> ，如果你是把

&lt;
符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：

4 &lt; 5

Markdown 将会把它转换为：

4 &lt; 5

不过需要注意的是，code 范围内，不论是行内还是区块，

&lt;
和

&amp;
两个符号都<em>一定</em>会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的

&lt;
和

&amp;
都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）

## 区块元素

### 段落和换行

一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。

「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成

<br />
标签。

如果你<em>确实</em>想要依赖 Markdown 来插入

<br />
标签的话，在插入处先按入两个以上的空格然后回车。

的确，需要多费点事（多加空格）来产生

<br />
，但是简单地「每个换行都转换为

<br />
」的方法在 Markdown 中并不适合， Markdown 中 email 式的 <a href="http://wowubuntu.com/markdown/#blockquote" target="_blank">区块引用</a> 和多段落的 <a href="http://wowubuntu.com/markdown/#list" target="_blank">列表</a> 在使用换行来排版的时候，不但更好用，还更方便阅读。

### 标题

Markdown 支持两种标题的语法，类 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank">Setext</a> 和类 <a href="http://www.aaronsw.com/2002/atx/" target="_blank">atx</a> 形式。

类 Setext 形式是用底线的形式，利用

=
（最高阶标题）和

-
（第二阶标题），例如：
This is an H1 ============= This is an H2 -------------

任何数量的

=
和

-
都可以有效果。

类 Atx 形式则是在行首插入 1 到 6 个

/#
，对应到标题 1 到 6 阶，例如：
/# 这是 H1 /#/# 这是 H2 /#/#/#/#/#/# 这是 H6

你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上

/#
，而行尾的

/#
数量也不用和开头一样（行首的井字符数量决定标题的阶数）：

/# 这是 H1 /# /#/# 这是 H2 /#/# /#/#/# 这是 H3 /#/#/#/#/#/#

### 区块引用 Blockquotes

Markdown 标记区块引用是使用类似 email 中用

&gt;
的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上

&gt;
：
&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, &gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. &gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse &gt; id sem consectetuer libero luctus adipiscing.

Markdown 也允许你偷懒只在整个段落的第一行最前面加上

&gt;
：

&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.

区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的

&gt;
：

&gt; This is the first level of quoting. &gt; &gt; &gt; This is nested blockquote. &gt; &gt; Back to the first level.

引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：

&gt; /#/# 这是一个标题。 &gt; &gt; 1. 这是第一行列表项。 &gt; 2. 这是第二行列表项。 &gt; &gt; 给出一些例子代码： &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;);

任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择<em>增加引用阶层</em>。

### 列表

Markdown 支持有序列表和无序列表。

无序列表使用星号、加号或是减号作为列表标记：
/<em> Red /</em> Green /<em> Blue

等同于：

+ Red + Green + Blue

也等同于：

- Red - Green - Blue

有序列表则使用数字接着一个英文句点：

1. Bird 2. McHale 3. Parish

很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：

<ol> <li>Bird</li> <li>McHale</li> <li>Parish</li> </ol>

如果你的列表标记写成：

1. Bird 1. McHale 1. Parish

或甚至是：

3. Bird 1. McHale 8. Parish

你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。

如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。

列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。

要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：
/</em> Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. /<em> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.

但是如果你懒，那也行：

/</em> Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. /<em> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.

如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用

<p>
标签包起来，举例来说：

/</em> Bird /<em> Magic

会被转换为：

<ul> <li>Bird</li> <li>Magic</li> </ul>

但是这个：

/</em> Bird /<em> Magic

会被转换为：

<ul> <li><p>Bird</p></li> <li><p>Magic</p></li> </ul>

列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：

1. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. 2. Suspendisse id sem consectetuer libero luctus adipiscing.

如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：

/</em> This is a list item with two paragraphs. This is the second paragraph in the list item. You&#39;re only required to indent the first line. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. /<em> Another item in the same list.

如果要在列表项目内放进引用，那

&gt;
就需要缩进：

/</em> A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item.

如果要放代码区块的话，该区块就需要缩进<em>两次</em>，也就是 8 个空格或是 2 个制表符：

/<em> 一列表项包含一个列表区块： &lt;代码写在这&gt;

当然，项目列表很可能会不小心产生，像是下面这样的写法：

1986. What a great season.

换句话说，也就是在行首出现</em>数字-句点-空白*，要避免这样的状况，你可以在句点前面加上反斜杠。

1986. What a great season.

### 代码区块

和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用

<pre>
和

<code>
标签来把代码区块包起来。

要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：
这是一个普通段落： 这是一个代码区块。

Markdown 会转换成：

<p>这是一个普通段落：</p> <pre><code>这是一个代码区块。 </code></pre>

这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：

Here is an example of AppleScript: tell application &quot;Foo&quot; beep end tell

会被转换为：

<p>Here is an example of AppleScript:</p> <pre><code>tell application &quot;Foo&quot; beep end tell </code></pre>

一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。

在代码区块里面，

&amp;
、

&lt;
和

&gt;
会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：
<div class="footer"> &copy; 2004 Foo Corporation </div>

<p>会被转换为：</p>
<pre><code>&lt;div class="footer"&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; </code></pre>

<p>代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。</p>
<h3 id="-">分隔线</h3>
<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：
/<em> /</em> /<em> /</em>/<em>/</em> /<em>/</em>/<em>/</em>/* - - - ---------------------------------------</p>
<h2 id="-">区段元素</h2>
<h3 id="-">链接</h3>
<p>Markdown 支持两种形式的链接语法： <em>行内式</em>和<em>参考式</em>两种形式。</p>
<p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p>
<p>要建立一个<em>行内式</em>的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：
This is <a href="http://example.com/" title="Title" target="_blank">an example</a> inline link. <a href="http://example.net/" target="_blank">This link</a> has no title attribute.</p>
<p>会产生：</p>
<p>This is <a href="http://example.com/" title="Title" target="_blank"> an example</a> inline link.</p> <p><a href="http://example.net/" target="_blank">This link</a> has no title attribute.</p>

<p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p>
<p>See my <a href="/about/">About</a> page for details.</p>
<p><em>参考式</em>的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p>
<p>This is <a href="url/to/image" title="Optional title attribute">an example</a> reference-style link.</p>
<p>你也可以选择性地在两个方括号中间加上一个空格：</p>
<p>This is <a href="url/to/image" title="Optional title attribute">an example</a> reference-style link.</p>
<p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</p>
<p>链接内容定义的形式为：</p>
<ul>
<li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li>
<li>接着一个冒号</li>
<li>接着一个以上的空格或制表符</li>
<li>接着链接的网址</li>
<li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li>
</ul>
<p>下面这三种链接的定义都是相同：</p>
<p><strong>请注意：</strong>有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。</p>
<p>链接网址也可以用方括号包起来：</p>
<p>你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：</p>
<p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p>
<p>链接辨别标签可以有字母、数字、空白和标点符号，但是并<em>不</em>区分大小写，因此下面两个链接是一样的：
[link text][a] [link text][A]</p>
<p><em>隐式链接标记</em>功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 &quot;Google&quot; 链接到 google.com，你可以简化成：</p>
<p><a href="http://google.com/" target="_blank">Google</a></p>
<p>然后定义链接内容：</p>
<p>由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：</p>
<p>Visit <a href="http://daringfireball.net/" target="_blank">Daring Fireball</a> for more information.</p>
<p>然后接着定义链接：</p>
<p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p>
<p>下面是一个参考式链接的范例：
I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3]. [1]: <a href="http://google.com/" target="_blank">http://google.com/</a> &quot;Google&quot; [2]: <a href="http://search.yahoo.com/" target="_blank">http://search.yahoo.com/</a> &quot;Yahoo Search&quot; [3]: <a href="http://search.msn.com/" target="_blank">http://search.msn.com/</a> &quot;MSN Search&quot;</p>
<p>如果改成用链接名称的方式写：</p>
<p>I get 10 times more traffic from <a href="http://google.com/" target="_blank">Google</a> than from [Yahoo][] or [MSN][]. <a href="http://google.com/" target="_blank">google</a>: <a href="http://google.com/" target="_blank">http://google.com/</a> &quot;Google&quot; [yahoo]: <a href="http://search.yahoo.com/" target="_blank">http://search.yahoo.com/</a> &quot;Yahoo Search&quot; [msn]: <a href="http://search.msn.com/" target="_blank">http://search.msn.com/</a> &quot;MSN Search&quot;</p>
<p>上面两种写法都会产生下面的 HTML。</p>
<p>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank">Google</a> than from <a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank">MSN</a>.</p>

<p>下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：</p>
<p>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank">Google</a> than from <a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank">MSN</a>.</p>
<p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。</p>
<p>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。</p>
<h3 id="-">强调</h3>
<p>Markdown 使用星号（</p>
<p>/*
）和底线（</p>
<p>_
）作为标记强调字词的符号，被</p>
<p>/*
或</p>
<p>_
包围的字词会被转成用</p>
<p><em>
标签包围，用两个</p>
<p>/*
或</p>
<p>_
包起来的话，则会被转成</p>
<p><strong>
，例如：
/<em>single asterisks/</em> <em>single underscores</em> /<em>/</em>double asterisks/<em>/</em> <strong>double underscores</strong></p>
<p>会转成：</p>
<p><em>single asterisks</em> <em>single underscores</em> <strong>double asterisks</strong> <strong>double underscores</strong></p>
<p>你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。</p>
<p>强调也可以直接插在文字中间：
un/<em>frigging/</em>believable</p>
<p>但是**如果你的</p>
<p>/*
和</p>
<p>_
两边都有空白的话，它们就只会被当成普通的符号**。</p>
<p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：
\/<em>this text is surrounded by literal asterisks\/</em></p>
<h3 id="-">代码</h3>
<p>如果要标记一小段行内代码，你可以用反引号把它包起来（</p>
<p><code>），例如：
Use the</code>printf()` function.</p>
<p>会产生：</p>
<p>Use the <code>printf()</code> function.</p>

<p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p>
<p><code>There is a literal backtick (`) here.</code></p>
<p>这段语法会产生：</p>
<p><code>There is a literal backtick (`) here.</code></p>

<p>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：</p>
<p>A single backtick in a code span: <code>` </code> A backtick-delimited string in a code span: <code>`foo` </code></p>
<p>会产生：</p>
<p>A single backtick in a code span: <code><code>&lt;/code&gt;&lt;/p&gt; &lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;</code>foo`</code></p>

<p>在代码区段内，</p>
<p>&amp;
和方括号<strong>都</strong>会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：</p>
<p>Please don&#39;t use any <code>&lt;blink&gt;</code> tags.</p>
<p>转为：</p>
<p>Please don&#39;t use any <code>&lt;blink&gt;</code> tags.</p>

<p>你也可以这样写：</p>
<p><code>&amp;/#8212;</code> is the decimal-encoded equivalent of <code>&amp;mdash;</code>.</p>
<p>以产生：</p>
<p><code>&amp;/#8212;</code> is the decimal-encoded equivalent of <code>&amp;mdash;</code>.</p>

<h3 id="-">图片</h3>
<p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。</p>
<p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： <em>行内式</em>和<em>参考式</em>。</p>
<p>行内式的图片语法看起来像是：
<img src="/path/to/img.jpg" alt="Alt text"> <img src="/path/to/img.jpg" alt="Alt text" title="Optional title"></p>
<p>详细叙述如下：</p>
<ul>
<li>一个惊叹号</li>
</ul>
<p>!</p>
<ul>
<li>接着一个方括号，里面放上图片的替代文字</li>
<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 &#39;title&#39; 文字。</li>
</ul>
<p>参考式的图片语法则长得像这样：
<img src="url/to/image" alt="Alt text" title="Optional title attribute"></p>
<p>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p>
<p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的</p>
<p><img>
标签。</p>
<h2 id="-">其它</h2>
<h3 id="-">自动链接</h3>
<p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：
<a href="http://example.com/" target="_blank">http://example.com/</a></p>
<p>Markdown 会转为：</p>
<p><a href="http://example.com/" target="_blank"><a href="http://example.com/">http://example.com/</a></a></p>
<p>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p>
<p><a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#97;&#x64;&#100;&#x72;&#101;&#x73;&#115;&#64;&#101;&#120;&#x61;&#x6d;&#x70;&#108;&#x65;&#46;&#99;&#x6f;&#x6d;">&#97;&#x64;&#100;&#x72;&#101;&#x73;&#115;&#64;&#101;&#120;&#x61;&#x6d;&#x70;&#108;&#x65;&#46;&#99;&#x6f;&#x6d;</a></p>
<p>Markdown 会转成：</p>
<p><a href="&/#x6D;&/#x61;i&/#x6C;&/#x74;&/#x6F;:&/#x61;&/#x64;&/#x64;&/#x72;&/#x65; &/#115;&/#115;&/#64;&/#101;&/#120;&/#x61;&/#109;&/#x70;&/#x6C;e&/#x2E;&/#99;&/#111; &/#109;">&amp;/#x61;&amp;/#x64;&amp;/#x64;&amp;/#x72;&amp;/#x65;&amp;/#115;&amp;/#115;&amp;/#64;&amp;/#101;&amp;/#120;&amp;/#x61; &amp;/#109;&amp;/#x70;&amp;/#x6C;e&amp;/#x2E;&amp;/#99;&amp;/#111;&amp;/#109;</a></p>
<p>在浏览器里面，这段字串（其实是</p>
<p><a href="mailto:address@example.com">address@example.com</a>
）会变成一个可以点击的「address@example.com」链接。</p>
<p>（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）</p>
<h3 id="-">反斜杠</h3>
<p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用</p>
<p><em>
标签），你可以在星号的前面加上反斜杠：
\/<em>literal asterisks\/</em></p>
<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<p>\ 反斜线 ` 反引号 /* 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 /# 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号</p>
<h2 id="-">感谢</h2>
<p>感谢 <a href="https://twitter.com/#!/leafy7382" target="_blank">leafy7382</a> 协助翻译，<a href="http://iamhlb.com/" target="_blank">hlb</a>、<a href="http://twitter.com/randylien" target="_blank">Randylien</a> 帮忙润稿，<a href="https://twitter.com/#!/ethantw" target="_blank">ethantw</a> 的<a href="http://ethantw.net/projects/han/" target="_blank">汉字标准格式・CSS Reset</a>， <a href="http://kidwm.net/" target="_blank">WM</a> 回报文字错误。</p>
<p>感谢 <a href="https://github.com/fenprace" target="_blank">fenprace</a>，<a href="https://github.com/addv" target="_blank">addv</a>。</p>
<h2 id="markdown-">Markdown 免费编辑器</h2>
<p>Windows 平台</p>
<ul>
<li><a href="http://markdownpad.com/" target="_blank">MarkdownPad</a></li>
<li><a href="http://code52.org/DownmarkerWPF/" target="_blank">MarkPad</a></li>
</ul>
<p>Linux 平台</p>
<ul>
<li><a href="http://sourceforge.net/p/retext/home/ReText/" target="_blank">ReText</a></li>
</ul>
<p>Mac 平台</p>
<ul>
<li><a href="http://mouapp.com/" target="_blank">Mou</a></li>
</ul>
<p>在线编辑器</p>
<ul>
<li><a href="http://markable.in/" target="_blank">Markable.in</a></li>
<li><a href="http://dillinger.io/" target="_blank">Dillinger.io</a></li>
</ul>
<p>浏览器插件</p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/oknndfeeopgpibecfjljjfanledpbkog" target="_blank">MaDe</a> (Chrome)</li>
</ul>
<p>高级应用</p>
<ul>
<li><a href="http://www.sublimetext.com/2" target="_blank">Sublime Text 2</a> + <a href="http://ttscoff.github.com/MarkdownEditing/" target="_blank">MarkdownEditing</a> / <a href="http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/" target="_blank">教程</a></li>
</ul>
<p>/<em>/</em>/* 如有更好的 Markdown 免费编辑器推荐，请到<a href="https://gitcafe.com/riku/Markdown-Syntax-CN/tickets/1" target="_blank">这里反馈</a>，谢谢！</p>
<p>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" target="_blank">comments powered by Disqus.</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/git&github/">git&github</a></li></span></span> | <span class="tags">Tagged <a href="/tags/git&github/" class="label label-primary">git&github</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-gitgithub--Markdown语法说明简体中文版/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-gitgithub--Markdown语法说明简体中文版" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-gitgithub--Git详解之三：Git分支/">Git详解之三：Git分支</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-gitgithub--Git详解之三：Git分支/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="git-git-">Git详解之三：Git分支</h1>
<p>原文：<a href="http://git-scm.com/book/zh" target="_blank">《Pro Git》</a></p>
<p><strong>Git 分支</strong></p>
<p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。（<a href="http://www.jobbole.com/" title="1" target="_blank">伯乐</a>在线注：如果你对Git还不了解，建议从本<a href="http://blog.jobbole.com/25775/" target="_blank">Git</a>系列<a href="http://blog.jobbole.com/25775/" target="_blank">第一篇文章</a>开始阅读）</p>
<p>有人把 Git 的分支模型称为“必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。Git 有何特别之处呢？Git 的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。和许多其他版本控制系统不同，Git 鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。理解分支的概念并熟练运用后，你才会意识到为什么 Git 是一个如此强大而独特的工具，并从此真正改变你的开发方式。</p>
<p><strong>3.1  何谓分支</strong></p>
<p>为了理解 Git 分支的实现方式，我们需要回顾一下 Git 是如何储存数据的。或许你还记得第一章的内容，Git 保存的不是文件差异或者变化量，而只是一系列文件快照。</p>
<p>在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对 象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。</p>
<p>为直观起见，我们假设在工作目录中有三个文件，准备将它们暂存后提交。暂存操作会对每一个文件计算校验和（即第一章中提到的 SHA-1 哈希字串），然后把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 类型的对象存储这些快照），并将校验和加入暂存区域：</p>
<p>1</p>
<p>2
$ git add README</p>
<p>test</p>
<p>.rb LICENSE</p>
<p>$ git commit -m</p>
<p>&#39;initial commit of my project&#39;</p>
<p>当使用 git commit新建一个提交对象前，Git 会先计算每一个子目录（本例中就是项目根目录）的校验和，然后在 Git 仓库中将这些目录保存为树（tree）对象。之后 Git 创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。</p>
<p>现在，Git 仓库中有五个对象：三个表示文件快照内容的 blob 对象；一个记录着目录树内容及其中各个文件对应 blob 对象索引的 tree 对象；以及一个包含指向 tree 对象（根目录）的索引和其他提交信息元数据的 commit 对象。概念上来说，仓库中的各个对象保存的数据和相互关系看起来如图 3-1 所示：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches1.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-1. 单个提交对象在仓库中的数据结构</p>
<p>作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（译注：即下图中的 parent 对象）。两次提交后，仓库历史会变成图 3-2 的样子：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches12.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-2. 多个提交对象之间的链接关系</p>
<p>现在来谈分支。Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。Git 会使用 master 作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 master 分支，它在每次提交的时候都会自动向前移动。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches13.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-3. 分支其实就是从某个提交对象往回看的历史</p>
<p>那么，Git 又是如何创建一个新的分支的呢？答案很简单，创建一个新的分支指针。比如新建一个 testing 分支，可以使用git branch命令：
1$ git branch testing</p>
<p>这会在当前 commit 对象上新建一个分支指针（见图 3-4）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches14.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-4. 多个分支指向提交数据的历史</p>
<p>那么，Git 是如何知道你当前在哪个分支上工作的呢？其实答案也很简单，它保存着一个名为 HEAD 的特别指针。请注意它和你熟知的许多其他版本控制系统（比如 Subversion 或 CVS）里的 HEAD 概念大不相同。在 Git 中，它是一个指向你正在工作中的本地分支的指针（译注：将 HEAD 想象为当前分支的别名。）。运行</p>
<p>git branch
 命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以在这个例子中，我们依然还在 master 分支里工作（参考图 3-5）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches15.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-5. HEAD 指向当前所在的分支</p>
<p>要切换到其他分支，可以执行 git checkout命令。我们现在转换到新建的 testing 分支：
1$ git checkout testing</p>
<p>这样 HEAD 就指向了 testing 分支（见图3-6）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches16.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-6. HEAD 在你转换分支时指向新的分支</p>
<p>这样的实现方式会给我们带来什么好处呢？好吧，现在不妨再提交一次：
$ vim test.rb $ git commit -a -m ‘made a change’</p>
<p>图 3-7 展示了提交后的结果。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches17.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-7. 每次提交后 HEAD 随着分支一起向前移动</p>
<p>非常有趣，现在 testing 分支向前移动了一格，而 master 分支仍然指向原先 </p>
<p>git checkout
 时所在的 commit 对象。现在我们回到 master 分支看看：
1$ git checkout master</p>
<p>图 3-8 显示了结果。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches18.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-8. HEAD 在一次 checkout 之后移动到了另一个分支</p>
<p>这条命令做了两件事。它把 HEAD 指针移回到 master 分支，并把工作目录中的文件换成了 master 分支所指向的快照内容。也就是说，现在开始所做的改动，将始于本项目中一个较老的版本。它的主要作用是将 testing 分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。</p>
<p>我们作些修改后再次提交：
1</p>
<p>2
$ vim</p>
<p>test</p>
<p>.rb</p>
<p>$ git commit -a -m</p>
<p>&#39;made other changes&#39;</p>
<p>现在我们的项目提交历史产生了分叉（如图 3-9 所示），因为刚才我们创建了一个分支，转换到其中进行了一些工作，然后又回到原来的主分支进行了另外一些工作。这些改变分别孤立在不同的分支里：我们可以 在不同分支里反复切换，并在时机成熟时把它们合并到一起。而所有这些工作，仅仅需要</p>
<p>branch
 和 </p>
<p>checkout
 这两条命令就可以完成。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches19.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-9. 不同流向的分支历史</p>
<p>由于 Git 中的分支实际上仅是一个包含所指对象校验和（40 个字符长度 SHA-1 字串）的文件，所以创建和销毁一个分支就变得非常廉价。说白了，新建一个分支就是向一个文件写入 41 个字节（外加一个换行符）那么简单，当然也就很快了。</p>
<p>这和大多数版本控制系统形成了鲜明对比，它们管理分支大多采取备份所有项目文件到特定目录的方式，所以根据项目文件数量和大小不同，可能花费的时间 也会有相当大的差别，快则几秒，慢则数分钟。而 Git 的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。同时，因为每次提交时都记录了祖先信息（译注：即</p>
<p>parent
 对象），将来要合并分支时，寻找恰当的合并基础（译注：即共同祖先）的工作其实已经自然而然地摆在那里了，所以实现起来非常容易。Git 鼓励开发者频繁使用分支，正是因为有着这些特性作保障。</p>
<p>接下来看看，我们为什么应该频繁使用分支。</p>
<p><strong>3.2  分支的新建与合并</strong></p>
<p>现在让我们来看一个简单的分支与合并的例子，实际工作中大体也会用到这样的工作流程：</p>
<ol>
<li>开发某个网站。 2. 为实现某个新的需求，创建一个分支。 3. 在这个分支上开展工作。</li>
</ol>
<p>假设此时，你突然接到一个电话说有个很严重的问题需要紧急修补，那么可以按照下面的方式处理：</p>
<ol>
<li>返回到原先已经发布到生产服务器上的分支。 2. 为这次紧急修补建立一个新分支，并在其中修复问题。 3. 通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。 4. 切换到之前实现新需求的分支，继续工作。</li>
</ol>
<p><strong>分支的新建与切换</strong></p>
<p>首先，我们假设你正在项目中愉快地工作，并且已经提交了几次更新（见图 3-10）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches20.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-10. 一个简短的提交历史</p>
<p>现在，你决定要修补问题追踪系统上的 /#53 问题。顺带说明下，Git 并不同任何特定的问题追踪系统打交道。这里为了说明要解决的问题，才把新建的分支取名为 iss53。要新建并切换到该分支，运行git checkout 并加上 -b 参数：</p>
<p>1</p>
<p>2
$ git checkout -b iss53</p>
<p>Switched to a new branch</p>
<p>&quot;iss53&quot;</p>
<p>这相当于执行下面这两条命令：</p>
<p>1</p>
<p>2
$ git branch iss53</p>
<p>$ git checkout iss53</p>
<p>图 3-11 示意该命令的执行结果。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches21.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-11. 创建了一个新分支的指针</p>
<p>接着你开始尝试修复问题，在提交了若干次更新后，iss53分支的指针也会随着向前推进，因为它就是当前分支（换句话说，当前的 HEAD 指针正指向 iss53，见图 3-12）：</p>
<p>1</p>
<p>2
$ vim index.html</p>
<p>$ git commit -a -m</p>
<p>&#39;added a new footer [issue 53]&#39;</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches22.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-12. iss53 分支随工作进展向前推进</p>
<p>现在你就接到了那个网站问题的紧急电话，需要马上修补。有了 Git ，我们就不需要同时发布这个补丁和 iss53 里作出的修改，也不需要在创建和发布该补丁到服务器之前花费大力气来复原这些修改。唯一需要的仅仅是切换回master 分支。</p>
<p>不过在此之前，留心你的暂存区或者工作目录里，那些还没有提交的修改，它会和你即将检出的分支产生冲突从而阻止 Git 为你切换分支。切换分支的时候最好保持一个清洁的工作区域。稍后会介绍几个绕过这种问题的办法（分别叫做 stashing 和 commit amending）。目前已经提交了所有的修改，所以接下来可以正常转换到master 分支：</p>
<p>1</p>
<p>2
$ git checkout master</p>
<p>Switched to branch</p>
<p>&quot;master&quot;</p>
<p>此时工作目录中的内容和你在解决问题 /#53 之前一模一样，你可以集中精力进行紧急修补。这一点值得牢记：Git 会把工作目录的内容恢复为检出某分支时它所指向的那个提交对象的快照。它会自动添加、删除和修改文件以确保目录的内容和你当时提交时完全一样。</p>
<p>接下来，你得进行紧急修补。我们创建一个紧急修补分支 hotfix 来开展工作，直到<a href="http://www.amazon.cn/gp/product/B007XPTAIS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;linkCode=as2&amp;camp=536&amp;creative=3200&amp;creativeASIN=B007XPTAIS" title="搞定(套装共3册) " target="_blank">搞定</a>（见图 3-13）：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
$ git checkout -b</p>
<p>&#39;hotfix&#39;</p>
<p>Switched to a new branch</p>
<p>&quot;hotfix&quot;
$ vim index.html</p>
<p>$ git commit -a -m</p>
<p>&#39;fixed the broken email address&#39;
[hotfix]: created 3a0874c:</p>
<p>&quot;fixed the broken email address&quot;</p>
<p>1 files changed, 0 insertions(+), 1 deletions(-)</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches23.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-13. hotfix 分支是从 master 分支所在点分化出来的</p>
<p>有必要作些测试，确保修补是成功的，然后回到 master 分支并把它合并进来，然后发布到生产服务器。用 git merge 命令来进行合并：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
$ git checkout master</p>
<p>$ git merge hotfix
Updating f42c576..3a0874c</p>
<p>Fast forward
README | 1 -</p>
<p>1 files changed, 0 insertions(+), 1 deletions(-)</p>
<p>请注意，合并时出现了“Fast forward”的提示。由于当前 master 分支所在的提交对象是要并入的 hotfix 分支的直接上游，Git 只需把master 分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。</p>
<p>现在最新的修改已经在当前 master 分支所指向的提交对象中了，可以部署到生产服务器上去了（见图 3-14）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches24.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-14. 合并之后，master 分支和 hotfix 分支指向同一位置。</p>
<p>在那个超级重要的修补发布以后，你想要回到被打扰之前的工作。由于当前 hotfix 分支和 master 都指向相同的提交对象，所以hotfix 已经完成了历史使命，可以删掉了。使用 git branch 的 -d 选项执行删除操作：</p>
<p>1</p>
<p>2
$ git branch -d hotfix</p>
<p>Deleted branch hotfix (3a0874c).</p>
<p>现在回到之前未完成的 /#53 问题修复分支上继续工作（图 3-15）：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
$ git checkout iss53</p>
<p>Switched to branch</p>
<p>&quot;iss53&quot;
$ vim index.html</p>
<p>$ git commit -a -m</p>
<p>&#39;finished the new footer [issue 53]&#39;
[iss53]: created ad82d7a:</p>
<p>&quot;finished the new footer [issue 53]&quot;</p>
<p>1 files changed, 1 insertions(+), 0 deletions(-)</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches25.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-15. iss53 分支可以不受影响继续推进。</p>
<p>不用担心之前 hotfix 分支的修改内容尚未包含到 iss53 中来。如果确实需要纳入此次修补，可以用git merge master 把 master 分支合并到 iss53；或者等 iss53 完成之后，再将iss53 分支中的更新并入 master。</p>
<p><strong>分支的合并</strong></p>
<p>在问题 /#53 相关的工作完成之后，可以合并回 master 分支。实际操作同前面合并 hotfix 分支差不多，只需回到master分支，运行 git merge 命令指定要合并进来的分支：</p>
<p>1</p>
<p>2
3</p>
<p>4
5$ git checkout master</p>
<p>$ git merge iss53
Merge made by recursive.</p>
<p>README | 1 +
1 files changed, 1 insertions(+), 0 deletions(-)</p>
<p>请注意，这次合并操作的底层实现，并不同于之前 hotfix 的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前 master 分支所指向的提交对象（C4）并不是 iss53 分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。图 3-16 用红框标出了 Git 用于合并的三个提交对象：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches26.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-16. Git 为分支合并自动识别出最佳的同源合并点。</p>
<p>这次，Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）（见图 3-17）。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。</p>
<p>值得一提的是 Git 可以自己裁决哪个共同祖先才是最佳合并基础；这和 CVS 或 Subversion（1.5 以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让 Git 的合并操作比其他系统都要简单不少。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches27.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-17. Git 自动创建了一个包含了合并结果的提交对象。</p>
<p>既然之前的工作成果已经合并到 master 了，那么 iss53 也就没用了。你可以就此删除它，并在问题追踪系统里关闭该问题。
1$ git branch -d iss53</p>
<p><strong>遇到冲突时的分支合并</strong></p>
<p>有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）。如果你在解决问题 /#53 的过程中修改了hotfix 中修改的部分，将得到类似下面的结果：</p>
<p>1</p>
<p>2
3</p>
<p>4
$ git merge iss53</p>
<p>Auto-merging index.html
CONFLICT (content): Merge conflict</p>
<p>in</p>
<p>index.html</p>
<p>Automatic merge failed; fix conflicts and</p>
<p>then</p>
<p>commit the result.</p>
<p>Git 作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用 git status 查阅：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11[master/*]$ git status</p>
<p>index.html: needs merge
/# On branch master</p>
<p>/# Changed but not updated:
/# (use &quot;git add</p>
<p>...&quot; to update what will be committed)
/# (use &quot;git checkout -- ...&quot;</p>
<p>to discard changes</p>
<p>in</p>
<p>working directory)
/#</p>
<p>/# unmerged: index.html
/#</p>
<p>任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches01.png" title="Git branches01" target="_blank"><img src="&quot;Git branches01&quot;" alt=""></a><a href="http://cdn2.jobbole.com/2012/08/Git-branches02.png" title="Git branches02" target="_blank"><img src="&quot;Git branches02&quot;" alt=""></a></p>
<p>可以看到 ======= 隔开的上半部分，是 HEAD（即 master 分支，在运行merge 命令时所切换到的分支）中的内容，下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches03.png" title="Git branches03" target="_blank"><img src="&quot;Git branches03&quot;" alt=""></a></p>
<p>这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，======= 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行。在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决状态（译注：实际上就是来一次快照保存到暂存区域。）。因为一旦暂存，就表示冲突已经解决。如果你想用一个有图形界面的工具来解决这些问题，不妨运行git mergetool，它会调用一个可视化的合并工具并引导你解决所有冲突：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7$ git mergetool</p>
<p>merge tool candidates: kdiff3 tkdiff xxdiff meld gvimdiff opendiff emerge vimdiff
Merging the files: index.html</p>
<p>Normal merge conflict</p>
<p>for</p>
<p>&#39;index.html&#39;</p>
<p>:
{</p>
<p>local</p>
<p>}: modified</p>
<p>{remote}: modified
Hit</p>
<p>return</p>
<p>to start merge resolution tool (opendiff):</p>
<p>如果不想用默认的合并工具（Git 为我默认选择了 opendiff，因为我在 Mac 上运行了该命令），你可以在上方”merge tool candidates”里找到可用的合并工具列表，输入你想用的工具名。我们将在第七章讨论怎样改变环境中的默认值。</p>
<p>退出合并工具以后，Git 会询问你合并是否成功。如果回答是，它会为你把相关文件暂存起来，以表明状态为已解决。</p>
<p>再运行一次 git status 来确认所有冲突都已解决：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
$ git status</p>
<p>/# On branch master
/# Changes to be committed:</p>
<p>/# (use &quot;git reset HEAD
...&quot; to unstage)</p>
<p>/#
/# modified: index.html</p>
<p>/#</p>
<p>如果觉得满意了，并且确认所有冲突都已解决，也就是进入了暂存区，就可以用 git commit 来完成这次合并提交。提交的记录差不多是这样：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
Merge branch</p>
<p>&#39;iss53&#39;</p>
<p>Conflicts:
index.html</p>
<p>/#
/# It looks like you may be committing a MERGE.</p>
<p>/# If this is not correct, please remove the file
/# .git/MERGE_HEAD /# and try again.</p>
<p>/#</p>
<p>如果想给将来看这次合并的人一些方便，可以修改该信息，提供更多合并细节。比如你都作了哪些改动，以及这么做的原因。有时候裁决冲突的理由并不直接或明显，有必要略加注解。</p>
<hr>
<p><strong>3.3  分支的管理</strong></p>
<p>到目前为止，你已经学会了如何创建、合并和删除分支。除此之外，我们还需要学习如何管理分支，在日后的常规工作中会经常用到下面介绍的管理命令。</p>
<p>git branch 命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有分支的清单：
1</p>
<p>2
3</p>
<p>4
$ git branch</p>
<p>iss53
/* master</p>
<p>testing</p>
<p>注意看 master 分支前的 /* 字符：它表示当前所在的分支。也就是说，如果现在提交更新，master 分支将随着开发进度前移。若要查看各个分支最后一个提交对象的信息，运行git branch -v：</p>
<p>1</p>
<p>2
3</p>
<p>4
$ git branch -</p>
<p>v</p>
<p>iss53 93b412c fix javascript issue
/* master 7a98805 Merge branch</p>
<p>&#39;iss53&#39;</p>
<p>testing 782fd34 add scott to the author list</p>
<p>in</p>
<p>the readmes</p>
<p>要从该清单中筛选出你已经（或尚未）与当前分支合并的分支，可以用 –merge 和 –no-merged 选项（Git 1.5.6 以上版本）。比如用git branch –merge 查看哪些分支已被并入当前分支（译注：也就是说哪些分支是当前分支的直接上游。）：</p>
<p>1</p>
<p>2
3$ git branch --merged</p>
<p>iss53
/* master</p>
<p>之前我们已经合并了 iss53，所以在这里会看到它。一般来说，列表中没有 /* 的分支通常都可以用 git branch -d 来删掉。原因很简单，既然已经把它们所包含的工作整合到了其他分支，删掉也不会损失什么。</p>
<p>另外可以用 git branch –no-merged 查看尚未合并的工作：</p>
<p>1</p>
<p>2
$ git branch --no-merged</p>
<p>testing</p>
<p>它会显示还未合并进来的分支。由于这些分支中还包含着尚未合并进来的工作成果，所以简单地用 git branch -d 删除该分支会提示错误，因为那样做会丢失数据：
1</p>
<p>2
3$ git branch -d testing</p>
<p>error: The branch</p>
<p>&#39;testing&#39;</p>
<p>is not an ancestor of your current HEAD.
If you are sure you want to delete it, run</p>
<p>&#39;git branch -D testing&#39;</p>
<p>.</p>
<p>不过，如果你确实想要删除该分支上的改动，可以用大写的删除选项 -D 强制执行，就像上面提示信息中给出的那样。</p>
<p><strong>3.4  利用分支进行开发的工作流程</strong></p>
<p>现在我们已经学会了新建分支和合并分支，可以（或应该）用它来做点什么呢？在本节，我们会介绍一些利用分支进行开发的工作流程。而正是由于分支管理的便捷，才衍生出了这类典型的工作模式，你可以根据项目的实际情况选择一种用用看。</p>
<p><strong>长期分支</strong></p>
<p>由于 Git 使用简单的三方合并，所以就算在较长一段时间内，反复多次把某个分支合并到另一分支，也不是什么难事。也就是说，你可以同时拥有多个开放的分支，每个分支用于完成特定的任务，随着开发的推进，你可以随时把某个特性分支的成果并到其他分支中。</p>
<p>许多使用 Git 的开发者都喜欢用这种方式来开展工作，比如仅在 master 分支中保留完全稳定的代码，即已经发布或即将发布的代码。与此同时，他们还有一个名为develop 或 next 的平行分支，专门用于后续的开发，或仅用于稳定性测试 — 当然并不是说一定要绝对稳定，不过一旦进入某种稳定状态，便可以把它合并到master 里。这样，在确保这些已完成的特性分支（短期分支，比如之前的 iss53 分支）能够通过所有测试，并且不会引入更多错误之后，就可以并到主干分支中，等待下一次的发布。</p>
<p>本质上我们刚才谈论的，是随着提交对象不断右移的指针。稳定分支的指针总是在提交历史中落后一大截，而前沿分支总是比较靠前（见图 3-18）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches28.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-18. 稳定分支总是比较老旧。</p>
<p>或者把它们想象成工作流水线，或许更好理解一些，经过测试的提交对象集合被遴选到更稳定的流水线（见图 3-19）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches29.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-19. 想象成流水线可能会容易点。</p>
<p>你可以用这招维护不同层次的稳定性。某些大项目还会有个 proposed（建议）或 pu（proposed updates，建议更新）分支，它包含着那些可能还没有成熟到进入next 或 master 的内容。这么做的目的是拥有不同层次的稳定性：当这些分支进入到更稳定的水平时，再把它们合并到更高层分支中去。再次说明下，使用多个长期分支的做法并非必需，不过一般来说，对于特大型项目或特复杂的项目，这么做确实更容易管理。</p>
<p><strong>特性分支</strong></p>
<p>在任何规模的项目中都可以使用特性（Topic）分支。一个特性分支是指一个短期的，用来实现单一特性或与其相关工作的分支。可能你在以前的版本控 制系统里从未做过类似这样的事情，因为通常创建与合并分支消耗太大。然而在 Git 中，一天之内建立、使用、合并再删除多个分支是常见的事。</p>
<p>我们在上节的例子里已经见过这种用法了。我们创建了 iss53 和 hotfix 这两个特性分支，在提交了若干更新后，把它们合并到主干分支，然后删除。该技术允许你迅速且完全的进行语境切换 — 因为你的工作分散在不同的流水线里，每个分支里的改变都和它的目标特性相关，浏览代码之类的事情因而变得更简单了。你可以把作出的改变保持在特性分支中几 分钟，几天甚至几个月，等它们成熟以后再合并，而不用在乎它们建立的顺序或者进度。</p>
<p>现在我们来看一个实际的例子。请看图 3-20，由下往上，起先我们在 master 工作到 C1，然后开始一个新分支 iss91 尝试修复 91 号缺陷，提交到 C6 的时候，又冒出一个解决该问题的新办法，于是从之前 C4 的地方又分出一个分支iss91v2，干到 C8 的时候，又回到主干 master 中提交了 C9 和 C10，再回到 iss91v2 继续工作，提交 C11，接着，又冒出个不太确定的想法，从 master 的最新提交 C10 处开了个新的分支dumbidea 做些试验。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches30.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-20. 拥有多个特性分支的提交历史。</p>
<p>现在，假定两件事情：我们最终决定使用第二个解决方案，即 iss91v2 中的办法；另外，我们把 dumbidea 分支拿给同事们看了以后，发现它竟然是个天才之作。所以接下来，我们准备抛弃原来的iss91 分支（实际上会丢弃 C5 和 C6），直接在主干中并入另外两个分支。最终的提交历史将变成图 3-21 这样：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches31.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-21. 合并了 dumbidea 和 iss91v2 后的分支历史。</p>
<p>请务必牢记这些分支全部都是本地分支，这一点很重要。当你在使用分支及合并的时候，一切都是在你自己的 Git 仓库中进行的 — 完全不涉及与服务器的交互。</p>
<hr>
<p><strong>3.5  远程分支</strong></p>
<p>远程分支（remote branch）是对远程仓库中的分支的索引。它们是一些无法移动的本地分支；只有在 Git 进行网络交互时才会更新。远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置。</p>
<p>我们用 (远程仓库名)/(分支名) 这样的形式表示远程分支。比如我们想看看上次同 origin 仓库通讯时master 的样子，就应该查看 origin/master 分支。如果你和同伴一起修复某个问题，但他们先推送了一个iss53 分支到远程仓库，虽然你可能也有一个本地的 iss53 分支，但指向服务器上最新更新的却应该是 origin/iss53 分支。</p>
<p>可能有点乱，我们不妨举例说明。假设你们团队有个地址为 git.ourcompany.com 的 Git 服务器。如果你从这里克隆，Git 会自动为你将此远程仓库命名为origin，并下载其中所有的数据，建立一个指向它的 master 分支的指针，在本地命名为origin/master，但你无法在本地更改其数据。接着，Git 建立一个属于你自己的本地master 分支，始于 origin 上 master分支相同的位置，你可以就此开始工作（见图 3-22）：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches32.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-22. 一次 Git 克隆会建立你自己的本地分支 master 和远程分支 origin/master，它们都指向 origin/master 分支的最后一次提交。</p>
<p>如果你在本地 master 分支做了些改动，与此同时，其他人向 git.ourcompany.com 推送了他们的更新，那么服务器上的master 分支就会向前推进，而于此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的 origin/master 指针仍然保持原位不会移动（见图 3-23）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches33.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-23. 在本地工作的同时有人向远程仓库推送内容会让提交历史开始分流。</p>
<p>可以运行 git fetch origin 来同步远程服务器上的数据到本地。该命令首先找到 origin 是哪个服务器（本例为git.ourcompany.com），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 origin/master 的指针移到它最新的位置上（见图 3-24）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches34.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-24. git fetch 命令会更新 remote 索引。</p>
<p>为了演示拥有多个远程分支（在不同的远程服务器上）的项目是如何工作的，我们假设你还有另一个仅供你的敏捷开发小组使用的内部服务器 git.team1.ourcompany.com。可以用第二章中提到的git remote add 命令把它加为当前项目的远程分支之一。我们把它命名为 teamone，以便代替原始的 Git 地址（见图 3-25）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches35.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-25. 把另一个服务器加为远程仓库</p>
<p>现在你可以用 git fetch teamone 来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你 origin 服务器上的子集，Git 不会下载任何数据，而只是简单地创建一个名为teamone/master 的分支，指向 teamone 服务器上 master分支所在的提交对象31b8e（见图 3-26）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches36.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-26. 你在本地有了一个指向 teamone 服务器上 master 分支的索引。</p>
<p><strong>推送本地分支</strong></p>
<p>要想和其他人分享某个本地分支，你需要把它推送到一个你拥有写权限的远程仓库。你的本地分支不会被自动同步到你引入的远程服务器上，除非你明确执行推送操作。换句话说，对于无意分享的分支，你尽管保留为私人分支好了，而只推送那些协同工作要用到的特性分支。</p>
<p>如果你有个叫 serverfix 的分支需要和他人一起开发，可以运行 git push (远程仓库名) (分支名)：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7$ git push origin serverfix</p>
<p>Counting objects: 20,</p>
<p>done</p>
<p>.
Compressing objects: 100% (14</p>
<p>/14</p>
<p>),</p>
<p>done</p>
<p>.</p>
<p>Writing objects: 100% (15</p>
<p>/15</p>
<p>), 1.74 KiB,</p>
<p>done</p>
<p>.
Total 15 (delta 5), reused 0 (delta 0)</p>
<p>To git@ &lt;span class=</p>
<p>&quot;wp_keywordlink&quot;</p>
<blockquote>
<p>&lt;a href=</p>
</blockquote>
<p>&quot;<a href="http://blog.jobbole.com/6492/" target="_blank">http://blog.jobbole.com/6492/</a>&quot;</p>
<p>title=</p>
<p>&quot;GitHub如何运作：时间并不决定一切&quot;</p>
<p>target=</p>
<p>&quot;_blank&quot;</p>
<blockquote>
<p>GitHub&lt;</p>
</blockquote>
<p>/a</p>
<blockquote>
<p>&lt;</p>
</blockquote>
<p>/span</p>
<blockquote>
<p>.com:schacon</p>
</blockquote>
<p>/simplegit</p>
<p>.git
/* [new branch] serverfix -&gt; serverfix</p>
<p>这其实有点像条捷径。Git 自动把 serverfix 分支名扩展为 refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”。我们将在第九章进一步介绍refs/heads/ 部分的细节，不过一般使用的时候都可以省略它。也可以运行 git push origin serverfix:serferfix 来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作awesomebranch，可以用 git push origin serverfix:awesomebranch 来推送数据。</p>
<p>接下来，当你的协作者再次从服务器上获取数据时，他们将得到一个新的远程分支 origin/serverfix：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7$ git fetch origin</p>
<p>remote: Counting objects: 20,</p>
<p>done</p>
<p>.
remote: Compressing objects: 100% (14</p>
<p>/14</p>
<p>),</p>
<p>done</p>
<p>.</p>
<p>remote: Total 15 (delta 5), reused 0 (delta 0)
Unpacking objects: 100% (15</p>
<p>/15</p>
<p>),</p>
<p>done</p>
<p>.</p>
<p>From git@ github.com:schacon</p>
<p>/simplegit
/* [new branch] serverfix -&gt; origin</p>
<p>/serverfix</p>
<p>值得注意的是，在 fetch 操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支。换句话说，在本例中，你不会有一个新的serverfix 分支，有的只是一个你无法移动的 origin/serverfix 指针。</p>
<p>如果要把该内容合并到当前分支，可以运行 git merge origin/serverfix。如果想要一份自己的 serverfix 来开发，可以在远程分支的基础上分化出一个新的分支来：</p>
<p>1</p>
<p>2
3$ git checkout -b serverfix origin</p>
<p>/serverfix</p>
<p>Branch serverfix</p>
<p>set</p>
<p>up to track remote branch refs</p>
<p>/remotes/origin/serverfix</p>
<p>.
Switched to a new branch</p>
<p>&quot;serverfix&quot;</p>
<p>这会切换到新建的 serverfix 本地分支，其内容同远程分支 origin/serverfix 一致，这样你就可以在里面继续开发了。</p>
<p><strong>跟踪远程分支</strong></p>
<p>从远程分支 checkout 出来的本地分支，称为<em>跟踪分支(tracking branch)</em>。跟踪分支是一种和远程分支有直接联系的本地分支。在跟踪分支里输入git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。反过来，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。</p>
<p>在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master。这正是git push 和 git pull 一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如origin 上除了 master 之外的其它分支。刚才我们已经看到了这样的一个例子：git checkout -b [分支名] [远程名]/[分支名]。如果你有 1.6.2 以上版本的 Git，还可以用–track 选项简化：
1</p>
<p>2
3$ git checkout --track origin</p>
<p>/serverfix</p>
<p>Branch serverfix</p>
<p>set</p>
<p>up to track remote branch refs</p>
<p>/remotes/origin/serverfix</p>
<p>.
Switched to a new branch</p>
<p>&quot;serverfix&quot;</p>
<p>要为本地分支设定不同于远程分支的名字，只需在前个版本的命令里换个名字：</p>
<p>1</p>
<p>2
3$ git checkout -b sf origin</p>
<p>/serverfix</p>
<p>Branch sf</p>
<p>set</p>
<p>up to track remote branch refs</p>
<p>/remotes/origin/serverfix</p>
<p>.
Switched to a new branch</p>
<p>&quot;sf&quot;</p>
<p>现在你的本地分支 sf 会自动向 origin/serverfix 推送和抓取数据了。</p>
<p><strong>删除远程分支</strong></p>
<p>如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的 master 分支（或任何其他存放稳定代码的地方），可以用这个非常无厘头的语法来删除它：git push [远程名] :[分支名]。如果想在服务器上删除serverfix 分支，运行下面的命令：
1</p>
<p>2
3$ git push origin :serverfix</p>
<p>To git@ github.com:schacon</p>
<p>/simplegit</p>
<p>.git</p>
<ul>
<li>[deleted] serverfix</li>
</ul>
<p>咚！服务器上的分支没了。你最好特别留心这一页，因为你一定会用到那个命令，而且你很可能会忘掉它的语法。有种方便记忆这条命令的方法：记住我们不久前见过的 git push [远程名] [本地分支]:[远程分支] 语法，如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”。</p>
<p><strong>3.6  分支的衍合</strong></p>
<p>把一个分支整合到另一个分支的办法有两种：merge 和 rebase（译注：rebase 的翻译暂定为“衍合”，大家知道就可以了。）。在本章我们会学习什么是衍合，如何使用衍合，为什么衍合操作如此富有魅力，以及我们应该在什么情况下使用衍合。</p>
<p><strong>基本的衍合操作</strong></p>
<p>回顾之前有关合并的一节（见图 3-27），你会看到开发进程分叉到两个不同分支，又各自提交了更新。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches37.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-27. 最初分叉的提交历史。</p>
<p>之前介绍过，最容易的整合分支的方法是 merge 命令，它会把两个分支最新的快照（C3 和 C4）以及二者最新的共同祖先（C2）进行三方合并，合并的结果是产生一个新的提交对象（C5）。如图 3-28 所示：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches38.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-28. 通过合并一个分支来整合分叉了的历史。</p>
<p>其实，还有另外一个选择：你可以把在 C3 里产生的变化补丁在 C4 的基础上重新打一遍。在 Git 里，这种操作叫做<em>衍合（rebase）</em>。有了 rebase 命令，就可以把在一个分支里提交的改变移到另一个分支里重放一遍。</p>
<p>在上面这个例子中，运行：
1</p>
<p>2
3</p>
<p>4
$ git checkout experiment</p>
<p>$ git rebase master
First, rewinding</p>
<p>head</p>
<p>to replay your work on</p>
<p>top</p>
<p>of it...</p>
<p>Applying: added staged</p>
<p>command</p>
<p>它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支 experiment）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支master）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 experiment 的提交历史，使它成为 master 分支的直接下游，如图 3-29 所示：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches39.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-29. 把 C3 里产生的改变到 C4 上重演一遍。</p>
<p>现在回到 master 分支，进行一次快进合并（见图 3-30）：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches40.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-30. master 分支的快进。</p>
<p>现在的 C3’ 对应的快照，其实和普通的三方合并，即上个例子中的 C5 对应的快照内容一模一样了。虽然最后整合得到的结果没有任何区别，但衍合能产生一个更为整洁的提交历史。如果视察一个衍合过的分支的历史记录，看起来会更 清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。</p>
<p>一般我们使用衍合的目的，是想要得到一个能在远程分支上干净应用的补丁 — 比如某些项目你不是维护者，但想帮点忙的话，最好用衍合：先在自己的一个分支里进行开发，当准备向主项目提交补丁的时候，根据最新的origin/master 进行一次衍合操作然后再提交，这样维护者就不需要做任何整合工作（译注：实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决。），只需根据你提供的仓库地址作一次快进合并，或者直接采纳你提交的补丁。</p>
<p>请注意，合并结果中最后一次提交所指向的快照，无论是通过衍合，还是三方合并，都会得到相同的快照内容，只不过提交历史不同罢了。衍合是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。</p>
<p><strong>有趣的衍合</strong></p>
<p>衍合也可以放到其他分支进行，并不一定非得根据分化之前的分支。以图 3-31 的历史为例，我们为了给服务器端代码添加一些功能而创建了特性分支 server，然后提交 C3 和 C4。然后又从 C3 的地方再增加一个client 分支来对客户端代码进行一些相应修改，所以提交了 C8 和 C9。最后，又回到 server 分支提交了 C10。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches41.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-31. 从一个特性分支里再分出一个特性分支的历史。</p>
<p>假设在接下来的一次软件发布中，我们决定先把客户端的修改并到主线中，而暂缓并入服务端软件的修改（因为还需要进一步测试）。这个时候，我们就可以把基于 server 分支而非 master 分支的改变（即 C8 和 C9），跳过 server 直接放到master 分支中重演一遍，但这需要用 git rebase 的 –onto 选项指定新的基底分支master：
1$ git rebase --onto master server client</p>
<p>这好比在说：“取出 client 分支，找出 client 分支和 server 分支的共同祖先之后的变化，然后把它们在master 上重演一遍”。是不是有点复杂？不过它的结果如图 3-32 所示，非常酷（译注：虽然 client 里的 C8, C9 在 C3 之后，但这仅表明时间上的先后，而非在 C3 修改的基础上进一步改动，因为server 和 client 这两个分支对应的代码应该是两套文件，虽然这么说不是很严格，但应理解为在 C3 时间点之后，对另外的文件所做的 C8，C9 修改，放到主干重演。）：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/42.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-32. 将特性分支上的另一个特性分支衍合到其他分支。</p>
<p>现在可以快进 master 分支了（见图 3-33）：
1$ git checkout master $ git merge client</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches43.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-33. 快进 master 分支，使之包含 client 分支的变化。</p>
<p>现在我们决定把 server 分支的变化也包含进来。我们可以直接把 server 分支衍合到 master，而不用手工切换到 server分支后再执行衍合操作 — git rebase [主分支] [特性分支] 命令会先取出特性分支server，然后在主分支 master 上重演：
1$ git rebase master server</p>
<p>于是，server 的进度应用到 master 的基础上，如图 3-34 所示：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches44.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-34. 在 master 分支上衍合 server 分支。</p>
<p>然后就可以快进主干分支 master 了：
1$ git checkout master $ git merge server</p>
<p>现在 client 和 server 分支的变化都已经集成到主干分支来了，可以删掉它们了。最终我们的提交历史会变成图 3-35 的样子：</p>
<p>1$ git branch -d client $ git branch -d server</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches45.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-35. 最终的提交历史</p>
<p><strong>衍合的风险</strong></p>
<p>呃，奇妙的衍合也并非完美无缺，要用它得遵守一条准则：</p>
<p><strong>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。</strong></p>
<p>如果你遵循这条金科玉律，就不会出差错。否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p>
<p>在进行衍合的时候，实际上抛弃了一些现存的提交对象而创造了一些类似但不同的新的提交对象。如果你把原来分支中的提交对象发布出去，并且其他人更新下载后在其基础上开展工作，而稍后你又用git rebase 抛弃这些提交对象，把新的重演后的提交对象发布出去的话，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容时，提交历史就会变得一团糟。</p>
<p>下面我们用一个实际例子来说明为什么公开的衍合会带来问题。假设你从一个中央服务器克隆然后在它的基础上搞了一些开发，提交历史类似图 3-36 所示：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches46.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-36. 克隆一个仓库，在其基础上工作一番。</p>
<p>现在，某人在 C1 的基础上做了些改变，并合并他自己的分支得到结果 C6，推送到中央服务器。当你抓取并合并这些数据到你本地的开发分支中后，会得到合并结果 C7，历史提交会变成图 3-37 这样：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches47.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-37. 抓取他人提交，并入自己主干。</p>
<p>接下来，那个推送 C6 上来的人决定用衍合取代之前的合并操作；继而又用 git push –force 覆盖了服务器上的历史，得到 C4’。而之后当你再从服务器上下载最新提交后，会得到：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches48.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-38. 有人推送了衍合后得到的 C4’，丢弃了你作为开发基础的 C4 和 C6。</p>
<p>下载更新后需要合并，但此时衍合产生的提交对象 C4’ 的 SHA-1 校验值和之前 C4 完全不同，所以 Git 会把它们当作新的提交对象处理，而实际上此刻你的提交历史 C7 中早已经包含了 C4 的修改内容，于是合并操作会把 C7 和 C4’ 合并为 C8（见图 3-39）:</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches49.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-39. 你把相同的内容又合并了一遍，生成一个新的提交 C8。</p>
<p>C8 这一步的合并是迟早会发生的，因为只有这样你才能和其他协作者提交的内容保持同步。而在 C8 之后，你的提交历史里就会同时包含 C4 和 C4’，两者有着不同的 SHA-1 校验值，如果用git log 查看历史，会看到两个提交拥有相同的作者日期与说明，令人费解。而更糟的是，当你把这样的历史推送到服务器后，会再次把这些衍合后的提交引入到中央服务 器，进一步困扰其他人（译注：这个例子中，出问题的责任方是那个发布了 C6 后又用衍合发布 C4’ 的人，其他人会因此反馈双重历史到共享主干，从而混淆大家的视听。）。</p>
<p>如果把衍合当成一种在推送之前清理提交历史的手段，而且仅仅衍合那些尚未公开的提交对象，就没问题。如果衍合那些已经公开的提交对象，并且已经有人基于这些提交对象开展了后续开发工作的话，就会出现叫人沮丧的麻烦。</p>
<p><strong>3.7  小结</strong></p>
<p>读到这里，你应该已经学会了如何创建分支并切换到新分支，在不同分支间转换，合并本地分支，把分支推送到共享服务器上，使用共享分支与他人协作，以及在分享之前进行衍合。</p>
<p><img src="&quot;2 votes, average: 5.00 out of 5&quot;" alt="2 votes, average: 5.00 out of 5"><img src="&quot;2 votes, average: 5.00 out of 5&quot;" alt="2 votes, average: 5.00 out of 5"><img src="&quot;2 votes, average: 5.00 out of 5&quot;" alt="2 votes, average: 5.00 out of 5"><img src="&quot;2 votes, average: 5.00 out of 5&quot;" alt="2 votes, average: 5.00 out of 5"><img src="&quot;2 votes, average: 5.00 out of 5&quot;" alt="2 votes, average: 5.00 out of 5"> (<strong>*2</strong> 个评分，平均: <strong>5.00*</strong>)</p>
<p><img src="&quot;Loading ...&quot;" alt="Loading ..."> Loading ...</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/git&github/">git&github</a></li></span></span> | <span class="tags">Tagged <a href="/tags/git&github/" class="label label-primary">git&github</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-gitgithub--Git详解之三：Git分支/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-gitgithub--Git详解之三：Git分支" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-gitgithub--Git详解之一：Git起步/">Git详解之一：Git起步</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-gitgithub--Git详解之一：Git起步/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="git-git-">Git详解之一：Git起步</h1>
<p>原文：<a href="http://git-scm.com/book/zh" target="_blank">《Pro Git》</a></p>
<p><strong>起步</strong></p>
<p>本章介绍开始使用 Git 前的相关知识。我们会先了解一些版本控制工具的历史背景，然后试着让 Git 在你的系统上跑起来，直到最后配置好，可以正常开始开发工作。读完本章，你就会明白为什么 Git 会如此流行，为什么你应该立即开始使用它。（<a href="http://blog.jobbole.com/tag/git/" target="_blank">查看Git详解系列的全部文章</a>）</p>
<p><strong>1.1 关于版本控制
</strong></p>
<p>什么是版本控制？我真的需要吗？版本控制是一种记录若干文件内容变化，以便将来查阅特定版本修订情况的系统。在本书所展示的例子中，我们仅对保存着软件源代码的文本文件作版本控制管理，但实际上，你可以对任何类型的文件进行版本控制。</p>
<p>如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本（这或许是你非常渴望拥有的功能）。采用版本控制系统 （VCS）是个明智的选择。有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态。你可以比较文件的变化细节，查出最 后是谁修改了哪个地方，从而导致出现怪异问题，又是谁在何时报告了某个功能缺陷等等。使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改 的改删的删，你也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。</p>
<p><strong>本地版本控制系统</strong></p>
<p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单。不过坏处也不少：有时候会混淆所在的工作目录，一旦弄错文件丢了数据就没法撤销恢复。</p>
<p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异（见图 1-1）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start1.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a></p>
<p>图 1-1. 本地版本控制系统</p>
<p>其中最流行的一种叫做 rcs，现今许多计算机系统上都还看得到它的踪影。甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 rcs 命令。它的工作原理基本上就是保存并管理文件补丁（patch）。文件补丁是一种特定格式的文本文件，记录着对应文件修订前后的内容变化。所以，根据每次 修订后的补丁，rcs 可以通过不断打补丁，计算出各个版本的文件内容。</p>
<p><strong>集中化的版本控制系统</strong></p>
<p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？于是，集中化的版本控制系统（ Centralized Version Control Systems，简称 CVCS ）应运而生。这类系统，诸如 CVS，Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这 已成为版本控制系统的标准做法（见图 1-2）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start2.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a></p>
<p>图 1-2. 集中化的版本控制系统</p>
<p>这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。</p>
<p>事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。要 是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就还是会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，而被客户端 提取出来的某些快照数据除外，但这样的话依然是个问题，你不能保证所有的数据都已经有人事先完整提取出来过。本地版本控制系统也存在类似问题，只要整个项 目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p>
<p><strong>分布式版本控制系统</strong></p>
<p>于是分布式版本控制系统（ Distributed Version Control System，简称 DVCS ）面世了。在这类系统中，像 Git，Mercurial，Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜 像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份（见图 1-3）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start3.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a>
图 1-3. 分布式版本控制系统</p>
<p>更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。</p>
<p><strong>1.2 Git 简史</strong></p>
<p>同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。</p>
<p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统制订了若干目标：</p>
<p>/<em> 速度 /</em> 简单的设计 /<em> 对非线性开发模式的强力支持（允许上千个并行开发的分支） /</em> 完全分布式 /* 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</p>
<p>自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。它的速度飞快，极其适合管理大项目，它还有着令人难以置信的非线性分支管理系统（见第三章），可以应付各种复杂的项目开发需求。</p>
<p><strong>1.3 Git 基础</strong></p>
<p>那么，简单地说，Git 究竟是怎样的一个系统呢？请注意，接下来的内容非常重要，若是理解了 Git 的思想和基本工作原理，用起来就会知其所以然，游刃有余。在开始学习 Git 的时候，请不要尝试把各种概念和其他版本控制系统（诸如 Subversion 和 Perforce 等）相比拟，否则容易混淆每个操作的实际意义。Git 在保存和处理各种信息的时候，虽然操作起来的命令形式非常相近，但它与其他版本控制系统的做法颇为不同。理解这些差异将有助于你准确地使用 Git 提供的各种工具。</p>
<p><strong>直接记录快照，而非差异比较</strong></p>
<p>Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。这类系统 （CVS，Subversion，Perforce，Bazaar 等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容，请看图 1-4。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start4.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a>
图 1-4. 其他系统在每个版本中记录着各个文件的具体差异</p>
<p>Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照 的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。Git 的工作方式就像图 1-5 所示。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start5.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a>
图 1-5. Git 保存每次更新时的文件快照</p>
<p>这是 Git 同其他系统的重要区别。它完全颠覆了传统版本控制的套路，并对各个环节的实现方式作了新的设计。Git 更像是个小型的文件系统，但它同时还提供了许多以此为基础的超强工具，而不只是一个简单的 VCS。稍后在第三章讨论 Git 分支管理的时候，我们会再看看这样的设计究竟会带来哪些好处。</p>
<p><strong>近乎所有操作都是本地执行</strong></p>
<p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。但如果用 CVCS 的话，差不多所有操作都需要连接网络。因为 Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。</p>
<p>举个例子，如果要浏览项目的历史更新摘要，Git 不用跑到外面的服务器上去取数据回来，而直接从本地数据库读取后展示给你看。所以任何时候你都可以马上翻阅，无需等待。如果想要看当前版本的文件和一个月 前的版本之间有何差异，Git 会取出一个月前的快照和当前文件作一次差异运算，而不用请求远程服务器来做这件事，或是把老版本的文件拉到本地来作比较。</p>
<p>用 CVCS 的话，没有网络或者断开 VPN 你就无法做任何事情。但用 Git 的话，就算你在飞机或者火车上，都可以非常愉快地频繁提交更新，等到了有网络的时候再上传到远程仓库。同样，在回家的路上，不用连接 VPN 你也可以继续工作。换作其他版本控制系统，这么做几乎不可能，抑或非常麻烦。比如 Perforce，如果不连到服务器，几乎什么都做不了（译注：默认无法发出命令</p>
<p>p4 edit file
 开始编辑文件，因为 Perforce 需要联网通知系统声明该文件正在被谁修订。但实际上手工修改文件权限可以绕过这个限制，只是完成后还是无法提交更新。）；如果是 Subversion 或 CVS，虽然可以编辑文件，但无法提交更新，因为数据库在网络上。看上去好像这些都不是什么大问题，但实际体验过之后，你就会惊喜地发现，这其实是会带来很大不同的。</p>
<p><strong>时刻保持数据完整性</strong></p>
<p>在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后，Git 一无所知。这项特性作为 Git 的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。</p>
<p>Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符（0-9 及 a-f）组成，看起来就像是：
124b9da6552252987aa493b52f8696cd6d3b00373</p>
<p>Git 的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。实际上，所有保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。</p>
<p><strong>多数操作仅添加数据</strong></p>
<p>常用的 Git 操作大多仅仅是把数据添加到数据库。因为任何一种不可逆的操作，比如删除数据，都会使回退或重现历史版本变得困难重重。在别的 VCS 中，若还未提交更新，就有可能丢失或者混淆一些修改的内容，但在 Git 里，一旦提交快照之后就完全不用担心丢失数据，特别是养成定期推送到其他仓库的习惯的话。</p>
<p>这种高可靠性令我们的开发工作安心不少，尽管去做各种试验性的尝试好了，再怎样也不会弄丢数据。至于 Git 内部究竟是如何保存和恢复数据的，我们会在第九章讨论 Git 内部原理时再作详述。</p>
<p><strong>文件的三种状态</strong></p>
<p>好，现在请注意，接下来要讲的概念非常重要。对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库 中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。</p>
<p>由此我们看到 Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start6.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a></p>
<p>图 1-6. 工作目录，暂存区域，以及本地仓库</p>
<p>每个项目都有一个 Git 目录（译注：如果 </p>
<p>git clone
 出来的话，就是其中 </p>
<p>.git
 的目录；如果</p>
<p>git clone --bare
 的话，新建的目录本身就是 Git 目录。），它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。</p>
<p>从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件实际上都是从 Git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。</p>
<p>所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。</p>
<p>基本的 Git 工作流程如下：</p>
<ol>
<li>在工作目录中修改某些文件。 2. 对修改后的文件进行快照，然后保存到暂存区域。 3. 提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。</li>
</ol>
<p>所以，我们可以从文件所处的位置来判断状态：如果是 Git 目录中保存着的特定版本文件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次取出后，作了修改但还没有放到暂存区域，就 是已修改状态。到第二章的时候，我们会进一步了解其中细节，并学会如何根据文件状态实施后续操作，以及怎样跳过暂存直接提交。</p>
<p><strong>1.4 安装 Git</strong></p>
<p>是时候动手尝试下 Git 了，不过得先安装好它。有许多种安装方式，主要分为两种，一种是通过编译源代码来安装；另一种是使用为特定平台预编译好的安装包。</p>
<p><strong>从源代码安装</strong></p>
<p>若是条件允许，从源代码安装有很多好处，至少可以安装最新的版本。Git 的每个版本都在不断尝试改进用户体验，所以能通过源代码自己编译安装最新版本就再好不过了。有些 Linux 版本自带的安装包更新起来并不及时，所以除非你在用最新的 distro 或者 backports，那么从源代码安装其实该算是最佳选择。</p>
<p>Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。在有 yum 的系统上（比如 Fedora）或者有 apt-get 的系统上（比如 Debian 体系），可以用下面的命令安装：
1</p>
<p>2
3</p>
<p>4
5$ yum</p>
<p>install</p>
<p>curl-devel expat-devel gettext-devel \</p>
<p>openssl-devel zlib-devel</p>
<p>$ apt-get</p>
<p>install</p>
<p>libcurl4-gnutls-dev libexpat1-dev gettext \</p>
<p>libz-dev libssl-dev</p>
<p>之后，从下面的 Git 官方站点下载最新版本源代码：</p>
<p>1http:</p>
<p>//git-scm</p>
<p>.com</p>
<p>/download</p>
<p>然后编译并安装：</p>
<p>1</p>
<p>2
3</p>
<p>4
$</p>
<p>tar</p>
<p>-zxf git-1.7.2.2.</p>
<p>tar</p>
<p>.gz</p>
<p>$</p>
<p>cd</p>
<p>git-1.7.2.2
$</p>
<p>make</p>
<p>prefix=</p>
<p>/usr/local</p>
<p>all</p>
<p>$</p>
<p>sudo</p>
<p>make</p>
<p>prefix=</p>
<p>/usr/local</p>
<p>install</p>
<p>现在已经可以用 </p>
<p>git
 命令了，用 </p>
<p>git
 把 Git 项目仓库克隆到本地，以便日后随时更新：</p>
<p>1$ git clone git:</p>
<p>//git</p>
<p>.kernel.org</p>
<p>/pub/scm/git/git</p>
<p>.git</p>
<p><strong>在 Linux 上安装</strong></p>
<p>如果要在 Linux 上安装预编译好的 Git 二进制安装包，可以直接用系统提供的包管理工具。在 Fedora 上用 yum 安装：
1$ yum</p>
<p>install</p>
<p>git-core</p>
<p>在 Ubuntu 这类 Debian 体系的系统上，可以用 apt-get 安装：</p>
<p>1$ apt-get</p>
<p>install</p>
<p>git-core</p>
<p><strong>在 Mac 上安装</strong></p>
<p>在 Mac 上安装 Git 有两种方式。最容易的当属使用图形化的 Git 安装工具，界面如图 1-7，下载地址在：
<a href="http://code.google.com/p/git-osx-installer" target="_blank">http://code.google.com/p/git-osx-installer</a></p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start7.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a>
图 1-7. Git OS X 安装工具</p>
<p>另一种是通过 MacPorts (</p>
<p><a href="http://www.macports.org" target="_blank">http://www.macports.org</a>
) 安装。如果已经装好了 MacPorts，用下面的命令安装 Git：
1$</p>
<p>sudo</p>
<p>port</p>
<p>install</p>
<p>git-core +svn +doc +bash_completion +gitweb</p>
<p>这种方式就不需要再自己安装依赖库了，Macports 会帮你<a href="http://www.amazon.cn/gp/product/B007XPTAIS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;linkCode=as2&amp;camp=536&amp;creative=3200&amp;creativeASIN=B007XPTAIS" title="搞定(套装共3册) " target="_blank">搞定</a>这些麻烦事。一般上面列出的安装选项已经够用，要是你想用 Git 连接 Subversion 的代码仓库，还可以加上 +svn 选项，具体将在第八章作介绍。（译注：还有一种是使用 homebrew（</p>
<p><a href="https://[GitHub](http://blog.jobbole.com/6492/" target="_blank">https://[GitHub](http://blog.jobbole.com/6492/</a> &quot;GitHub如何运作：时间并不决定一切&quot;).com/mxcl/homebrew
）：</p>
<p>brew install git
。）</p>
<p><strong>在 Windows 上安装</strong></p>
<p>在 Windows 上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包，可以到 Google Code 的页面上下载 exe 安装文件并运行：
1http:</p>
<p>//code</p>
<p>.google.com</p>
<p>/p/msysgit</p>
<p>完成安装之后，就可以使用命令行的 </p>
<p>git
 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。</p>
<p><strong>1.5 初次运行 Git 前的配置</strong></p>
<p>一般在新的系统上，我们都需要先配置下自己的 Git 工作环境。配置工作只需一次，以后升级时还会沿用现在的配置。当然，如果需要，你随时可以用相同的命令修改已有的配置。</p>
<p>Git 提供了一个叫做 git config 的工具（译注：实际是 </p>
<p>git-config
 命令，只不过可以通过 </p>
<p>git
 加一个名字来呼叫此命令。），专门用来配置或读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p>
<p>●/etc/gitconfig
 文件：系统中对所有用户都普遍适用的配置。若使用 </p>
<p>git config
 时用</p>
<p>--system
 选项，读写的就是这个文件。</p>
<p>●~/.gitconfig
 文件：用户目录下的配置文件只适用于该用户。若使用 </p>
<p>git config
 时用</p>
<p>--global
 选项，读写的就是这个文件。</p>
<p>●当前项目的 git 目录中的配置文件（也就是工作目录中的 </p>
<p>.git/config
 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以</p>
<p>.git/config
 里的配置会覆盖</p>
<p>/etc/gitconfig
 中的同名变量。</p>
<p>在 Windows 系统上，Git 会找寻用户主目录下的 </p>
<p>.gitconfig
 文件。主目录即 </p>
<p>$HOME
 变量指定的目录，一般都是</p>
<p>C:\Documents and Settings\$USER
。此外，Git 还会尝试找寻</p>
<p>/etc/gitconfig
 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p>
<p><strong>用户信息</strong></p>
<p>第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：
1</p>
<p>2
$ git config --global user.name</p>
<p>&quot;John Doe&quot;</p>
<p>$ git config --global user.email johndoe@ example.com</p>
<p>如果用了 </p>
<p>--global
 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉</p>
<p>--global
 选项重新配置即可，新的设定保存在当前项目的</p>
<p>.git/config
 文件里。</p>
<p><strong>文本编辑器</strong></p>
<p>接下来要设置的是默认使用的文本编辑器。Git 需要你输入一些额外消息的时候，会自动调用一个外部文本编辑器给你用。默认会使用操作系统指定的默认编辑器，一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：
1$ git config --global core.editor emacs</p>
<p><strong>差异分析工具</strong></p>
<p>还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：
1$ git config --global merge.tool vimdiff</p>
<p>Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。当然，你也可以指定使用自己开发的工具，具体怎么做可以参阅第七章。</p>
<p><strong>查看配置信息</strong></p>
<p>要检查已有的配置信息，可以使用 </p>
<p>git config --list
 命令：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
$ git config --list</p>
<p>user.name=Scott Chacon
user.email=schacon@ gmail.com</p>
<p>color.status=auto
color.branch=auto</p>
<p>color.interactive=auto
color.</p>
<p>diff</p>
<p>=auto</p>
<p>...</p>
<p>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 </p>
<p>/etc/gitconfig
 和 </p>
<p>~/.gitconfig
），不过最终 Git 实际采用的是最后一个。</p>
<p>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：
1$ git config user.name Scott Chacon</p>
<p><strong>1.6 获取帮助</strong></p>
<p>想了解 Git 的各式工具该怎么用，可以阅读它们的使用帮助，方法有三：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
$ git help</p>
<p>$ git</p>
<p>--help</p>
<p>$</p>
<p>man</p>
<p>git-</p>
<p>比如，要学习 config 命令可以怎么用，运行：</p>
<p>1$ git help config</p>
<p>我们随时都可以浏览这些帮助信息而无需连网。不过，要是你觉得还不够，可以到 Frenode IRC 服务器（irc.freenode.net）上的 </p>
<p>/#git
 或 </p>
<p>/#github
 频道寻求他人帮助。这两个频道上总有着上百号人，大多都有着丰富的 git 知识，并且乐于助人。</p>
<hr>
<p><strong>1.7 小结</strong></p>
<p>至此，你该对 Git 有了点基本认识，包括它和以前你使用的 CVCS 之间的差别。现在，在你的系统上应该已经装好了 Git，设置了自己的名字和电邮。接下来让我们继续学习 Git 的基础知识。</p>
<p><img src="&quot;6 votes, average: 5.00 out of 5&quot;" alt="6 votes, average: 5.00 out of 5"><img src="&quot;6 votes, average: 5.00 out of 5&quot;" alt="6 votes, average: 5.00 out of 5"><img src="&quot;6 votes, average: 5.00 out of 5&quot;" alt="6 votes, average: 5.00 out of 5"><img src="&quot;6 votes, average: 5.00 out of 5&quot;" alt="6 votes, average: 5.00 out of 5"><img src="&quot;6 votes, average: 5.00 out of 5&quot;" alt="6 votes, average: 5.00 out of 5"> (<strong>*6</strong> 个评分，平均: <strong>5.00*</strong>)</p>
<p><img src="&quot;Loading ...&quot;" alt="Loading ..."> Loading ...</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/git&github/">git&github</a></li></span></span> | <span class="tags">Tagged <a href="/tags/git&github/" class="label label-primary">git&github</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-gitgithub--Git详解之一：Git起步/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-gitgithub--Git详解之一：Git起步" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-gitgithub--Git与Github入门资料←阳志平的个人网站技术/">Git与Github入门资料 ← 阳志平的个人网站  技术</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-gitgithub--Git与Github入门资料←阳志平的个人网站技术/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="git-github-">Git与Github入门资料 ← 阳志平的个人网站 技术</h1>
<h1 id="-http-www-yangzhiping-com-tech-"><a href="http://www.yangzhiping.com/tech/" title="阳志平的个人网站::技术" target="_blank">阳志平的个人网站::技术</a></h1>
<ul>
<li><a href="http://www.yangzhiping.com/tech/past.html" target="_blank">文章存档</a></li>
<li><a href="http://www.yangzhiping.com/" target="_blank">回到首页</a></li>
</ul>
<h1 id="git-github-">Git与Github入门资料</h1>
<h2 id="git-">Git主要优势及安装</h2>
<p>git，一个非常强大的版本管理工具。<a href="http://www.github.com/" target="_blank">Github</a>则是一个基于Git的日益流行的开源项目托管库。Git与svn的最大区别是，它的使用流程不需要联机，可以先将对代码的修改，评论，保存在本机。等上网之后，再实时推送过去。同时它创建分支与合并分支更容易，推送速度也更快，配合Github提交需求也更容易。</p>
<p>git的入门，稍微有点麻烦，需要在本机创建一个ssh的钥匙，其他的则海空天空了。windows下可以参考<a href="http://hi.baidu.com/mcspring/blog/item/171b1e38986d39fab211c71b.html" target="_blank">这篇教程</a>，Mac等更多教程则可以参考<a href="http://help.github.com/win-set-up-git/" target="_blank">Github官方</a>。</p>
<h2 id="git-">Git全局设置</h2>
<p>下载并安装Git
git config --global user.name &quot;Your Name&quot; git config --global user.email youremail@email.com</p>
<h2 id="-it-github-">将Ｇit项目与Github建立联系</h2>
<p>mkdir yourgithubproject cd yourgithubproject git init touch README git add README git commit -m &#39;first commit&#39; git remote add origin git@github.com:yourgithubname/yourgithubproject.git git push origin master</p>
<h2 id="-git-">导入现有的Git仓库</h2>
<p>cd existing_git_repo git remote add origin git@github.com:yourgithubname/yourgithubproject.git git push origin master</p>
<h2 id="-subversion-">导入现有的Subversion仓库</h2>
<p><a href="http://help.github.com/import-from-subversion/" target="_blank">点击此处</a></p>
<h2 id="git-">git最主要的命令</h2>
<p>git --help</p>
<p>The most commonly used git commands are:</p>
<p>add Add file contents to the index bisect Find by binary search the change that introduced a bug branch List, create, or delete branches checkout Checkout a branch or paths to the working tree clone Clone a repository into a new directory commit Record changes to the repository diff Show changes between commits, commit and working tree, etc fetch Download objects and refs from another repository grep Print lines matching a pattern init Create an empty git repository or reinitialize an existing one log Show commit logs merge Join two or more development histories together mv Move or rename a file, a directory, or a symlink pull Fetch from and merge with another repository or a local branch push Update remote refs along with associated objects rebase Forward-port local commits to the updated upstream head reset Reset current HEAD to the specified state rm Remove files from the working tree and from the index show Show various types of objects status Show the working tree status tag Create, list, delete or verify a tag object signed with GPG</p>
<h2 id="-">第一次提交的时候</h2>
<p>git push yourgithubproject maste</p>
<h2 id="-">日常提交常用命令</h2>
<p>git add . git commit -a -m&quot;some files&quot; git push yourgithubproject</p>
<h2 id="textmate-git-bundles">Textmate的Git Bundles</h2>
<p><img src="&quot;Textmate的Git Bundles&quot;" alt="参考"></p>
<h2 id="-">更多参考</h2>
<ul>
<li><a href="http://progit.org/book/" target="_blank">Pro Git</a>，<a href="http://progit.org/2010/06/09/pro-git-zh.html" target="_blank">中文版</a></li>
<li><a href="http://peepcode.com/products/git" target="_blank">Peepcode的Git教程</a></li>
<li><a href="http://help.github.com/git-cheat-sheets/" target="_blank">Git cheat sheets</a></li>
</ul>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">知识共享署名-非商业性使用-禁止演绎 3.0 Unported许可协议</a>进行许可。
25 November 2010</p>
<p>分享到： <a href="&quot;分享到新浪微博&quot;"></a> <a href="&quot;分享到腾讯微博&quot;"></a> <a href="&quot;分享到人人网&quot;"></a> <a href="&quot;分享到Instapaper&quot;"></a> <a href="http://www.jiathis.com/share" target="_blank">更多</a>
<img src="" alt="DISQUS"><img src="" alt="..."></p>
<ul>
<li><a href="http://www.yangzhiping.com/tech/git.html#" title="更多社区信息"></a></li>
<li><p><a href="http://www.yangzhiping.com/tech/git.html#" target="_blank">Disqus</a></p>
</li>
<li><p><a href="http://www.yangzhiping.com/tech/git.html#" target="_blank">登录</a></p>
</li>
<li><p><a href="http://disqus.com/" target="_blank">About Disqus</a></p>
</li>
<li><p><a href="http://www.yangzhiping.com/tech/git.html#" title="I like this page" target="_blank">喜欢</a></p>
</li>
<li><a href="http://www.yangzhiping.com/tech/git.html#" title="I don&#39;t like this page" target="_blank">Dislike</a></li>
<li></li>
<li><a href="http://disqus.com/loo2k/" target="_blank"><img src="" alt=""></a></li>
<li>and 1 other liked this.</li>
</ul>
<h3 id="glad-you-liked-it-would-you-like-to-share-">Glad you liked it. Would you like to share?</h3>
<p>Facebook</p>
<p>Twitter</p>
<ul>
<li><a href="http://www.yangzhiping.com/tech/git.html#" target="_blank">Share</a></li>
<li><a href="http://www.yangzhiping.com/tech/git.html#" target="_blank">No thanks</a></li>
</ul>
<p>Sharing this page …
Thanks! <a href="http://www.yangzhiping.com/tech/git.html#" target="_blank">Close</a>
<a href="http://www.yangzhiping.com/tech/git.html#" target="_blank">登录</a></p>
<h3 id="-">添加新的评论</h3>
<p><img src="" alt=""></p>
<ul>
<li>以什么身份发表 …</li>
<li>Image
*</li>
</ul>
<p>排序 受欢迎的   排序 best rating   排序 后发表在前   排序 先发表在前</p>
<h3 id="-2-">显示 2 评论</h3>
<p>*</p>
<ul>
<li><a href="http://disqus.com/google-2f926cdf4c90bb949573659bf911e7a6/" target="_blank"><img src="" alt=""></a></li>
</ul>
<p>Huayi Duan  1 comment collapsed  <a href="http://www.yangzhiping.com/tech/git.html#" title="Collapse thread" target="_blank">Collapse</a> <a href="http://www.yangzhiping.com/tech/git.html#" title="Expand thread" target="_blank">Expand</a></p>
<p>这个陈述有问题吧。Git与svn的最大区别是，它的使用流程不需要联机，可以先将对代码的修改，评论，保存在本机。等上网之后，再实时推送过去。</p>
<ul>
<li>A <a href="http://www.yangzhiping.com/tech/git.html#" target="_blank">喜欢</a></li>
<li><p><a href="http://www.yangzhiping.com/tech/git.html#" target="_blank">回复</a></p>
</li>
<li><p><a href="http://www.yangzhiping.com/tech/git.html#comment-600500053" title="Link to comment by Huayi Duan" target="_blank">5 月前</a></p>
</li>
<li><a href="http://www.yangzhiping.com/tech/git.html#" target="_blank">1 喜欢</a></li>
<li><a href="http://www.yangzhiping.com/tech/git.html#" target="_blank">F</a>
<em>
</em></li>
<li><a href="http://disqus.com/guest/c689eb38a3c4c5a1341d2287b165fb9c/" target="_blank"><img src="" alt=""></a></li>
</ul>
<p>Jid  1 comment collapsed  <a href="http://www.yangzhiping.com/tech/git.html#" title="Collapse thread" target="_blank">Collapse</a> <a href="http://www.yangzhiping.com/tech/git.html#" title="Expand thread" target="_blank">Expand</a></p>
<p>的</p>
<ul>
<li>A <a href="http://www.yangzhiping.com/tech/git.html#" target="_blank">喜欢</a></li>
<li><p><a href="http://www.yangzhiping.com/tech/git.html#" target="_blank">回复</a></p>
</li>
<li><p><a href="http://www.yangzhiping.com/tech/git.html#comment-629347515" title="Link to comment by Jid" target="_blank">4 月前</a></p>
</li>
<li><a href="http://www.yangzhiping.com/tech/git.html#" target="_blank">0 喜欢</a></li>
<li><a href="http://www.yangzhiping.com/tech/git.html#" target="_blank">F</a>
*</li>
<li><a href="http://www.yangzhiping.com/tech/git.html#" target="_blank">M <em>通过邮件订阅</em></a></li>
<li><a href="http://ouyang.disqus.com/gitgithub/latest.rss" target="_blank">S <em>RSS</em></a></li>
</ul>
<p>引用通告网址
     <div id="footer"> <address> <span class="copyright"> Content by <a href="http://www.yangzhiping.com/">阳志平</a> (<a rel="licence" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">Some rights reserved</a>) </span> <span class="engine"> Powered by <a href="http://github.com/mreid/jekyll/" title="A static, minimalist CMS" target="_blank">Jekyll</a> and <a href="http://mark.reid.name/" target="_blank">Mark Reid</a> </span> </address> </div> </div> <script type="text/javascript"> var _gaq = _gaq || []; _gaq.push([&#39;_setAccount&#39;, &#39;UA-6781501-12&#39;]); _gaq.push([&#39;_trackPageview&#39;]); (function() { var ga = document.createElement(&#39;script&#39;); ga.type = &#39;text/javascript&#39;; ga.async = true; ga.src = (&#39;https:&#39; == document.location.protocol ? &#39;<a href="https://ssl" target="_blank">https://ssl</a>&#39; : &#39;<a href="http://www" target="_blank">http://www</a>&#39;) + &#39;.google-analytics.com/ga.js&#39;; var s = document.getElementsByTagName(&#39;script&#39;)[0]; s.parentNode.insertBefore(ga, s); })(); </script> </body> </html></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/git&github/">git&github</a></li></span></span> | <span class="tags">Tagged <a href="/tags/git&github/" class="label label-primary">git&github</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-gitgithub--Git与Github入门资料←阳志平的个人网站技术/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-gitgithub--Git与Github入门资料←阳志平的个人网站技术" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/31/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/29/">29</a></li><li><a class="page-number" href="/page/30/">30</a></li><li><a class="page-number" href="/page/31/">31</a></li><li class="active"><li><span class="page-number current">32</span></li><li><a class="page-number" href="/page/33/">33</a></li><li><a class="page-number" href="/page/34/">34</a></li><li><a class="page-number" href="/page/35/">35</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/33/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 15:12:18</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
