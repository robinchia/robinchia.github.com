
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 32 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--Java内存分配、管理小结--ITeye技术网站/">Java内存分配、管理小结 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--Java内存分配、管理小结--ITeye技术网站/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-iteye-">Java内存分配、管理小结 - - ITeye技术网站</h1>
<p><a href="http://www.iteye.com/" target="_blank">首页</a> <a href="http://www.iteye.com/news" target="_blank">新闻</a> <a href="http://www.iteye.com/forums" target="_blank">论坛</a> <a href="http://www.iteye.com/ask" target="_blank">问答</a> <a href="http://www.iteye.com/blogs" target="_blank">博客</a> <a href="http://www.iteye.com/job" target="_blank">招聘</a> <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">更多 ▼</a></p>
<p><a href="http://www.iteye.com/wiki" target="_blank">专栏</a>  <a href="http://www.iteye.com/groups" target="_blank">群组</a> <a href="http://www.iteye.com/search" target="_blank">搜索</a></p>
<p><a href="http://java-mzd.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://www.iteye.com/all" target="_blank">我的应用</a> <a href="http://java-mzd.iteye.com/login" target="_blank">登录</a> <a href="http://java-mzd.iteye.com/signup" target="_blank">注册</a></p>
<h1 id="-java-mzd-http-java-mzd-iteye-com-"><a href="http://java-mzd.iteye.com/" target="_blank">java-mzd</a></h1>
<p>永久域名 <a href="http://java-mzd.iteye.com/" target="_blank"><a href="http://java-mzd.iteye.com">http://java-mzd.iteye.com</a></a></p>
<p><a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">55顶</a>
<a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">8踩</a></p>
<p><a href="http://java-mzd.iteye.com/blog/862787" title="开源软件？自由软件？免费软件？你了解多少？" target="_blank">开源软件？自由软件？免费软件？你了解多少 ...</a> | <a href="http://java-mzd.iteye.com/blog/838683" title="JAVA程序执行顺序，你了解了吗？" target="_blank">JAVA程序执行顺序，你了解了吗？</a></p>
<p>2010-12-21</p>
<h3 id="-java-"><a href="">Java内存分配、管理小结</a></h3>
<p><strong>文章分类:<a href="http://www.iteye.com/blogs/category/java" target="_blank">Java编程</a></strong>
P.S.</p>
<p>想写这篇总结酝酿了有个来月了，却始终感觉还差点什么东西，一直未敢动笔。</p>
<pre><code>   最近两天连夜奋战，重新整理下前面查阅的资料、笔记，还是决定将它写出来。

   现在提出几个问题，如果都能熟练回答的大虾，请您飘过.如以往一样，我是小菜，本文自然也是针对小菜阶层的总结。
</code></pre><p>首先是概念层面的几个问题：</p>
<ul>
<li>Java中运行时内存结构有哪几种？</li>
<li>Java中为什么要设计堆栈分离?</li>
<li>Java多线程中是如何实现数据共享的？</li>
<li>Java反射的基础是什么？</li>
</ul>
<p>然后是运用层面：</p>
<ul>
<li>引用类型变量和对象的区别？</li>
<li>什么情况下用局部变量，什么情况下用成员变量？</li>
<li>数组如何初始化？声明一个数组的过程中，如何分配内存？</li>
<li>声明基本类型数组和声明引用类型的数组，初始化时，内存分配机制有什么区？</li>
<li>在什么情况下，我们的方法设计为静态化，为什么？（上次胡老师问文奇，问的哑口无言，当时想回答，却老感觉表述不清楚，这里也简单说明一下）</li>
</ul>
<p>好了，问题提完了，如果您都能一眼看出答案，那么，没有必要再浪费您宝贵的时间看下去了。</p>
<p>如果您还不太明白，请跟随我一路走下去。</p>
<p>Java中运行时内存结构</p>
<p>   1.1 方法区： </p>
<p><strong>方法区是系统分配的一个内存逻辑区域，是JVM在装载类文件时，用于存储类型信息的(类的描述信息)。</strong></p>
<p>方法区存放的信息包括：</p>
<pre><code>        1.1.1**类的基本信息：**
</code></pre><ol>
<li>每个类的全限定名</li>
<li>每个类的直接超类的全限定名(可约束类型转换)</li>
<li>该类是类还是接口</li>
<li>该类型的访问修饰符</li>
<li><p>直接超接口的全限定名的有序列表</p>
<pre><code>      1.1.2**已装载类的详细信息**：
</code></pre></li>
<li><p>运行时常量池：</p>
</li>
</ol>
<p>在方法区中，每个类型都对应一个常量池，存放该类型所用到的所有常量，常量池中存储了诸如文字字符串、final变量值、类名和方法名常量。它们以数组形式通过索引被访问，是外部调用与类联系及类型对象化的桥梁。（存的可能是个普通的字符串，然后经过常量池解析，则变成指向某个类的引用）</p>
<ol>
<li>字段信息：</li>
</ol>
<p>字段信息存放类中声明的每一个字段的信息，包括字段的名、类型、修饰符。</p>
<p>字段名称指的是类或接口的实例变量或类变量，字段的描述符是一个指示字段的类型的字符串，如private A a=null;则a为字段名，A为描述符，private为修饰符</p>
<ol>
<li>方法信息：</li>
</ol>
<p>类中声明的每一个方法的信息，包括方法名、返回值类型、参数类型、修饰符、异常、方法的字节码。</p>
<p>(在编译的时候，就已经将方法的局部变量、操作数栈大小等确定并存放在字节码中，在装载的时候，随着类一起装入方法区。)
在运行时，JVM从常量池中获得符号引用，然后在运行时解析成引用项的实际地址，最后通过常量池中的全限定名、方法和字段描述符，把当前类或接口中的代码与其它类或接口中的代码联系起来。</p>
<ol>
<li>静态变量：</li>
</ol>
<p>这个没什么好说的，就是类变量，类的所有实例都共享，我们只需知道，在方法区有个静态区，静态区专门存放静态变量和静态块。</p>
<ol>
<li>到类classloader的引用：到该类的类装载器的引用。</li>
<li><p>到类class 的引用：虚拟机为每一个被装载的类型创建一个class 实例，用来代表这个被装载的类。 </p>
<p><strong>由此我们可以知道反射的基础</strong>：</p>
</li>
</ol>
<p>在装载类的时候，加入方法区中的所有信息，最后都会形成Class类的实例，代表这个被装载的类。方法区中的所有的信息，都是可以通过这个Class类对象反射得到。我们知道对象是类的实例，类是相同结构的对象的一种抽象。同类的各个对象之间，其实是拥有相同的结构（属性），拥有相同的功能（方法），各个对象的区别只在于属性值的不同。
    同样的，我们所有的类，其实都是Class类的实例，他们都拥有相同的结构-----Field数组、Method数组。而各个类中的属性都是Field属性的一个具体属性值，方法都是Method属性的一个具体属性值。</p>
<p> 在运行时，JVM从常量池中获得符号引用，然后在运行时解析成引用项的实际地址，最后通过常量池中的全限定名、方法和字段描述符，把当前类或接口中的代码与其它类或接口中的代码联系起来。</p>
<p>1.2 Java栈</p>
<p>JVM栈是程序运行时单位，决定了程序如何执行，或者说数据如何处理。</p>
<p>在Java中，一个线程就会有一个线程的JVM栈与之对应，因为不过的线程执行逻辑显然不同，因此都需要一个独立的JVM栈来存放该线程的执行逻辑。</p>
<p>对方法的调用：</p>
<p>Java栈内存，以帧的形式存放本地方法的调用状态，包括方法调用的参数、局部变量、中间结果等（方法都是以方法帧的形式存放在方法区的），每调用一个方法就将对应该方法的方法帧压入Java 栈，成为当前方法帧。当调用结束(返回)时，就弹出该帧。</p>
<p><strong>这意味着：</strong></p>
<p>在方法中定义的一些基本类型的变量和引用变量都在方法的栈内存中分配。<strong>当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后（方法执行完成后），Java 会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作它用</strong>。--------<strong>同时，因为变量被释放，该变量对应的对象，也就失去了引用，也就变成了可以被gc对象回收的垃圾。</strong></p>
<p><strong>因此我们可以知道成员变量与局部变量的区别：</strong></p>
<p>局部变量，在方法内部声明，当该方法运行完时，内存即被释放。
成员变量，只要该对象还在，哪怕某一个方法运行完了，还是存在。
从系统的角度来说，声明局部变量有利于内存空间的更高效利用（方法运行完即回收）。
成员变量可用于各个方法间进行数据共享。</p>
<p>Java 栈内存的组成：
局部变量区、操作数栈、帧数据区组成。
（1）：局部变量区为一个以字为单位的数组，每个数组元素对应一个局部变量的值。调用方法时，将方法的局部变量组成一个数组，通过索引来访问。若为非静态方法，则加入一个隐含的引用参数this,该参数指向调用这个方法的对象。而静态方法则没有this参数。因此，对象无法调用静态方法。</p>
<p><strong>由此，我们可以知道，方法什么时候设计为静态，什么时候为非静态？</strong></p>
<p>前面已经说过，对象是类的一个实例，各个对象结构相同，只是属性不同。
而静态方法是对象无法调用的。
所以，静态方法适合那些工具类中的工具方法，这些类只是用来实现一些功能，也不需要产生对象，通过设置对象的属性来得到各个不同的个体。</p>
<p>（2）：操作数栈也是一个数组，但是通过栈操作来访问。所谓操作数是那些被指令操作的数据。当需要对参数操作时如a=b+c,就将即将被操作的参数压栈，如将b 和c 压栈，然后由操作指令将它们弹出，并执行操作。虚拟机将操作数栈作为工作区。
（3）：帧数据区处理常量池解析，异常处理等</p>
<p>1.3 java堆 </p>
<pre><code>  java的堆是一个运行时的数据区，用来存储数据的单元，存放通过new关键字新建的对象和数组，对象从中分配内存。
  在堆中声明的对象，是不能直接访问的，必须通过在栈中声明的指向该引用的变量来调用。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。


** 由此我们可以知道,引用类型变量和对象的区别: **
</code></pre><p>声明的对象是在堆内存中初始化的， 真正用来存储数据的。不能直接访问。</p>
<p>引用类型变量是保存在栈当中的，一个用来引用堆中对象的符号而已（指针）。</p>
<p><strong>堆与栈的比较</strong>：
JAVA堆与栈都是用来存放数据的，那么他们之间到底有什么差异呢？既然栈也能存放数据，为什么还要设计堆呢？</p>
<p>1.从存放数据的角度:</p>
<pre><code>  前面我们已经说明:

  栈中存放的是基本类型的变量or引用类型的变量

   堆中存放的是对象or数组对象.

   在栈中，引用变量的大小为32位，基本类型为1-8个字节。
   但是对象的大小和数组的大小是动态的，这也决定了堆中数据的动态性，因为它是在运行时动态分配内存的，生存期也不必在编译时确定，Java 的垃圾收集器会自动收走这些不再使用的数据。
</code></pre><p>2.<strong>从数据共享的角度</strong>:</p>
<pre><code>1).在单个线程类，栈中的数据可共享

例如我们定义：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>int a=3;  </li>
<li><p>int b=3;<br>int a=3; int b=3;</p>
<p> 编译器先处理int a = 3；首先它会在栈中创建一个变量为a 的引用，然后查找栈中是否有3 这个值，如果没找到，就将3 存放进来，然后将a 指向3。接着处理int b = 3；在创建完b 的引用变量后，因为在栈中已经有3这个值，便将b 直接指向3。这样，就出现了a 与b 同时均指向3的情况。</p>
<p> 而如果我们定义： 
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>Integer a=new Integer(3);//(1)  </p>
</li>
<li><p>Integer b=new Integer(3);//(2)<br>Integer a=new Integer(3);//(1) Integer b=new Integer(3);//(2)</p>
<p>这个时候执行过程为：在执行(1)时，首先在栈中创建一个变量a，然后在堆内存中实例化一个对象，并且将变量a指向这个实例化的对象。在执行(2)时，过程类似，此时，在堆内存中，会有两个Integer类型的对象。 </p>
</li>
</ol>
<pre><code>2).**在进程的各个线程之间，数据的共享通过堆来实现**

    例：那么，在多线程开发中，我们的数据共享又是怎么实现的呢？
</code></pre><p><img src="" alt=""></p>
<p>  如图所示，堆中的数据是所有线程栈所共享的，我们可以通过参数传递，将一个堆中的数据传入各个栈的工作内存中，从而实现多个线程间的数据共享</p>
<p>（多个进程间的数据共享则需要通过网络传输了。） </p>
<p>3.从程序设计的的角度:</p>
<p>从软件设计的角度看，JVM栈代表了处理逻辑，而JVM堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。</p>
<p>4.值传递和引用传递的真相</p>
<p>有了以上关于栈和堆的种种了解后，我们很容易就可以知道值传递和引用传递的真相：</p>
<p>1.程序运行永远都是在JVM栈中进行的，因而参数传递时，只存在传递基本类型和对象引用的问题。不会直接传对象本身。</p>
<p>但是传引用的错觉是如何造成的呢?</p>
<p>在运行JVM栈中，基本类型和引用的处理是一样的，都是传值，所以，如果是传引用的方法调用，也同时可以理解为“传引用值”的传值调用，即引用的处理跟基本类型是完全一样的。</p>
<p>但是当进入被调用方法时，被传递的这个引用的值，被程序解释(或者查找)到JVM堆中的对象，这个时候才对应到真正的对象。</p>
<p>如果此时进行修改，修改的是引用对应的对象，而不是引用本身，即：修改的是JVM堆中的数据。所以这个修改是可以保持的了。</p>
<p>最后：</p>
<p>从某种意义上来说对象都是由基本类型组成的。 </p>
<p>可以把一个对象看作为一棵树，对象的属性如果还是对象，则还是一颗树(即非叶子节点)，基本类型则为树的叶子节点。程序参数传递时，被传递的值本身都是不能进行修改的，但是，如果这个值是一个非叶子节点(即一个对象引用)，则可以修改这个节点下面的所有内容。 </p>
<p><strong>其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别</strong>。</p>
<p>面向对象的引入，只是改变了我们对待问题的思考方式，而更接近于自然方式的思考。</p>
<p>当我们把对象拆开，其实对象的属性就是数据，存放在JVM堆中;而对象的行为(方法)，就是运行逻辑，放在JVM栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。 </p>
<p>P.S</p>
<p>关于数组的内存分配，对象初始化的内存分配等问题，由于篇幅问题，下次再搞个专题写吧。</p>
<p> 连续几天几夜对着此文了。想吐的很，先到这里吧。</p>
<ul>
<li><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></li>
<li><p>大小: 13.2 KB</p>
</li>
<li><p><a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">查看图片附件</a>
<a href="http://java-mzd.iteye.com/blog/848635#"><strong>55</strong>
顶</a><a href="http://java-mzd.iteye.com/blog/848635#"><strong>8</strong>
踩</a></p>
</li>
</ul>
<p><a href="http://java-mzd.iteye.com/blog/862787" title="开源软件？自由软件？免费软件？你了解多少？" target="_blank">开源软件？自由软件？免费软件？你了解多少 ...</a> | <a href="http://java-mzd.iteye.com/blog/838683" title="JAVA程序执行顺序，你了解了吗？" target="_blank">JAVA程序执行顺序，你了解了吗？</a></p>
<ul>
<li>20:46</li>
<li>浏览 (10080)</li>
<li><a href="http://java-mzd.iteye.com/blog/848635#comments" target="_blank">评论</a> (20)</li>
<li><a href="http://www.iteye.com/wiki/topic/848635" target="_blank">相关推荐</a></li>
</ul>
<h3 id="-">评论</h3>
<p><a href=""></a></p>
<p>20 楼 <a href="http://zkgale.iteye.com/" target="_blank">zkgale</a> 2011-01-14   <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">引用</a></p>
<p>满好的,谢谢你
不过,可能还是象前面几位说的那样吧,在分配的细节上写得还不是很深入,
不管怎么说,让我在引用关系方面的理解更深入了一些.
继续加油,很给力
19 楼 <a href="http://z-jiankun.iteye.com/" target="_blank">z_jiankun</a> 2011-01-06   <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">引用</a></p>
<p>zzc_zj 写道</p>
<p>分析得很细致，一遍没完全看明白，收藏下来，继续看
同感</p>
<p>18 楼 <a href="http://anmo.iteye.com/" target="_blank">anmo</a> 2011-01-05   <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">引用</a></p>
<p>总结的有深度，学习一下！
17 楼 <a href="http://wanglong1615.iteye.com/" target="_blank">wanglong1615</a> 2011-01-04   <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">引用</a></p>
<p>JAVA堆与栈都是用来存放数据的，那么他们之间到底有什么差异呢？既然栈也能存放数据，为什么还要设计堆呢？
我觉得还有一个原因，也就是为什么有基本类型和基本类型的包装类一样。
在JAVA中，基本类型是经常被使用和运算的，设计基本类型，最主要是节约性能的考虑。</p>
<p>16 楼 <a href="http://javahero1984.iteye.com/" target="_blank">javahero1984</a> 2011-01-03   <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">引用</a></p>
<p>不错，至少楼主是用心总结了，值得学习和讨论。
15 楼 <a href="http://culbertzp.iteye.com/" target="_blank">culbertzp</a> 2010-12-30   <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">引用</a></p>
<p>bu_choreography 写道</p>
<p>2.从数据共享的角度:.
这块对整型的引用讲的很好。
补充一点：整型在常量池里只能表示-128到127.超过这个范围的就不归常量池管了
例如
Integer a = 128;
Integer b = 128;
a==b  返回的是false.
如果：
Integer a = 128;
int b = 128;
a == b 返回的是true
int a = 128;
int b = 128;
a == b 返回的也是true</p>
<p>14 楼 <a href="http://irving-wei.iteye.com/" target="_blank">Irving_wei</a> 2010-12-28   <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">引用</a></p>
<p>  挺不错
13 楼 <a href="http://cosmoswon.iteye.com/" target="_blank">CosmosWon</a> 2010-12-27   <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">引用</a></p>
<p>明白了，但是我觉得楼主在这段上还有待斟酌：
（当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后（方法执行完成后），Java 会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作它用。--------同时，因为变量被释放，该变量对应的对象，也就失去了引用，也就变成了可以被gc对象回收的垃圾。）
当然了，本文也不是在讨论垃圾回收的，呵呵，不过既然说了，应该在说的精确点。</p>
<p>12 楼 <a href="http://hjk685.iteye.com/" target="_blank">hjk685</a> 2010-12-24   <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">引用</a></p>
<p>很有条理
11 楼 <a href="http://java-mzd.iteye.com/" target="_blank">java_mzd</a> 2010-12-23   <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">引用</a></p>
<p>eXeSP 写道</p>
<p>查了下以前的帖子：
引用</p>
<p>java虚拟机规范中说：Primitive values do not share state with other primitive values. A variable whose type is a primitive type always holds a primitive value of that type.
看一下实际的处理情况:
  int a=3;
  int b=3;
打开class文件，这2句就4个字节，内容是“06 3B 06 3C”
看对应的虚拟机指令，可以知道变量里实际存储的是什么:
Code:
  0: iconst_3 //3
  1: istore_1
  2: iconst_3 //3
  3: istore_2
第1个字节06 iconst_3是一个指令，让CPU把寄存器放上3的值
第2个字节3B istore_0也是一个指令，就是让CPU把寄存器的值放到第1个变量的内存中
第3个字节06 iconst_3是一个指令，让CPU把寄存器放上3的值
第4个字节3C istore_1也是一个指令，就是让CPU把寄存器的值放到第2个变量的内存中
（jvm没有“寄存器”的概念，用“Operand Stack 操作数栈”。）
int a = 3，int b =3是直接从指令获取数值，而没有进行栈中交换或进入常量池。
引用</p>
<p>这里可以看到JAVA虚拟机的一个小技巧，它把一些对常用常量（比如0,1,2,3,4,5）的操作直接定义成了指令，而不是传统的操作指令后带操作数。
目的是减少指令长度。有心的人再用 int a = 6...试，根本就没有iconst_6的指令！
而是bipush 6，机器码10 06, 2个字节，10就是bipush， 06就是操作数6，就是传统的指令＋操作数。
那么大于6的数呢
引用</p>
<p>int e=32330;
对应指令：
11: sipush 32330
14: istore 5
这句,11-13,正好是3个字节的指令大小,一个字节是sipush指令,2个字节用来存储32330这个数.两次使用到这个数,都是把它直接存给变量的。
那么如果大于2个字节的数又如何？
引用</p>
<p>int f = 65535;
对应指令:
4: ldc /#2; //int 65535
6: istore_3
对于65535,它是大于两个字节的,编译的时候把它放入常量池部分,而把取这个数的指令写为ldc/#2,我感觉这样一个直观的好处是减少了指令代码的长度.尤其是多次使用到一个相同的数时
.
大于2个字节的int数值，开始进入常量池。
那么int和Integer一样吗？
引用</p>
<p>Integer i = 3；
sun的编译器是这样处理的:
Integer i=Integer.valueOf(3);
而不是通过new来创建了,因为Integer类中静态的创建了-128~+127之间的对象,需要的数在这个范围之内时,直接返回,此范围之外的数才通过new来创建.
多谢多谢。  我还真没注意在cpu中到底怎么处理这部分。
受教了。</p>
<p>10 楼 <a href="http://laozhu1662006-126-com.iteye.com/" target="_blank">生活小丑</a> 2010-12-22   <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">引用</a></p>
<p>java内存分配方面的知识一直都是朦朦胧胧的，说知道说不清楚，说不知道，还有点知道，网上搜了好多文章，楼主的文章算是比较详细的了.
9 楼 <a href="http://exesp.iteye.com/" target="_blank">eXeSP</a> 2010-12-22   <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">引用</a></p>
<p>查了下以前的帖子：
引用</p>
<p>java虚拟机规范中说：Primitive values do not share state with other primitive values. A variable whose type is a primitive type always holds a primitive value of that type.
看一下实际的处理情况:
  int a=3;
  int b=3;
打开class文件，这2句就4个字节，内容是“06 3B 06 3C”
看对应的虚拟机指令，可以知道变量里实际存储的是什么:
Code:
  0: iconst_3 //3
  1: istore_1
  2: iconst_3 //3
  3: istore_2
第1个字节06 iconst_3是一个指令，让CPU把寄存器放上3的值
第2个字节3B istore_0也是一个指令，就是让CPU把寄存器的值放到第1个变量的内存中
第3个字节06 iconst_3是一个指令，让CPU把寄存器放上3的值
第4个字节3C istore_1也是一个指令，就是让CPU把寄存器的值放到第2个变量的内存中
（jvm没有“寄存器”的概念，用“Operand Stack 操作数栈”。）
int a = 3，int b =3是直接从指令获取数值，而没有进行栈中交换或进入常量池。
引用</p>
<p>这里可以看到JAVA虚拟机的一个小技巧，它把一些对常用常量（比如0,1,2,3,4,5）的操作直接定义成了指令，而不是传统的操作指令后带操作数。
目的是减少指令长度。有心的人再用 int a = 6...试，根本就没有iconst_6的指令！
而是bipush 6，机器码10 06, 2个字节，10就是bipush， 06就是操作数6，就是传统的指令＋操作数。
那么大于6的数呢
引用</p>
<p>int e=32330;
对应指令：
11: sipush 32330
14: istore 5
这句,11-13,正好是3个字节的指令大小,一个字节是sipush指令,2个字节用来存储32330这个数.两次使用到这个数,都是把它直接存给变量的。
那么如果大于2个字节的数又如何？
引用</p>
<p>int f = 65535;
对应指令:
4: ldc /#2; //int 65535
6: istore_3
对于65535,它是大于两个字节的,编译的时候把它放入常量池部分,而把取这个数的指令写为ldc/#2,我感觉这样一个直观的好处是减少了指令代码的长度.尤其是多次使用到一个相同的数时
.
大于2个字节的int数值，开始进入常量池。
那么int和Integer一样吗？
引用</p>
<p>Integer i = 3；
sun的编译器是这样处理的:
Integer i=Integer.valueOf(3);
而不是通过new来创建了,因为Integer类中静态的创建了-128~+127之间的对象,需要的数在这个范围之内时,直接返回,此范围之外的数才通过new来创建.</p>
<p>8 楼 <a href="http://exesp.iteye.com/" target="_blank">eXeSP</a> 2010-12-22   <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">引用</a></p>
<p>在方法区，Integer类中静态的创建了-128~+127之间的对象。int a = 3的数值是从常量池返回到栈当中的吧，想问问int b = 3，b是先从栈还是先从常量池查找数值，印象中String的话是从常量池查找的。
7 楼 <a href="http://iuf6853.iteye.com/" target="_blank">iuf6853</a> 2010-12-22   <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">引用</a></p>
<p>辛苦了，让出入java圣殿的门外汉们受益匪浅。</p>
<p>6 楼 <a href="http://zcj.iteye.com/" target="_blank">zzc_zj</a> 2010-12-22   <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">引用</a></p>
<p>分析得很细致，一遍没完全看明白，收藏下来，继续看
5 楼 <a href="http://java-mzd.iteye.com/" target="_blank">java_mzd</a> 2010-12-22   <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">引用</a></p>
<p>juda 写道</p>
<p>写的不错，鼓励一下
多谢鼓励。
继续加油。</p>
<p>4 楼 <a href="http://java-mzd.iteye.com/" target="_blank">java_mzd</a> 2010-12-22   <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">引用</a></p>
<p>bu_choreography 写道</p>
<p>2.从数据共享的角度:.
这块对整型的引用讲的很好。
补充一点：整型在常量池里只能表示-128到127.超过这个范围的就不归常量池管了
例如
Integer a = 128;
Integer b = 128;
a==b  返回的是false.
多谢指导，意思就是现在常量池整形只能存一个字节？
  那么关于double等类型的是不是也有相应变化呢？
最近借不到《深入JVM》
还是再查查资料吧。
多些指导
3 楼 <a href="http://juda.iteye.com/" target="_blank">juda</a> 2010-12-22   <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">引用</a></p>
<p>写的不错，鼓励一下</p>
<p>2 楼 <a href="http://bu-choreography.iteye.com/" target="_blank">bu_choreography</a> 2010-12-21   <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">引用</a></p>
<p>2.从数据共享的角度:.
这块对整型的引用讲的很好。
补充一点：整型在常量池里只能表示-128到127.超过这个范围的就不归常量池管了
例如
Integer a = 128;
Integer b = 128;
a==b  返回的是false.
1 楼 <a href="http://javafound.iteye.com/" target="_blank">javafound</a> 2010-12-21   <a href="http://java-mzd.iteye.com/blog/848635#" target="_blank">引用</a></p>
<p>还算给力,鼓励一下，</p>
<h3 id="-">发表评论</h3>
<h3 id="-">表情图标</h3>
<p><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""></p>
<p>字体颜色: 标准深红红色橙色棕色黄色绿色橄榄青色蓝色深蓝靛蓝紫色灰色白色黑色 字体大小: 标准1 (xx-small)2 (x-small)3 (small)4 (medium)5 (large)6 (x-large)7 (xx-large) 对齐: 标准居左居中居右</p>
<p>提示：选择您需要装饰的文字, 按上列按钮即可添加上相应的标签</p>
<p>您还没有登录，请<a href="http://java-mzd.iteye.com/login" target="_blank">登录</a>后发表评论(快捷键 Alt+S / Ctrl+Enter)</p>
<p><a href="http://java-mzd.iteye.com/" target="_blank"><img src="&quot;java_mzd的博客: &quot;" alt="java_mzd的博客"></a></p>
<p>java_mzd</p>
<ul>
<li>浏览: 70749 次</li>
<li>性别: <img src="&quot;男&quot;" alt="Icon_minigender_1"></li>
<li>来自: 长沙</li>
<li><img src="" alt=""></li>
<li><a href="http://java-mzd.iteye.com/blog/profile" target="_blank">详细资料</a> <a href="http://java-mzd.iteye.com/blog/guest_book" target="_blank">留言簿</a></li>
</ul>
<h3 id="-">搜索本博客</h3>
<h3 id="-http-java-mzd-iteye-com-blog-user_visits-">最近访客 <a href="http://java-mzd.iteye.com/blog/user_visits" target="_blank">&gt;&gt;更多访客</a></h3>
<p><a href="http://zhxing.iteye.com/" target="_blank"><img src="&quot;zhxing的博客: ヾ孤星随缘ツ  http://t.sina.com.cn/samzhxing&quot;" alt="zhxing的博客"></a></p>
<p><a href="http://zhxing.iteye.com/" target="_blank">zhxing</a></p>
<p><a href="http://java-suddy.iteye.com/" target="_blank"><img src="&quot;java_suddy的博客: “平凡”的思想&quot;" alt="java_suddy的博客"></a></p>
<p><a href="http://java-suddy.iteye.com/" target="_blank">java_suddy</a>
<a href="http://liuxinglanyue.iteye.com/" target="_blank"><img src="&quot;liuxinglanyue的博客: liuxinglanyue&quot;" alt="liuxinglanyue的博客"></a></p>
<p><a href="http://liuxinglanyue.iteye.com/" target="_blank">liuxinglanyue</a></p>
<p><a href="http://libo-591.iteye.com/" target="_blank"><img src="&quot;libo_591的博客: 让更多的人站在巨人的肩膀上&quot;" alt="libo_591的博客"></a></p>
<p><a href="http://libo-591.iteye.com/" target="_blank">libo_591</a></p>
<h3 id="-">博客分类</h3>
<ul>
<li><a href="http://java-mzd.iteye.com/" target="_blank">全部博客 (43)</a></li>
<li><a href="http://java-mzd.iteye.com/category/133623" target="_blank">数据结构----------JAVA类集 (5)</a></li>
<li><p><a href="http://java-mzd.iteye.com/category/153171" target="_blank">TCP/IP (7)</a></p>
<h3 id="-http-java-mzd-iteye-com-blog-guest_book-">我的留言簿 <a href="http://java-mzd.iteye.com/blog/guest_book" target="_blank">&gt;&gt;更多留言</a></h3>
</li>
<li><p>楼主 你工作多久了。。。。
-- by <a href="http://java-mzd.iteye.com/blog/guest_book#39913" target="_blank">fanmingxing</a></p>
</li>
<li>写的不错，学习，谢谢！
-- by <a href="http://java-mzd.iteye.com/blog/guest_book#39693" target="_blank">chenge2k</a></li>
<li>看了LZ的文章，发现工作快两年的我，就像是一块浮起来的木头，真的很惭愧！也不怪我拿 ...
-- by <a href="http://java-mzd.iteye.com/blog/guest_book#39618" target="_blank">GoTiger</a></li>
</ul>
<h3 id="-">其他分类</h3>
<ul>
<li><a href="http://java-mzd.iteye.com/blog/favorite" target="_blank">我的收藏</a> (23)</li>
<li><a href="http://java-mzd.iteye.com/blog/code_favorite" target="_blank">我的代码</a> (0)</li>
<li><a href="http://java-mzd.iteye.com/blog/topic" target="_blank">我的论坛主题帖</a> (3)</li>
<li><a href="http://java-mzd.iteye.com/blog/post" target="_blank">我的所有论坛帖</a> (37)</li>
<li><p><a href="http://java-mzd.iteye.com/blog/article" target="_blank">我的精华良好帖</a> (0)</p>
<h3 id="-">最近加入群组</h3>
</li>
<li><p><a href="http://android.group.iteye.com/" target="_blank">Android</a></p>
</li>
</ul>
<h3 id="-">存档</h3>
<ul>
<li><a href="http://java-mzd.iteye.com/blog/monthblog/2011-05" target="_blank">2011-05</a> (2)</li>
<li><a href="http://java-mzd.iteye.com/blog/monthblog/2011-04" target="_blank">2011-04</a> (7)</li>
<li><a href="http://java-mzd.iteye.com/blog/monthblog/2011-03" target="_blank">2011-03</a> (2)</li>
<li><p><a href="http://java-mzd.iteye.com/blog/monthblog_more" target="_blank">更多存档...</a></p>
<h3 id="-">评论排行榜</h3>
</li>
<li><p><a href="http://java-mzd.iteye.com/blog/1050043" title="腾讯、淘宝、金山网络，实习生我该何去何从" target="_blank">腾讯、淘宝、金山网络，实习生我该何去何从</a></p>
</li>
<li><a href="http://java-mzd.iteye.com/blog/1050926" title="淘宝、金山网络，百感交集" target="_blank">淘宝、金山网络，百感交集</a></li>
<li><a href="http://java-mzd.iteye.com/blog/1007577" title="TCP/IP传输层，你懂多少？" target="_blank">TCP/IP传输层，你懂多少？</a></li>
<li><a href="http://java-mzd.iteye.com/blog/1004784" title="淘宝武汉*面试归来" target="_blank">淘宝武汉/*面试归来</a></li>
<li><p><a href="http://java-mzd.iteye.com/blog/862787" title="开源软件？自由软件？免费软件？你了解多少？" target="_blank">开源软件？自由软件？免费软件？你了解多少 ...</a></p>
</li>
<li><p><a href="http://java-mzd.iteye.com/rss" target="_blank"><img src="" alt="Rss"></a></p>
</li>
<li><a href="http://fusion.google.com/add?feedurl=http://java-mzd.iteye.com/rss" target="_blank"><img src="" alt="Rss_google"></a>
声明：ITeye文章版权属于作者，受法律保护。没有作者书面许可不得转载。若作者同意转载，必须以超链接形式标明文章原始出处和作者。
© 2003-2011 ITeye.com. All rights reserved. [ 京ICP证110151号 ]
<img src="" alt=""></li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_总结类/">Java_总结类</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_总结类/" class="label label-success">Java_总结类</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--Java内存分配、管理小结--ITeye技术网站/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_总结类--Java内存分配、管理小结--ITeye技术网站" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类-easy-mock--easymock教程/">easymock教程</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类-easy-mock--easymock教程/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="easymock-">easymock教程</h1>
<p><img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <a href="http://www.javaeye.com" target="_blank">http://www.javaeye.com</a> - 做最棒的软件开发交流社区
easymock教程
作者: skydream <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
easymock教程，详细的介绍easymock的使用
第 1 / 65 页
本书由JavaEye提供的电子书DIY功能自动生成于 2010-12-06
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
目录</p>
<ol>
<li>software test
1.1 easymock教程-目录 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 1.2 easymock教程-mock和stub . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 1.3 easymock教程-单元测试中的主要测试对象和依赖 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 1.4 easymock教程-record-replay-verify模型 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 1.5 easymock教程-easymock的典型使用 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 1.6 easymock教程-class mocking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 1.7 easymock教程-mock的限制 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 1.8 easymock教程-strict和nice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 1.9 easymock教程-创建stub对象 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 1.10 easymock教程-放宽调用次数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 1.11 easymock教程-参数匹配 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 1.12 easymock教程-partial class mocking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 1.13 easymock教程-运行时返回值或者异常 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 1.14 easymock教程-改变同一个方法调用的行为 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55 1.15 easymock教程-自定义参数匹配器 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 1.16 easymock教程-命名mock对象 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 1.17 easymock教程-使用MockControl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
第 2 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.1 easymock教程-目录
1.1 easymock教程-目录
发表时间: 2010-10-14 easymock是目前比较流行的java mock 工具，这个教程将比较详细的介绍easymock的使用。
主要内容来自easymock的官网介绍和教程，我针对日常使用情况进行了一些筛选和补充，另外增加一些个 人的理解和认识，希望能对不熟悉easymock的朋友们有所帮助。
如有疏漏，错误或者疑惑，欢迎大家指正和提醒，不胜感激。
一. 基本概念
这里讲述一些测试相关的基本概念，不仅仅适用于easymock，也同样适用于其他的mock框架如jmock， jmockit等。
1) mock 和 stub
2) 单元测试中的主要测试对象和依赖
3) record-replay-verify 模型
二. 基础教程
1) 典型使用
2) Class Mocking
第 3 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.1 easymock教程-目录
3) mock的限制
4) strict和nice
5) 创建stub对象
6) 放宽调用次数
7) 参数匹配
三. 高级教程
1) Partial class mocking
2) 运行时返回值或者异常
3) 改变同一个方法调用的行为
4) 自定义参数匹配器
四. 最佳实践 1) 命名mock对象
第 4 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.1 easymock教程-目录
2) 使用 MocksControl
第 5 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.2 easymock教程-mock和stub
1.2 easymock教程-mock和stub
发表时间: 2010-08-26 作为测试的基本概念，在开发测试中经常遇到mock和stub。之前认为自己对这两个概念已经很明白了，但是 当决定要写下来并写清楚以便能让不明白的人也能弄明白，似乎就很有困难。 试着写下此文，以检验自己是不是真的明白mock和stub。 一. 相同点 先看看两者的相同点吧，非常明确的是，mock和stub都可以用来对系统(或者将粒度放小为模块，单元)进行 隔离。 在测试，尤其是单元测试中，我们通常关注的是主要测试对象的功能和行为，对于主要测试对象涉及到的次 要对象尤其是一些依赖，我们仅仅关注主要测试对象和次要测试对象的交互，比如是否调用，何时调用，调用 的参数，调用的次数和顺序等，以及返回的结果或发生的异常。但次要对象是如何执行这次调用的具体细节， 我们并不关注，因此常见的技巧就是用mock对象或者stub对象来替代真实的次要对象，模拟真实场景来进行对 主要测试对象的测试工作。 因此从实现上看，mock和stub都是通过创建自己的对象来替代次要测试对象，然后按照测试的需要控制这个 对象的行为。 二. 不同点 1. 类实现的方式 从类的实现方式上看，stub有一个显式的类实现，按照stub类的复用层次可以实现为普通类(被多个测试案 例复用)，内部类(被同一个测试案例的多个测试方法复用)乃至内部匿名类(只用于当前测试方法)。对于stub的方 法也会有具体的实现，哪怕简单到只有一个简单的return语句。 而mock则不同，mock的实现类通常是有mock的工具包如easymock, jmock来隐式实现，具体mock的 方法的行为则通过record方式来指定。 以mock一个UserService, UserDao为例，最简单的例子，只有一个查询方法：
第 6 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.2 easymock教程-mock和stub
public interface UserService { User query(String userId); }
public class UserServiceImpl implements UserService { private UserDao userDao; public User query(String userId) { return userDao.getById(userId); } //setter for userDao }
public interface UserDao { User getById(String userId); }
stub的标准实现，需要自己实现一个类并实现方法:
public class UserDaoStub implements UserDao { public User getById(String id) { User user = new User(); user.set..... return user; } }
@Test public void testGetById() { UserServiceImpl service = new UserServiceImpl(); UserDao userDao = new UserDaoStub();
service.setUserDao(userDao);
User user = service.query(&quot;1001&quot;);
第 7 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.2 easymock教程-mock和stub
... }
mock的实现，以easymock为例，只要指定mock的类并record期望的行为，并没有显式的构造新类:
@Test public void testGetById() { UserDao dao = Easymock.createMock(UserDao.class); User user = new User(); user.set..... Easymock.expect(dao.getById(&quot;1001&quot;)).andReturn(user); Easymock.reply(dao);
UserServiceImpl service = new UserServiceImpl(); service.setUserDao(userDao); User user = service.query(&quot;1001&quot;); ... Easymock.verify(dao)； }
对比可以看出，mock编写相对简单，只需要关注被使用的函数，所谓&quot;just enough&quot;。stub要复杂一些， 需要实现逻辑，即使是不需要关注的方法也至少要给出空实现。 2. 测试逻辑的可读性 从上面的代码可以看出，在形式上，mock通常是在测试代码中直接mock类和定义mock方法的行为，测 试代码和mock的代码通常是放在一起的，因此测试代码的逻辑也容易从测试案例的代码上看出来。 Easymock.expect(dao.getById(&quot;1001&quot;)).andReturn(user); 直截了当的指明了当前测试案例对UserDao这个 依赖的预期: getById需要被调用，调用的参数应该是&quot;1001&quot;，调用次数为1(不明确指定调用次数时easymock 默认为1)。 而stub的测试案例的代码中只有简单的UserDao userDao = new UserDaoStub ();构造语句和
第 8 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.2 easymock教程-mock和stub
service.setUserDao(userDao);设置语句，我们无法直接从测试案例的代码中看出对依赖的预期，只能进入具体 的UserServiceImpl类的query()方法，看到具体的实现是调用userDao.getById(userId)，这个时候才能明白完 整的测试逻辑。因此当测试逻辑复杂，stub数量多并且某些stub需要传入一些标记比如true，false之类的来制 定不同的行为时，测试逻辑的可读性就会下降。 3. 可复用性 Mock通常很少考虑复用，每个mock对象通过都是遵循&quot;just enough&quot;原则，一般只适用于当前测试方 法。因此每个测试方法都必须实现自己的mock逻辑，当然在同一个测试类中还是可以有一些简单的初始化逻辑 可以复用。 stub则通常比较方便复用，尤其是一些通用的stub，比如jdbc连接之类。spring框架就为此提供了大量的 stub来方便测试，不过很遗憾的是，它的名字用错了：spring-mock！ 4. 设计和使用 接着我们从mock和stub的设计和使用上来比较两者，这里需要引入两个概念：interaction-based和 state-based。 具体关于interaction-based和state-based，不再本文阐述，强烈推荐Martin Fowler 的一篇文 章，&quot;Mocks Aren&#39;t Stubs&quot;。地址为<a href="http://martinfowler.com/articles/mocksArentStubs.html(PS：当在" target="_blank">http://martinfowler.com/articles/mocksArentStubs.html(PS：当在</a> google中输入mock stub两个关键字做搜索时，出来结果的第一条就是此文，向Martin Fowler致敬，向 google致敬)，英文不好的同学，可以参考这里的一份中文翻译：<a href="http://www.cnblogs.com/anf/archive/" target="_blank">http://www.cnblogs.com/anf/archive/</a> 2006/03/27/360248.html。 总结来说，stub是state-based，关注的是输入和输出。mock是interaction-based，关注的是交互过 程。 5. expectiation/期望 这个才是mock和stub的最重要的区别：expectiation/期望。 对于mock来说，exception是重中之重：我们期待方法有没有被调用，期待适当的参数，期待调用的次 数，甚至期待多个mock之间的调用顺序。所有的一切期待都是事先准备好，在测试过程中和测试结束后验证是 否和预期的一致。 而对于stub，通常都不会关注exception，就像上面给出的UserDaoStub的例子，没有任何代码来帮助判 断这个stub类是否被调用。虽然理论上某些stub实现也可以通过自己编码的方式增加对expectiation的内容，
第 9 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a> 比如增加一个计数器，每次调用+1之类，但是实际上极少这样做。 6. 总结
1.2 easymock教程-mock和stub
关于mock和stub的不同，在Martin Fowler的&quot;Mocks Aren&#39;t Stubs&quot;一文中，有以下结束，我将它列出来 作为总结： (1) Dummy 对象被四处传递，但是从不被真正使用。通常他们只是用来填充参数列表。 (2) Fake 有实际可工作的实现，但是通常有一些缺点导致不适合用于产品(基于内存的数据库就是一个好 例子)。 (3) Stubs 在测试过程中产生的调用提供预备好的应答，通常不应答计划之外的任何事。stubs可能记录关 于调用的信息，比如 邮件网关的stub 会记录它发送的消息，或者可能仅仅是发送了多少信息。 (4) Mocks 如我们在这里说的那样：预先计划好的对象，带有各种期待，他们组成了一个关于他们期待接 受的调用的详细说明。 三. 退化和转化 在实际的开发测试过程中，我们会发现其实mock和stub的界限有时候很模糊，并没有严格的划分方式， 从而造成我们理解上的含糊和困惑。 主要的原因在于现实使用中，我们经常将mock做不同程度的退化，从而使得mock对象在某些程度上如 stub一样工作。以easymock为例，我们可以通过anyObject(), isA(Class)等方式放宽对参数的检测，以 atLeastOnce(),anytimes()来放松对调用次数的检测，我们可以使用Easymock.createControl()而不是 Easymock.createStrictControl()来放宽对调用顺序的检测(或者调用checkOrder(false))，我们甚至可以通过 createNiceControl(), createNiceMock()来创建完全不限制调用方式而且自动返回简单值的mock，这和stub 就几乎没有本质区别了。 目前大多数的mock工具都提供mock退化为stub的支持，比如easyock中，除了上面列出的 any/<em>/</em>/*,NiceMock之外，还提供诸如 andStubAnswer(),andStubDelegateTo(),andStubReturn(),andStubThrow()和asStub()。
第 10 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.2 easymock教程-mock和stub
前面也谈到过stub也是可以通过增加代码来实现一些expectiation的特性，stub理论上也是可以向mock 的方向做转化，而从使得两者的界限更加的模糊。
第 11 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.3 easymock教程-单元测试中的主要测试对象和依赖
1.3 easymock教程-单元测试中的主要测试对象和依赖
发表时间: 2010-10-14 在单元测试中，通常我们都会有一个明确的测试对象，我们测试的主要目的就是为了验证这个类的工作如我 们预期。
以下面的简单代码为例：
public interface UserService { User query(String userId); }
public class UserServiceImpl implements UserService { private UserDao userDao; public User query(String userId) { return userDao.getById(userId); }
public void setUserDao(UserDao userDao) { this.userDao = userDao; } }
public interface UserDao { User getById(String userId); }
public class UserDaoImpl implements UserDao {
private Datasource dataSource;
public User getById(String id) { User user = new User(); //execute database query
第 12 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
user.set.. return user; }
1.3 easymock教程-单元测试中的主要测试对象和依赖
public void setDatasource(Datasource datasource) { this.datasource = datasource; }
}
这里我们定义有两个interface: UserService 和 UserDao， 并给出了两个实现类UserServiceImpl 和 UserDaoImpl。 其中UserServiceImpl依赖到UserDao，通过setter方法可以注入一个UserDao实现。而 UserDaoImpl的实现则依赖到Datasource。
然后我们来为实现类UserServiceImpl 和 UserDaoImpl编写单元测试:</li>
<li>UserServiceImplTest
public class UserServiceImplTest {
@Test public void testQuery() { User expectedUser = new User(); expectedUser.setId(&quot;1001&quot;); expectedUser.setAge(30); expectedUser.setName(&quot;user-1001&quot;); UserDao userDao = EasyMock.createMock(UserDao.class); EasyMock.expect(userDao.getById(&quot;1001&quot;)).andReturn(expectedUser); EasyMock.replay(userDao);
UserServiceImpl service = new UserServiceImpl(); service.setUserDao(userDao); User user = service.query(&quot;1001&quot;);
第 13 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
assertNotNull(user); assertEquals(&quot;1001&quot;, user.getId()); assertEquals(30, user.getAge()); assertEquals(&quot;user-1001&quot;, user.getName());
1.3 easymock教程-单元测试中的主要测试对象和依赖
EasyMock.verify(userDao); } }
在这个测试类中，主要测试对象就是UserServiceImpl，对于UserServiceImpl的依赖UserDao，我们采取 mock这个UserDao来满足UserServiceImpl的测试需要。</li>
<li>UserDaoImplTest 代码示例就不详细写了，和上面的类似，主要测试对象就是UserDaoImpl, 我们将通过mock Datasource来 满足UserDaoImpl对datasource的测试需要。 可以从上面的例子中简单的看出，通常单元测试都遵循这样的惯例: AClass的单元测试类命名为 AclassTest，主要职责是测试AClass的行为，理所当然的主要测试对象就是AClass。而所有被AClass的依赖则 自然而然的成为次要测试对象，通常我们都不关注这些依赖的内部实现，也不会要求在AClass的单元测试案例 中对这些依赖的实现进行测试和验证。 这也符合单元测试的理念: 我们将类AClass定义为单元，测试这个单元的行为是否如预期。同时也符合 UserServiceImpl的实现逻辑：UserServiceImpl依赖到UserDao接口，并不直接依赖到UserDaoImpl，因此在 UserServiceImpl的单元测试中，也不应该引入UserDaoImpl这样的真实类，mock框架在这个时候是最适合出 场表演的了：我们可以通过mock UserDao来模拟出UserDao的各种行为以便检测UserServiceImpl在这些行为 下的处理是否正确: 不同的返回值，错误场景，异常场景。这也是mock框架在单元测试中被广泛使用的原因： 还有什么比mock 类更能方便的做到这些？
第 14 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.4 easymock教程-record-replay-verify模型
1.4 easymock教程-record-replay-verify模型
发表时间: 2010-10-15 record-replay-verify 模型容许记录mock对象上的操作然后重演并验证这些操作。这是目前mock框架领域 最常见的模型，几乎所有的mock框架都是用这个模型，有些是现实使用如easymock，有些是隐式使用如 jmockit。
以easymock为例，典型的easymock使用案例一般如下, 援引上一章中的例子：
public class UserServiceImplTest {
//<em>/</em> /<em> this is a classic test case to use EasyMock. /</em>/ @Test public void testQuery() { User expectedUser = new User(); expectedUser.setId(&quot;1001&quot;); expectedUser.setAge(30); expectedUser.setName(&quot;user-1001&quot;); UserDao userDao = EasyMock.createMock(UserDao.class); EasyMock.expect(userDao.getById(&quot;1001&quot;)).andReturn(expectedUser); EasyMock.replay(userDao);
UserServiceImpl service = new UserServiceImpl(); service.setUserDao(userDao); User user = service.query(&quot;1001&quot;); assertNotNull(user); assertEquals(&quot;1001&quot;, user.getId()); assertEquals(30, user.getAge()); assertEquals(&quot;user-1001&quot;, user.getName());
EasyMock.verify(userDao);
第 15 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
} }
1.4 easymock教程-record-replay-verify模型
在这里有两句非常明显的调用语句: Easymock.replay(...)和Easymock.verify(...)。这两个语句将上述代码分 成三个部分，分别对应record-replay-verify 3个阶段</li>
<li>record
User expectedUser = new User(); expectedUser.setId(&quot;1001&quot;); expectedUser.setAge(30); expectedUser.setName(&quot;user-1001&quot;); UserDao userDao = EasyMock.createMock(UserDao.class); EasyMock.expect(userDao.getById(&quot;1001&quot;)).andReturn(expectedUser);
这里我们开始创建mock对象，并期望这个mock对象的方法被调用，同时给出我们希望这个方法返回的结 果。
这就是所谓的&quot;记录mock对象上的操作&quot;, 同时我们也会看到&quot;expect&quot;这个关键字。
总结说，在record阶段，我们需要给出的是我们对mock对象的一系列期望：若干个mock对象被调用，依从 我们给定的参数，顺序，次数等，并返回预设好的结果(返回值或者异常).</li>
<li>replay
UserServiceImpl service = new UserServiceImpl(); service.setUserDao(userDao); User user = service.query(&quot;1001&quot;);
第 16 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.4 easymock教程-record-replay-verify模型
在replay阶段，我们关注的主要测试对象将被创建，之前在record阶段创建的相关依赖被关联到主要测试对 象，然后执行被测试的方法，以模拟真实运行环境下主要测试对象的行为。
在测试方法执行过程中，主要测试对象的内部代码被执行，同时和相关的依赖进行交互：以一定的参数调用 依赖的方法，获取并处理返回。我们期待这个过程如我们在record阶段设想的交互场景一致，即我们期望在 replay阶段所有在record阶段记录的行为都将被完整而准确的重新演绎一遍，从而到达验证主要测试对象行为 的目的。</li>
<li>verify
assertNotNull(user); assertEquals(&quot;1001&quot;, user.getId()); assertEquals(30, user.getAge()); assertEquals(&quot;user-1001&quot;, user.getName()); EasyMock.verify(userDao);
在verify阶段，我们将验证测试的结果和交互行为。
通常验证分为两部分，如上所示： 一部分是验证结果，即主要测试对象的测试方法返回的结果(对于异常测试 场景则是抛出的异常)是否如预期，通常这个验证过程需要我们自行编码实现。另一部分是验证交互行为，典型 如依赖是否被调用，调用的参数，顺序和次数，这部分的验证过程通常是由mock框架来自动完成，我们只需要 简单调用即可。
在easymock的实现中，verify的部分交互行为验证工作，会提前在replay阶段进行：比如未记录的调用，调 用的参数等。如果验证失败，则直接结束replay以致整个测试案例。
record-replay-verify 模型非常好的满足了大多数测试场景的需要：先指定测试的期望，然后执行测试，再 验证期望是否被满足。这个模型简单直接，易于实现，也容易被开发人员理解和接受，因此被各个mock框架广 泛使用。
第 17 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.5 easymock教程-easymock的典型使用
1.5 easymock教程-easymock的典型使用
发表时间: 2010-10-15
关于easymock的典型使用方式，在easymock的官网文档中，有非常详尽的讲解，文档地址为 <a href="http://easymock.org/EasyMock3_0_Documentation.html，文档的开头一部分内容都是easymock中最基本" target="_blank">http://easymock.org/EasyMock3_0_Documentation.html，文档的开头一部分内容都是easymock中最基本</a> 的使用介绍，虽然是英文，但是非常容易看懂，适用新学者入门。
这里只罗列一些简单的常用功能，依然以前面教程中使用到的测试案例为例：
public class UserServiceImplTest extends Assert {
@Test public void testQuery() {
User expectedUser = new User(); user.set.; UserDao userDao = Easymock.createMock(UserDao.class); Easymock.expect(userDao.getById(&quot;1001&quot;)).andReturn(expectedUser); Easymock.replay(userDao);
UserServiceImpl service = new UserServiceImpl(); service.setUserDao(userDao); user user = service.query(&quot;1001&quot;); assertNotNull(user); assertEquals(); //veify return user
Easymock.verify(userDao);
}
}
第 18 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.5 easymock教程-easymock的典型使用
这段简短的代码中包含以下easymock的功能：</li>
<li>创建mock对象 UserDao userDao = Easymock.createMock(UserDao.class);</li>
<li>记录mock对象期望的行为 Easymock.expect(userDao.getById(&quot;1001&quot;)).andReturn(expectedUser); 这里记录了mock对象的行为：getById()方法被调用，调用次数为1(easymock之中如果没有明确指出调 用次数，默认为1),参数为&quot;1001&quot;，expectedUser将作为返回值。</li>
<li>进入replay阶段 Easymock.replay(userDao);</li>
<li>对mock对象执行验证 Easymock.verify(userDao);
对上面上面的代码稍加改动以展示easymock的其他基本功能：</li>
<li>指定期望的调用次数 Easymock.expect(userDao.getById(&quot;1001&quot;)).andReturn(expectedUser).times(3);</li>
<li>指定抛出期望的异常 Easymock.expect(userDao.getById(&quot;1001&quot;)).andThrow(new RuntimeException(&quot;no user exist&quot;));</li>
<li>记录void 方法的行为
第 19 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.5 easymock教程-easymock的典型使用
Easymock.expect(userDao.getById(&quot;1001&quot;)) 这样的用法只能使用与mock对象的有返回值的方法，如 果mock对象的方法是void，则需要使用expectLastCall()： userDao.someVoidMethod(); Easymock.expectLastCall(); 和Easymock.expect(/<em>/</em>/*)一样，同样支持指定调用次数，抛出异常等： Easymock.expectLastCall().times(3); Easymock.expectLastCall().andThrow(new RuntimeException(&quot;some error&quot;));</li>
<li>灵活的参数匹配 Easymock.expect(userDao.getById(Easymock.isA(String.class))).andReturn(expectedUser); 类似的还有anyInt()，anyObject()， isNull() ， same(), startsWith()等诸多实现。具体细节请参考本教 程中的&quot;参数匹配&quot;一文。
第 20 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.6 easymock教程-class mocking
1.6 easymock教程-class mocking
发表时间: 2010-10-26 前面的例子中，mock的对象都是基于interface，虽然说我们总是强调要面对接口编程，而不要面对实现， 但是实际开发中不提取interface而直接使用class的场景非常之多。尤其是一些当前只有一个明确实现而看不到 未来扩展的类，是否应该提取interface或者说是否应该现在就提取interface，总是存在争论。
这种情况下，我们就会面临主要测试对象依赖到一个具体类而不是interface的情况，easymock中通过class extension 来提供对class mocking的支持。</li>
<li>class mocking的使用
easymock class extension的使用方式和普通的interface mock完全一致，基本上easymock中有的功能 easymock class extension都同样提供，而且所有的类名和方法名都保持一致。
ClassA impl = Easymock.createMock(ClassA.class); Easymock.expect(impl.getById(&quot;1001&quot;)).andReturn(...); Easymock.replay(impl); 唯一的差异在于，easymock class extension的java package和easymock不同，easymock是 org.easymock./<em>, 而 easymock class extension是org.easymock.classextension./</em>，典型如 org.easymock.classextension.Easymock 对应 org.easymock.Easymock。另外在发布时，两者是分开发布 的，easymock.jar 和 easymockclassextension.jar，需要根据需要分别导入，或者必要时同时导入。</li>
<li>3.0新版本和向后兼容
我们来回顾一下easymock的历史版本: easymock 1./<em> 非常久远了，已经没有人在用。2.0版本在 2005-12-24发布，基于jdk1.5，之后陆续发布的2.1/2.2/2.3/2.4/2.5等几个版本中，都提供了对应版本的 easymock class extension。easymock 3.0 版本是最新版本，2010-05-08 发布，主要改进就是将easymock
第 21 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.6 easymock教程-class mocking
class extension的功能合并到easymock中，以后只要使用easymock就可以提供class mocking的功能。当然 为了兼容2./</em>下的旧代码，依然提供了EasyMock 3.0 Class Extension代理到easymock 3.0。
3.0版本之后，easymock class extension的class mocking功能已经无缝集成到easymock中，因此代码的 编写简洁了很多，强烈建议新用户直接使用3.0版本。对于使用2./<em>版本的旧有代码，easymock提供了 easymock class extension的3.0版本，兼容2./</em>的代码，底层实现实际是代理给easymock3.0。因此2./*版本 easymock class extension的用户可以通过简单的升级easymock class extension到3.0即可平滑升级，之后再 逐渐替换掉easymock class extension的代码。</li>
<li>class mocking的限制
class mocking是有一些限制的， 1) 不能mock类的 final方法 如果final方法被调用，则只能执行原有的正常代码。
2) 不能mock类的static 方法。 同样如果private方法被调用，只能执行原有的正常代码。
3) 不能mock类的一些特殊方法: equals(), toString()和hashCode(). 原因是easymock在实现是为每个class mock对象提供了内建的以上三个方法。需要强调的是，对于基于 interface的mock，这个限制也是同样存在的，即使以上三个方式是interface定义的一部分。
在使用时需要避开这种场景，或者组合使用其他的mock 框架比如jmockit来mock private方法和final方法。
第 22 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.6 easymock教程-class mocking
第 23 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.7 easymock教程-mock的限制
1.7 easymock教程-mock的限制
发表时间: 2010-11-25 easymock并不是万能的，在使用easymock时有一些限制需要注意。
(1) Object方法的限制 我们都知道java是一个单根继承体系，Object是所有类的基类。在Object类上有几个基本的方法， easymock是不能改变其行为的：equals(), hashCode()和toString()。
即对于easymock创建的mock对象，其equals(), hashCode()和toString()三个方法的行为时已经固定了点， 不能通过Easymock.expect()来指定这三个方法的行为，即使这三个方法是接口定义的一部分。
我们来先看一个例子：
public class Business { private Service service;
public void execute() { System.out.println(&quot;service.toString() = &quot; + service.toString()); System.out.println(&quot;service.hashCode() = &quot; + service.hashCode()); }
public void setService(Service service) { this.service = service; } }
private interface Service {
public String toString();
public int hashCode();
第 24 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
}
1.7 easymock教程-mock的限制
execute()方法将为我们打印出toString()和hashCode()方法的结果。
public class LimitationTest {
private Business
business;
private IMocksControl mocksControl;
private Service
service;
@Before public void init() { business = new Business(); mocksControl = EasyMock.createStrictControl(); service = mocksControl.createMock(Service.class); business.setService(service); }
@Test public void testDefaultBehavior() { business.execute(); }
@Test public void testCustomizedBehavior() {
EasyMock.expect(service.toString()).andReturn(&quot;Customized toString&quot;); EasyMock.expect(service.hashCode()).andReturn(100000); mocksControl.replay();
business.execute(); mocksControl.verify(); } }
第 25 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.7 easymock教程-mock的限制
测试案例testDefaultBehavior()将为我们打印出mock对象默认的行为，输出如下： service.toString() = EasyMock for interface net.sourcesky.study.easymock.tutorial.LimitationTest$Service service.hashCode() = 26208195
可见easymock内部已经做好了toString()和hashCode()实现。
在测试案例testCustomizedBehavior()中，我们试图通过EasyMock.expect()来指定toString()和 hashCode()的行为，但是运行时遭遇错误：
java.lang.IllegalStateException: no last call on a mock available at org.easymock.EasyMock.getControlForLastCall(EasyMock.java:521) at org.easymock.EasyMock.expect(EasyMock.java:499) at net.sourcesky.study.easymock.tutorial.LimitationTest.testCustomizedBehavior(LimitationTest.java:51) ...
从&quot;no last call on a mock available&quot;的描述上看，easymock根本没有把对toString()方法的调用记录 (record)下来作为一个对mock对象的调用。
因此，在使用mock对象时，请注意equals(), hashCode()和toString()三个方法无法更改其行为。
(2) class mock的限制
相对于interface mock，class mock下easymock限制更多，除了上面谈到的equals(), hashCode()和 toString()三个方法外，还有以下限制：
第 26 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.7 easymock教程-mock的限制</li>
<li>final 方法不能被mock 2. private 方法不能对mock
(3) 静态方法 对于静态方法，easymock也无法mock其行为。
由于这个限制，当被测试类中有静态方法调用时，典型如单例方法调用，lookup方式的依赖查找， easymock就会力不从心。从这个角度上，推荐尽量使用IOC 控制反转/ DI依赖注入的方式来实现依赖的获取， 而不要使用lookup的主动查找方式。
实际开发中，当发现有因为静态方法的限制从而导致easymock无法mock我们期望的行为，造成测试案 例&quot;不好写&quot;，“写不下去”时，请换个角度思考：为什么要用静态方法？可不可以改成注入？
(4) 解决的方法
如果由于某些原因必须使用静态方法或者定制final, private方法的行为，则可以考虑搭配其他mock框架来完 成功能。
以静态方法方法为例，一个典型的使用范例是：使用jmockit来定制静态方法的行为，指定其返回easymock 创建的mock对象，然后使用easymock的标准方式定制这个mock对象的行为。
第 27 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.8 easymock教程-strict和nice
1.8 easymock教程-strict和nice
发表时间: 2010-11-19 在easymock的使用过程中，当创建mock对象时，我们会遇到 strict mock和nice mock的概念。
比如创建mock对象我们通常使用EasyMock.createMock()，但是我们会发现easymock同时提供了两个类似 的方法：
EasyMock.createNiceMock() EasyMock.createStrictMock()
类似的在创建MocksControl时，除了通常的EasyMock.createControl() 外，easymock也同时提供两个类 似的方法：
EasyMock.createNiceControl() EasyMock.createStrictControl()
我们来看看strict和nice有什么作用。参考easymock的javadoc，我们对比createMock()和 createStrictMock()：
EasyMock.createMock()： checking is disabled by default.
Creates a mock object that implements the given interface, order
EasyMock.createNiceMock() ： Creates a mock object that implements the given interface, order checking is enabled by default.
发现strict mock方式下默认是开启调用顺序检测的，而普通的mock方式则默认不开启调用顺序检测。
再看一下createNiceMock()：
第 28 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.8 easymock教程-strict和nice
Creates a mock object that implements the given interface, order checking is disabled by default, and the mock object will return 0, null or false for unexpected invocations.
和createMock()相同的是默认不开启调用顺序检测，另外有一个非常有用的功能就是对于意料之外的调用将 返回0,null 或者false.之所以说有用，是因为在我们的实际开发过程中，有时候会有这样的需求：对于某个 mock对象的调用(可以是部分，也可以是全部)，我们完全不介意调用细节，包括是否调用和调用顺序，参数， 返回值，我们只要求mock对象容许程序可以继续而不是抛出异常报告说 unexpected invocations 。nice mock在这种情况下可以为我们节省大量的工作量，非常方便。
我们来看一个简单的实际使用的例子，假设我们有一个Business类，依赖于两个service 接口：
先看只调用一个依赖的情况，注意在record阶段service1.method2()和service1.method1()的顺序和 business.executeService1()方法中的实际调用顺序是故意设置为不同的。
public class Business { private Service1 service1;
private Service2 service2;
public void executeService1() { service1.method1(); service1.method2(); }
public void executeService1And2() { service1.method1(); service1.method2();
service2.method3(); service2.method4(); }
public void setService1(Service1 service1) {
第 29 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
this.service1 = service1; }
1.8 easymock教程-strict和nice
public void setService2(Service2 service2) { this.service2 = service2; } }
private interface Service1 {
public void method1();
public void method2(); }
private interface Service2 {
public void method3();
public void method4(); }</li>
<li>普通mock
@Test public void testMock() { Business business = new Business(); Service1 service1 = EasyMock.createMock(&quot;service1&quot;, Service1.class); business.setService1(service1);
service1.method2(); EasyMock.expectLastCall(); service1.method1(); EasyMock.expectLastCall();
EasyMock.replay(service1);
第 30 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
business.executeService1(); EasyMock.verify(service1); }
1.8 easymock教程-strict和nice
测试案例可以通过，说明EasyMock.createMock()的确是不检测方法的调用顺序。 2. strict mock
@Test public void testStrictMock() { Business business = new Business(); Service1 service1 = EasyMock.createStrictMock(&quot;service1&quot;, Service1.class); ... }
案例失败，错误信息如下 java.lang.AssertionError: Unexpected method call service1.method1(): service1.method2(): expected: 1, actual: 0 at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:45) at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:73) at net.sourcesky.study.easymock.tutorial.$Proxy4.method1(Unknown Source) at net.sourcesky.study.easymock.tutorial.OrderTest$Business.executeService1(OrderTest.java:14) at net.sourcesky.study.easymock.tutorial.OrderTest.testStrictMock(OrderTest.java:79) ...... 说明strict mock下，easymock检测到了实际调用时的顺序和预期的不同。 3. nick mock
@Test public void testNiceMock() { Business business = new Business(); Service1 service1 = EasyMock.createNiceMock(&quot;service1&quot;, Service1.class);
第 31 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
... }
1.8 easymock教程-strict和nice
测试案例可以通过，而且如果是nick mock的话，record阶段可以简化：
@Test public void testNiceMockSimplify() { Business business = new Business(); Service1 service1 = EasyMock.createNiceMock(&quot;service1&quot;, Service1.class); business.setService1(service1);
EasyMock.replay(service1); business.executeService1(); EasyMock.verify(service1); }
这个简化版本的测试案例也是可以通过的。
上述的测试案例验证了strict mock和nice mock的基本使用，对于同一个mock对象，strict模式下多个方法 之间的调用顺序在record阶段和replay阶段下是需要保持一致的。但是故事并不是到此结束，更有意思的内容 在后面：如果出现多个mock对象，那么这些不同mock对象的方法之间，他们的调用顺序是否检测？普通mock 和nice mock模式下自然是不会检测顺序，但是strict模式下呢？
我们来看需要测试的方法executeService1And2()，这个方法会依次调用service1和service2的方法。使用 easymock测试这个方法，注意我们在record阶段依然故意将方法的调用顺序设置为和实际不同。</li>
<li>不使用control，直接创建两个strict mock对象
@Test public void testWithoutControlInWrongOrder() { Business business = new Business(); Service1 service1 = EasyMock.createStrictMock(&quot;service1&quot;, Service1.class);
第 32 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
Service2 service2 = EasyMock.createStrictMock(&quot;service2&quot;, Service2.class); business.setService1(service1); business.setService2(service2);
1.8 easymock教程-strict和nice
service2.method3(); EasyMock.expectLastCall(); service1.method1(); EasyMock.expectLastCall();
EasyMock.replay(service1, service2); business.executeService1And2(); EasyMock.verify(service1, service2); }
这个测试案例，出于意外的，通过了。easymock并没有检测service1.method1()和service2.method3()这 两个方法的调用顺序。</li>
<li>使用strict control创建两个strict mock对象
@Test public void testWithStrictControlInWrongOrder() { Business business = new Business(); IMocksControl mocksControl = EasyMock.createStrictControl(); ... }
案例失败，错误信息为： java.lang.AssertionError: Unexpected method call service1.method1(): service2.method3(): expected: 1, actual: 0 at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:45) at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:73) at net.sourcesky.study.easymock.tutorial.$Proxy4.method1(Unknown Source) at net.sourcesky.study.easymock.tutorial.OrderTest$Business.executeService1And2(OrderTest.java:19) at net.sourcesky.study.easymock.tutorial.OrderTest.testWithStrictControlInWrongOrder(OrderTest.java:218) ......
第 33 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.8 easymock教程-strict和nice
OK，easymock终于检测到service1.method1()和service2.method3()这两个方法的调用顺序和期望的不一 致了。
解释一下，EasyMock.createStrictMock()方法实际上内部是生成一个新的strict control，然后再创建mock 对象。 Service1 service1 = EasyMock.createStrictMock(&quot;service1&quot;, Service1.class); Service2 service2 = EasyMock.createStrictMock(&quot;service2&quot;, Service2.class);
这里实际是创建了两个strict control，而easymock是不会跨control进行顺序检测的。在实际使用过程中， 我们会有大量的场景需要检测多个mock之间的调用顺序(按说如果没有特殊要求，一般的测试场景默认都应该 如此),这种情况下就必须使用control, 而且必须是同一个strict control才能满足要求。
教程后面的最佳实践中有一条就是推荐使用mock control，可以跨mock对象检测方法调用顺序是一个重要 原因。
第 34 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.9 easymock教程-创建stub对象
1.9 easymock教程-创建stub对象
发表时间: 2010-11-23
前面教程中有个章节讨论到mock和stub的概念差别，一般来说easymock如其名所示，主要是用来做mock 用的，但是easymock中也提供有对stub的支持, 主要体现在 andStubAnswer(),andStubDelegateTo(),andStubReturn(),andStubThrow()和asStub()等方法的使用上。
我们来看一个实际使用的例子：
public class Business { private Service service;
private StubService stubService;
public void execute1() { if (service.execute()) { stubService.method1(); } }
public void execute2() { if (service.execute()) { stubService.method2(); } }
public void execute3() { if (service.execute()) { stubService.method1(); stubService.method2(); } }
第 35 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
public void setStubService(StubService stubService) { this.stubService = stubService; }
1.9 easymock教程-创建stub对象
public void setService(Service service) { this.service = service; } }
private interface Service { public boolean execute(); }
private interface StubService {
public String method1();
public String method2(); }
这里的Business类依赖到Service和StubService，execute1() / execute2() / execute3() 是我们需要测试的 三个方法，相同点都是必须调用service.execute()，不同点在于其后对stubService的调用各不相同。而我们假 设在这里我们只关心Business类对Service的调用是否如预期，不关心对于StubService的调用，只要程序可以 继续运行就可以了。
一个正统的做法是手工写一个StubService的stub 实现，例如：
private class StubServiceImpl { public String method1() { return &quot;&quot;; }
public String method2() { return &quot;&quot;; }
第 36 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
}
1.9 easymock教程-创建stub对象
但是如果这个接口复杂方法众多，则这个stub类不得不实现所有的其他方法，即使完全用不到，因为java的 语法限制。
可以这样使用easymock来实现stub：
public class BusinessTest {
private Business
business;
private IMocksControl mocksControl;
private Service
service;
@Before public void init() { business = new Business(); business.setStubService(prepareStubService()); mocksControl = EasyMock.createStrictControl(); service = mocksControl.createMock(&quot;service&quot;, Service.class); business.setService(service); }
private StubService prepareStubService() { StubService service = EasyMock.createMock(&quot;stubService&quot;, StubService.class); service.method1(); EasyMock.expectLastCall().andStubReturn(&quot;&quot;); service.method2(); EasyMock.expectLastCall().andStubReturn(&quot;&quot;);
第 37 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
EasyMock.replay(service); return service; }
1.9 easymock教程-创建stub对象
@Test public void testExecute1() { EasyMock.expect(service.execute()).andReturn(true); mocksControl.replay(); business.execute1(); mocksControl.verify(); }
@Test public void testExecute2() { EasyMock.expect(service.execute()).andReturn(false); mocksControl.replay(); business.execute2(); mocksControl.verify(); }
@Test public void testExecute3() { EasyMock.expect(service.execute()).andReturn(true); mocksControl.replay(); business.execute3(); mocksControl.verify(); } }
在方法prepareStubService()中，我们通过easymock创建了一个mock对象，然后和普通mock对象一样记 录了期望的行为。不同的是用andStubReturn()替代了andReturn().
然后我们直接调用EasyMock.replay(service)，注意在这个测试案例中，我们另外创建了一个mocksControl 并通过这个mocksControl创建了我们关注的Service接口的mock对象，它的record/replay/和verify()是和 StubService完全分离的。这样做的好处是在execute1() / execute2() / execute3()的测试案例中，我们完全不
第 38 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.9 easymock教程-创建stub对象
必额外关心这个stub，所有的事情在init()函数中就已经准备好了。这样做的好处显而易见，execute1() / execute2() / execute3()的测试案例中，代码和测试逻辑都简单了。
最后总结，在适当的时候使用easymock来创建stub对象，对于简化测试还是能有所帮助的。
第 39 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.10 easymock教程-放宽调用次数
1.10 easymock教程-放宽调用次数
发表时间: 2010-11-29 对于mock对象上的mock方法的调用,easymock支持指定次数，默认为1，例如
Easymock.expect(mock.method1()).andReturn(...);
这里没有显式的指定调用次数，因此效果等同于
Easymock.expect(mock.method1()).andReturn(...).once();
同时easymock提供了其他的方法，用于指定具体调用次数或者放宽调用次数检验。</li>
<li>once() 如果明确调用次数为1，则可以使用这个方法显式指定，也可以省略，easymock默认为1。</li>
<li>atLeastOnce() 指定调用为1次或者多次，即 count &gt;= 1.</li>
<li>anyTimes() 容许调用次数为任意次，即 count &gt;= 0.</li>
<li>times(int count) 直接指定调用次数</li>
<li>times(int min, int max) 这个方法比较灵活，可以指定最小次数和最大次数。
第 40 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.10 easymock教程-放宽调用次数
其他的方法都可以视为这个方法的变体，比如 once()等价于times(1,1) atLeastOnce()等价于times(1,Integer.MAX_VALUE) anyTimes()等价于times(0,Integer.MAX_VALUE) times(int count)等价于times(count,count)
实际使用中根据具体要求可以灵活选用上述方法来指定我们期望的调用数次。
第 41 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.11 easymock教程-参数匹配
1.11 easymock教程-参数匹配
发表时间: 2010-11-29 easymock中提供了非常多的方法来实现参数匹配，基本能满足一般参数匹配的要求。 我们来具体看一下到底有哪些方法：
(1) 基于基本类型的比较</li>
<li>eq(X value)方法, X 可以是boolean,byte,char, double,float,int,long,short,T 有多个重载方法，支持基本类型如boolean, byte,char, double,float,int, long,short，后面会介绍它也 支持Object比较。 这个eq()方法的用法直接了当，基本数值直接比较数值，对于非整型的double和float，由于存在精度 的问题，因此增加了以下两个方法来指定比较精度。
eq(double value, double delta) eq(float value, float delta)</li>
<li>aryEq(X[] values) X 可以是boolean,byte,char, double,float,int,long,short,T 这个是eq(X value)方法的数组版本，要求比较的两个数组拥有相同的长度，然后每个元素都&quot;相同&quot;，即 都可以满足eq(X value)方法。 注意到double和float并没有像eq(X value)方法那样提供可以设置精度的重载版本，不知道在数组比较 时如何去设置容许精度。</li>
<li>gt(X value), lt(X value), X 可以是byte,double,float,int,long,short 这两个方法用于参数的大小匹配，适用于数值型的基本类型如byte,double,float,int,long,short。</li>
<li>geq(X value), leq(X value)
第 42 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.11 easymock教程-参数匹配
类似gt()和lt()，无非是将&quot;&gt;&quot;改为&quot;&gt;=&quot;, &quot;&lt;&quot;改为&quot;&lt;=&quot;。</li>
<li>anyX(), X可以是Boolean, Byte, Char, Double, Float, Int, Long, Short 这是一个宽松的匹配方法，任何数值都被视为匹配OK。这个方法在我们不介意参数值时特别有用。
(2) 基于对象的比较</li>
<li>eq(T value)方法 和基本类型类似，不过对于Object，是通过调用equals()方法来进行比较。</li>
<li>same(T value) 方法 和eq()不同，same()是通过比较对象引用来进行比较的。类似java代码中, a.equals(b)和a == b的差 别。</li>
<li>anyObject() 和 anyObject(Class<T> clazz) 类似基本类型的any/<em>/</em>/*()方法，非常宽松，在我们不介意参数值时使用。 使用方式有三种: (T)EasyMock.anyObject() // 强制类型转换 EasyMock.<T> anyObject() // 固定返回的泛型 EasyMock.anyObject(T.class) // 在参数中指定返回的泛型</li>
<li>isA(Class<T> clazz) 和anyObject(Class<T> clazz) 非常，唯一一个差别在于当输入参数为null时，anyObject(Class<T> clazz)返回true而isA(Class<T> clazz) 返回false。
第 43 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.11 easymock教程-参数匹配
(3) 逻辑计算 easymock支持在参数匹配时进行一些简单的逻辑计算, 如and(), or (), not()。
not()容易理解，取反而已。or()也容易理解，两个匹配方法匹配一个即可。而and()匹配方法通常用于设置取 值区间，典型如and(gt(0), lt(5))) 的写法可以设置期望值大于0而小于5，即(0,5)区间。
此外在参数匹配中，有几个特殊角色，享受的待遇与众不同，easymock为它们提供了专有方法。</li>
<li>Comparable 对于实现了Comparable接口的对象，easymock提供了一系列的专用方法来处理，包括eq, gt, lt, geq, leq：
cmpEq(Comparable<T> value) gt(Comparable<T> value) lt(Comparable<T> value) geq(Comparable<T> value) leq(Comparable<T> value) 这个特殊处理非常合理，本来Comparable接口就提供了比较的功能，在参数匹配时应该容许直接使用。</li>
<li>string 由于字符串匹配使用的场景非常多，因此easymock为此也提供了几个常见的参数匹配方法：
contains(String substring) startsWith(String prefix) endsWith(String suffix) find(String regex) 其中contains/startsWith/endsWith是简单的字符串查找，而find()则通过支持正则表达式来提供复杂匹配。
第 44 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.11 easymock教程-参数匹配</li>
<li>null 对于Object匹配，很常见的一个场景就是输入的参数为null，easymock中提供isNull() 和 notNull() 两个 方法来完成对null值的匹配。
开发中，经常会遇到下面这种场景，期望输入的参数满足isA()或者容许为null。而直接使用isA()，是不能 支持null的，即如果参数为null时isA()会报不匹配。这个不是easymock的bug，而是刻意而为，解决的方法是 使用 or(isA(...), isNull(...))或者anyObject()。
service.execute((ClassA) EasyMock.or(EasyMock.isA(ClassA.class), EasyMock.isNull())); service.execute(EasyMock.anyObject(ClassA.class));
第 45 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.12 easymock教程-partial class mocking
1.12 easymock教程-partial class mocking
发表时间: 2010-11-30 easymock中提供对于类的mock功能，我们可以方便的mock这个类的某些方法，指定预期的行为以便测试 这个类的调用者。这种场景下被mock的类在测试案例中扮演的是次要测试对象或者说依赖的角色，主要测试对 象是这个mock类的调用者。但是有时候我们需要将这个测试类作为主要测试对象，我们希望这个类中的部分 (通常是大部分)方法保持原有的正常行为，只有个别方法被我们mock掉以便测试。</li>
<li>使用方法
我们先来看看这个partial class mocking 是如何工作的：
public class Service {
public void execute() { actualMethod(); needMockMethod(); }
void actualMethod() { System.out.println(&quot;call actualMethod()&quot;); }
public void needMockMethod() { System.out.println(&quot;call needMockMethod()&quot;); }
}
我们给出了一个非常简单的类，我们将要测试execute()方法，期望能测试到actualMethod()这个方法的正常 行为，然后需要mock掉needMockMethod().
public class PartialClassMockTest extends Assert {
第 46 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
@Test public void testPartialMock() {
1.12 easymock教程-partial class mocking
Service service = EasyMock.createMockBuilder(Service.class).addMockedMethod(&quot;needMockMethod&quot;).createMock(); service.needMockMethod(); EasyMock.expectLastCall();
EasyMock.replay(service); service.execute(); EasyMock.verify(service); } }
上面的测试案例运行通过，输出为&quot;call actualMethod()&quot;，没有&quot;call needMockMethod()&quot;，说明我们设置 的mock生效了。我们创建的mock类的确是只有部分我们制定的方法是mock的，其他都是正常行为。
再来看看为什么我们要需要partial class mocking 这个功能？为什么需要mock掉其中的一个方法？
我们来看看下面这个更加真实的例子：
public class Service {
public String execute2() { return getConfiguration(); }
public String getConfiguration() { return Configuration.getUsername(); } }
public class Configuration { public static String getUsername() { //ignore the code to get configuration from file or database return &quot;username&quot;;
第 47 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
} }
1.12 easymock教程-partial class mocking
这里例子中，需要测试的 execute2()方法需要调用getConfiguration()方法，而getConfiguration()方法则 调用了Configuration的静态方法来获取配置信息。我们假设读取配置的代码比较复杂不能直接在单元测试环境 下运行，因此通过情况下这里的execute2()方法就会因为这个getConfiguration()而造成无法测试。因此我们可 以考虑通过partial class mocking的功能来mock掉getConfiguration()方法从而使得我们的测试案例可以覆盖 到execute2()方法
@Test public void testStaticMethod() {
Service service = EasyMock.createMockBuilder(Service.class).addMockedMethod(&quot;getConfiguration&quot;).createMock(); EasyMock.expect(service.getConfiguration()).andReturn(&quot;abc&quot;);
EasyMock.replay(service); assertEquals(&quot;abc&quot;, service.execute2()); EasyMock.verify(service); }
这个测试案例可以正常通过，我们通过partial class mocking成功的避开了getConfiguration()这个绊脚 石。
当然这里的实例代码本身就有点问题，应该采用DI的方法将configuration注入进来，而不是在内部通过静态 方法来获取。因此一个建议是在使用partial class mocking功能前，先看看是不是可以通过重构来显改进测试 类。只有当我们有足够充分的不得已的理由时，才使用partial class mocking这种变通(或者说取巧)的方式来解 决问题。</li>
<li>限制
上面两个例子中，我们仔细看看会发现，被mock的方法都是public的。我们试着将方法修改为protected和 default，partial class mocking依然生效。但是修改为private之后，则抛出异常：
第 48 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.12 easymock教程-partial class mocking
java.lang.IllegalArgumentException: Method not found (or private): needMockMethod at org.easymock.internal.MockBuilder.addMockedMethod(MockBuilder.java:75) at net.sourcesky.study.easymock.tutorial.PartialClassMockTest.testPartialMock(PartialClassMockTest.java:52)
或者将mock的方法继续保持public，但是加上final，则抛出以下异常：
java.lang.IllegalStateException: no last call on a mock available at org.easymock.EasyMock.getControlForLastCall(EasyMock.java:521) at org.easymock.EasyMock.expectLastCall(EasyMock.java:512) at net.sourcesky.study.easymock.tutorial.PartialClassMockTest.testPartialMock(PartialClassMockTest.java:54)
我们回到之前的章节，class mocking里面讲述了class mocking的一些限制：private方法和final方法是不能 mock的。partial class mocking下这些限制依然存在。因此，为了开启partial class mocking，我们不得不稍 微破坏一下类的封装原则，对于原本应该是private的方法，修改为protected或者default。 不得不再次申明，partial class mocking不是一个足够好的解决方案，它只适合在不得已的情况下使用，不 要太依赖这个特性。重构代码改善代码才是王道。 3. 疑问 另外class mocking中还讲到，对于类的equals(), toString()和hashCode()这三个方法，class mocking下是 easymock为这三个方法内建了easymock的实现，因此也不能mock。而partial class mocking，这三个方法 同样不能mock，但是easymock不再为它们内建实现，而是使用它们正常的功能。
关于这点还是有一点疑问，我在easymock的官方文档中看到以下描述 Remark: EasyMock provides a default behavior for Object&#39;s methods (equals, hashCode, toString). However, for a partial mock, if these methods are not mocked explicitly, they will have their normal behavior instead of EasyMock default&#39;s one.
第 49 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.12 easymock教程-partial class mocking
言下之意，似乎equals, hashCode, toString这三个方法还是可以显式mock的。但是我测试了一下：
public class Service {
public String execute3() { actualMethod(); return toString(); }
@Override public String toString() { return &quot;defaultToString()&quot;; } }
@Test public void testToStringMethod() { Service service = EasyMock.createMockBuilder(Service.class).addMockedMethod(&quot;toString&quot;).createMock(); EasyMock.expect(service.toString()).andReturn(&quot;abc&quot;); EasyMock.replay(service); assertEquals(&quot;abc&quot;, service.execute3()); EasyMock.verify(service); }
toString()方法的mock没能生效，抛出异常:
java.lang.IllegalStateException: no last call on a mock available at org.easymock.EasyMock.getControlForLastCall(EasyMock.java:521) at org.easymock.EasyMock.expect(EasyMock.java:499) at
net.sourcesky.study.easymock.tutorial.PartialClassMockTest.testToStringMethod(PartialClassMockTest.java:
可以看到明显是EasyMock.expect(service.toString()).andReturn(&quot;abc&quot;); 这里的record没有成功。
第 50 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.13 easymock教程-运行时返回值或者异常
1.13 easymock教程-运行时返回值或者异常
发表时间: 2010-11-30 前面的教程中，我们看到easymock可以通过expect方法来设定mock方法的返回值或者异常，但是注意这 些案例中设置的返回值都是在调用被测试的类的方法前就已经确定下来的，即我们其实在测试类的代码运行前 (实际是在EasyMock.replay()方法调用前)就已经&quot;预知&quot;了返回结果。
但是在某些情况下，我们可能无法预知返回值，比如我们需要根据输入的参数值来决定返回什么，而这个参 数可能无法在record阶段获得。因此在mock方法中我们无法在record阶段就决定应该返回什么。
对于这种场景，easymock提供了IAnswer接口和andAnswer()方法来提供运行时决定返回值或者异常的机 制。
我们来看一个简单的例子：
public class Business { private Service service;
public void execute() { int count = ramdonInt(); int result = service.execute(count); }
public void setService(Service service) { this.service = service; }
private int ramdonInt() { Random random = new Random(); return random.nextInt() / 10000; } }
第 51 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
public interface Service { public int execute(int count); }
1.13 easymock教程-运行时返回值或者异常
在Business的execute()方法中，需要调用service.execute(int count)方法，而传入的参数count是需要运行 时才能确定的，这里为了简单我们random了一个int来模拟这种情况。
然后看测试案例
@Test public void testRuntimeReturn() { Business business = new Business(); Service service = EasyMock.createMock(Service.class); business.setService(service); EasyMock.expect(service.execute(EasyMock.anyInt())).andAnswer(new IAnswer<Integer>() { public Integer answer() throws Throwable { Integer count = (Integer) EasyMock.getCurrentArguments()[0]; return count /<em> 2; } });
EasyMock.replay(service); business.execute(); EasyMock.verify(service); }
这里我们通过EasyMock.expect(service.execute(EasyMock.anyInt()))来接受任意值的count参数输入， andAnswer(new IAnswer<Integer>() {}) 让我们可以指定一个IAnswer的实现类来给出返回值。在这个 IAnswer的实现类中，我们通过EasyMock.getCurrentArguments()[0]获取到service.execute()方法的第一个 参数，然后简单的运用count/</em>2规则给出返回值。这里的EasyMock.getCurrentArguments()方法可以获取到 运行时的参数列表，不过注意这个方法对重构不够友好，如果参数列表发生变化则必须手工修改对象的获取参 数的代码。
下面是一个运行时抛出异常的例子，简单起见我们通过设置exception的message来在错误信息中传递运行 时的count值。
第 52 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
@Test public void testRuntimeException() { Business business = new Business(); Service service = EasyMock.createMock(Service.class); business.setService(service);
1.13 easymock教程-运行时返回值或者异常
EasyMock.expect(service.execute(EasyMock.anyInt())).andAnswer(new IAnswer<Integer>() { public Integer answer() throws Throwable { Integer count = (Integer) EasyMock.getCurrentArguments()[0]; throw new RuntimeException(&quot;count=&quot; + count); } });
EasyMock.replay(service); try { business.execute(); fail(&quot;should throw RuntimeException&quot;); } catch (RuntimeException e) { assertTrue(e.getMessage().indexOf(&quot;count=&quot;) != -1); //get count from message EasyMock.verify(service); } }
除了IAnswer接口外，easymock中还有另外一个方式可以完成类似的功能，就是使用andDelegate()方法，
public class ServiceStub implements Service { public int execute(int count) { return count /* 2; } }
@Test public void testRuntimeReturn() { Business business = new Business(); Service service = EasyMock.createMock(Service.class); business.setService(service); EasyMock.expect(service.execute(EasyMock.anyInt())).andDelegateTo(new ServiceStub());
第 53 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
EasyMock.replay(service); business.execute(); EasyMock.verify(service); }
1.13 easymock教程-运行时返回值或者异常
这里需要先创建一个Service类的实现类和一个实例，然后通过andDelegateTo()将这个stub的实例传进去， 注意这里delegate进去的实例必须是mock对象接口相同。
delegateTo方式实际上是我们手工创建了stub(mock和stub的概念及差别请参考本教程的&quot;mock和stub&quot;一 文)，这和我们使用easymock的初衷有所违背。而且当这个接口有众多方法时，创建这样一个stub会显得很痛 苦，不如使用IAnswer方便直接。
第 54 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.14 easymock教程-改变同一个方法调用的行为
1.14 easymock教程-改变同一个方法调用的行为
发表时间: 2010-11-30 在easymock中，对于mock对象的同一个方法，可以为每一次的调用定制不同的行为。在record阶段 easymock会精确的记录我们录入的行为，基于每一次的方法调用。
这里有一个官网文档中的例子：
expect(mock.voteForRemoval(&quot;Document&quot;)) .andReturn((byte) 42).times(3) .andThrow(new RuntimeException()).times(4) .andReturn((byte) -42);
对于mock.voteForRemoval(&quot;Document&quot;)方法的调用，.andReturn((byte) 42).times(3) 表明前3次调用将 返回42，.andThrow(new RuntimeException()).times(4)表示随后的4次调用(第4,5,6,7次)都将抛出异常， andReturn((byte) -42)表示第8次调用时将返回-42。
我们来验证一下:
public class ChangeBehehaviorTest extends Assert { private static interface Service { public byte voteForRemoval(String name); }
@Test public void testExecute() { final String name = &quot;Document&quot;;
Service mock = EasyMock.createMock(&quot;service&quot;, Service.class);
EasyMock.expect(mock.voteForRemoval(&quot;Document&quot;)).andReturn((byte) 42).times(3).andThrow(new RuntimeException .times(4).andReturn((byte) -42);
第 55 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
EasyMock.replay(mock);
1.14 easymock教程-改变同一个方法调用的行为
for (int i = 0; i &lt; 3; i++) { assertEquals(42, mock.voteForRemoval(name)); } for (int i = 0; i &lt; 4; i++) { try { mock.voteForRemoval(name); fail(&quot;should throw RuntimeException&quot;); } catch (RuntimeException e) {
} } assertEquals(-42, mock.voteForRemoval(name)); EasyMock.verify(mock); } }
测试案例顺利通过。
第 56 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.15 easymock教程-自定义参数匹配器
1.15 easymock教程-自定义参数匹配器
发表时间: 2010-11-30 虽然easymock中提供了大量的方法来进行参数匹配，但是对于一些特殊场合比如参数是复杂对象而又不能 简单的通过equals()方法来比较，这些现有的参数匹配器就无能为力了。easymock为此提供了 IArgumentMatcher 接口来让我们实现自定义的参数匹配器。
我们还是用例子来说话：
public interface Service { public void execute(Request request); }
service类的execute()方法接收一个Request实例作为参数, Request是一个javabean:
public static class Request {
private boolean condition;
private String value1;
private String value2;
//ignore getter and setter method }
假设在我们的这个单独的测试案例中，我们有以下参数匹配逻辑: 如果condition为true，则只需要比较 value1；如果condition为false，则只需要比较value2. 由于这个逻辑和默认的equals方法不一致，因此我们不 能直接使用equals方法，只能实现自己的参数匹配器。
public class RequestMatcher implements IArgumentMatcher {
private boolean condition;
private String expectedValue;
第 57 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
private RequestMatcher(boolean condition, String expectedValue) { this.condition = condition; this.expectedValue = expectedValue; }
1.15 easymock教程-自定义参数匹配器
@Override public void appendTo(StringBuffer buffer) { buffer.append(&quot;RequestMatcher expect(condition=&quot;); buffer.append(condition); buffer.append(&quot; expectedValue=&quot;); buffer.append(expectedValue); buffer.append(&quot;)&quot;); }
@Override public boolean matches(Object argument) { if (!(argument instanceof Request)) { return false; }
Request request = (Request) argument; if (condition) { return expectedValue.equals(request.getValue1()); } else { return expectedValue.equals(request.getValue2()); } }
public static Request requestEquals(boolean condition, String expectedValue) { EasyMock.reportMatcher(new RequestMatcher(condition, expectedValue)); return null; } }
RequestMatcher 是我们定义的参数匹配器，matches()方法中是参数匹配逻辑的代码实现，appendTo()方 法用于在匹配失败时打印错误信息，后面我们会演示这个方法的使用。然后是最重要的方法requestEquals()， 在这里我们通过调用EasyMock.reportMatcher()告诉easymock我们要用的参数匹配器。
第 58 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.15 easymock教程-自定义参数匹配器
在测试案例中，我们和以往一样，先创建了mock对象，然后准备request对象作为测试数据。不同的是，我 们没有使用easymock提供的参数匹配方法，而是通过 service.execute(RequestMatcher.requestEquals(expectedCondition, expectedValue)); 来调用 EasyMock.reportMatcher()，以创建我们自定义的参数匹配器并为它传入了两个必备的参数 expectedCondition和expectedValue。
上面的测试案例可以顺利通过，我们的参数匹配器可以正常工作。然后我们来试试参数匹配不成功的情况
@Test public void testConditionTrueFailure() { final boolean expectedCondition = true; final String expectedValue = &quot;aaa&quot;;
Service service = EasyMock.createMock(&quot;service&quot;, Service.class); Request request = prepareRequest(expectedCondition, &quot;bbb&quot;, &quot;ccc&quot;); service.execute(RequestMatcher.requestEquals(expectedCondition, expectedValue)); EasyMock.expectLastCall();
EasyMock.replay(service); service.execute(request); EasyMock.verify(service); }
注意在Request request = prepareRequest(expectedCondition, &quot;bbb&quot;, &quot;ccc&quot;)中，我们故意设置value为 和期望的不同，当然这样测试案例就通不过了:
java.lang.AssertionError: Unexpected method call service.execute(net.sourcesky.study.easymock.tutorial.IArgumentMatcherTest$Request@10ef90c): service.execute(RequestMatcher expect(condition=true expectedValue=aaa)): expected: 1, actual: 0 at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:45) at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:73)
第 59 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.15 easymock教程-自定义参数匹配器
at $Proxy4.execute(Unknown Source) at
net.sourcesky.study.easymock.tutorial.IArgumentMatcherTest.testConditionTrueFailure(IArgumentMatcherT
注意&quot;service.execute(RequestMatcher expect(condition=true expectedValue=aaa)): expected: 1, actual: 0&quot;这行，其中的&quot;RequestMatcher expect(condition=true expectedValue=aaa)&quot;是我们在 appendTo()方法中构建出来的错误信息。appendTo()方法只在这个时候才被调用，用于生成可读性强的错误 信息以便我们在失败时检查，因此不要疏忽了这个方法的实现。
第 60 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.16 easymock教程-命名mock对象
1.16 easymock教程-命名mock对象
发表时间: 2010-11-29 在创建mock对象的时候，我们可以命名mock对象。
前面我们谈到easymock中有三种mock对象，分别用下面三个方法创建:
createMock(Class<T> toMock) createStrictMock(Class<T> toMock) createNiceMock(Class<T> toMock)
带有命名功能的方法也有对应的三种:
createMock(String name, Class<T> toMock) createStrictMock(String name, Class<T> toMock) createNiceMock(String name, Class<T> toMock)
命名mock对象有什么好处呢？其实就是一点，即在当测试案例因为某个mock对象的状态或行为不符合要求 而失败的时候，在异常信息里面可以输出这个mock对象的名称。
我们用实际的例子来看，同样是创建一个mock对象，然后调用一个没有record的方法，easymock报错退出 的测试案例。</li>
<li>不命名
Service service = EasyMock.createMock(Service.class);
异常信息如下： java.lang.AssertionError: Unexpected method call execute(): at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:45) at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:73)
第 61 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.16 easymock教程-命名mock对象
at net.sourcesky.study.easymock.tutorial.$Proxy4.execute(Unknown Source) at net.sourcesky.study.easymock.tutorial.NamingMockTest$Business.execute(NamingMockTest.java:11) at net.sourcesky.study.easymock.tutorial.NamingMockTest.testExecute(NamingMockTest.java:31) ...... 这里的错误信息&quot;Unexpected method call execute()&quot;，只指出了发生错误的是execute()方法，并未指出具 体是哪个mock对象。 当测试案例简单时，比如就一两个mock对象，我们可以直接从方法名上就看出是哪个mock对象。但是当 mock对象多了之后，尤其是方法很多的时候，就会浪费时间。</li>
<li>命名后
Service service = EasyMock.createMock(&quot;service&quot;, Service.class);
异常信息如下： java.lang.AssertionError: Unexpected method call service.execute(): at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:45) at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:73) at net.sourcesky.study.easymock.tutorial.$Proxy4.execute(Unknown Source) at net.sourcesky.study.easymock.tutorial.NamingMockTest$Business.execute(NamingMockTest.java:11) at net.sourcesky.study.easymock.tutorial.NamingMockTest.testExecute(NamingMockTest.java:30)
差别只在错误信息中&quot;Unexpected method call serviceMock.execute()&quot; 包含serviceMock的字样，因此我 们可以快递定位到具体的mock对象。
命名mock对象在初次编写测试案例时用处还不是很明显，因为编写者当时肯定对代码很熟悉。但是当另外一 个开发人员因为某此修改代码造成测试案例不能通过时，由于这个开发人员对代码的熟悉程度不够，因此命名 mock对象可以对他有所帮助，方便维护。
第 62 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.16 easymock教程-命名mock对象
命名之后的mock对象，还有一个特殊的地方就是toString()方法将返回该mock对象的名称，以代码为例:
Service service = EasyMock.createMock(&quot;service&quot;, Service.class); System.out.println(service.toString());
输出就是&quot;service&quot;，对比不命名mock对象的情况：
Service service = EasyMock.createMock(Service.class); System.out.println(service.toString());
得到的输出是&quot;EasyMock for interface net.sourcesky.study.easymock.tutorial.NamingMockTest$Service&quot;.
第 63 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.17 easymock教程-使用MockControl
1.17 easymock教程-使用MockControl
发表时间: 2010-10-26 在easymock中，通常我们使用一下的代码来创建mock对象
IMyInterface mock = createStrictMock(IMyInterface.class); replay(mock); verify(mock); reset(mock);
如果需要mock多个对象，则需要如此:
IMyInterface1 mock1 = createStrictMock(IMyInterface1.class); IMyInterface2 mock2 = createStrictMock(IMyInterface2.class); IMyInterface3 mock3 = createStrictMock(IMyInterface2.class); ... replay(mock1, mock2, mock3, ...); verify(mock1, mock2, mock3, ...); reset(mock1, mock2, mock3, ...);
不仅需要为每个mock对象增加create语句，而且需要为这个新增的mock对象更新replay()/verify()/reset() 方法，比较啰嗦，而且容易出错。
这种情况下可以考虑使用MocksControl来简化代码：
IMocksControl mocksControl = createControl(); IMyInterface1 mock1 = mocksControl.createMock(IMyInterface1.class); IMyInterface2 mock2 = mocksControl.createMock(IMyInterface2.class); IMyInterface3 mock3 = mocksControl.createMock(IMyInterface3.class); ... mocksControl.replay(); mocksControl.verify(); mocksControl.reset();
IMocksControl接口容许创建多个mock对象，这些创建的对象自动关联到这个mocksControl实例上，以后
第 64 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.17 easymock教程-使用MockControl
再调用replay()/verify()/reset()时就不需要逐个列举出每个mock对象。当mock对象比较多，尤其是原有代码 上新增mock 对象时非常方便。 事实上，Easymock.createMock()方法内部实现也是使用IMocksControl的:
public static <T> T createMock(final Class<T> toMock) { return createControl().createMock(toMock); }
public static IMocksControl createControl() { return new MocksControl(MocksControl.MockType.DEFAULT); }
除了使用方便外，使用IMocksControl还有另外一个重要的好处，就是如果使用strict control，则可以跨多 个mock对象检测方法的调用顺序，具体的内容请参考本教程中的&quot;strict和nice&quot;一文。
第 65 / 65 页</li>
</ol>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_总结类/">Java_总结类</a></li><li><a href="/categories/Java&J2EE/Java_总结类/easy-mock/">easy-mock</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_总结类/" class="label label-success">Java_总结类</a><a href="/tags/easy-mock/" class="label label-info">easy-mock</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类-easy-mock--easymock教程/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_总结类-easy-mock--easymock教程" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-unix--Awk学习笔记/">Awk学习笔记</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-unix--Awk学习笔记/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="awk-">Awk学习笔记</h1>
<h1 id="-awk-"><a href=""></a>Awk学习笔记</h1>
<h3 id="-jims-of-http-www-ringkee-com-">整理：Jims of <a href="http://www.ringkee.com/" target="_blank">肥肥世家</a></h3>
<p><a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#106;&#x69;&#109;&#x73;&#46;&#x79;&#97;&#110;&#103;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#106;&#x69;&#109;&#x73;&#x2e;&#x79;&#x61;&#x6e;&#x67;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#41;">&#x5b;&#106;&#x69;&#109;&#x73;&#46;&#x79;&#97;&#110;&#103;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#106;&#x69;&#109;&#x73;&#x2e;&#x79;&#x61;&#x6e;&#x67;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#41;</a>
Copyright © 2004 本文遵从GPL协议，欢迎转载、修改、散布。</p>
<p>第一次发布时间:2004年8月6日</p>
<p><strong>Table of Contents</strong>
<a href="">1. awk简介</a><a href="">2. awk命令格式和选项</a><a href="">2.1. awk的语法有两种形式</a><a href="">2.2. 命令选项</a><a href="">3. 模式和操作</a><a href="">3.1. 模式</a><a href="">3.2. 操作</a><a href="">4. awk的环境变量</a><a href="">5. awk运算符</a><a href="">6. 记录和域</a><a href="">6.1. 记录</a><a href="">6.2. 域</a><a href="">6.3. 域分隔符</a><a href="">7. gawk专用正则表达式元字符</a><a href="">8. POSIX字符集</a><a href="">9. 匹配操作符(~)</a><a href="">10. 比较表达式</a><a href="">11. 范围模板</a><a href="">12. 一个验证passwd文件有效性的例子</a><a href="">13. 几个实例</a><a href="">14. awk编程</a><a href="">14.1. 变量</a><a href="">14.2. BEGIN模块</a><a href="">14.3. END模块</a><a href="">14.4. 重定向和管道</a><a href="">14.5. 条件语句</a><a href="">14.6. 循环</a><a href="">14.7. 数组</a><a href="">14.8. awk的内建函数</a><a href="">15. How-to</a></p>
<h2 id="-1-awk-"><a href=""></a>1. awk简介</h2>
<p>awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk的处理文本和数据的方式是这样的，它逐行扫描文件，从第一行到最后一行，寻找匹配的特定模式的行，并在这些行上进行你想要的操作。如果没有指定处理动作，则把匹配的行显示到标准输出(屏幕)，如果没有指定模式，则所有被操作所指定的行都被处理。awk分别代表其作者姓氏的第一个字母。因为它的作者是三个人，分别是Alfred Aho、Brian Kernighan、Peter Weinberger。gawk是awk的GNU版本，它提供了Bell实验室和GNU的一些扩展。下面介绍的awk是以GUN的gawk为例的，在linux系统中已把awk链接到gawk，所以下面全部以awk进行介绍。</p>
<h2 id="-2-awk-"><a href=""></a>2. awk命令格式和选项</h2>
<h3 id="-2-1-awk-"><a href=""></a>2.1. awk的语法有两种形式</h3>
<ul>
<li>awk [options] &#39;script&#39; var=value file(s)</li>
<li>awk [options] -f scriptfile var=value file(s)<h3 id="-2-2-"><a href=""></a>2.2. 命令选项</h3>
</li>
</ul>
<p>-F fs or --field-separator fs
指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。
-v var=value or --asign var=value
赋值一个用户定义变量。
-f scripfile or --file scriptfile
从脚本文件中读取awk命令。
-mf nnn and -mr nnn
对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。
-W compact or --compat, -W traditional or --traditional
在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。
-W copyleft or --copyleft, -W copyright or --copyright
打印简短的版权信息。
-W help or --help, -W usage or --usage
打印全部awk选项和每个选项的简短说明。
-W lint or --lint
打印不能向传统unix平台移植的结构的警告。
-W lint-old or --lint-old
打印关于不能向传统unix平台移植的结构的警告。
-W posix
打开兼容模式。但有以下限制，不识别：\x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符/<em>/</em>和/<em>/</em>=不能代替^和^=；fflush无效。
-W re-interval or --re-inerval
允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。
-W source program-text or --source program-text
使用program-text作为源代码，可与-f命令混用。
-W version or --version
打印bug报告信息的版本。</p>
<h2 id="-3-"><a href=""></a>3. 模式和操作</h2>
<p>awk脚本是由模式和操作组成的：
pattern {action} 如$ awk &#39;/root/&#39; test，或$ awk &#39;$3 &lt; 100&#39; test。</p>
<p>两者是可选的，如果没有模式，则action应用到全部记录，如果没有action，则输出匹配全部记录。默认情况下，每一个输入行都是一条记录，但用户可通过RS变量指定不同的分隔符进行分隔。</p>
<h3 id="-3-1-"><a href=""></a>3.1. 模式</h3>
<p>模式可以是以下任意一个：</p>
<ul>
<li>/正则表达式/：使用通配符的扩展集。</li>
<li>关系表达式：可以用下面运算符表中的关系运算符进行操作，可以是字符串或数字的比较，如$2&gt;%1选择第二个字段比第一个字段长的行。</li>
<li>模式匹配表达式：用运算符~(匹配)和~!(不匹配)。</li>
<li>模式，模式：指定一个行的范围。该语法不能包括BEGIN和END模式。</li>
<li>BEGIN：让用户指定在第一条输入记录被处理之前所发生的动作，通常可在这里设置全局变量。</li>
<li>END：让用户在最后一条输入记录被读取之后发生的动作。</li>
</ul>
<h3 id="-3-2-"><a href=""></a>3.2. 操作</h3>
<p>操作由一人或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内。主要有四部份：</p>
<ul>
<li>变量或数组赋值</li>
<li>输出命令</li>
<li>内置函数</li>
<li>控制流命令</li>
</ul>
<h2 id="-4-awk-"><a href=""></a>4. awk的环境变量</h2>
<p><a href=""></a></p>
<p><strong>Table 1. awk的环境变量</strong></p>
<p>变量描述$n当前记录的第n个字段，字段间由FS分隔。$0完整的输入记录。ARGC命令行参数的数目。ARGIND命令行中当前文件的位置(从0开始算)。ARGV包含命令行参数的数组。CONVFMT数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组。ERRNO最后一个系统错误的描述。FIELDWIDTHS字段宽度列表(用空格键分隔)。FILENAME当前文件名。FNR同NR，但相对于当前文件。FS字段分隔符(默认是任何空格)。IGNORECASE如果为真，则进行忽略大小写的匹配。NF当前记录中的字段数。NR当前记录数。OFMT数字的输出格式(默认值是%.6g)。OFS输出字段分隔符(默认值是一个空格)。ORS输出记录分隔符(默认值是一个换行符)。RLENGTH由match函数所匹配的字符串的长度。RS记录分隔符(默认是一个换行符)。RSTART由match函数所匹配的字符串的第一个位置。SUBSEP数组下标分隔符(默认值是\034)。</p>
<h2 id="-5-awk-"><a href=""></a>5. awk运算符</h2>
<p><a href=""></a></p>
<p><strong>Table 2. 运算符</strong></p>
<p>运算符描述= += -= /<em>= /= %= ^= /</em>/<em>=赋值?:C条件表达式||逻辑或&amp;&amp;逻辑与~ ~!匹配正则表达式和不匹配正则表达式&lt; &lt;= &gt; &gt;= != ==关系运算符空格连接+ -加，减/</em> / &amp;乘，除与求余+ - !一元加，减和逻辑非^ /<em>/</em>/*求幂++ --增加或减少，作为前缀或后缀$字段引用in数组成员</p>
<h2 id="-6-"><a href=""></a>6. 记录和域</h2>
<h3 id="-6-1-"><a href=""></a>6.1. 记录</h3>
<p>awk把每一个以换行符结束的行称为一个记录。</p>
<p>记录分隔符：默认的输入和输出的分隔符都是回车，保存在内建变量ORS和RS中。</p>
<p>$0变量：它指的是整条记录。如$ awk &#39;{print $0}&#39; test将输出test文件中的所有记录。</p>
<p>变量NR：一个计数器，每处理完一条记录，NR的值就增加1。如$ awk &#39;{print NR,$0}&#39; test将输出test文件中所有记录，并在记录前显示记录号。</p>
<h3 id="-6-2-"><a href=""></a>6.2. 域</h3>
<p>记录中每个单词称做“域”，默认情况下以空格或tab分隔。awk可跟踪域的个数，并在内建变量NF中保存该值。如$ awk &#39;{print $1,$3}&#39; test将打印test文件中第一和第三个以空格分开的列(域)。</p>
<h3 id="-6-3-"><a href=""></a>6.3. 域分隔符</h3>
<p>内建变量FS保存输入域分隔符的值，默认是空格或tab。我们可以通过-F命令行选项修改FS的值。如$ awk -F: &#39;{print $1,$5}&#39; test将打印以冒号为分隔符的第一，第五列的内容。</p>
<p>可以同时使用多个域分隔符，这时应该把分隔符写成放到方括号中，如$awk -F&#39;[:\t]&#39; &#39;{print $1,$3}&#39; test，表示以空格、冒号和tab作为分隔符。</p>
<p>输出域的分隔符默认是一个空格，保存在OFS中。如$ awk -F: &#39;{print $1,$5}&#39; test，$1和$5间的逗号就是OFS的值。</p>
<h2 id="-7-gawk-"><a href=""></a>7. gawk专用正则表达式元字符</h2>
<p>一般通用的元字符集就不讲了，可参考我的<a href="http://www.ringkee.com/jims/technic_folder/sed.htm" target="_blank">Sed</a>和<a href="http://www.ringkee.com/jims/technic_floder/grep.htm" target="_blank">Grep</a>学习笔记。以下几个是gawk专用的，不适合unix版本的awk。</p>
<p>\Y
匹配一个单词开头或者末尾的空字符串。
\B
匹配单词内的空字符串。
\&lt;
匹配一个单词的开头的空字符串，锚定开始。
>
匹配一个单词的末尾的空字符串，锚定末尾。
\w
匹配一个字母数字组成的单词。
\W
匹配一个非字母数字组成的单词。
\‘
匹配字符串开头的一个空字符串。
\&#39;
匹配字符串末尾的一个空字符串。</p>
<h2 id="-8-posix-"><a href=""></a>8. POSIX字符集</h2>
<p>可参考我的<a href="http://www.ringkee.com/jims/technic_folder/grep.htm" target="_blank">Grep学习笔记</a></p>
<h2 id="-9-"><a href=""></a>9. 匹配操作符(~)</h2>
<p>用来在记录或者域内匹配正则表达式。如$ awk &#39;$1 ~/^root/&#39; test将显示test文件第一列中以root开头的行。</p>
<h2 id="-10-"><a href=""></a>10. 比较表达式</h2>
<p>conditional expression1 ? expression2: expression3，例如：$ awk &#39;{max = {$1 &gt; $3} ? $1: $3: print max}&#39; test。如果第一个域大于第三个域，$1就赋值给max，否则$3就赋值给max。</p>
<p>$ awk &#39;$1 + $2 &lt; 100&#39; test。如果第一和第二个域相加大于100，则打印这些行。</p>
<p>$ awk &#39;$1 &gt; 5 &amp;&amp; $2 &lt; 10&#39; test,如果第一个域大于5，并且第二个域小于10，则打印这些行。</p>
<h2 id="-11-"><a href=""></a>11. 范围模板</h2>
<p>范围模板匹配从第一个模板的第一次出现到第二个模板的第一次出现之间所有行。如果有一个模板没出现，则匹配到开头或末尾。如$ awk &#39;/root/,/mysql/&#39; test将显示root第一次出现到mysql第一次出现之间的所有行。</p>
<h2 id="-12-passwd-"><a href=""></a>12. 一个验证passwd文件有效性的例子</h2>
<p><a href=""></a><img src="http://man.lupaworld.com/content/manage/ringkee/images/callouts/1.png" alt="1">$ cat /etc/passwd | awk -F: &#39;\ <a href=""></a><img src="http://man.lupaworld.com/content/manage/ringkee/images/callouts/2.png" alt="2">NF != 7{\ <a href=""></a><img src="http://man.lupaworld.com/content/manage/ringkee/images/callouts/3.png" alt="3">printf(&quot;line %d,does not have 7 fields:%s\n&quot;,NR,$0)}\ <a href=""></a><img src="http://man.lupaworld.com/content/manage/ringkee/images/callouts/4.png" alt="4">$1 !~ /[A-Za-z0-9]/{printf(&quot;line %d,non alpha and numeric user id:%d: %s\n,NR,$0)}\ <a href=""></a><img src="http://man.lupaworld.com/content/manage/ringkee/images/callouts/5.png" alt="5">$2 == &quot;/*&quot; {printf(&quot;line %d, no password: %s\n&quot;,NR,$0)}&#39;</p>
<p><a href=""><img src="http://man.lupaworld.com/content/manage/ringkee/images/callouts/1.png" alt="1"></a>
cat把结果输出给awk，awk把域之间的分隔符设为冒号。<a href=""><img src="http://man.lupaworld.com/content/manage/ringkee/images/callouts/2.png" alt="2"></a>
如果域的数量(NF)不等于7，就执行下面的程序。<a href=""><img src="http://man.lupaworld.com/content/manage/ringkee/images/callouts/3.png" alt="3"></a>
printf打印字符串&quot;line ?? does not have 7 fields&quot;，并显示该条记录。<a href=""><img src="http://man.lupaworld.com/content/manage/ringkee/images/callouts/4.png" alt="4"></a>
如果第一个域没有包含任何字母和数字，printf打印“no alpha and numeric user id&quot; ，并显示记录数和记录。<a href=""><img src="http://man.lupaworld.com/content/manage/ringkee/images/callouts/5.png" alt="5"></a>
如果第二个域是一个星号，就打印字符串“no passwd”，紧跟着显示记录数和记录本身。</p>
<h2 id="-13-"><a href=""></a>13. 几个实例</h2>
<ul>
<li>$ awk &#39;/^(no|so)/&#39; test-----打印所有以模式no或so开头的行。</li>
<li>$ awk &#39;/^[ns]/{print $1}&#39; test-----如果记录以n或s开头，就打印这个记录。</li>
<li>$ awk &#39;$1 ~/[0-9][0-9]$/(print $1}&#39; test-----如果第一个域以两个数字结束就打印这个记录。</li>
<li>$ awk &#39;$1 == 100 || $2 &lt; 50&#39; test-----如果第一个或等于100或者第二个域小于50，则打印该行。</li>
<li>$ awk &#39;$1 != 10&#39; test-----如果第一个域不等于10就打印该行。</li>
<li>$ awk &#39;/test/{print $1 + 10}&#39; test-----如果记录包含正则表达式test，则第一个域加10并打印出来。</li>
<li>$ awk &#39;{print ($1 &gt; 5 ? &quot;ok &quot;$1: &quot;error&quot;$1)}&#39; test-----如果第一个域大于5则打印问号后面的表达式值，否则打印冒号后面的表达式值。</li>
<li>$ awk &#39;/^root/,/^mysql/&#39; test----打印以正则表达式root开头的记录到以正则表达式mysql开头的记录范围内的所有记录。如果找到一个新的正则表达式root开头的记录，则继续打印直到下一个以正则表达式mysql开头的记录为止，或到文件末尾。</li>
</ul>
<h2 id="-14-awk-"><a href=""></a>14. awk编程</h2>
<h3 id="-14-1-"><a href=""></a>14.1. 变量</h3>
<ul>
<li>在awk中，变量不需要定义就可以直接使用，变量类型可以是数字或字符串。</li>
<li>赋值格式：Variable = expression，如$ awk &#39;$1 ~/test/{count = $2 + $3; print count}&#39; test,上式的作用是,awk先扫描第一个域，一旦test匹配，就把第二个域的值加上第三个域的值，并把结果赋值给变量count，最后打印出来。</li>
<li>awk可以在命令行中给变量赋值，然后将这个变量传输给awk脚本。如$ awk -F: -f awkscript month=4 year=2004 test，上式的month和year都是自定义变量，分别被赋值为4和2004。在awk脚本中，这些变量使用起来就象是在脚本中建立的一样。注意，如果参数前面出现test，那么在BEGIN语句中的变量就不能被使用。</li>
<li>域变量也可被赋值和修改，如$ awk &#39;{$2 = 100 + $1; print }&#39; test,上式表示，如果第二个域不存在，awk将计算表达式100加$1的值，并将其赋值给$2，如果第二个域存在，则用表达式的值覆盖$2原来的值。再例如：$ awk &#39;$1 == &quot;root&quot;{$1 =&quot;test&quot;;print}&#39; test，如果第一个域的值是“root”，则把它赋值为“test”，注意，字符串一定要用双引号。</li>
<li>内建变量的使用。变量列表在前面已列出，现在举个例子说明一下。$ awk -F: &#39;{IGNORECASE=1; $1 == &quot;MARY&quot;{print NR,$1,$2,$NF}&#39;test，把IGNORECASE设为1代表忽略大小写，打印第一个域是mary的记录数、第一个域、第二个域和最后一个域。<h3 id="-14-2-begin-"><a href=""></a>14.2. BEGIN模块</h3>
</li>
</ul>
<p>BEGIN模块后紧跟着动作块，这个动作块在awk处理任何输入文件之前执行。所以它可以在没有任何输入的情况下进行测试。它通常用来改变内建变量的值，如OFS,RS和FS等，以及打印标题。如：$ awk &#39;BEGIN{FS=&quot;:&quot;; OFS=&quot;\t&quot;; ORS=&quot;\n\n&quot;}{print $1,$2,$3} test。上式表示，在处理输入文件以前，域分隔符(FS)被设为冒号，输出文件分隔符(OFS)被设置为制表符，输出记录分隔符(ORS)被设置为两个换行符。$ awk &#39;BEGIN{print &quot;TITLE TEST&quot;}只打印标题。</p>
<h3 id="-14-3-end-"><a href=""></a>14.3. END模块</h3>
<p>END不匹配任何的输入文件，但是执行动作块中的所有动作，它在整个输入文件处理完成后被执行。如$ awk &#39;END{print &quot;The number of records is&quot; NR}&#39; test，上式将打印所有被处理的记录数。</p>
<h3 id="-14-4-"><a href=""></a>14.4. 重定向和管道</h3>
<ul>
<li>awk可使用shell的重定向符进行重定向输出，如：$ awk &#39;$1 = 100 {print $1 &gt; &quot;output_file&quot; }&#39; test。上式表示如果第一个域的值等于100，则把它输出到output_file中。也可以用&gt;&gt;来重定向输出，但不清空文件，只做追加操作。</li>
<li>输出重定向需用到getline函数。getline从标准输入、管道或者当前正在处理的文件之外的其他输入文件获得输入。它负责从输入获得下一行的内容，并给NF,NR和FNR等内建变量赋值。如果得到一条记录，getline函数返回1，如果到达文件的末尾就返回0，如果出现错误，例如打开文件失败，就返回-1。如：</li>
</ul>
<p>$ awk &#39;BEGIN{ &quot;date&quot; | getline d; print d}&#39; test。执行linux的date命令，并通过管道输出给getline，然后再把输出赋值给自定义变量d，并打印它。</p>
<p>$ awk &#39;BEGIN{&quot;date&quot; | getline d; split(d,mon); print mon[2]}&#39; test。执行shell的date命令，并通过管道输出给getline，然后getline从管道中读取并将输入赋值给d，split函数把变量d转化成数组mon，然后打印数组mon的第二个元素。</p>
<p>$ awk &#39;BEGIN{while( &quot;ls&quot; | getline) print}&#39;，命令ls的输出传递给geline作为输入，循环使getline从ls的输出中读取一行，并把它打印到屏幕。这里没有输入文件，因为BEGIN块在打开输入文件前执行，所以可以忽略输入文件。</p>
<p>$ awk &#39;BEGIN{printf &quot;What is your name?&quot;; getline name &lt; &quot;/dev/tty&quot; } $1 ~name {print &quot;Found&quot; name on line &quot;, NR &quot;.&quot;} END{print &quot;See you,&quot; name &quot;.&quot;} test。在屏幕上打印”What is your name?&quot;,并等待用户应答。当一行输入完毕后，getline函数从终端接收该行输入，并把它储存在自定义变量name中。如果第一个域匹配变量name的值，print函数就被执行，END块打印See you和name的值。</p>
<p>$ awk &#39;BEGIN{while (getline &lt; &quot;/etc/passwd&quot; &gt; 0) lc++; print lc}&#39;。awk将逐行读取文件/etc/passwd的内容，在到达文件末尾前，计数器lc一直增加，当到末尾时，打印lc的值。注意，如果文件不存在，getline返回-1，如果到达文件的末尾就返回0，如果读到一行，就返回1，所以命令 while (getline &lt; &quot;/etc/passwd&quot;)在文件不存在的情况下将陷入无限循环，因为返回-1表示逻辑真。</p>
<ul>
<li>可以在awk中打开一个管道，且同一时刻只能有一个管道存在。通过close()可关闭管道。如：$ awk &#39;{print $1, $2 | &quot;sort&quot; }&#39; test END {close(&quot;sort&quot;)}。awd把print语句的输出通过管道作为linux命令sort的输入,END块执行关闭管道操作。</li>
<li>system函数可以在awk中执行linux的命令。如：$ awk &#39;BEGIN{system(&quot;clear&quot;)&#39;。</li>
<li>fflush函数用以刷新输出缓冲区，如果没有参数，就刷新标准输出的缓冲区，如果以空字符串为参数，如fflush(&quot;&quot;),则刷新所有文件和管道的输出缓冲区。</li>
</ul>
<h3 id="-14-5-"><a href=""></a>14.5. 条件语句</h3>
<p>awk中的条件语句是从C语言中借鉴过来的，可控制程序的流程。</p>
<h3 id="-14-5-1-if-if-expression-statement-statement-"><a href=""></a>14.5.1. if语句格式： {if (expression){ statement; statement; ... } }</h3>
<p>$ awk &#39;{if ($1 &lt;$2) print $2 &quot;too high&quot;}&#39; test。如果第一个域小于第二个域则打印。</p>
<p>$ awk &#39;{if ($1 &lt; $2) {count++; print &quot;ok&quot;}}&#39; test.如果第一个域小于第二个域，则count加一，并打印ok。</p>
<h3 id="-14-5-2-if-else-if-expression-statement-statement-else-statement-statement-"><a href=""></a>14.5.2. if/else语句，用于双重判断。格式： {if (expression){ statement; statement; ... } else{ statement; statement; ... } }</h3>
<p>$ awk &#39;{if ($1 &gt; 100) print $1 &quot;bad&quot; ; else print &quot;ok&quot;}&#39; test。如果$1大于100则打印$1 bad,否则打印ok。</p>
<p>$ awk &#39;{if ($1 &gt; 100){ count++; print $1} else {count--; print $2}&#39; test。如果$1大于100，则count加一，并打印$1，否则count减一，并打印$1。</p>
<h3 id="-14-5-3-if-else-else-if-if-expression-statement-statement-else-if-expression-statement-statement-else-if-expression-statement-statement-else-statement-statement-"><a href=""></a>14.5.3. if/else else if语句，用于多重判断。格式： {if (expression){ statement; statement; ... } else if (expression){ statement; statement; ... } else if (expression){ statement; statement; ... } else { statement; statement; ... } }</h3>
<h3 id="-14-6-"><a href=""></a>14.6. 循环</h3>
<ul>
<li>awk有三种循环:while循环；for循环；special for循环。</li>
<li>$ awk &#39;{ i = 1; while ( i &lt;= NF ) { print NF,$i; i++}}&#39; test。变量的初始值为1，若i小于可等于NF(记录中域的个数),则执行打印语句，且i增加1。直到i的值大于NF.</li>
<li>$ awk &#39;{for (i = 1; i&lt;NF; i++) print NF,$i}&#39; test。作用同上。</li>
<li>breadkcontinue语句。break用于在满足条件的情况下跳出循环；continue用于在满足条件的情况下忽略后面的语句，直接返回循环的顶端。如：
{for ( x=3; x&lt;=NF; x++) if ($x&lt;0){print &quot;Bottomed out!&quot;; break}} {for ( x=3; x&lt;=NF; x++) if ($x==0){print &quot;Get next item&quot;; continue}}</li>
<li>next语句从输入文件中读取一行，然后从头开始执行awk脚本。如：
{if ($1 ~/test/){next} else {print} }</li>
<li>exit语句用于结束awk程序，但不会略过END块。退出状态为0代表成功，非零值表示出错。</li>
</ul>
<h3 id="-14-7-"><a href=""></a>14.7. 数组</h3>
<p>awk中的数组的下标可以是数字和字母，称为关联数组。</p>
<h3 id="-14-7-1-"><a href=""></a>14.7.1. 下标与关联数组</h3>
<ul>
<li>用变量作为数组下标。如：$ awk {name[x++]=$2};END{for(i=0;i&lt;NR;i++) print i,name[i]}&#39; test。数组name中的下标是一个自定义变量x，awk初始化x的值为0，在每次使用后增加1。第二个域的值被赋给name数组的各个元素。在END模块中，for循环被用于循环整个数组，从下标为0的元素开始，打印那些存储在数组中的值。因为下标是关健字，所以它不一定从0开始，可以从任何值开始。</li>
<li>special for循环用于读取关联数组中的元素。格式如下：
{for (item in arrayname){ print arrayname[item] } } $ awk &#39;/^tom/{name[NR]=$1}; END{for(i in name){print name[i]}}&#39; test。打印有值的数组元素。打印的顺序是随机的。</li>
<li>用字符串作为下标。如：count[&quot;test&quot;]</li>
<li>用域值作为数组的下标。一种新的for循环方式，for (index_value in array) statement。如:$ awk &#39;{count[$1]++} END{for(name in count) print name,count[name]}&#39; test。该语句将打印$1中字符串出现的次数。它首先以第一个域作数组count的下标，第一个域变化，索引就变化。</li>
<li>delete函数用于删除数组元素。如：$ awk &#39;{line[x++]=$1} END{for(x in line) delete(line[x])}&#39; test。分配给数组line的是第一个域的值，所有记录处理完成后，special for循环将删除每一个元素。<h3 id="-14-8-awk-"><a href=""></a>14.8. awk的内建函数</h3>
</li>
</ul>
<h3 id="-14-8-1-"><a href=""></a>14.8.1. 字符串函数</h3>
<ul>
<li>sub函数匹配记录中最大、最靠左边的子字符串的正则表达式，并用替换字符串替换这些字符串。如果没有指定目标字符串就默认使用整个记录。替换只发生在第一次匹配的时候。格式如下：
sub (regular expression, substitution string): sub (regular expression, substitution string, target string)</li>
</ul>
<p>实例：</p>
<p>$ awk &#39;{ sub(/test/, &quot;mytest&quot;); print }&#39; testfile $ awk &#39;{ sub(/test/, &quot;mytest&quot;); $1}; print }&#39; testfile</p>
<p>第一个例子在整个记录中匹配，替换只发生在第一次匹配发生的时候。如要在整个文件中进行匹配需要用到gsub</p>
<p>第二个例子在整个记录的第一个域中进行匹配，替换只发生在第一次匹配发生的时候。</p>
<ul>
<li>gsub函数作用如sub，但它在整个文档中进行匹配。格式如下：
gsub (regular expression, substitution string) gsub (regular expression, substitution string, target string)</li>
</ul>
<p>实例：</p>
<p>$ awk &#39;{ gsub(/test/, &quot;mytest&quot;); print }&#39; testfile $ awk &#39;{ gsub(/test/, &quot;mytest&quot;), $1 }; print }&#39; testfile</p>
<p>第一个例子在整个文档中匹配test，匹配的都被替换成mytest。</p>
<p>第二个例子在整个文档的第一个域中匹配，所有匹配的都被替换成mytest。</p>
<ul>
<li>index函数返回子字符串第一次被匹配的位置，偏移量从位置1开始。格式如下：
index(string, substring)</li>
</ul>
<p>实例：</p>
<p>$ awk &#39;{ print index(&quot;test&quot;, &quot;mytest&quot;) }&#39; testfile</p>
<p>实例返回test在mytest的位置，结果应该是3。</p>
<ul>
<li>length函数返回记录的字符数。格式如下：
length( string ) length</li>
</ul>
<p>实例：</p>
<p>$ awk &#39;{ print length( &quot;test&quot; ) }&#39; $ awk &#39;{ print length }&#39; testfile</p>
<p>第一个实例返回test字符串的长度。</p>
<p>第二个实例返回testfile文件中第条记录的字符数。</p>
<ul>
<li>substr函数返回从位置1开始的子字符串，如果指定长度超过实际长度，就返回整个字符串。格式如下：
substr( string, starting position ) substr( string, starting position, length of string )</li>
</ul>
<p>实例：</p>
<p>$ awk &#39;{ print substr( &quot;hello world&quot;, 7,11 ) }&#39;</p>
<p>上例截取了world子字符串。</p>
<ul>
<li>match函数返回在字符串中正则表达式位置的索引，如果找不到指定的正则表达式则返回0。match函数会设置内建变量RSTART为字符串中子字符串的开始位置，RLENGTH为到子字符串末尾的字符个数。substr可利于这些变量来截取字符串。函数格式如下：
match( string, regular expression )</li>
</ul>
<p>实例：</p>
<p>$ awk &#39;{start=match(&quot;this is a test&quot;,/[a-z]+$/); print start}&#39; $ awk &#39;{start=match(&quot;this is a test&quot;,/[a-z]+$/); print start, RSTART, RLENGTH }&#39;</p>
<p>第一个实例打印以连续小写字符结尾的开始位置，这里是11。</p>
<p>第二个实例还打印RSTART和RLENGTH变量，这里是11(start)，11(RSTART)，4(RLENGTH)。</p>
<ul>
<li>toupper和tolower函数可用于字符串大小间的转换，该功能只在gawk中有效。格式如下：
toupper( string ) tolower( string )</li>
</ul>
<p>实例：</p>
<p>$ awk &#39;{ print toupper(&quot;test&quot;), tolower(&quot;TEST&quot;) }&#39;</p>
<ul>
<li>split函数可按给定的分隔符把字符串分割为一个数组。如果分隔符没提供，则按当前FS值进行分割。格式如下：
split( string, array, field separator ) split( string, array )</li>
</ul>
<p>实例：</p>
<p>$ awk &#39;{ split( &quot;20:18:00&quot;, time, &quot;:&quot; ); print time[2] }&#39;</p>
<p>上例把时间按冒号分割到time数组内，并显示第二个数组元素18。</p>
<h3 id="-14-8-2-"><a href=""></a>14.8.2. 时间函数</h3>
<ul>
<li>systime函数返回从1970年1月1日开始到当前时间(不计闰年)的整秒数。格式如下：
systime()</li>
</ul>
<p>实例：</p>
<p>$ awk &#39;{ now = systime(); print now }&#39;</p>
<ul>
<li>strftime函数使用C库中的strftime函数格式化时间。格式如下：
systime( [format specification][,timestamp] )</li>
</ul>
<p><a href=""></a></p>
<p><strong>Table 3. 日期和时间格式说明符</strong></p>
<p>格式描述%a星期几的缩写(Sun)%A星期几的完整写法(Sunday)%b月名的缩写(Oct)%B月名的完整写法(October)%c本地日期和时间%d十进制日期%D日期 08/20/99%e日期，如果只有一位会补上一个空格%H用十进制表示24小时格式的小时%I用十进制表示12小时格式的小时%j从1月1日起一年中的第几天%m十进制表示的月份%M十进制表示的分钟%p12小时表示法(AM/PM)%S十进制表示的秒%U十进制表示的一年中的第几个星期(星期天作为一个星期的开始)%w十进制表示的星期几(星期天是0)%W十进制表示的一年中的第几个星期(星期一作为一个星期的开始)%x重新设置本地日期(08/20/99)%X重新设置本地时间(12：00：00)%y两位数字表示的年(99)%Y当前月份%Z时区(PDT)%%百分号(%)</p>
<p>实例：
$ awk &#39;{ now=strftime( &quot;%D&quot;, systime() ); print now }&#39; $ awk &#39;{ now=strftime(&quot;%m/%d/%y&quot;); print now }&#39;</p>
<h3 id="-14-8-3-"><a href=""></a>14.8.3. 内建数学函数</h3>
<p><a href=""></a></p>
<p><strong>Table 4. </strong></p>
<p>函数名称返回值atan2(x,y)y,x范围内的余切cos(x)余弦函数exp(x)求幂int(x)取整log(x)自然对数rand()随机数sin(x)正弦sqrt(x)平方根srand(x)x是rand()函数的种子int(x)取整，过程没有舍入rand()产生一个大于等于0而小于1的随机数</p>
<h3 id="-14-8-4-"><a href=""></a>14.8.4. 自定义函数</h3>
<p>在awk中还可自定义函数，格式如下：</p>
<p>function name ( parameter, parameter, parameter, ... ) { statements return expression /# the return statement and expression are optional }</p>
<h2 id="-15-how-to"><a href=""></a>15. How-to</h2>
<ul>
<li>如何把一行竖排的数据转换成横排？</li>
</ul>
<p>awk &#39;{printf(&quot;%s,&quot;,$1)}&#39; filename</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/unix/">unix</a></li></span></span> | <span class="tags">Tagged <a href="/tags/unix/" class="label label-primary">unix</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-unix--Awk学习笔记/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-unix--Awk学习笔记" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-gitgithub--2013年前端开发者如何提升自己-Web前端-ITeye资讯/">2013年前端开发者如何提升自己 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-gitgithub--2013年前端开发者如何提升自己-Web前端-ITeye资讯/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="2013-web-iteye-">2013年前端开发者如何提升自己 - Web前端 - ITeye资讯</h1>
<p><a href="http://www.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://www.iteye.com/login" target="_blank">登录</a> <a href="http://www.iteye.com/signup" target="_blank">注册</a></p>
<p><a href="http://www.iteye.com/" target="_blank"><img src="&quot;ITeye-最棒的软件开发交流社区&quot;" alt="ITeye3.0"></a></p>
<p><a href="http://www.iteye.com/news" target="_blank">资讯频道</a> → <a href="http://www.iteye.com/news/category/web" target="_blank">Web前端</a></p>
<h3 id="20-">20顶</h3>
<p>0踩</p>
<p><a href="http://www.iteye.com/news/category/web" title="查看Web前端分类资讯" target="_blank"><img src="" alt="Web前端"></a></p>
<h3 id="-2013-2013-"><img src="" alt="转载新闻"> <a href="&quot;2013年前端开发者如何提升自己&quot;">2013年前端开发者如何提升自己</a></h3>
<p>2012-12-28 16:07 by 见习编辑 <a href="http://wnoum.iteye.com/" title="WnouM" target="_blank">WnouM</a> <a href="http://www.iteye.com/news/26873#comments" target="_blank">评论(10)</a> 有6735人浏览</p>
<p><a href="http://www.iteye.com/news/tag/css" target="_blank">css</a> <a href="http://www.iteye.com/news/tag/javascript" target="_blank">javascript</a> <a href="http://www.iteye.com/news/tag/%E6%8A%80%E8%83%BD" target="_blank">技能</a> <a href="http://www.iteye.com/news/tag/html5" target="_blank">html5</a></p>
<p><a href="http://www.iteye.com/news/26873#" target="_blank">&lt;</a> <a href="http://www.iteye.com/news/26873#" target="_blank">&gt;</a>  猎头职位: <a href="http://www.iteye.com/jobs/2504" target="_blank">陕西:  西安：senior java engineer</a>
大部分人非常在意个人在技术上的提升。但是保持对新技术的了解是一项不小的挑战， 毕竟我们需要的信息在数量上过于庞大。2012年里，伴随着前端发展的是大量的革命性突破和对前端的重新定义。
我们在实践的路上飞速前进，具体的进步体现在使用抽象化，优秀的代码质量，维护性上的提升以及更好的性能。如果你实在忙到没有时间来跟上最新的技术，不用担心。
随着假日的来临，我们就有了一些空闲的时间可以自己支配，我想，如果我把我收集的前端相关的精品讨论列表分享出来，那一定会对大家有一些帮助。你不需要把所有的都阅读一遍，但是这些相关的建议会让你了解更多相关的知识，为明年成为一名更好的前工程端开发师做准备。
以下是一些关于前端开发的优秀的PPT，你可以通过文中的链接来访问。
<strong>一、基础部分</strong>
<strong>走在技术前沿的方法</strong>
PPT：<a href="https://speakerdeck.com/chriscoyier/how-to-stay-up-to-date-on-web-technology" target="_blank">How to Stay Up to Date on Web Stuff</a>, Chris Coyier
即使技术相关的理念会不断变化，我们依然可以做到让自己处于技术的前沿。
<img src="" alt="">
<strong>确保你的开发模式已经跟上时代</strong>
PPT：<a href="https://speakerdeck.com/rmurphey/a-new-baseline-for-front-end-devs" target="_blank">A New Baseline for Front-End Developers</a>, Rebecca Murphey
曾经在我们编辑文件的时候，本地测试完然后传到ftp上是最常规的做法。我们通过一个前端是否能编写一个兼容ie6的页面来判断他的前端水平。我们在html，css和javascript中的技术都不够强悍。
这样的情况在近几年有了很大的转变，随着工作方式的改进和各类工具的推出。前端开发越来越受到重视，这个主题讲解了前端在开发中的新起点。
<img src="" alt="">
<strong>二、前端开发工程师的新起点</strong>
<strong>理解浏览器在屏幕后面的工作原理</strong>
PPT：<a href="https://speakerdeck.com/dmosher/so-you-want-to-be-a-front-end-engineer" target="_blank">So, You Want to Be a Front-End Engineer</a>, David Mosher (<a href="http://www.youtube.com/watch?v=Lsg84NtJbmI" target="_blank">Video</a>)
有些人会说，浏览器是他所知道的开发平台中最不稳定的一个。如果你是一个客户端开发工程师，理解浏览器内部工作原理会帮助你作出更好的决定，并且你也会赞叹那些最佳实践背后的种种辩论。在这个今年最好的主题之一里，david mosher会待你了解浏览器的解析和页面的渲染。
<img src="" alt="">
<strong>了解web平台现在需要提供什么</strong>
PPT：<a href="https://speakerdeck.com/addyosmani/tooling-for-the-modern-webapp-developer" target="_blank">Tooling for the Modern Web App Developer</a>, Addy Osmani
web在不断的进化，了解这个平台中新出的技术不是一件容易的事情。html5的新特性让我们可以构建一个完全崭新的web应用，包含很多以前无法实现的特性（至少，在没有插件的情况下）。
在这个主题中，我的队友eric会带你了解html5的痛苦边缘，关注很多解决现实世界问题的方案。你会了解媒体流，设备输入，现代css设计，媒体捕捉，文件i/o等等。
<img src="" alt="">
<strong>三、工作方式</strong>
<strong>web app开发工程师的工作方式</strong>
无论你在使用coffeescript还是javascript，less还是sass，构建一个好的web应用在现在需要大量引用外部资源，框架，工具和结合工具来将他们整合到一起。简单地说，你需要一个打屁股用的实用腰带。
在这个主题中，你会了解到当前前端系统的概况，并学习到一个新工具来整合这些系统，叫做yeoman。
你还可以访问这个主题的扩展版本。
PPT：<a href="https://speakerdeck.com/addyosmani/tooling-for-the-modern-webapp-developer" target="_blank">Tooling For The Modern WebApp Developer</a>
<img src="" alt="">
<strong>web设计师的工作方式</strong>
PPT：<a href="https://speakerdeck.com/chriscoyier/a-modern-web-designers-workflow" target="_blank">A Modern Web Designer’s Workflow</a>, Chris Coyier (<a href="http://www.youtube.com/watch?v=vsTrAfJFLXI" target="_blank">Video</a>)
今天我们对web构架师的要求很高。如果在以前，这个岗位名称已经表达了它所对应的工作，但是现在不仅仅是视觉设计岗位，甚至涉及到交互的构建。设计师需要考虑不同形状，不同尺寸，不同连接方式的不同设备，并且这些设备下都要能正常工作。
作为一个设计师，你通常需要在团队之间沟通和分享代码，并且需要了解很多不同的技术。在这个主题中，chris coyier会说到很多令人赞叹的工具来帮助手头的工作更加顺利地完成，还会讨论应该做些什么来提供一个高水准的现代工作流。
<img src="" alt="">
<strong>移动web开发的工作方式</strong>
PPT：<a href="http://petelepage.com/presentations/2012/qcon/" target="_blank">Mobile Web Developers Toolbelt</a>, Pete Le Page (<a href="https://developers.google.com/live/shows/11154750/" target="_blank">Video</a>)
移动端开发和PC端开发有很大的不同，这个主题讲述了各种工具来让移动web开发更加方便，让移动web开发更加容易。
<img src="" alt="">
<strong>如何调试</strong>
PPT：<a href="http://oredev.org/2012/sessions/secrets-of-the-chrome-developer-tools" target="_blank">Secrets of the Chrome DevTools</a>, Patrick Dubroy (<a href="http://vimeo.com/53073654" target="_blank">Video</a>)
深度了解谷歌开发者工具
<img src="" alt="">
<strong>四、面向未来的开发</strong>
<strong>CSS</strong>
PPT：<a href="https://speakerdeck.com/stopsatgreen/the-css-of-tomorrow-revised" target="_blank">The CSS of Tomorrow</a>, Peter Gasston
这个主题介绍了CSS给你现在的开发带来了什么，作为一个CSS程序员，如何利用CSS3来实现面向未来的开发。
<img src="" alt="">
<strong>JAVASCRIPT</strong>
PPT：<a href="https://speakerdeck.com/dherman/the-future-of-javascript-1" target="_blank">The Future of JavaScript</a>, Dave Herman
了解ES6的新特性，以及使用方式
<img src="" alt="">
<strong>WEB APPLICATIONS</strong>
PPT：<a href="http://html5-demos.appspot.com/static/webcomponents/index.html" target="_blank">Web Components and the Future of Web App Development</a>, Eric Bidelman
如何更好地将各种新技术整合到你的web应用中。
<img src="" alt="">
<strong>五、CSS</strong>
<strong>CSS领域中的艺术</strong>
PPT：<a href="http://darcyclarke.me/dev/hawtcss/" target="_blank">All the New CSS Hawtness</a>, Darcy Clarke
这个主题介绍了最新的CSS实现以及相关的标准，并且学习到这些新的CSS技术是如何改变我们的日常开发。
<img src="" alt="">
<strong>模块化CSS</strong>
PPT：<a href="https://speakerdeck.com/snookca/your" target="_blank">Your CSS Is a Mess</a>, Jonathan Snook
大部分人的CSS代码都是一团糟，在这个主题中，你会知道如何解决CSS的模块化问题，方便管理和维护。
<img src="" alt="">
<strong>CSS的预处理器</strong>
PPT：<a href="https://speakerdeck.com/bermonpainter/css-pre-processors-stylus-less-and-sass" target="_blank">CSS Pre-Processors</a>, Bermon Painter
如果你还没有用过CSS预处理器，那你就OUT了。这个主题会对比较流行的几个CSS预处理器进行概述。
<img src="" alt="">
<strong>文档</strong>
PPT：<a href="https://speakerdeck.com/kneath/a-better-future-with-kss" target="_blank">A Better Future With KSS</a>, Kyle Neath
本主题介绍了Kyle的一个工具，KSS，用于生成CSS文件的文档和代码格式化。
<img src="" alt="">
<strong>六、JavaScript</strong>
<strong>代码风格的重要性</strong>
PPT：<a href="http://www.slideshare.net/nzakas/maintainable-javascript-2012" target="_blank">Maintainable JavaScript</a>, Nicholas Zakas
编写有趣的JavaScript代码和编写专业的JavaScript代码是两码事，在Zakas的这个主题中，你会学习到如何做到编写可持续性维护的JavaScript代码
<img src="" alt="">
<strong>构建大规模的APP</strong>
PPT：<a href="http://spadgos.github.com/sfjs-next-soundcloud/" target="_blank">SoundCloud’s Stack</a>, Nick Fisher
这个主题中，来自<a href="https://soundcloud.com/" target="_blank">SoundCloud</a>的Nick Fisher会介绍他们公司开发一个大规模JavaScript APP的故事，并且分享他们的开发步骤以及如何提高开发效率。
<img src="" alt="">
<strong>重新思考应用的结构</strong>
PPT：<a href="https://docs.google.com/a/google.com/presentation/pub?id=1kDvp3O2xZ6ZSXF4F1YTbg_jy_ei2sFl38f3c6VkBfSo&amp;start=false&amp;loop=false&amp;delayms=3000" target="_blank">Re-Imagining the Browser With AngularJS</a>, Igor Minar
在这个主题中，你会了解如何将未来Web平台的力量使用到当前的Web应用中。
<img src="" alt="">
<strong>国际化</strong>
PPT：<a href="http://i18n.asciidisco.com/" target="_blank">Entschuldigen you, parlez vouz JavaScript</a>, Sebastian Golasch (<a href="http://www.youtube.com/watch?feature=player_embedded&amp;v=ekiZuLl1mWc" target="_blank">Video</a>)
这个主题中，Sebastian介绍了从如何定位现实世界中的国际化问题，到如何用优雅的方式进行解决。
<img src="" alt="">
<strong>模式和原则</strong>
PPT：<a href="https://speakerdeck.com/bkeepers/the-plight-of-pinocchio" target="_blank">The Plight of Pinocchio</a>, Brandon Keepers
我们需要将JavaScript作为一门真正的语言，就需要能在JavaScript上使用真正的语言会使用的各种最佳实践。JavaScript不再是一门玩具语言。
<img src="" alt="">
<strong>什么时候来延迟(惰性)加载脚本</strong>
PPT：<a href="https://speakerdeck.com/mmarcon/how-late-is-later-a-lazy-loading-solution-on-the-edge-between-very-clever-and-incredibly-mad" target="_blank">How Late Is Later?</a>, Massimiliano Marcon
我们都知道延迟(惰性)加载脚本可以提高Web应用的加载时间，那么什么时候才是正确的时间来加载脚本呢？
<img src="" alt="">
<strong>七、移动Web开发</strong>
PPT：<a href="http://www.slideshare.net/ysaw/html5-touch-interfaces-sxsw-extended-version" target="_blank">Creating Responsive HTML5 Touch Interfaces</a>, Stephen Woods (<a href="http://www.youtube.com/watch?v=lcD9CF0bxyk" target="_blank">Video</a> | <a href="http://audio.sxsw.com/2012/podcasts/11-HIL-Creating_Responsive_HTML5_Touch_Interfaces.mp3" target="_blank">Audio</a>)
如何去解决UI和用户间交互的问题，避免这些陷阱是很多应用开发者在未来需要面对的。
<img src="" alt="">
<strong>来自滚动条的挑战</strong>
PPT：<a href="http://markdalgleish.com/presentations/embracingtouch/" target="_blank">Embracing Touch: Cross-Platform Scrolling</a>, Mark Dalgleish (<a href="http://www.youtube.com/watch?feature=player_embedded&amp;v=Ii5AkRNSVHg" target="_blank">Video</a>)
滚动效果是最流行的移动页面的方式。可惜滑动的效果总是不能与原生滚动条媲美。我们应该如何在移动浏览器上解决这个问题？
<img src="" alt="">
<strong>原生，HTML5和混合的应用</strong>
PPT：<a href="http://www.slideshare.net/zzeran/fowa-2012-native-html5-and-hybrid-mobile-app-development-reallife-experiences-eran-zinman" target="_blank">Native, HTML5 and Hybrid Mobile Development</a>, Eran Zinman
这个主题中，Eran分享了他在跨平台开发中的经验。
<img src="" alt="">
<strong>性能，分布和facebook在HTML5上的实践</strong>
PPT：<a href="https://speakerdeck.com/sicross/on-the-future-of-mobile-web-apps" target="_blank">On the Future of Mobile Web Apps</a>, Simon Cross
facebook利用HTML5做了什么？还有什么需要改进？
<img src="" alt="">
<strong>移动开发的调试工具</strong>
PPT：<a href="https://speakerdeck.com/rem/mobile-debugging" target="_blank">Mobile Debugging</a>, Remy Sharp
<img src="" alt="">
<strong>响应式设计技术</strong>
PPT：<a href="https://speakerdeck.com/smashingmag/responsive-web-design-clever-tips-and-techniques" target="_blank">Responsive Web Design: Clever Tips and Techniques</a>, Vitaly Friedman
这个主题提供了响应式设计实现的概述。
<img src="" alt="">
<strong>八、Web Apps</strong>
<strong>离线的web应用</strong>
PPT：<a href="https://speakerdeck.com/triblondon/offline-rules-full-frontal-2012" target="_blank">Offline Rules</a>, Andrew Betts (<a href="http://www.youtube.com/watch?feature=player_embedded&amp;v=RrGo1Sz4IgQ" target="_blank">Video</a>)
如何在Web应用中做到客户端的存储，并且如何将其用在提高网站的体验上。
<img src="" alt="">
<strong>STATE OF THE ART</strong>
PPT：<a href="http://lanyrd.com/2012/full-frontal/sztqg/" target="_blank">Building Web Apps of the Future: Tomorrow, Today and Yesterday</a>, Paul Kinlan (<a href="http://2012.full-frontal.org/audio/5-paul.mp3" target="_blank">Audio</a>)
Paul介绍了如何构建面向未来的web app。
<img src="" alt="">
<strong>客户端存储</strong>
PPT：<a href="https://speakerdeck.com/triblondon/storage-in-the-browser-londonjs" target="_blank">Storage in the Browser</a>, Andrew Betts
<img src="" alt="">
<strong>应用缓存</strong>
PPT：<a href="https://speakerdeck.com/jaffathecake/application-cache-douchebag" target="_blank">Application Cache: Douchebag</a>, Jake Archibald (<a href="http://vimeo.com/43336762" target="_blank">Video</a>)
如何利用Application Cache来构建你的网站
<img src="" alt="">
<strong>九、性能</strong>
<strong>CSS</strong>
PPT：<a href="https://dl.dropbox.com/u/39519/talks/cssperf-cssdevconf/index.html" target="_blank">High-Performance CSS</a>, Paul Irish
找出那些影响页面性能的CSS，比如引发浏览器绘制至少多70毫秒的box-shadow，以及解决方案。
<img src="" alt="">
PPT：<a href="https://speakerdeck.com/jonrohan/githubs-css-performance" target="_blank">GitHub’s CSS Performance</a>, Jon Rohan
<img src="" alt="">
<strong>避免JANK</strong>
PPT：<a href="http://jankfree.com/velocity-europe/index.html" target="_blank">Jank-Free: In Pursuit of Smooth Web Apps</a>, Tom Wiltzius
JANK是指当动画顿卡，特效执行缓慢，或者页面滚动慢时的一种状态。该主题介绍了如何避免这些状态。
<img src="" alt="">
<strong>Web</strong>
PPT：<a href="http://www.igvita.com/slides/2012/webperf-crash-course.pdf" target="_blank">Building Faster Websites</a>, Ilya Grigorik
如何在网站的角度考虑整体性能的提升。
<img src="" alt="">
<strong>JavaScript</strong>
PPT：<a href="http://v8-io12.appspot.com/" target="_blank">Breaking the JavaScript Speed Limit With V8</a>, Daniel Clifford
如何打破V8执行脚本的速度限制。
<img src="" alt="">
<strong>十、测试</strong>
<strong>理解代码的不好的原因</strong>
PPT：<a href="https://speakerdeck.com/bkeepers/why-our-code-smells" target="_blank">Why Our Code Smells</a>, Brandon Keepers (<a href="http://www.youtube.com/watch?v=JxPKljUkFQw" target="_blank">Video</a>)
这个主题中，Brandon会介绍他日常的代码，寻找那些会引起问题的劣质代码，理解为什么会出现这些代码，并且这些代码意味着什么，最后介绍如何对其进行重构。
<img src="" alt="">
<strong>CURRENT STATE OF THE ART</strong>
PPT：<a href="https://speakerdeck.com/twinturbo/javascript-testing-the-holy-grail" target="_blank">JavaScript Testing: The Holy Grail</a>, Adam Hawkins (<a href="http://www.youtube.com/watch?feature=player_detailpage&amp;v=YdFQ29oK50M" target="_blank">Video</a>)
如何利用测试工具，来保证一个应用的体验。
<img src="" alt="">
<strong>提高代码的可测试性</strong>
PPT：<a href="https://speakerdeck.com/rmurphey/writing-testable-javascript-mocha-version" target="_blank">Writing Testable JavaScript</a>, Rebecca Murphey (<a href="http://2012.full-frontal.org/audio/6-rebecca.mp3" target="_blank">Audio</a>)
<img src="" alt="">
<strong>十一、总结</strong>
花在思考自己技术提升上的时间是非常值得的。磨练的越多，你就更有机会去成为一名优秀的工程师。
这个列表不一定会覆盖今年所有优秀的PPT，不过还是希望能给大家提供一些指引。去阅读一些你感兴趣的。这样的阅读会提高你的能力，也希望能真正为你的日常开发提供帮助。
最后，祝大家享受节日，新的一年有更多的进步和突破。
原文：<a href="http://www.smashingmagazine.com/2012/12/22/talks-to-help-you-become-a-better-front-end-engineer-in-2013/" target="_blank">Talks To Help You Become A Better Front-End Engineer In 2013</a>（译文来自<a href="http://w3ctech.com/p/1395" target="_blank">w3ctech</a>）</p>
<ul>
<li><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></li>
<li><p>大小: 25.8 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 22.5 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 44.2 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 13.5 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 18.7 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 11.8 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 15 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 24 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 69.1 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 18.6 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 10.5 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 36.5 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 57.6 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 26.7 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 32 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 31 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 16.2 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 25.1 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 36.3 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 56 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 40.1 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 54.7 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 26.3 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 16.1 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 17.9 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 29.3 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 66.6 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 35.1 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 37.1 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 27.7 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 32.9 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 12.3 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 10.4 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 9.9 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 12.8 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 17.4 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 55.5 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 79.1 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 48.7 KB</p>
</li>
<li><p><a href="http://www.iteye.com/news/26873#" target="_blank">查看图片附件</a>
来自: <a href="http://w3ctech.com/p/1395" target="_blank">w3ctech</a></p>
</li>
</ul>
<p>分享到： <a href="&quot;分享到新浪微博&quot;"><img src="" alt=""></a> <a href="&quot;分享到腾讯微博&quot;"><img src="" alt=""></a></p>
<p><strong>20</strong>
顶
<strong>0</strong>
踩
评论 共 10 条 请<a href="http://www.iteye.com/login" target="_blank">登录</a>后发表评论 <a href=""></a></p>
<h3 id="10-vtaminn-http-vtaminn-iteye-com-vtaminn-2013-01-04-08-49">10 楼 <a href="http://vtaminn.iteye.com/" title="vtaminn" target="_blank">vtaminn</a> 2013-01-04 08:49</h3>
<p>很好。很强悍！</p>
<h3 id="9-rayzy1991-http-rayzy1991-iteye-com-rayzy1991-2013-01-01-16-50">9 楼 <a href="http://rayzy1991.iteye.com/" title="rayzy1991" target="_blank">rayzy1991</a> 2013-01-01 16:50</h3>
<p><img src="" alt=""> 革命尚未成功，同志仍需努力！</p>
<h3 id="8-dianthus-http-dianthus-iteye-com-dianthus-2012-12-31-13-38">8 楼 <a href="http://dianthus.iteye.com/" title="dianthus" target="_blank">dianthus</a> 2012-12-31 13:38</h3>
<p>mark..</p>
<h3 id="7-caizi12-http-caizi12-iteye-com-caizi12-2012-12-31-10-06">7 楼 <a href="http://caizi12.iteye.com/" title="caizi12" target="_blank">caizi12</a> 2012-12-31 10:06</h3>
<p>”前端开发工程师的新起点“ 配图里面的人物不是“军团要塞”上的火箭兵吗？</p>
<h3 id="6-sdhery-http-sdhery-iteye-com-sdhery-2012-12-30-09-14">6 楼 <a href="http://sdhery.iteye.com/" title="sdhery" target="_blank">sdhery</a> 2012-12-30 09:14</h3>
<p>文章很长，很好很强大<img src="" alt=""> <img src="" alt=""></p>
<h3 id="5-geminiyellow-http-swt-iteye-com-geminiyellow-2012-12-29-18-47">5 楼 <a href="http://swt.iteye.com/" title="geminiyellow" target="_blank">geminiyellow</a> 2012-12-29 18:47</h3>
<p><img src="" alt=""> nm，好多</p>
<h3 id="4-tianshaojie-http-tianshaojie-iteye-com-tianshaojie-2012-12-29-11-20">4 楼 <a href="http://tianshaojie.iteye.com/" title="tianshaojie" target="_blank">tianshaojie</a> 2012-12-29 11:20</h3>
<p><img src="" alt=""> 方向大而全</p>
<h3 id="3-topcss-http-topcss-iteye-com-topcss-2012-12-29-09-18">3 楼 <a href="http://topcss.iteye.com/" title="topcss" target="_blank">topcss</a> 2012-12-29 09:18</h3>
<p>很多打不开呀<img src="" alt=""></p>
<h3 id="2-beeke-http-beeke-iteye-com-beeke-2012-12-28-21-01">2 楼 <a href="http://beeke.iteye.com/" title="beeke" target="_blank">beeke</a> 2012-12-28 21:01</h3>
<p>这篇文章很酷<img src="" alt=""></p>
<h3 id="1-xingkongxieyang-http-xingkongxieyang-iteye-com-xingkongxieyang-2012-12-28-17-34">1 楼 <a href="http://xingkongxieyang.iteye.com/" title="xingkongxieyang" target="_blank">xingkongxieyang</a> 2012-12-28 17:34</h3>
<p>很好，很强大！</p>
<h3 id="-">发表评论</h3>
<p><a href="http://www.iteye.com/login" target="_blank"><img src="" alt=""> 您还没有登录,请您登录后再发表评论</a></p>
<p><a href="http://www.iteye.com/news/25338-iteye-csdn-recruitment" target="_blank"><strong>2012 ITeye&amp;CSDN最新职位火热招聘中！</strong>急聘ruby研发、编辑、运营！请将简历发送至hrzhaopin@csdn.net</a></p>
<h3 id="-">相关资讯</h3>
<ul>
<li><a href="http://www.iteye.com/news/26875" target="_blank">24 个实用的 HTML5 前端开发教程</a></li>
<li><a href="http://www.iteye.com/news/26835" target="_blank">16 个高效测试响应式设计界面的工具</a></li>
<li><p><a href="http://www.iteye.com/news/26863" target="_blank">15 个最佳 jQuery 翻书效果插件</a></p>
<h3 id="-">相关讨论</h3>
</li>
<li><p><a href="http://www.iteye.com/topic/1127320" target="_blank">javascript和html5写的五子棋</a></p>
</li>
<li><a href="http://www.iteye.com/topic/1128304" target="_blank">使用JavaScript实现数独解题程序</a></li>
<li><a href="http://www.iteye.com/topic/1128396" target="_blank">一个静态页面AJAX 读取服务器上的数据的问题</a></li>
<li><a href="http://www.iteye.com/topic/1128296" target="_blank">移动3g为什么这么坑爹</a></li>
<li><a href="http://www.iteye.com/topic/734871" target="_blank">豆豆趣事(十九)----游记(上)</a></li>
</ul>
<h3 id="-">相关博客</h3>
<ul>
<li><a href="http://fxly0401.iteye.com/blog/1749656" target="_blank">Java/Tomcat on Windows Azure</a></li>
<li><a href="http://pypy.iteye.com/blog/1754298" target="_blank">swift benchmark 转载</a></li>
<li><a href="http://yixiu285.iteye.com/blog/1751554" target="_blank">java web学习路线图</a></li>
<li><a href="http://yuandingjiema.iteye.com/blog/1750042" target="_blank">Maven入门示例(2)：调试helloworld webapp程序</a></li>
<li><a href="http://weli.iteye.com/blog/1747308" target="_blank">使用JPDA调试Tomcat（一）</a></li>
<li><a href="http://www.iteye.com/" target="_blank">首页</a></li>
<li><a href="http://www.iteye.com/news" target="_blank">资讯</a></li>
<li><a href="http://www.iteye.com/magazines" target="_blank">精华</a></li>
<li><a href="http://www.iteye.com/forums" target="_blank">论坛</a></li>
<li><a href="http://www.iteye.com/ask" target="_blank">问答</a></li>
<li><a href="http://www.iteye.com/blogs" target="_blank">博客</a></li>
<li><a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a></li>
<li><a href="http://www.iteye.com/groups" target="_blank">群组</a></li>
<li><a href="http://job.iteye.com/iteye" target="_blank">招聘</a></li>
<li><a href="http://www.iteye.com/search" target="_blank">搜索</a></li>
<li><a href="http://www.iteye.com/index/service" target="_blank">广告服务</a></li>
<li><a href="http://webmaster.iteye.com/" target="_blank">ITeye黑板报</a></li>
<li><a href="http://www.iteye.com/index/contactus" target="_blank">联系我们</a></li>
<li><a href="http://www.iteye.com/index/friend_links" target="_blank">友情链接</a></li>
</ul>
<p>© 2003-2012 ITeye.com. [ <a href="http://www.miibeian.gov.cn/" target="_blank">京ICP证110151号</a> 京公网安备110105010620 ]
百联优力(北京)投资有限公司 版权所有 <img src="" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/git&github/">git&github</a></li></span></span> | <span class="tags">Tagged <a href="/tags/git&github/" class="label label-primary">git&github</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-gitgithub--2013年前端开发者如何提升自己-Web前端-ITeye资讯/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-gitgithub--2013年前端开发者如何提升自己-Web前端-ITeye资讯" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-gitgithub--Git详解之一：Git起步/">Git详解之一：Git起步</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-gitgithub--Git详解之一：Git起步/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="git-git-">Git详解之一：Git起步</h1>
<p>原文：<a href="http://git-scm.com/book/zh" target="_blank">《Pro Git》</a></p>
<p><strong>起步</strong></p>
<p>本章介绍开始使用 Git 前的相关知识。我们会先了解一些版本控制工具的历史背景，然后试着让 Git 在你的系统上跑起来，直到最后配置好，可以正常开始开发工作。读完本章，你就会明白为什么 Git 会如此流行，为什么你应该立即开始使用它。（<a href="http://blog.jobbole.com/tag/git/" target="_blank">查看Git详解系列的全部文章</a>）</p>
<p><strong>1.1 关于版本控制
</strong></p>
<p>什么是版本控制？我真的需要吗？版本控制是一种记录若干文件内容变化，以便将来查阅特定版本修订情况的系统。在本书所展示的例子中，我们仅对保存着软件源代码的文本文件作版本控制管理，但实际上，你可以对任何类型的文件进行版本控制。</p>
<p>如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本（这或许是你非常渴望拥有的功能）。采用版本控制系统 （VCS）是个明智的选择。有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态。你可以比较文件的变化细节，查出最 后是谁修改了哪个地方，从而导致出现怪异问题，又是谁在何时报告了某个功能缺陷等等。使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改 的改删的删，你也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。</p>
<p><strong>本地版本控制系统</strong></p>
<p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单。不过坏处也不少：有时候会混淆所在的工作目录，一旦弄错文件丢了数据就没法撤销恢复。</p>
<p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异（见图 1-1）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start1.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a></p>
<p>图 1-1. 本地版本控制系统</p>
<p>其中最流行的一种叫做 rcs，现今许多计算机系统上都还看得到它的踪影。甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 rcs 命令。它的工作原理基本上就是保存并管理文件补丁（patch）。文件补丁是一种特定格式的文本文件，记录着对应文件修订前后的内容变化。所以，根据每次 修订后的补丁，rcs 可以通过不断打补丁，计算出各个版本的文件内容。</p>
<p><strong>集中化的版本控制系统</strong></p>
<p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？于是，集中化的版本控制系统（ Centralized Version Control Systems，简称 CVCS ）应运而生。这类系统，诸如 CVS，Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这 已成为版本控制系统的标准做法（见图 1-2）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start2.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a></p>
<p>图 1-2. 集中化的版本控制系统</p>
<p>这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。</p>
<p>事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。要 是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就还是会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，而被客户端 提取出来的某些快照数据除外，但这样的话依然是个问题，你不能保证所有的数据都已经有人事先完整提取出来过。本地版本控制系统也存在类似问题，只要整个项 目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p>
<p><strong>分布式版本控制系统</strong></p>
<p>于是分布式版本控制系统（ Distributed Version Control System，简称 DVCS ）面世了。在这类系统中，像 Git，Mercurial，Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜 像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份（见图 1-3）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start3.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a>
图 1-3. 分布式版本控制系统</p>
<p>更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。</p>
<p><strong>1.2 Git 简史</strong></p>
<p>同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。</p>
<p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统制订了若干目标：</p>
<p>/<em> 速度 /</em> 简单的设计 /<em> 对非线性开发模式的强力支持（允许上千个并行开发的分支） /</em> 完全分布式 /* 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</p>
<p>自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。它的速度飞快，极其适合管理大项目，它还有着令人难以置信的非线性分支管理系统（见第三章），可以应付各种复杂的项目开发需求。</p>
<p><strong>1.3 Git 基础</strong></p>
<p>那么，简单地说，Git 究竟是怎样的一个系统呢？请注意，接下来的内容非常重要，若是理解了 Git 的思想和基本工作原理，用起来就会知其所以然，游刃有余。在开始学习 Git 的时候，请不要尝试把各种概念和其他版本控制系统（诸如 Subversion 和 Perforce 等）相比拟，否则容易混淆每个操作的实际意义。Git 在保存和处理各种信息的时候，虽然操作起来的命令形式非常相近，但它与其他版本控制系统的做法颇为不同。理解这些差异将有助于你准确地使用 Git 提供的各种工具。</p>
<p><strong>直接记录快照，而非差异比较</strong></p>
<p>Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。这类系统 （CVS，Subversion，Perforce，Bazaar 等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容，请看图 1-4。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start4.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a>
图 1-4. 其他系统在每个版本中记录着各个文件的具体差异</p>
<p>Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照 的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。Git 的工作方式就像图 1-5 所示。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start5.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a>
图 1-5. Git 保存每次更新时的文件快照</p>
<p>这是 Git 同其他系统的重要区别。它完全颠覆了传统版本控制的套路，并对各个环节的实现方式作了新的设计。Git 更像是个小型的文件系统，但它同时还提供了许多以此为基础的超强工具，而不只是一个简单的 VCS。稍后在第三章讨论 Git 分支管理的时候，我们会再看看这样的设计究竟会带来哪些好处。</p>
<p><strong>近乎所有操作都是本地执行</strong></p>
<p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。但如果用 CVCS 的话，差不多所有操作都需要连接网络。因为 Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。</p>
<p>举个例子，如果要浏览项目的历史更新摘要，Git 不用跑到外面的服务器上去取数据回来，而直接从本地数据库读取后展示给你看。所以任何时候你都可以马上翻阅，无需等待。如果想要看当前版本的文件和一个月 前的版本之间有何差异，Git 会取出一个月前的快照和当前文件作一次差异运算，而不用请求远程服务器来做这件事，或是把老版本的文件拉到本地来作比较。</p>
<p>用 CVCS 的话，没有网络或者断开 VPN 你就无法做任何事情。但用 Git 的话，就算你在飞机或者火车上，都可以非常愉快地频繁提交更新，等到了有网络的时候再上传到远程仓库。同样，在回家的路上，不用连接 VPN 你也可以继续工作。换作其他版本控制系统，这么做几乎不可能，抑或非常麻烦。比如 Perforce，如果不连到服务器，几乎什么都做不了（译注：默认无法发出命令</p>
<p>p4 edit file
 开始编辑文件，因为 Perforce 需要联网通知系统声明该文件正在被谁修订。但实际上手工修改文件权限可以绕过这个限制，只是完成后还是无法提交更新。）；如果是 Subversion 或 CVS，虽然可以编辑文件，但无法提交更新，因为数据库在网络上。看上去好像这些都不是什么大问题，但实际体验过之后，你就会惊喜地发现，这其实是会带来很大不同的。</p>
<p><strong>时刻保持数据完整性</strong></p>
<p>在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后，Git 一无所知。这项特性作为 Git 的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。</p>
<p>Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符（0-9 及 a-f）组成，看起来就像是：
124b9da6552252987aa493b52f8696cd6d3b00373</p>
<p>Git 的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。实际上，所有保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。</p>
<p><strong>多数操作仅添加数据</strong></p>
<p>常用的 Git 操作大多仅仅是把数据添加到数据库。因为任何一种不可逆的操作，比如删除数据，都会使回退或重现历史版本变得困难重重。在别的 VCS 中，若还未提交更新，就有可能丢失或者混淆一些修改的内容，但在 Git 里，一旦提交快照之后就完全不用担心丢失数据，特别是养成定期推送到其他仓库的习惯的话。</p>
<p>这种高可靠性令我们的开发工作安心不少，尽管去做各种试验性的尝试好了，再怎样也不会弄丢数据。至于 Git 内部究竟是如何保存和恢复数据的，我们会在第九章讨论 Git 内部原理时再作详述。</p>
<p><strong>文件的三种状态</strong></p>
<p>好，现在请注意，接下来要讲的概念非常重要。对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库 中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。</p>
<p>由此我们看到 Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start6.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a></p>
<p>图 1-6. 工作目录，暂存区域，以及本地仓库</p>
<p>每个项目都有一个 Git 目录（译注：如果 </p>
<p>git clone
 出来的话，就是其中 </p>
<p>.git
 的目录；如果</p>
<p>git clone --bare
 的话，新建的目录本身就是 Git 目录。），它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。</p>
<p>从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件实际上都是从 Git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。</p>
<p>所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。</p>
<p>基本的 Git 工作流程如下：</p>
<ol>
<li>在工作目录中修改某些文件。 2. 对修改后的文件进行快照，然后保存到暂存区域。 3. 提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。</li>
</ol>
<p>所以，我们可以从文件所处的位置来判断状态：如果是 Git 目录中保存着的特定版本文件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次取出后，作了修改但还没有放到暂存区域，就 是已修改状态。到第二章的时候，我们会进一步了解其中细节，并学会如何根据文件状态实施后续操作，以及怎样跳过暂存直接提交。</p>
<p><strong>1.4 安装 Git</strong></p>
<p>是时候动手尝试下 Git 了，不过得先安装好它。有许多种安装方式，主要分为两种，一种是通过编译源代码来安装；另一种是使用为特定平台预编译好的安装包。</p>
<p><strong>从源代码安装</strong></p>
<p>若是条件允许，从源代码安装有很多好处，至少可以安装最新的版本。Git 的每个版本都在不断尝试改进用户体验，所以能通过源代码自己编译安装最新版本就再好不过了。有些 Linux 版本自带的安装包更新起来并不及时，所以除非你在用最新的 distro 或者 backports，那么从源代码安装其实该算是最佳选择。</p>
<p>Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。在有 yum 的系统上（比如 Fedora）或者有 apt-get 的系统上（比如 Debian 体系），可以用下面的命令安装：
1</p>
<p>2
3</p>
<p>4
5$ yum</p>
<p>install</p>
<p>curl-devel expat-devel gettext-devel \</p>
<p>openssl-devel zlib-devel</p>
<p>$ apt-get</p>
<p>install</p>
<p>libcurl4-gnutls-dev libexpat1-dev gettext \</p>
<p>libz-dev libssl-dev</p>
<p>之后，从下面的 Git 官方站点下载最新版本源代码：</p>
<p>1http:</p>
<p>//git-scm</p>
<p>.com</p>
<p>/download</p>
<p>然后编译并安装：</p>
<p>1</p>
<p>2
3</p>
<p>4
$</p>
<p>tar</p>
<p>-zxf git-1.7.2.2.</p>
<p>tar</p>
<p>.gz</p>
<p>$</p>
<p>cd</p>
<p>git-1.7.2.2
$</p>
<p>make</p>
<p>prefix=</p>
<p>/usr/local</p>
<p>all</p>
<p>$</p>
<p>sudo</p>
<p>make</p>
<p>prefix=</p>
<p>/usr/local</p>
<p>install</p>
<p>现在已经可以用 </p>
<p>git
 命令了，用 </p>
<p>git
 把 Git 项目仓库克隆到本地，以便日后随时更新：</p>
<p>1$ git clone git:</p>
<p>//git</p>
<p>.kernel.org</p>
<p>/pub/scm/git/git</p>
<p>.git</p>
<p><strong>在 Linux 上安装</strong></p>
<p>如果要在 Linux 上安装预编译好的 Git 二进制安装包，可以直接用系统提供的包管理工具。在 Fedora 上用 yum 安装：
1$ yum</p>
<p>install</p>
<p>git-core</p>
<p>在 Ubuntu 这类 Debian 体系的系统上，可以用 apt-get 安装：</p>
<p>1$ apt-get</p>
<p>install</p>
<p>git-core</p>
<p><strong>在 Mac 上安装</strong></p>
<p>在 Mac 上安装 Git 有两种方式。最容易的当属使用图形化的 Git 安装工具，界面如图 1-7，下载地址在：
<a href="http://code.google.com/p/git-osx-installer" target="_blank">http://code.google.com/p/git-osx-installer</a></p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start7.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a>
图 1-7. Git OS X 安装工具</p>
<p>另一种是通过 MacPorts (</p>
<p><a href="http://www.macports.org" target="_blank">http://www.macports.org</a>
) 安装。如果已经装好了 MacPorts，用下面的命令安装 Git：
1$</p>
<p>sudo</p>
<p>port</p>
<p>install</p>
<p>git-core +svn +doc +bash_completion +gitweb</p>
<p>这种方式就不需要再自己安装依赖库了，Macports 会帮你<a href="http://www.amazon.cn/gp/product/B007XPTAIS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;linkCode=as2&amp;camp=536&amp;creative=3200&amp;creativeASIN=B007XPTAIS" title="搞定(套装共3册) " target="_blank">搞定</a>这些麻烦事。一般上面列出的安装选项已经够用，要是你想用 Git 连接 Subversion 的代码仓库，还可以加上 +svn 选项，具体将在第八章作介绍。（译注：还有一种是使用 homebrew（</p>
<p><a href="https://[GitHub](http://blog.jobbole.com/6492/" target="_blank">https://[GitHub](http://blog.jobbole.com/6492/</a> &quot;GitHub如何运作：时间并不决定一切&quot;).com/mxcl/homebrew
）：</p>
<p>brew install git
。）</p>
<p><strong>在 Windows 上安装</strong></p>
<p>在 Windows 上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包，可以到 Google Code 的页面上下载 exe 安装文件并运行：
1http:</p>
<p>//code</p>
<p>.google.com</p>
<p>/p/msysgit</p>
<p>完成安装之后，就可以使用命令行的 </p>
<p>git
 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。</p>
<p><strong>1.5 初次运行 Git 前的配置</strong></p>
<p>一般在新的系统上，我们都需要先配置下自己的 Git 工作环境。配置工作只需一次，以后升级时还会沿用现在的配置。当然，如果需要，你随时可以用相同的命令修改已有的配置。</p>
<p>Git 提供了一个叫做 git config 的工具（译注：实际是 </p>
<p>git-config
 命令，只不过可以通过 </p>
<p>git
 加一个名字来呼叫此命令。），专门用来配置或读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p>
<p>●/etc/gitconfig
 文件：系统中对所有用户都普遍适用的配置。若使用 </p>
<p>git config
 时用</p>
<p>--system
 选项，读写的就是这个文件。</p>
<p>●~/.gitconfig
 文件：用户目录下的配置文件只适用于该用户。若使用 </p>
<p>git config
 时用</p>
<p>--global
 选项，读写的就是这个文件。</p>
<p>●当前项目的 git 目录中的配置文件（也就是工作目录中的 </p>
<p>.git/config
 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以</p>
<p>.git/config
 里的配置会覆盖</p>
<p>/etc/gitconfig
 中的同名变量。</p>
<p>在 Windows 系统上，Git 会找寻用户主目录下的 </p>
<p>.gitconfig
 文件。主目录即 </p>
<p>$HOME
 变量指定的目录，一般都是</p>
<p>C:\Documents and Settings\$USER
。此外，Git 还会尝试找寻</p>
<p>/etc/gitconfig
 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p>
<p><strong>用户信息</strong></p>
<p>第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：
1</p>
<p>2
$ git config --global user.name</p>
<p>&quot;John Doe&quot;</p>
<p>$ git config --global user.email johndoe@ example.com</p>
<p>如果用了 </p>
<p>--global
 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉</p>
<p>--global
 选项重新配置即可，新的设定保存在当前项目的</p>
<p>.git/config
 文件里。</p>
<p><strong>文本编辑器</strong></p>
<p>接下来要设置的是默认使用的文本编辑器。Git 需要你输入一些额外消息的时候，会自动调用一个外部文本编辑器给你用。默认会使用操作系统指定的默认编辑器，一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：
1$ git config --global core.editor emacs</p>
<p><strong>差异分析工具</strong></p>
<p>还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：
1$ git config --global merge.tool vimdiff</p>
<p>Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。当然，你也可以指定使用自己开发的工具，具体怎么做可以参阅第七章。</p>
<p><strong>查看配置信息</strong></p>
<p>要检查已有的配置信息，可以使用 </p>
<p>git config --list
 命令：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
$ git config --list</p>
<p>user.name=Scott Chacon
user.email=schacon@ gmail.com</p>
<p>color.status=auto
color.branch=auto</p>
<p>color.interactive=auto
color.</p>
<p>diff</p>
<p>=auto</p>
<p>...</p>
<p>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 </p>
<p>/etc/gitconfig
 和 </p>
<p>~/.gitconfig
），不过最终 Git 实际采用的是最后一个。</p>
<p>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：
1$ git config user.name Scott Chacon</p>
<p><strong>1.6 获取帮助</strong></p>
<p>想了解 Git 的各式工具该怎么用，可以阅读它们的使用帮助，方法有三：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
$ git help</p>
<p>$ git</p>
<p>--help</p>
<p>$</p>
<p>man</p>
<p>git-</p>
<p>比如，要学习 config 命令可以怎么用，运行：</p>
<p>1$ git help config</p>
<p>我们随时都可以浏览这些帮助信息而无需连网。不过，要是你觉得还不够，可以到 Frenode IRC 服务器（irc.freenode.net）上的 </p>
<p>/#git
 或 </p>
<p>/#github
 频道寻求他人帮助。这两个频道上总有着上百号人，大多都有着丰富的 git 知识，并且乐于助人。</p>
<hr>
<p><strong>1.7 小结</strong></p>
<p>至此，你该对 Git 有了点基本认识，包括它和以前你使用的 CVCS 之间的差别。现在，在你的系统上应该已经装好了 Git，设置了自己的名字和电邮。接下来让我们继续学习 Git 的基础知识。</p>
<p><img src="&quot;6 votes, average: 5.00 out of 5&quot;" alt="6 votes, average: 5.00 out of 5"><img src="&quot;6 votes, average: 5.00 out of 5&quot;" alt="6 votes, average: 5.00 out of 5"><img src="&quot;6 votes, average: 5.00 out of 5&quot;" alt="6 votes, average: 5.00 out of 5"><img src="&quot;6 votes, average: 5.00 out of 5&quot;" alt="6 votes, average: 5.00 out of 5"><img src="&quot;6 votes, average: 5.00 out of 5&quot;" alt="6 votes, average: 5.00 out of 5"> (<strong>*6</strong> 个评分，平均: <strong>5.00*</strong>)</p>
<p><img src="&quot;Loading ...&quot;" alt="Loading ..."> Loading ...</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/git&github/">git&github</a></li></span></span> | <span class="tags">Tagged <a href="/tags/git&github/" class="label label-primary">git&github</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-gitgithub--Git详解之一：Git起步/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-gitgithub--Git详解之一：Git起步" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/31/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/29/">29</a></li><li><a class="page-number" href="/page/30/">30</a></li><li><a class="page-number" href="/page/31/">31</a></li><li class="active"><li><span class="page-number current">32</span></li><li><a class="page-number" href="/page/33/">33</a></li><li><a class="page-number" href="/page/34/">34</a></li><li><a class="page-number" href="/page/35/">35</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/161/">161</a></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="extend next" href="/page/33/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-04-07 17:26:53</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
