
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 45 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_设计类--软件设计文档二三事-善攻者动于九天之上-博客园/">软件设计文档二三事 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T09:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_设计类--软件设计文档二三事-善攻者动于九天之上-博客园/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">软件设计文档二三事 - 善攻者动于九天之上 - 博客园</h1>
<p><img src="" alt=""> Saving Data...
正在保存数据...
正在儲存資料...</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_设计类/">Java_设计类</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_设计类/" class="label label-success">Java_设计类</a></span> | <span class="time">recent updated:<time title="2014-03-07 01:54:42"datetime="2014-03-07 01:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_设计类--软件设计文档二三事-善攻者动于九天之上-博客园/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_设计类--软件设计文档二三事-善攻者动于九天之上-博客园" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--通过Java-JMX得到fullGC次数？-高级语言虚拟机/">通过Java</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T09:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--通过Java-JMX得到fullGC次数？-高级语言虚拟机/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-jmx-full-gc-">通过Java/JMX得到full GC次数？ - 高级语言虚拟机</h1>
<p><a href="http://hllvm.group.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a> <a href="http://hllvm.group.iteye.com/signup" target="_blank">注册</a></p>
<p><a href="http://www.iteye.com/" target="_blank"><img src="&quot;ITeye-最棒的软件开发交流社区&quot;" alt="ITeye3.0"></a></p>
<p><a href=""></a></p>
<p><a href="http://www.iteye.com/groups" target="_blank">群组首页</a> → <a href="http://hllvm.group.iteye.com/groups/category/language" target="_blank">编程语言</a> → <a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a> → <a href="http://hllvm.group.iteye.com/group/wiki" target="_blank">知识库</a> → <a href="http://hllvm.group.iteye.com/group/wiki?category_id=315" target="_blank">JVM实战</a> → <a href="">通过Java/JMX得到full GC次数？</a>
原创作者: <a href="http://www.javaeye.com/topic/790015" target="_blank">RednaxelaFX</a>   阅读:2261次   评论:1条   更新时间:2011-05-26    </p>
<p>今天有个同事问如何能通过<a href="http://java.sun.com/javase/technologies/core/mntr-mgmt/javamanagement/" target="_blank">JMX</a>获取到某个Java进程的full GC次数：
引用</p>
<p>hi,问个问题，怎们在java中获取到full gc的次数呢？
我现在用jmx的那个得到了gc次数，不过不能细化出来full gc的次数
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>for (final GarbageCollectorMXBean garbageCollector  </li>
<li>: ManagementFactory.getGarbageCollectorMXBeans()) {  </li>
<li>gcCounts += garbageCollector.getCollectionCount();  </li>
<li><p>}<br>for (final GarbageCollectorMXBean garbageCollector : ManagementFactory.getGarbageCollectorMXBeans()) { gcCounts += garbageCollector.getCollectionCount(); }
你比如我现在是这样拿次数的
我回答说因为full GC概念只有在分代式GC的上下文中才存在，而JVM并不强制要求GC使用分代式实现，所以JMX提供的标准<a href="http://download-llnw.oracle.com/javase/6/docs/technotes/guides/management/mxbeans.html" target="_blank">MXBean</a> API里不提供“full GC次数”这样的方法也正常。
既然“full GC”本来就是非常平台相关的概念，那就hack一点，用平台相关的代码来解决问题好了。这些GC的MXBean都是有名字的，而主流的JVM的GC名字相对稳定，非要通过JMX得到full GC次数的话，用名字来判断一下就好了。
举个例子来看看。通过JDK 6自带的<a href="http://download-llnw.oracle.com/javase/6/docs/technotes/guides/management/jconsole.html" target="_blank">JConsole</a>工具来查看相关的MXBean的话，可以看到，
GC的MXBean在这个位置：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
这个例子是用server模式启动JConsole的，使用的是ParallelScavenge GC，它的年老代对应的收集器在这里：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
该收集器的总收集次数在此，这也就是full GC的次数：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
于是只要知道我们用的JVM提供的GC MXBean的名字与分代的关系，就可以知道full GC的次数了。
Java代码写起来冗长，这帖就不用Java来写例子了，反正API是一样的，意思能表达清楚就OK。
用一个<a href="http://groovy.codehaus.org/" target="_blank">Groovy</a>脚本简单演示一下适用于Oracle (Sun) HotSpot与Oracle (BEA) JRockit的GC统计程序：
Groovy代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>import java.lang.management.ManagementFactory  </p>
</li>
<li></li>
<li>printGCStats = {  </li>
<li>def youngGenCollectorNames = [  </li>
<li>// Oracle (Sun) HotSpot  </li>
<li>// -XX:+UseSerialGC  </li>
<li>&#39;Copy&#39;,  </li>
<li>// -XX:+UseParNewGC  </li>
<li>&#39;ParNew&#39;,  </li>
<li>// -XX:+UseParallelGC  </li>
<li>&#39;PS Scavenge&#39;,  </li>
<li></li>
<li>// Oracle (BEA) JRockit  </li>
<li>// -XgcPrio:pausetime  </li>
<li>&#39;Garbage collection optimized for short pausetimes Young Collector&#39;,  </li>
<li>// -XgcPrio:throughput  </li>
<li>&#39;Garbage collection optimized for throughput Young Collector&#39;,  </li>
<li>// -XgcPrio:deterministic  </li>
<li>&#39;Garbage collection optimized for deterministic pausetimes Young Collector&#39;  </li>
<li>]  </li>
<li></li>
<li>def oldGenCollectorNames = [  </li>
<li>// Oracle (Sun) HotSpot  </li>
<li>// -XX:+UseSerialGC  </li>
<li>&#39;MarkSweepCompact&#39;,  </li>
<li>// -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting)  </li>
<li>&#39;PS MarkSweep&#39;,  </li>
<li>// -XX:+UseConcMarkSweepGC  </li>
<li>&#39;ConcurrentMarkSweep&#39;,  </li>
<li></li>
<li>// Oracle (BEA) JRockit  </li>
<li>// -XgcPrio:pausetime  </li>
<li>&#39;Garbage collection optimized for short pausetimes Old Collector&#39;,  </li>
<li>// -XgcPrio:throughput  </li>
<li>&#39;Garbage collection optimized for throughput Old Collector&#39;,  </li>
<li>// -XgcPrio:deterministic  </li>
<li>&#39;Garbage collection optimized for deterministic pausetimes Old Collector&#39;  </li>
<li>]  </li>
<li></li>
<li>R: {  </li>
<li>ManagementFactory.garbageCollectorMXBeans.each {  </li>
<li>def name  = it.name  </li>
<li>def count = it.collectionCount  </li>
<li>def gcType;  </li>
<li>switch (name) {  </li>
<li>case youngGenCollectorNames:  </li>
<li>gcType = &#39;Minor Collection&#39;  </li>
<li>break  </li>
<li>case oldGenCollectorNames:  </li>
<li>gcType = &#39;Major Collection&#39;  </li>
<li>break  </li>
<li>default:  </li>
<li>gcType = &#39;Unknown Collection Type&#39;  </li>
<li>break  </li>
<li>}  </li>
<li>println &quot;$count &lt;- $gcType: $name&quot;  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li><p>printGCStats()<br>import java.lang.management.ManagementFactory printGCStats = { def youngGenCollectorNames = [ // Oracle (Sun) HotSpot // -XX:+UseSerialGC &#39;Copy&#39;, // -XX:+UseParNewGC &#39;ParNew&#39;, // -XX:+UseParallelGC &#39;PS Scavenge&#39;, // Oracle (BEA) JRockit // -XgcPrio:pausetime &#39;Garbage collection optimized for short pausetimes Young Collector&#39;, // -XgcPrio:throughput &#39;Garbage collection optimized for throughput Young Collector&#39;, // -XgcPrio:deterministic &#39;Garbage collection optimized for deterministic pausetimes Young Collector&#39; ] def oldGenCollectorNames = [ // Oracle (Sun) HotSpot // -XX:+UseSerialGC &#39;MarkSweepCompact&#39;, // -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting) &#39;PS MarkSweep&#39;, // -XX:+UseConcMarkSweepGC &#39;ConcurrentMarkSweep&#39;, // Oracle (BEA) JRockit // -XgcPrio:pausetime &#39;Garbage collection optimized for short pausetimes Old Collector&#39;, // -XgcPrio:throughput &#39;Garbage collection optimized for throughput Old Collector&#39;, // -XgcPrio:deterministic &#39;Garbage collection optimized for deterministic pausetimes Old Collector&#39; ] R: { ManagementFactory.garbageCollectorMXBeans.each { def name = it.name def count = it.collectionCount def gcType; switch (name) { case youngGenCollectorNames: gcType = &#39;Minor Collection&#39; break case oldGenCollectorNames: gcType = &#39;Major Collection&#39; break default: gcType = &#39;Unknown Collection Type&#39; break } println &quot;$count &lt;- $gcType: $name&quot; } } } printGCStats()
执行可以看到类似这样的输出：
Command prompt代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>5 &lt;- Minor Collection: Copy  </p>
</li>
<li><p>0 &lt;- Major Collection: MarkSweepCompact<br>5 &lt;- Minor Collection: Copy 0 &lt;- Major Collection: MarkSweepCompact
↑这是用client模式的HotSpot执行得到的；
Command prompt代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>0 &lt;- Minor Collection: Garbage collection optimized for throughput Young Collector  </p>
</li>
<li><p>0 &lt;- Major Collection: Garbage collection optimized for throughput Old Collector<br>0 &lt;- Minor Collection: Garbage collection optimized for throughput Young Collector 0 &lt;- Major Collection: Garbage collection optimized for throughput Old Collector
↑这是用JRockit R28在32位Windows上的默认模式得到的。
通过上述方法，要包装起来方便以后使用的话也很简单，例如下面Groovy程序：
Groovy代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>import java.lang.management.ManagementFactory  </p>
</li>
<li></li>
<li>class GCStats {  </li>
<li>static final List<String> YoungGenCollectorNames = [  </li>
<li>// Oracle (Sun) HotSpot  </li>
<li>// -XX:+UseSerialGC  </li>
<li>&#39;Copy&#39;,  </li>
<li>// -XX:+UseParNewGC  </li>
<li>&#39;ParNew&#39;,  </li>
<li>// -XX:+UseParallelGC  </li>
<li>&#39;PS Scavenge&#39;,  </li>
<li></li>
<li>// Oracle (BEA) JRockit  </li>
<li>// -XgcPrio:pausetime  </li>
<li>&#39;Garbage collection optimized for short pausetimes Young Collector&#39;,  </li>
<li>// -XgcPrio:throughput  </li>
<li>&#39;Garbage collection optimized for throughput Young Collector&#39;,  </li>
<li>// -XgcPrio:deterministic  </li>
<li>&#39;Garbage collection optimized for deterministic pausetimes Young Collector&#39;  </li>
<li>]  </li>
<li></li>
<li>static final List<String> OldGenCollectorNames = [  </li>
<li>// Oracle (Sun) HotSpot  </li>
<li>// -XX:+UseSerialGC  </li>
<li>&#39;MarkSweepCompact&#39;,  </li>
<li>// -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting)  </li>
<li>&#39;PS MarkSweep&#39;,  </li>
<li>// -XX:+UseConcMarkSweepGC  </li>
<li>&#39;ConcurrentMarkSweep&#39;,  </li>
<li></li>
<li>// Oracle (BEA) JRockit  </li>
<li>// -XgcPrio:pausetime  </li>
<li>&#39;Garbage collection optimized for short pausetimes Old Collector&#39;,  </li>
<li>// -XgcPrio:throughput  </li>
<li>&#39;Garbage collection optimized for throughput Old Collector&#39;,  </li>
<li>// -XgcPrio:deterministic  </li>
<li>&#39;Garbage collection optimized for deterministic pausetimes Old Collector&#39;  </li>
<li>]  </li>
<li></li>
<li>static int getYoungGCCount() {  </li>
<li>ManagementFactory.garbageCollectorMXBeans.inject(0) { youngGCCount, gc -&gt;  </li>
<li>if (YoungGenCollectorNames.contains(gc.name))  </li>
<li>youngGCCount + gc.collectionCount  </li>
<li>else  </li>
<li>youngGCCount  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>static int getFullGCCount() {  </li>
<li>ManagementFactory.garbageCollectorMXBeans.inject(0) { fullGCCount, gc -&gt;  </li>
<li>if (OldGenCollectorNames.contains(gc.name))  </li>
<li>fullGCCount + gc.collectionCount  </li>
<li>else  </li>
<li>fullGCCount  </li>
<li>}  </li>
<li>}  </li>
<li><p>}<br>import java.lang.management.ManagementFactory class GCStats { static final List<String> YoungGenCollectorNames = [ // Oracle (Sun) HotSpot // -XX:+UseSerialGC &#39;Copy&#39;, // -XX:+UseParNewGC &#39;ParNew&#39;, // -XX:+UseParallelGC &#39;PS Scavenge&#39;, // Oracle (BEA) JRockit // -XgcPrio:pausetime &#39;Garbage collection optimized for short pausetimes Young Collector&#39;, // -XgcPrio:throughput &#39;Garbage collection optimized for throughput Young Collector&#39;, // -XgcPrio:deterministic &#39;Garbage collection optimized for deterministic pausetimes Young Collector&#39; ] static final List<String> OldGenCollectorNames = [ // Oracle (Sun) HotSpot // -XX:+UseSerialGC &#39;MarkSweepCompact&#39;, // -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting) &#39;PS MarkSweep&#39;, // -XX:+UseConcMarkSweepGC &#39;ConcurrentMarkSweep&#39;, // Oracle (BEA) JRockit // -XgcPrio:pausetime &#39;Garbage collection optimized for short pausetimes Old Collector&#39;, // -XgcPrio:throughput &#39;Garbage collection optimized for throughput Old Collector&#39;, // -XgcPrio:deterministic &#39;Garbage collection optimized for deterministic pausetimes Old Collector&#39; ] static int getYoungGCCount() { ManagementFactory.garbageCollectorMXBeans.inject(0) { youngGCCount, gc -&gt; if (YoungGenCollectorNames.contains(gc.name)) youngGCCount + gc.collectionCount else youngGCCount } } static int getFullGCCount() { ManagementFactory.garbageCollectorMXBeans.inject(0) { fullGCCount, gc -&gt; if (OldGenCollectorNames.contains(gc.name)) fullGCCount + gc.collectionCount else fullGCCount } } }
用的时候：
Groovysh代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>D:>\sdk\groovy-1.7.2\bin\groovysh  </p>
</li>
<li>Groovy Shell (1.7.2, JVM: 1.6.0_20)  </li>
<li>Type &#39;help&#39; or &#39;\h&#39; for help.  </li>
<li><hr>
</li>
<li>groovy:000&gt; GCStats.fullGCCount  </li>
<li>===&gt; 0  </li>
<li>groovy:000&gt; System.gc()  </li>
<li>===&gt; null  </li>
<li>groovy:000&gt; GCStats.fullGCCount  </li>
<li>===&gt; 1  </li>
<li>groovy:000&gt; System.gc()  </li>
<li>===&gt; null  </li>
<li>groovy:000&gt; System.gc()  </li>
<li>===&gt; null  </li>
<li>groovy:000&gt; GCStats.fullGCCount  </li>
<li>===&gt; 3  </li>
<li>groovy:000&gt; GCStats.youngGCCount  </li>
<li>===&gt; 9  </li>
<li>groovy:000&gt; GCStats.youngGCCount  </li>
<li>===&gt; 9  </li>
<li>groovy:000&gt; GCStats.youngGCCount  </li>
<li>===&gt; 9  </li>
<li>groovy:000&gt; System.gc()  </li>
<li>===&gt; null  </li>
<li>groovy:000&gt; GCStats.youngGCCount  </li>
<li>===&gt; 9  </li>
<li>groovy:000&gt; GCStats.fullGCCount  </li>
<li>===&gt; 4  </li>
<li>groovy:000&gt; quit<br>D:>\sdk\groovy-1.7.2\bin\groovysh Groovy Shell (1.7.2, JVM: 1.6.0_20) Type &#39;help&#39; or &#39;\h&#39; for help. -------------------------------------------------- groovy:000&gt; GCStats.fullGCCount ===&gt; 0 groovy:000&gt; System.gc() ===&gt; null groovy:000&gt; GCStats.fullGCCount ===&gt; 1 groovy:000&gt; System.gc() ===&gt; null groovy:000&gt; System.gc() ===&gt; null groovy:000&gt; GCStats.fullGCCount ===&gt; 3 groovy:000&gt; GCStats.youngGCCount ===&gt; 9 groovy:000&gt; GCStats.youngGCCount ===&gt; 9 groovy:000&gt; GCStats.youngGCCount ===&gt; 9 groovy:000&gt; System.gc() ===&gt; null groovy:000&gt; GCStats.youngGCCount ===&gt; 9 groovy:000&gt; GCStats.fullGCCount ===&gt; 4 groovy:000&gt; quit
这是在Sun JDK 6 update 20上跑的。顺带一提，如果这是跑在JRockit上的话，那full GC的次数就不会增加——因为JRockit里System.gc()默认是触发young GC的；请不要因为Sun HotSpot的默认行为而认为System.gc()总是会触发full GC的。
关于JMX的MXBean的使用，也可以参考下面两篇文档：
<a href="http://docs.codehaus.org/display/GROOVY/Groovy+and+JMX" target="_blank">Groovy and JMX</a>
<a href="http://www.engineyard.com/blog/2010/monitoring-the-jvm-heap-with-jruby/" target="_blank">Monitoring the JVM Heap with JRuby</a>
<a href="http://hllvm.group.iteye.com/group/wiki/3042-JVM-eclipse" title="如何更快的启动eclipse" target="_blank">如何更快的启动eclipse</a></li>
</ol>
<p>评论 共 1 条 请<a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a>后发表评论 <a href=""></a></p>
<h3 id="1-xgj1988-http-xgj1988-iteye-com-xgj1988-2011-04-27-15-07">1 楼 <a href="http://xgj1988.iteye.com/" title="xgj1988" target="_blank">xgj1988</a> 2011-04-27 15:07</h3>
<p>SUN jdk   使用FULL GC 是如下的几种之一？
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>static final List<String> OldGenCollectorNames = [     </li>
<li>// Oracle (Sun) HotSpot     </li>
<li>// -XX:+UseSerialGC     </li>
<li>&#39;MarkSweepCompact&#39;,     </li>
<li>// -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting)     </li>
<li>&#39;PS MarkSweep&#39;,     </li>
<li>// -XX:+UseConcMarkSweepGC     </li>
<li>&#39;ConcurrentMarkSweep&#39;,     </li>
<li></li>
<li><p>]<br>static final List<String> OldGenCollectorNames = [ // Oracle (Sun) HotSpot // -XX:+UseSerialGC &#39;MarkSweepCompact&#39;, // -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting) &#39;PS MarkSweep&#39;, // -XX:+UseConcMarkSweepGC &#39;ConcurrentMarkSweep&#39;, ]
这几个是young gc?
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>&#39;Copy&#39;,     </p>
</li>
<li>// -XX:+UseParNewGC     </li>
<li>&#39;ParNew&#39;,     </li>
<li>// -XX:+UseParallelGC     </li>
<li>&#39;PS Scavenge&#39;,     </li>
<li>&#39;Copy&#39;, // -XX:+UseParNewGC &#39;ParNew&#39;, // -XX:+UseParallelGC &#39;PS Scavenge&#39;,
根据名字判断来获取full gc<img src="" alt=""><h3 id="-">发表评论</h3>
</li>
</ol>
<p><a href="http://hllvm.group.iteye.com/login" target="_blank"><img src="" alt=""> 您还没有登录,请您登录后再发表评论</a></p>
<p><a href="http://hllvm.group.iteye.com/group/wiki/new" target="_blank"><img src="" alt="New-page"></a></p>
<h3 id="-">文章信息</h3>
<p><a href="http://hllvm.group.iteye.com/group/wiki/" target="_blank">知识库: 高级语言虚拟机</a></p>
<ul>
<li>由<a href="http://kiral.iteye.com/" title="fantasy" target="_blank">fantasy</a>在2010-12-16创建</li>
<li><p>由<a href="http://kiral.iteye.com/" title="fantasy" target="_blank">fantasy</a>在2011-05-26更新</p>
<h3 id="-">相关新闻</h3>
</li>
<li><p><a href="http://hllvm.group.iteye.com/news/6318-java-se-6-update-14-early-access-version" target="_blank">Java SE 6 Update 14 Early Access 早期使用版本现已发布</a></p>
</li>
<li><a href="http://hllvm.group.iteye.com/news/4146-jdk-7-in-the-new-garbage-collection-mechanism" target="_blank">JDK 7 中新的垃圾收集机制</a></li>
<li><a href="http://hllvm.group.iteye.com/news/10069" target="_blank">Java 7的新功能和Java 1.5,1.6,1.7的性能测试比较</a></li>
</ul>
<h3 id="-">相关讨论</h3>
<ul>
<li><a href="http://hllvm.group.iteye.com/topic/894148" target="_blank">HotSpot VM 内存堆的两个Servivor区</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/976522" target="_blank">java内存管理以及GC</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/802638" target="_blank">JVM内存管理：深入垃圾收集器与内存分配策略</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/212967" target="_blank">一次Java垃圾收集调优实战</a></li>
<li><p><a href="http://hllvm.group.iteye.com/topic/262541" target="_blank">JVM的GC-生命不能承受之重</a></p>
<h3 id="-">相关博客</h3>
</li>
<li><p><a href="http://rednaxelafx.iteye.com/blog/790015" target="_blank">通过Java/JMX得到full GC次数？</a></p>
</li>
<li><a href="http://millerhu.iteye.com/blog/890724" target="_blank">通过Java/JMX得到full GC次数？</a></li>
<li><a href="http://rednaxelafx.iteye.com/blog/790864" target="_blank">用Java获取full GC的次数？（2）</a></li>
<li><a href="http://tianshibaijia.iteye.com/blog/1343308" target="_blank">常用垃圾收集器在Mbean上的名称</a></li>
<li><a href="http://rednaxelafx.iteye.com/blog/1042471" target="_blank">答复: HotSpot VM 内存堆的两个Survivor区</a></li>
<li><a href="http://www.iteye.com/" target="_blank">首页</a></li>
<li><a href="http://www.iteye.com/news" target="_blank">资讯</a></li>
<li><a href="http://www.iteye.com/magazines" target="_blank">精华</a></li>
<li><a href="http://www.iteye.com/forums" target="_blank">论坛</a></li>
<li><a href="http://www.iteye.com/ask" target="_blank">问答</a></li>
<li><a href="http://www.iteye.com/blogs" target="_blank">博客</a></li>
<li><a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a></li>
<li><a href="http://www.iteye.com/groups" target="_blank">群组</a></li>
<li><a href="http://job.iteye.com/iteye" target="_blank">招聘</a></li>
<li><a href="http://www.iteye.com/search" target="_blank">搜索</a></li>
<li><a href="http://hllvm.group.iteye.com/index/service" target="_blank">广告服务</a></li>
<li><a href="http://webmaster.iteye.com/" target="_blank">ITeye黑板报</a></li>
<li><a href="http://hllvm.group.iteye.com/index/contactus" target="_blank">联系我们</a></li>
<li><a href="http://hllvm.group.iteye.com/index/friend_links" target="_blank">友情链接</a></li>
</ul>
<p>© 2003-2012 ITeye.com. [ <a href="http://www.miibeian.gov.cn/" target="_blank">京ICP证110151号</a> 京公网安备110105010620 ]
百联优力(北京)投资有限公司 版权所有 <img src="http://stat.iteye.com/?url=http%3A%2F%2Fhllvm.group.iteye.com%2Fgroup%2Fwiki%2F2950-gc&amp;referrer=&amp;user_id=" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 01:54:42"datetime="2014-03-07 01:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--通过Java-JMX得到fullGC次数？-高级语言虚拟机/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--通过Java-JMX得到fullGC次数？-高级语言虚拟机" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE学习总结思维方式和理念/">J2EE学习总结 思维方式和理念</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T09:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE学习总结思维方式和理念/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="j2ee-">J2EE学习总结 思维方式和理念</h1>
<p>J2EE学习总结:思维方式和理念
Webjx网页教学提示：不管怎么样我还是建议从基本的做起，学精J2SE，熟读它的源码，准确了解其设计理念，然后分头击破J2EE――一口吃不成一个胖子!不要贪多贪广!脚踏实地就可以了!</p>
<p>这篇文章写在我研究J2SE、J2EE近三年后。前3年我研究了J2SE的Swing、Applet、Net、RMI、Collections、IO、JNI……研究了J2EE的JDBC、Sevlet、JSP、JNDI…..不久我发现这些好像太浮浅了：首先，我发现自己知道的仅仅是java提供的大量的API，根本不能很好地使用它; 其次，我根本就没有学到任何有助于写程序的知识，此时我也只不过能写个几页的小程序。出于这个幼稚的想法我研究了JDK中Collections、Logger、IO…..的源代码，发现这个世界真的很神奇，竟然有如此的高手――利用java语言最最基本的语法，创造了这些优秀的Framework。</p>
<p>从此一发不可收拾，我继续研究了J2EE的部分，又发现这是一个我根本不能理解的方向(曾经有半年停滞不前)，为什么只有接口没有实现啊!后来由于一直使用Tomcat、Derby等软件突然发现：哦!原来J2EE仅仅是一个标准，只是一个架构。真正的实现是不同提供商提供的。</p>
<p>接着我研究了MOM4J、OpenJMS、Mocki、HSQLD……发现这些就是J2EE的实现啊!原来软件竟会如此复杂，竟会如此做….规范和实现又是如何成为一体的呢?通过上面的研究发现：原来J2EE后面竟然有太多太多理念、太多太多的相似!这些相似就是其背后的理念――设计模式!(很幸运，在我学java的时候，我一般学java的一个方向就会读一些关于设计模式的书!很幸运，到能领略一点的时候能真正知道这是为什么!)其实模式就是一种思维方式、就是一种理念……模式是要运用到程序中的，只有从真正的项目中才能领会模式的含义……
学得越多，发现懂得越少!在学习过程中发现一些很有用，很值得学习的开源项目，今天在此推荐给大家。</p>
<p>一、JavaServlet和JSP方向</p>
<p>很多人都是从Servlet和JSP步入J2EE的。它就是J2EE的表现层，用于向客户呈现服务器上的内容。J2EE很重要的方面。不罗嗦了!大家都知道的!下面就开始推荐吧!</p>
<ol>
<li>Jakarta Tomcat</li>
</ol>
<p>Apache基金会提供的免费的开源的Serlvet容器，它是的Jakarta项目中的一个核心项目，由Apache、Sun和其它一些公司(都是IT界的大鳄哦)及个人共同开发而成，全世界绝大部分Servlet和Jsp的容器都是使用它哦!由于Sun的参与和支持，最新的Servlet和Jsp规范总能在Tomcat中得到体现。</p>
<p>不过它是一个非常非常全的Serlvet容器，全部源码可能有4000页，对于初学者或者一般的老手可能还是比较大了!在你有能力时推荐研究!下载地址：<a href="http://jakarta.apache.org/tomcat/index.html" target="_blank">http://jakarta.apache.org/tomcat/index.html</a></p>
<p>下面推荐两个小一点的吧!</p>
<ol>
<li>Jetty</li>
</ol>
<p>Jetty是一个开放源码的HTTP服务器和Java serverlet容器。源代码只有1000页左右，很值得研究。有兴趣可以去<a href="http://jetty.mortbay.com/下载看看。我曾经翻了一下，只是目前没有时间。(都化在博客上了，等博客基本定型，且内容完整了，再干我热衷的事件吧!" target="_blank">http://jetty.mortbay.com/下载看看。我曾经翻了一下，只是目前没有时间。(都化在博客上了，等博客基本定型，且内容完整了，再干我热衷的事件吧!</a>)</p>
<ol>
<li>Jigsaw</li>
</ol>
<p>Jigsaw是W3C开发的HTTP，基于Java 的服务器，提供了未来 Web 技术发展的蓝图。W3C知道吧!(太有名气了，很多标准都是它制订的!有空经常去看看吧!)下载网址：<a href="http://www.w3.org/Jigsaw代码仅仅1000页左右。" target="_blank">http://www.w3.org/Jigsaw代码仅仅1000页左右。</a></p>
<ol>
<li>Jo!</li>
</ol>
<p>Jo!是一个纯Java的实现了Servlet API 2.2, JSP 1.1, 和HTTP/1.1的Web服务器。它的特性包括支持servlet tag,支持SSI，高级线程管理，虚拟主机，数据缓存，自动压缩text或HTML文件进行传输，国际化支持，自动重新加载Servlet、Jsp，自动重新加载web工程文件(WARs)，支持WAR热部署和一个Swing控制台。jo!可以被用做jboss和jakarta avalon-phoenix的web容器。下载地址<a href="http://www.tagtraum.com/" target="_blank">http://www.tagtraum.com/</a> 。我极力推荐大家在研究Tomcat之前研究该软件，主要是其比Tomcat小多了，且开发者提供比较全的手册。该方向研究这两个也就可以了!</p>
<p>二、JDBC方向</p>
<p>很多人都喜欢JDBC，数据库吗!很深奥的东西，一听就可以糊弄人。其实等你真正研究了数据库的实现后发现，接口其实真的太简单，太完美了!要想设计如此优秀的框架还是需要学习的。下面就推荐几个数据库的实现吧!</p>
<ol>
<li>Hypersonic SQL</li>
</ol>
<p>Hypersonic SQL开源数据库方向比较流行的纯Java开发的关系型数据库。好像不是JDBC兼容的，JDBC的很多高级的特性都没有支持，不过幸好支持ANSI-92 标准 SQL语法。我推荐它主要是它的代码比较少1600页左右，如此小的数据库值得研究，而且他占的空间很小，大约只有160K，拥有快速的数据库引擎。推荐你的第一个开源数据库。下载地址：<a href="http://hsqldb.sourceforge.net/。" target="_blank">http://hsqldb.sourceforge.net/。</a></p>
<ol>
<li>Mckoi DataBase</li>
</ol>
<p>McKoiDB 和Hypersonic SQL差不多，它是GPL 的license的纯Java开发的数据库。他的 JDBC Driver 是使用 JDBC version 3 的 Specifaction。 他也是遵循 SQL-92 的标准，也尽量支持新的 SQL 特色, 并且支持 Transaction 的功能。两个可以选一个吧!下载地址：<a href="http://mckoi.com/database/。" target="_blank">http://mckoi.com/database/。</a></p>
<ol>
<li>Apache Derby</li>
</ol>
<p>学Java的数据库我建议使用Apache Derby ，研究数据库想成为一个数据库的高手我建议你先研究Apache Derby。Apache Derby是一个高质量的、纯 Java开发的嵌入式关系数据库引擎，IBM® 将其捐献给Apache开放源码社区，同时IBM的产品CloudSpace是它对应的产品。Derby是基于文件系统，具有高度的可移植性，并且是轻量级的，这使得它非常便于发布。主要是没有商业用户的很好的界面，没有其太多的功能。不过对于我们使用数据库、研究数据库还是极其有用的。对于中小型的企业说老实话你也不要用什么Oracle、SqlServer了，用Derby就可以了，何况是开源的呢!只要能发挥其长处也不容易啊!下载地址：<a href="http://incubator.apache.org/derby。" target="_blank">http://incubator.apache.org/derby。</a></p>
<p>不过在没有足够的能力前，不要试图读懂它!注释和源代码15000页左右，我一年的阅读量!能读下来并且能真正领会它，绝对高手!你能读完Derby的源代码只有两种可能：1.你成为顶尖的高手――至少是数据库这部分; 2.你疯了。选择吧!!!!作为我自己我先选择Hypersonic SQL这样的数据库先研究，能过这一关，再继续研究Derby!不就是一年的阅读量吗!我可以化3年去研究如何做一个数据库其实还是很值得的!有的人搞IT一辈子自己什么都没有做，也根本没有研究别人的东西!</p>
<p>作为一个IT落后于别国若干年的、从事IT的下游产业“外包”的国家的IT从业人员，我认为还是先研究别人的优秀的东西比较好!可以先研究别人的，然后消化，学为己用!一心闭门造车实在遗憾!</p>
<p>三、JMS方向</p>
<p>JMS可能对大家来说是一个比较陌生的方向!其实JMS是一个比较容易理解，容易上手的方向。主要是Java消息服务，API也是相当简单的。不过在企业应用中相当广泛。下面就介绍几个吧!</p>
<ol>
<li>MOM4J</li>
</ol>
<p>MOM4J是一个完全实现JMS1.1规范的消息中间件并且向下兼容JMS1.0与1.02。它提供了自己的消息处理存储使它独立于关系数据与语言，它的客户端可以用任何语言开发。它可以算是一个小麻雀，很全实现也比较简单!它包含一个命名服务器，一个消息服务器，同时提供自己的持续层。设计也相当的巧妙，完全利用操作系统中文件系统设计的观念。代码也很少，250页左右，最近我在写该实现的源代码阅读方面的书，希望明年年中能与大家见面!下载地址：<a href="http://mom4j.sourceforge.net/index.html。" target="_blank">http://mom4j.sourceforge.net/index.html。</a></p>
<ol>
<li>OpenJMS</li>
</ol>
<p>OpenJMS是一个开源的Java Message Service API 1.0.2 规范的实现，它包含有以下特性：</p>
<ol>
<li><p>它既支持点到点(point-to-point)(PTP)模型和发布/订阅(Pub/Sub)模型。</p>
</li>
<li><p>支持同步与异步消息发送 。</p>
</li>
<li><p>JDBC持久性管理使用数据库表来存储消息 。</p>
</li>
<li><p>可视化管理界面。</p>
</li>
<li><p>Applet支持。</p>
</li>
<li><p>能够与Jakarta Tomcat这样的Servlet容器结合。</p>
</li>
<li><p>支持RMI, TCP, HTTP 与SSL协议。</p>
</li>
<li><p>客户端验证 。</p>
</li>
<li><p>提供可靠消息传输、事务和消息过滤。</p>
</li>
</ol>
<p>很好的JMS方向的开源项目!我目前也在研究它的源代码!学习它可以顺便研究JNDI的实现、以及网络通信的细节。这是我JMS方向研究的第二个开源项目。代码量1600页左右吧!下载地址：<a href="http://openjms.sourceforge.net/index.html" target="_blank">http://openjms.sourceforge.net/index.html</a></p>
<ol>
<li>ActiveMQ</li>
</ol>
<p>ActiveMQ是一个开放源码基于Apache 2.0 licenced 发布并实现了JMS 1.1。它能够与Geronimo，轻量级容器和任Java应用程序无缝的给合。主要是Apache的可以任意的使用和发布哦!个人比较喜欢Apache的源代码!下载地址：<a href="http://activemq.codehaus.org/" target="_blank">http://activemq.codehaus.org/</a></p>
<ol>
<li>JORAM</li>
</ol>
<p>JORAM一个类似于openJMS分布在ObjectWeb之下的JMS消息中间件。ObjectWeb的产品也是非常值得研究的!下面我还会给大家另外一个ObjectWeb的产品。下载地址：<a href="http://joram.objectweb.org/" target="_blank">http://joram.objectweb.org/</a></p>
<p>我个人推荐：OpenJMS和ActiveMQ!</p>
<p>四、EJB方向</p>
<p>EJB一个比较“高级”的方向。Sun公司曾经以此在分布式计算领域重拳出击。不过自从出现了Spring、Hibernation……后似乎没落了!这个方向单独开源的也比较少，主要EJB是和JNDI、JDBC、JMS、JTS、JTA结合在一起的是以很少有单独的。下面推荐两个不过好像也要下载其它类库。</p>
<ol>
<li>EasyBeans</li>
</ol>
<p>ObjectWeb的一个新的项目，一个轻量级的EJB3容器，虽然还没有正式发布，但是已经可以从它们的subversion仓库中检出代码。代码量比较小600页左右，熟读它可以对网络编程、架构、RMI、容器的状态设计比较了解了!即学会EJB又能学习其它设计方法何乐而不为哦!下载地址：<a href="http://easybeans.objectweb.org/" target="_blank">http://easybeans.objectweb.org/</a></p>
<ol>
<li>OpenEJB</li>
</ol>
<p>OpenEJB是一个预生成的、自包含的、可移植的EJB容器系统，可以被插入到任意的服务器环境，包括应用程序服务器，Web服务器，J2EE平台， CORBA ORB和数据库等等。OpenEJB 被用于 Apple的WebObjects。听起来很好，我目前没有研究过。不知道我就不推荐了。下载地址：<a href="http://www.openejb.org/" target="_blank">http://www.openejb.org/</a></p>
<p>五、J2EE容器</p>
<p>上面谈了这么多，都是J2EE的各个方向的。其实J2EE是一个规范，J2EE的产品一般要求专业提供商必须提供它们的实现。这些实现本身就是J2EE容器。市场上流行的J2EE容器很多，在开源领域流行的只有很少，很少。其中最著名的是JBoss。</p>
<ol>
<li>JBoss</li>
</ol>
<p>在J2EE应用服务器领域，Jboss是发展最为迅速的应用服务器。由于Jboss遵循商业友好的LGPL授权分发，并且由开源社区开发，这使得Jboss广为流行。另外，Jboss应用服务器还具有许多优秀的特质。</p>
<p>其一，它将具有革命性的JMX微内核服务作为其总线结构;</p>
<p>其二，它本身就是面向服务的架构(Service-Oriented Architecture，SOA);</p>
<p>其三，它还具有统一的类装载器，从而能够实现应用的热部署和热卸载能力。因此，它是高度模块化的和松耦合的。Jboss用户的积极反馈告诉我们，Jboss应用服务器是健壮的、高质量的，而且还具有良好的性能。为满足企业级市场日益增长的需求，Jboss公司从2003年开始就推出了24/*7、专业级产品支持服务。同时，为拓展Jboss的企业级市场，Jboss公司还签订了许多渠道合作伙伴。比如，Jboss公司同HP、Novell、Computer Associates、Unisys等都是合作伙伴。</p>
<p>在2004年6月，Jboss公司宣布，Jboss应用服务器通过了Sun公司的J2EE认证。这是Jboss应用服务器发展史上至今为止最重要的里程碑。与此同时，Jboss一直在紧跟最新的J2EE规范，而且在某些技术领域引领J2EE规范的开发。因此，无论在商业领域，还是在开源社区，Jboss成为了第一个通过J2EE 1.4认证的主流应用服务器。现在，Jboss应用服务器已经真正发展成具有企业强度(即，支持关键级任务的应用)的应用服务器。</p>
<p>Jboss 4.0作为J2EE认证的重要成果之一，已经于2004年9月顺利发布了。同时，Jboss 4.0还提供了Jboss AOP(Aspect-Oriented Programming，面向方面编程)组件。近来，AOP吸引了大量开发者的关注。它提供的新的编程模式使得用户能够将方面(比如，事务)从底层业务逻辑中分离出来，从而能够缩短软件开发周期。用户能够单独使用Jboss AOP，即能够在Jboss应用服务器外部使用它。或者，用户也可以在应用服务器环境中使用它。Jboss AOP 1.0已经在2004年10月发布了。 很有名吧!可以下载一个用一下，下载地址：<a href="http://www.jboss.org/" target="_blank">http://www.jboss.org/</a></p>
<p>关于JBoss的使用资料也非常多，甚至比商业软件的还多。有机会研究吧!</p>
<ol>
<li>JOnAS</li>
</ol>
<p>JOnAS是一个开放源代码的J2EE实现，在ObjectWeb协会中开发。整合了Tomcat或Jetty成为它的Web容器，以确保符合Servlet 2.3和JSP 1.2规范。JOnAS服务器依赖或实现以下的Java API：JCA、JDBC、JTA 、JMS、JMX、JNDI、JAAS、JavaMail 。下载地址：<a href="http://jonas.objectweb.org/" target="_blank">http://jonas.objectweb.org/</a>
3.Apache Geronimo</p>
<p>Apache Geronimo 是 Apache 软件基金会的开放源码J2EE服务器，它集成了众多先进技术和设计理念。 这些技术和理念大多源自独立的项目，配置和部署模型也各不相同。 Geronimo能将这些项目和方法的配置及部署完全整合到一个统一、易用的模型中。作为符合J2EE标准的服务器，Geronimo提供了丰富的功能集和无责任 Apache 许可，具备“立即部署”式J2EE 1.4容器的各种优点，其中包括：</p>
<ol>
<li><p>符合J2EE1.4标准的服务器 。</p>
</li>
<li><p>预集成的开放源码项目 。</p>
</li>
<li><p>统一的集成模型 。</p>
</li>
<li><p>可伸缩性、可管理性和配置管理功能。</p>
</li>
</ol>
<p>我一直比较推荐Apache的产品。主要是可以任意自由地使用。下载地址：<a href="http://incubator.apache.org/projects/geronimo/" target="_blank">http://incubator.apache.org/projects/geronimo/</a></p>
<p>六、其它</p>
<p>讲了这么多大家可能很厌烦了!是不是很多很多啊!其实不然，我们不会的太多太多了!不会的太多太多了。不管你是不是J2EE高手，还是J2SE高手，有些东西你要绝对很精明的。例如：1.Java的Collections Framework就是java的数据结构了，不仅要吃透它，还要能按照需要扩展它，利用其思想创建一个自己的数据结构。2.网络编程肯定要会吧，现在以及以后很多程序都是不在同一台机器上的，不会网络怎么行哦!3.IO肯定要会的吧!你的程序难道不用输入输出数据啊!整个IO包加NIO也有600多页的源代码哦!4.JDBC你要会吧!数据库都不会，在你的企业应用中你的数据又保存到哪里啊!文件中――太落后了吧!典型的没有学过J2EE。尽管数据库背后也是采用文件保存的。5.Serverlet、JSp你要是做网页做网站，肯定要做到。问你一个简单的问题，网页中如何实现分页啊!有具体方法的就在本文章后发言吧!6. Ant要会吧!java语言中发布的工具，类似与c中的make工具。7.JUnit用过吧!单元测试软件。你不要啊!你的软件就没有bug!你牛!(建议大家研究研究其源代码，很有用的框架，包含大量的设计模式，源代码不到100页!看了只能感叹――高手就是高手)细心的朋友可以看到在你使用的很多IDE工具中都有JUnit哦!就是它。</p>
<p>一切的一切才刚刚开始!有兴趣，有需要你可以研究数据库连接池的框架，如：C3P0、Jakarta DBCP、 DBPool….可以研究J2EE框架Spring……. Web框架Struts……持久层框架Hibernate…..甚至开发工具Eclipse…..Sun领导的点对点通信的JXTA…..报表工具JFreeChart、JasperReports…..分布式网络编程的CORBA、网络通信的JGROUPS、XML解析的xerces…..(在不经意间开源已经步入你的电脑，不信啊!你JDK的安装目录jdk1.6.0 src com sun org apache就是Xerces，一个XML解析的著名的开源 项目)</p>
<p>不管怎么样我还是建议从基本的做起，学精J2SE，熟读它的源码，准确了解其设计理念，然后分头击破J2EE――一口吃不成一个胖子!不要贪多贪广!脚踏实地就可以了!</p>
<hr>
<p><strong><a href="http://www.webjx.com/exam/java-15508.html" target="_blank">http://www.webjx.com/exam/java-15508.html</a></strong></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_总结类/">Java_总结类</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_总结类/" class="label label-success">Java_总结类</a></span> | <span class="time">recent updated:<time title="2014-03-07 01:54:43"datetime="2014-03-07 01:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE学习总结思维方式和理念/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_总结类--J2EE学习总结思维方式和理念" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--请别再拿“StringsnewString-xyz-创建了多少个String实例”来/">请别再拿“String s = new String(</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T09:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--请别再拿“StringsnewString-xyz-创建了多少个String实例”来/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-string-s-new-string-xyz-string-">请别再拿“String s = new String(&quot;xyz&quot;);创建了多少个String实例”来面试了吧</h1>
<p>这帖是用来回复<a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a>圈子里的一个问题，<a href="http://hllvm.group.iteye.com/group/topic/21761" target="_blank">一道Java笔试题</a>的。
本来因为见得太多已经吐槽无力，但这次实在忍不住了就又爆发了一把。写得太长干脆单独开了一帖。
顺带广告：对JVM感兴趣的同学们同志们请多多支持<a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a>圈子 <img src="" alt=""></p>
<h1 id="-">以下是回复内容。文中的“楼主”是针对原问题帖而言。</h1>
<p>楼主是看各种宝典了么……以后我面试人的时候就要专找宝典答案是错的来问，方便筛人orz
楼主要注意了：这题或类似的题虽然经常见，但使用这个描述方式实际上没有任何意义：
引用</p>
<p>问题：</p>
<p>Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>String s = new String(&quot;xyz&quot;);<br>String s = new String(&quot;xyz&quot;);创建了几个String Object？
这个问题自身就没有合理的答案，楼主所引用的“标准答案”自然也就不准确了：
引用</li>
</ol>
<p>答案：两个(一个是“xyz”,一个是指向“xyz”的引用对象s)
（好吧这个答案的吐槽点很多……大家慢慢来）
这问题的毛病是什么呢？它并没有定义“创建了”的意义。
什么叫“创建了”？什么时候创建了什么？
而且这段Java代码片段实际运行的时候真的会“创建两个String实例”么？
如果这道是面试题，那么可以当面让面试官澄清“创建了”的定义，然后再对应的回答。这种时候面试官多半会让被面试者自己解释，那就好办了，好好晒给面试官看。</p>
<h1 id="-">如果是笔试题就没有提问要求澄清的机会了。不过会出这种题目的地方水平多半也不怎么样。说不定出题的人就是从各种宝典上把题抄来的，那就按照宝典把那不大对劲的答案写上去就能混过去了<img src="" alt=""></h1>
<p>先换成另一个问题来问：
引用</p>
<p>问题：</p>
<p>Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>String s = new String(&quot;xyz&quot;);<br>String s = new String(&quot;xyz&quot;);在运行时涉及几个String实例？
一种合理的解答是：
引用</li>
</ol>
<p>答案：两个，一个是字符串字面量&quot;xyz&quot;所对应的、驻留（intern）在一个全局共享的字符串常量池中的实例，另一个是通过new String(String)创建并初始化的、内容与&quot;xyz&quot;相同的实例
这是根据Java语言规范相关规定可以给出的合理答案。考虑到Java语言规范中明确指出了：
The Java Language Specification, Third Edition 写道</p>
<p>The Java programming language is normally compiled to the bytecoded instruction set and binary format defined in <em>The Java Virtual Machine Specification, Second Edition</em> (Addison-Wesley, 1999).
也就是规定了Java语言一般是编译为Java虚拟机规范所定义的Class文件，但并没有规定“一定”（must），留有不使用JVM来实现Java语言的余地。
考虑上Java虚拟机规范，确实在这段代码里涉及的常量种类为<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#29297" target="_blank">CONSTANT_String_info</a>的字符串常量也只有&quot;xyz&quot;一个。CONSTANT_String_info是用来表示Java语言中String类型的常量表达式的值（包括字符串字面量）用的常量种类，只在这个层面上考虑的话，这个解答也没问题。
所以这种解答可以认为是合理的。
值得注意的是问题中“在运行时”既包括类加载阶段，也包括这个代码片段自身执行的时候。下文会再讨论这个细节与楼主原本给出的问题的关系。
碰到这种问题首先应该想到去查阅相关的规范，这里具体是<a href="http://java.sun.com/docs/books/jls/" target="_blank">Java语言规范</a>与<a href="http://java.sun.com/docs/books/jvms/" target="_blank">Java虚拟机规范</a>，以及一些相关API的JavaDoc。很多人喜欢把“按道理说”当作口头禅，规范就是用来定义各种“道理”的——“为什么XXX是YYY的意思？”“因为规范里是这样定义的！”——无敌了。
在Java虚拟机规范中相关的定义有下面一些：
The Java Virtual Machine Specification, Second Edition 写道</p>
<p><strong>2.3 Literals</strong>
A literal is the source code representation of a value of a primitive type <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#19511" target="_blank">(§2.4.1)</a>, the String type <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#25486" target="_blank">(§2.4.8)</a>, or the null type <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#22930" target="_blank">(§2.4)</a>. String literals and, more generally, strings that are the values of constant expressions are &quot;interned&quot; so as to share unique instances, using the method String.intern.
The null type has one value, the null reference, denoted by the literal null. The boolean type has two values, denoted by the literals true and false.
<strong>2.4.8 The Class String</strong>
Instances of class String represent sequences of Unicode characters <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#25310" target="_blank">(§2.1)</a>. A String object has a constant, unchanging value. String literals <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#20359" target="_blank">(§2.3)</a> are references to instances of class String.
<strong>2.17.6 Creation of New Class Instances</strong>
A new class instance is explicitly created when one of the following situations occurs:</p>
<ul>
<li>Evaluation of a class instance creation expression creates a new instance of the class whose name appears in the expression.</li>
<li><p>Invocation of the newInstance method of class Class creates a new instance of the class represented by the Class object for which the method was invoked.
A new class instance may be implicitly created in the following situations:</p>
</li>
<li><p>Loading of a class or interface that contains a String literal may create a new String object <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#25486" target="_blank">(§2.4.8)</a> to represent that literal. This may not occur if the a String object has already been created to represent a previous occurrence of that literal, or if the String.intern method has been invoked on a String object representing the same string as the literal.</p>
</li>
<li>Execution of a string concatenation operator that is not part of a constant expression sometimes creates a new String object to represent the result. String concatenation operators may also create temporary wrapper objects for a value of a primitive type <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#19511" target="_blank">(§2.4.1)</a>.
Each of these situations identifies a particular constructor to be called with specified arguments (possibly none) as part of the class instance creation process.
<strong>5.1 The Runtime Constant Pool</strong>
...
● A string literal <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#20359" target="_blank">(§2.3)</a> is derived from a CONSTANT_String_info structure <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#29297" target="_blank">(§4.4.3)</a> in the binary representation of a class or interface. The CONSTANT_String_info structure gives the sequence of Unicode characters constituting the string literal.
● The Java programming language requires that identical string literals (that is, literals that contain the same sequence of characters) must refer to the same instance of class String. In addition, if the method String.intern is called on any string, the result is a reference to the same class instance that would be returned if that string appeared as a literal. Thus,
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></li>
</ul>
<ol>
<li>(&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() == &quot;abc&quot;  </li>
</ol>
<p>(&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() == &quot;abc&quot;
must have the value true.
● To derive a string literal, the Java virtual machine examines the sequence of characters given by the CONSTANT_String_info structure.
  ○ If the method String.intern has previously been called on an instance of class String containing a sequence of Unicode characters identical to that given by the CONSTANT_String_info structure, then the result of string literal derivation is a reference to that same instance of class String.
  ○ Otherwise, a new instance of class String is created containing the sequence of Unicode characters given by the CONSTANT_String_info structure; that class instance is the result of string literal derivation. Finally, the intern method of the new String instance is invoked.
...
The remaining structures in the constant_pool table of the binary representation of a class or interface, the CONSTANT_NameAndType_info <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#1327" target="_blank">(§4.4.6)</a> and CONSTANT_Utf8_info <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#7963" target="_blank">(§4.4.7)</a> structures are only used indirectly when deriving symbolic references to classes, interfaces, methods, and fields, and when deriving string literals.
把Sun的JDK看作参考实现（reference implementation, RI），其中<a href="http://download.oracle.com/javase/6/docs/api/java/lang/String.html#intern(" target="_blank">String.intern()的JavaDoc</a>)为：
JavaDoc 写道</p>
<p>public String intern()
    Returns a canonical representation for the string object.
    A pool of strings, initially empty, is maintained privately by the class String.
    When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.
    It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.
    All literal strings and string-valued constant expressions are interned. String literals are defined in §3.10.5 of the Java Language Specification
    <strong>Returns:</strong></p>
<pre><code>    a string that has the same contents as this string, but is guaranteed to be from a pool of unique strings.
</code></pre><p>===============================================================
再换一个问题来问：
引用</p>
<p>问题：</p>
<p>Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>String s = new String(&quot;xyz&quot;);<br>String s = new String(&quot;xyz&quot;); 涉及用户声明的几个String类型的变量？
答案也很简单：
引用</li>
</ol>
<p>答案：一个，就是String s。
把问题换成下面这个版本，答案也一样：
引用</p>
<p>问题：</p>
<p>Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li><p>String s = null;<br>String s = null; 涉及用户声明的几个String类型的变量？
Java里变量就是变量，引用类型的变量只是对某个对象实例或者null的引用，不是实例本身。声明变量的个数跟创建实例的个数没有必然关系，像是说：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>String s1 = &quot;a&quot;;  </p>
</li>
<li>String s2 = s1.concat(&quot;&quot;);  </li>
<li>String s3 = null;  </li>
<li>new String(s1);  </li>
</ol>
<p>String s1 = &quot;a&quot;;</p>
<p>String s2 = s1.concat(&quot;&quot;);
String s3 = null;</p>
<p>new String(s1);
这段代码会涉及3个String类型的变量，
1、s1，指向下面String实例的1
2、s2，指向与s1相同
3、s3，值为null，不指向任何实例
以及3个String实例，
1、&quot;a&quot;字面量对应的驻留的字符串常量的String实例
2、&quot;&quot;字面量对应的驻留的字符串常量的String实例
（<a href="http://download.oracle.com/javase/6/docs/api/java/lang/String.html#concat(java.lang.String" target="_blank">String.concat()</a>)是个有趣的方法，当发现传入的参数是空字符串时会返回this，所以这里不会额外创建新的String实例）</p>
<h1 id="3-new-string-string-string-">3、通过new String(String)创建的新String实例；没有任何变量指向它。</h1>
<p>回到楼主开头引用的问题与“标准答案”
引用</p>
<p>问题：</p>
<p>Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li><p>String s = new String(&quot;xyz&quot;);<br>String s = new String(&quot;xyz&quot;);创建了几个String Object？
答案：两个(一个是“xyz”,一个是指向“xyz”的引用对象s)
用归谬法论证。假定问题问的是“在执行这段代码片段时创建了几个String实例”。如果“标准答案”是正确的，那么下面的代码片段在执行时就应该创建4个String实例了：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>String s1 = new String(&quot;xyz&quot;);  </p>
</li>
<li>String s2 = new String(&quot;xyz&quot;);  </li>
</ol>
<p>String s1 = new String(&quot;xyz&quot;);</p>
<p>String s2 = new String(&quot;xyz&quot;);
马上就会有人跳出来说上下两个&quot;xyz&quot;字面量都是引用了同一个String对象，所以不应该是创建了4个对象。
那么应该是多少个？
运行时的类加载过程与实际执行某个代码片段，两者必须分开讨论才有那么点意义。
为了执行问题中的代码片段，其所在的类必然要先被加载，而且同一个类最多只会被加载一次（要注意对JVM来说“同一个类”并不是类的全限定名相同就足够了，而是&lt;类全限定名, 定义类加载器&gt;一对都相同才行）。
根据上文引用的规范的内容，符合规范的JVM实现应该在类加载的过程中创建并驻留一个String实例作为常量来对应&quot;xyz&quot;字面量；具体是在类加载的resolve阶段进行的。这个常量是全局共享的，只在先前尚未有内容相同的字符串驻留过的前提下才需要创建新的String实例。
等到真正执行原问题中的代码片段时，JVM需要执行的字节码类似这样：
Java bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0: new  /#2; //class java/lang/String  </li>
<li>3: dup  </li>
<li>4: ldc  /#3; //String xyz  </li>
<li>6: invokespecial    /#4; //Method java/lang/String.&quot;<init>&quot;:(Ljava/lang/String;)V  </li>
<li>9: astore_1  </li>
</ol>
<p>0: new    /#2; //class java/lang/String</p>
<p>3: dup
4: ldc    /#3; //String xyz</p>
<p>6: invokespecial    /#4; //Method java/lang/String.&quot;<init>&quot;:(Ljava/lang/String;)V
9: astore_1
这之中出现过多少次new java/lang/String就是创建了多少个String对象。也就是说原问题中的代码在每执行一次只会新创建一个String实例。
这里，ldc指令只是把先前在类加载过程中已经创建好的一个String对象（&quot;xyz&quot;）的一个引用压到操作数栈顶而已，并不新创建String对象。
所以刚才用于归谬的代码片段：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>String s1 = new String(&quot;xyz&quot;);  </li>
<li>String s2 = new String(&quot;xyz&quot;);  </li>
</ol>
<p>String s1 = new String(&quot;xyz&quot;);</p>
<p>String s2 = new String(&quot;xyz&quot;);</p>
<h2 id="-2-string-">每执行一次只会新创建2个String实例。</h2>
<p>为了避免一些同学犯糊涂，再强调一次：
在Java语言里，“new”表达式是负责创建实例的，其中会调用构造器去对实例做初始化；构造器自身的返回值类型是void，并不是“构造器返回了新创建的对象的引用”，而是new表达式的值是新创建的对象的引用。
对应的，在JVM里，“new”字节码指令只负责把实例创建出来（包括分配空间、设定类型、所有字段设置默认值等工作），并且把指向新创建对象的引用压到操作数栈顶。此时该引用还不能直接使用，处于未初始化状态（uninitialized）；如果某方法a含有代码试图通过未初始化状态的引用来调用任何实例方法，那么方法a会通不过JVM的字节码校验，从而被JVM拒绝执行。
能对未初始化状态的引用做的唯一一种事情就是通过它调用实例构造器，在Class文件层面表现为特殊初始化方法“<init>”。实际调用的指令是invokespecial，而在实际调用前要把需要的参数按顺序压到操作数栈上。在上面的字节码例子中，压参数的指令包括dup和ldc两条，分别把隐藏参数（新创建的实例的引用，对于实例构造器来说就是“this”）与显式声明的第一个实际参数（&quot;xyz&quot;常量的引用）压到操作数栈上。
在构造器返回之后，新创建的实例的引用就可以正常使用了。</p>
<h1 id="-http-rednaxelafx-iteye-com-blog-652719-">关于构造器的讨论，可以参考我之前的一帖，<a href="http://rednaxelafx.iteye.com/blog/652719" target="_blank">实例构造器是不是静态方法？</a></h1>
<p>以上讨论都只是针对规范所定义的Java语言与Java虚拟机而言。概念上是如此，但实际的JVM实现可以做得更优化，原问题中的代码片段有可能在实际执行的时候一个String实例也不会完整创建（没有分配空间）。
例如说，在x86、Windows Vista SP2、Sun JDK 6 update 14的fastdebug版上跑下面的测试代码：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class C2EscapeAnalysisDemo {  </li>
<li>private static void warmUp() {  </li>
<li>IFoo[] array = new IFoo[] {  </li>
<li>new FooA(), new FooB(), new FooC(), new FooD()  </li>
<li>};  </li>
<li>for (int i = 0; i &lt; 1000000; i++) {  </li>
<li>array[i % array.length].foo(); // megamorphic callsite to prevent inlining  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>public static void main(String[] args) {  </li>
<li>while (true) {  </li>
<li>warmUp();  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>interface IFoo {  </li>
<li>void foo();  </li>
<li>}  </li>
<li></li>
<li>class FooA implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String s1 = new String(&quot;xyz&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>class FooB implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String s1 = new String(&quot;xyz&quot;);  </li>
<li>String s2 = new String(&quot;xyz&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>class FooC implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String s1 = new String(&quot;xyz&quot;);  </li>
<li>String s2 = new String(&quot;xyz&quot;);  </li>
<li>String s3 = new String(&quot;xyz&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>class FooD implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String s1 = new String(&quot;xyz&quot;);  </li>
<li>String s2 = new String(&quot;xyz&quot;);  </li>
<li>String s3 = new String(&quot;xyz&quot;);  </li>
<li>String s4 = new String(&quot;xyz&quot;);  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public class C2EscapeAnalysisDemo {</p>
<p>  private static void warmUp() {
    IFoo[] array = new IFoo[] {</p>
<pre><code>  new FooA(), new FooB(), new FooC(), new FooD()
};

for (int i = 0; i &lt; 1000000; i++) {
  array[i % array.length].foo(); // megamorphic callsite to prevent inlining

}
</code></pre><p>  }</p>
<p>  public static void main(String[] args) {</p>
<pre><code>while (true) {
  warmUp();

}
</code></pre><p>  }</p>
<p>}</p>
<p>interface IFoo {
  void foo();</p>
<p>}</p>
<p>class FooA implements IFoo {
  public void foo() {</p>
<pre><code>String s1 = new String(&quot;xyz&quot;);
</code></pre><p>  }</p>
<p>}</p>
<p>class FooB implements IFoo {
  public void foo() {</p>
<pre><code>String s1 = new String(&quot;xyz&quot;);
String s2 = new String(&quot;xyz&quot;);
</code></pre><p>  }
}</p>
<p>class FooC implements IFoo {</p>
<p>  public void foo() {
    String s1 = new String(&quot;xyz&quot;);</p>
<pre><code>String s2 = new String(&quot;xyz&quot;);
String s3 = new String(&quot;xyz&quot;);
</code></pre><p>  }
}</p>
<p>class FooD implements IFoo {</p>
<p>  public void foo() {
    String s1 = new String(&quot;xyz&quot;);</p>
<pre><code>String s2 = new String(&quot;xyz&quot;);
String s3 = new String(&quot;xyz&quot;);

String s4 = new String(&quot;xyz&quot;);
</code></pre><p>  }</p>
<p>}
照常用javac用默认参数编译，然后先用server模式的默认配置来跑，顺带打出GC和JIT编译日志来看
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>java -server -verbose:gc -XX:+PrintCompilation C2EscapeAnalysisDemo  </li>
</ol>
<p>java -server -verbose:gc -XX:+PrintCompilation C2EscapeAnalysisDemo
看到的日志的开头一段如下：
Hotspot log代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>1       java.lang.String::charAt (33 bytes)  </li>
<li>2       java.lang.Object::<init> (1 bytes)  </li>
<li>3       java.lang.String::<init> (61 bytes)  </li>
<li>1%      C2EscapeAnalysisDemo::warmUp @ 47 (71 bytes)  </li>
<li>4       FooA::foo (11 bytes)  </li>
<li>5       FooB::foo (21 bytes)  </li>
<li>6       FooC::foo (31 bytes)  </li>
<li>7       FooD::foo (42 bytes)  </li>
<li>[GC 3072K-&gt;168K(32768K), 0.0058325 secs]  </li>
<li>[GC 3240K-&gt;160K(32768K), 0.0104623 secs]  </li>
<li>[GC 3232K-&gt;160K(32768K), 0.0027323 secs]  </li>
<li>[GC 3232K-&gt;160K(35840K), 0.0026220 secs]  </li>
<li>[GC 6304K-&gt;160K(35840K), 0.0173733 secs]  </li>
<li>[GC 6304K-&gt;144K(41664K), 0.0059720 secs]  </li>
<li>[GC 12432K-&gt;144K(41664K), 0.0353320 secs]  </li>
<li>[GC 12432K-&gt;144K(54016K), 0.0139333 secs]  </li>
<li>8       C2EscapeAnalysisDemo::warmUp (71 bytes)  </li>
<li>[GC 24720K-&gt;160K(54016K), 0.0697970 secs]  </li>
<li>[GC 24736K-&gt;160K(68800K), 0.0261921 secs]  </li>
<li>[GC 39520K-&gt;160K(68800K), 0.0958433 secs]  </li>
<li>[GC 39520K-&gt;160K(87168K), 0.0433377 secs]  </li>
<li>[GC 57888K-&gt;160K(87168K), 0.0542482 secs]  </li>
<li>[GC 57888K-&gt;148K(87168K), 0.0533140 secs]  </li>
<li>[GC 57876K-&gt;164K(84288K), 0.0533537 secs]  </li>
<li>[GC 55204K-&gt;164K(81728K), 0.0596820 secs]  </li>
<li>[GC 52644K-&gt;164K(79488K), 0.0515090 secs]  </li>
<li>[GC 50212K-&gt;164K(76992K), 0.0491227 secs]  </li>
<li>[GC 47908K-&gt;164K(74944K), 0.0450666 secs]  </li>
<li>[GC 45668K-&gt;164K(72640K), 0.0467671 secs]  </li>
<li>[GC 43556K-&gt;152K(70784K), 0.0420757 secs]  </li>
<li>[GC 41560K-&gt;168K(68736K), 0.0391296 secs]  </li>
<li>[GC 39656K-&gt;168K(67072K), 0.0397539 secs]  </li>
<li><p>[GC 37864K-&gt;188K(65216K), 0.0360861 secs]  </p>
<p>1       java.lang.String::charAt (33 bytes)</p>
<p>2       java.lang.Object::<init> (1 bytes)
3       java.lang.String::<init> (61 bytes)</p>
<p>1%      C2EscapeAnalysisDemo::warmUp @ 47 (71 bytes)
4       FooA::foo (11 bytes)</p>
<p>5       FooB::foo (21 bytes)
6       FooC::foo (31 bytes)</p>
<p>7       FooD::foo (42 bytes)
[GC 3072K-&gt;168K(32768K), 0.0058325 secs]</p>
</li>
</ol>
<p>[GC 3240K-&gt;160K(32768K), 0.0104623 secs]
[GC 3232K-&gt;160K(32768K), 0.0027323 secs]</p>
<p>[GC 3232K-&gt;160K(35840K), 0.0026220 secs]
[GC 6304K-&gt;160K(35840K), 0.0173733 secs]</p>
<p>[GC 6304K-&gt;144K(41664K), 0.0059720 secs]
[GC 12432K-&gt;144K(41664K), 0.0353320 secs]</p>
<p>[GC 12432K-&gt;144K(54016K), 0.0139333 secs]
  8       C2EscapeAnalysisDemo::warmUp (71 bytes)</p>
<p>[GC 24720K-&gt;160K(54016K), 0.0697970 secs]
[GC 24736K-&gt;160K(68800K), 0.0261921 secs]</p>
<p>[GC 39520K-&gt;160K(68800K), 0.0958433 secs]
[GC 39520K-&gt;160K(87168K), 0.0433377 secs]</p>
<p>[GC 57888K-&gt;160K(87168K), 0.0542482 secs]
[GC 57888K-&gt;148K(87168K), 0.0533140 secs]</p>
<p>[GC 57876K-&gt;164K(84288K), 0.0533537 secs]
[GC 55204K-&gt;164K(81728K), 0.0596820 secs]</p>
<p>[GC 52644K-&gt;164K(79488K), 0.0515090 secs]
[GC 50212K-&gt;164K(76992K), 0.0491227 secs]</p>
<p>[GC 47908K-&gt;164K(74944K), 0.0450666 secs]
[GC 45668K-&gt;164K(72640K), 0.0467671 secs]</p>
<p>[GC 43556K-&gt;152K(70784K), 0.0420757 secs]
[GC 41560K-&gt;168K(68736K), 0.0391296 secs]</p>
<p>[GC 39656K-&gt;168K(67072K), 0.0397539 secs]
[GC 37864K-&gt;188K(65216K), 0.0360861 secs]
上面的日志中，后面的方法名的行是JIT编译的日志，而以<a href="&quot;复制代码&quot;">GC开头的是minor GC的日志。
程序一直跑，GC的日志还会不断的打出来。这是理所当然的对吧？HotSpot的堆就那么大，而测试代码在不断新创建String对象，肯定得不断触发GC的。
用不同的VM启动参数来跑的话，
Command prompt代码 [<img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>java -server -verbose:gc -XX:+PrintCompilation -XX:+DoEscapeAnalysis -XX:+EliminateAllocations C2EscapeAnalysisDemo  </li>
</ol>
<p>java -server -verbose:gc -XX:+PrintCompilation -XX:+DoEscapeAnalysis -XX:+EliminateAllocations C2EscapeAnalysisDemo
还是同样的Java测试程序，同样的Sun JDK 6 update 14，但打开了逃逸分析和空间分配消除功能，再运行，看到的全部日志如下：
Hotspot log代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>1       java.lang.String::charAt (33 bytes)  </li>
<li>2       java.lang.Object::<init> (1 bytes)  </li>
<li>3       java.lang.String::<init> (61 bytes)  </li>
<li>1%      C2EscapeAnalysisDemo::warmUp @ 47 (71 bytes)  </li>
<li>5       FooB::foo (21 bytes)  </li>
<li>4       FooA::foo (11 bytes)  </li>
<li>6       FooC::foo (31 bytes)  </li>
<li>7       FooD::foo (42 bytes)  </li>
<li>[GC 3072K-&gt;176K(32768K), 0.0056527 secs]  </li>
<li><p>8       C2EscapeAnalysisDemo::warmUp (71 bytes)  </p>
<p>1       java.lang.String::charAt (33 bytes)</p>
<p>2       java.lang.Object::<init> (1 bytes)
3       java.lang.String::<init> (61 bytes)</p>
<p>1%      C2EscapeAnalysisDemo::warmUp @ 47 (71 bytes)
5       FooB::foo (21 bytes)</p>
<p>4       FooA::foo (11 bytes)
6       FooC::foo (31 bytes)</p>
<p>7       FooD::foo (42 bytes)
[GC 3072K-&gt;176K(32768K), 0.0056527 secs]</p>
<p>8       C2EscapeAnalysisDemo::warmUp (71 bytes)
继续跑下去也没有再打出GC日志了。难道新创建String对象都不吃内存了么？
实际情况是：经过HotSpot的server模式编译器的优化后，FooA、FooB、FooC、FooD四个版本的foo()实现都不新创建String实例了。这样自然不吃内存，也就不再触发GC了。
经过的分析和优化笼统说有方法内联（method inlining）、逃逸分析（escape analysis）、标量替换（scalar replacement）、无用代码削除（dead-code elimination）之类。
FooA.foo()最短，就以它举例来大致演示一下优化的过程。
它其实就是创建并初始化了一个String对象而已。调用的构造器的源码是：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>public String(String original) {  </p>
</li>
<li>int size = original.count;  </li>
<li>char[] originalValue = original.value;  </li>
<li>char[] v;  </li>
<li>if (originalValue.length &gt; size) {  </li>
<li>// The array representing the String is bigger than the new  </li>
<li>// String itself.  Perhaps this constructor is being called  </li>
<li>// in order to trim the baggage, so make a copy of the array.  </li>
<li>int off = original.offset;  </li>
<li>v = Arrays.copyOfRange(originalValue, off, off+size);  </li>
<li>} else {  </li>
<li>// The array representing the String is the same  </li>
<li>// size as the String, so no point in making a copy.  </li>
<li>v = originalValue;  </li>
<li>}  </li>
<li>this.offset = 0;  </li>
<li>this.count = size;  </li>
<li>this.value = v;  </li>
<li>}  </li>
</ol>
<p>public String(String original) {</p>
<pre><code>int size = original.count;
char[] originalValue = original.value;

char[] v;
if (originalValue.length &gt; size) {

   // The array representing the String is bigger than the new
   // String itself.  Perhaps this constructor is being called

   // in order to trim the baggage, so make a copy of the array.
  int off = original.offset;

  v = Arrays.copyOfRange(originalValue, off, off+size);
} else {

   // The array representing the String is the same
   // size as the String, so no point in making a copy.

  v = originalValue;
}

this.offset = 0;
this.count = size;

this.value = v;
</code></pre><p>}
因为参数是&quot;xyz&quot;，可以确定在我们的测试代码里不会走到构造器的if分支里，下面为了演示方便就省略掉那部分代码（实际代码还是存在的，只是没执行而已）
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public String(String original) {  </li>
<li>int size = original.count;  </li>
<li>char[] originalValue = original.value;  </li>
<li>char[] v;  </li>
<li>if (originalValue.length &gt; size) {  </li>
<li>// 省略  </li>
<li>} else {  </li>
<li>v = originalValue;  </li>
<li>}  </li>
<li>this.offset = 0;  </li>
<li>this.count = size;  </li>
<li>this.value = v;  </li>
<li>}  </li>
</ol>
<p>public String(String original) {</p>
<pre><code>int size = original.count;
char[] originalValue = original.value;

char[] v;
if (originalValue.length &gt; size) {

   // 省略
} else {

  v = originalValue;
}

this.offset = 0;
this.count = size;

this.value = v;
</code></pre><p>}
那么把构造器内联到FooA.foo()里，
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public FooA implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String s = AllocateString(); // 这里虚构一个只分配空间，不调用构造器的函数  </li>
<li>String original = &quot;xyz&quot;;  </li>
<li></li>
<li>// 下面就是内联进来的构造器内容  </li>
<li>int size = original.count;  </li>
<li>char[] originalValue = original.value;  </li>
<li>char[] v;  </li>
<li>if (originalValue.length &gt; size) {  </li>
<li>// 省略  </li>
<li>} else {  </li>
<li>v = originalValue;  </li>
<li>}  </li>
<li></li>
<li>s.offset = 0;  </li>
<li>s.count = size;  </li>
<li>s.value = v;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public FooA implements IFoo {</p>
<p>  public void foo() {
    String s = AllocateString(); // 这里虚构一个只分配空间，不调用构造器的函数</p>
<pre><code>String original = &quot;xyz&quot;;


// 下面就是内联进来的构造器内容
int size = original.count;

char[] originalValue = original.value;
char[] v;

if (originalValue.length &gt; size) {
   // 省略

} else {
  v = originalValue;

}


s.offset = 0;
s.count = size;

s.value = v;
</code></pre><p>  }</p>
<p>}
然后经过逃逸分析与标量替换，
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public FooA implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String original = &quot;xyz&quot;;  </li>
<li></li>
<li>// 下面就是内联进来的构造器内容  </li>
<li>int size = original.count;  </li>
<li>char[] originalValue = original.value;  </li>
<li>char[] v;  </li>
<li>if (originalValue.length &gt; size) {  </li>
<li>// 省略  </li>
<li>} else {  </li>
<li>v = originalValue;  </li>
<li>}  </li>
<li></li>
<li>// 原本s的实例变量被标量替换为foo()的局部变量  </li>
<li>int sOffset = 0;  </li>
<li>int sCount = size;  </li>
<li>char[] sValue = v;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public FooA implements IFoo {</p>
<p>  public void foo() {
    String original = &quot;xyz&quot;;</p>
<pre><code>// 下面就是内联进来的构造器内容

int size = original.count;
char[] originalValue = original.value;

char[] v;
if (originalValue.length &gt; size) {

   // 省略
} else {

  v = originalValue;
}


// 原本s的实例变量被标量替换为foo()的局部变量

int sOffset = 0;
int sCount = size;

char[] sValue = v;
</code></pre><p>  }</p>
<p>}
注意，到这里就已经把新创建String在堆上分配空间的代码全部削除了，原本新建的String实例的字段变成了FooA.foo()的局部变量。
最后再经过无用代码削除，把sOffset、sCount和sValue这三个没被读过的局部变量给削除掉，
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public FooA implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String original = &quot;xyz&quot;;  </li>
<li></li>
<li>// 下面就是内联进来的构造器内容  </li>
<li>int size = original.count;  </li>
<li>char[] originalValue = original.value;  </li>
<li>char[] v;  </li>
<li>if (originalValue.length &gt; size) {  </li>
<li>// 省略  </li>
<li>} else {  </li>
<li>v = originalValue;  </li>
<li>}  </li>
<li></li>
<li>// 几个局部变量也干掉了  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public FooA implements IFoo {</p>
<p>  public void foo() {
    String original = &quot;xyz&quot;;</p>
<pre><code>// 下面就是内联进来的构造器内容

int size = original.count;
char[] originalValue = original.value;

char[] v;
if (originalValue.length &gt; size) {

   // 省略
} else {

  v = originalValue;
}


// 几个局部变量也干掉了
</code></pre><p>  }
}
这就跟FooA.foo()被优化编译后实际执行的代码基本一致了。
实际执行的x86代码如下：
X86 asm代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0x0247aeec: mov    %eax,-0x4000(%esp) ; 检查栈是否溢出（stack bang），若溢出则这条指令会引发异常  </li>
<li>0x0247aef3: push   %ebp               ; 保存老的栈帧指针  </li>
<li>0x0247aef4: sub    $0x18,%esp         ; 为新栈帧分配空间  </li>
<li>0x0247aefa: mov    $0x1027e9a8,%edi   ; String original //<em> EDI /</em>/ = &quot;xyz&quot;  </li>
<li>0x0247aeff: mov    0x8(%edi),%ecx     ; char[] originalValue //<em> ECX /</em>/ = original.value;  </li>
<li>0x0247af02: mov    0x8(%ecx),%ebx     ; EBX = originalValue.length  </li>
<li>0x0247af05: mov    0x10(%edi),%ebp    ; int size //<em> EBP /</em>/ = original.count;  </li>
<li>0x0247af08: cmp    %ebp,%ebx          ; 比较originalValue.length与size  </li>
<li>0x0247af0a: jg     0x0247af17         ; 如果originalValue.length &gt; size则跳转到0x0247af17  </li>
<li>;   实际不会发生跳转（就是不会执行if分支），所以后面代码省略  </li>
<li>0x0247af0c: add    $0x18,%esp         ; 撤销栈帧分配的空间  </li>
<li>0x0247af0f: pop    %ebp               ; 恢复老的栈帧指针  </li>
<li>0x0247af10: test   %eax,0x310000      ; 方法返回前检查是否需要进入safepoint （{poll_return}）  </li>
<li>0x0247af16: ret                       ; 方法返回  </li>
<li>0x0247af17: ; 以下是if分支和异常处理器的代码，因为实际不会执行，省略  </li>
</ol>
<p>0x0247aeec: mov    %eax,-0x4000(%esp) ; 检查栈是否溢出（stack bang），若溢出则这条指令会引发异常</p>
<p>0x0247aef3: push   %ebp               ; 保存老的栈帧指针
0x0247aef4: sub    $0x18,%esp         ; 为新栈帧分配空间</p>
<p>0x0247aefa: mov    $0x1027e9a8,%edi   ; String original //<em> EDI /</em>/ = &quot;xyz&quot;
0x0247aeff: mov    0x8(%edi),%ecx     ; char[] originalValue //<em> ECX /</em>/ = original.value;</p>
<p>0x0247af02: mov    0x8(%ecx),%ebx     ; EBX = originalValue.length
0x0247af05: mov    0x10(%edi),%ebp    ; int size //<em> EBP /</em>/ = original.count;</p>
<p>0x0247af08: cmp    %ebp,%ebx          ; 比较originalValue.length与size
0x0247af0a: jg     0x0247af17         ; 如果originalValue.length &gt; size则跳转到0x0247af17</p>
<pre><code>                                  ;   实际不会发生跳转（就是不会执行if分支），所以后面代码省略
</code></pre><p>0x0247af0c: add    $0x18,%esp         ; 撤销栈帧分配的空间</p>
<p>0x0247af0f: pop    %ebp               ; 恢复老的栈帧指针
0x0247af10: test   %eax,0x310000      ; 方法返回前检查是否需要进入safepoint （{poll_return}）</p>
<p>0x0247af16: ret                       ; 方法返回
0x0247af17: ; 以下是if分支和异常处理器的代码，因为实际不会执行，省略
看，确实没有新创建String对象了。
另外三个版本的foo()实现也是类似，HotSpot成功的把无用的new String(&quot;xyz&quot;)全部干掉了。
关于逃逸分析的例子，可以参考我以前一篇帖，<a href="http://rednaxelafx.iteye.com/blog/659108" target="_blank">HotSpot 17.0-b12的逃逸分析/标量替换的一个演示</a></p>
<h1 id="-fooa-foo-string-">再回头看看楼主的原问题，问题中的代码片段执行的时候（对应到FooA.foo()被调用的时候）一个String对象也没有新建。于是那“标准答案”在现实中的指导意义又有多少呢？</h1>
<p>另外，楼主还提到了PermGen：
QM42977 写道</p>
<p>&quot;xyz&quot;在perm gen应该还会生成一个对象，因为常量(&quot;xyz&quot;)都会保存在perm gen中
这里也是需要强调一点：永生代（“Perm Gen”）只是Sun JDK的一个实现细节而已，Java语言规范和Java虚拟机规范都没有规定必须有“Permanent Generation”这么一块空间，甚至没规定要用什么GC算法——不用分代式GC算法哪儿来的“永生代”？
HotSpot的PermGen是用来实现Java虚拟机规范中的“<strong>方法区</strong>”（method area）的。如果使用“方法区”这个术语，在讨论概念中的JVM时就安全得多——大家都必须实现出这个表象。
当然如何实现又是另一回事了。Oracle JRockit没有PermGen，IBM J9也没有，事实上有这么一块空间特别管理的反而是少数吧orz
事实上新版HotSpot VM也在计划去除PermGen，转而使用native memory来实现方法区存储元数据。在JDK8的HotSpot VM中已经实现了这点。</p>
<h1 id="-http-rednaxelafx-iteye-com-blog-905273-http-rednaxelafx-iteye-com-blog-905273-">可以参考这帖：<a href="http://rednaxelafx.iteye.com/blog/905273" target="_blank"><a href="http://rednaxelafx.iteye.com/blog/905273">http://rednaxelafx.iteye.com/blog/905273</a></a></h1>
<p>费那么多口舌，最后点题：请别再拿“String s = new String(&quot;xyz&quot;);创建了多少个String实例”来面试了吧，既没意义又不涨面子。
困，睡觉去……<img src="" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 01:54:42"datetime="2014-03-07 01:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--请别再拿“StringsnewString-xyz-创建了多少个String实例”来/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--请别再拿“StringsnewString-xyz-创建了多少个String实例”来" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（三）-基本垃圾回收算法/">JVM调优总结（三）</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T09:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（三）-基本垃圾回收算法/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jvm-">JVM调优总结（三）-基本垃圾回收算法</h1>
<p>可以从不同的的角度去划分垃圾回收算法：</p>
<h2 id="-">按照基本回收策略分</h2>
<p><strong>引用计数（Reference Counting）:</strong></p>
<p>比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。</p>
<p><strong>标记-清除（Mark-Sweep）:</strong></p>
<p><img src="" alt=""></p>
<p>此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</p>
<p><strong>复制（Copying）:</strong></p>
<p><img src="" alt=""></p>
<p>此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。</p>
<p><strong>标记-整理（Mark-Compact）:</strong></p>
<p><img src="" alt=""></p>
<p>此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</p>
<h2 id="-">按分区对待的方式分</h2>
<p><strong>增量收集（Incremental Collecting）:</strong>实时垃圾回收算法，即：在应用进行的同时进行垃圾回收。不知道什么原因JDK5.0中的收集器没有使用这种算法的。</p>
<p><strong>分代收集（Generational Collecting）:</strong>基于对对象生命周期分析后得出的垃圾回收算法。把对象分为年青代、年老代、持久代，对不同生命周期的对象使用不同的算法（上述方式中的一个）进行回收。现在的垃圾回收器（从J2SE1.2开始）都是使用此算法的。</p>
<h2 id="-">按系统线程分</h2>
<p><strong>串行收集:</strong>串行收集使用单线程处理所有垃圾回收工作，因为无需多线程交互，实现容易，而且效率比较高。但是，其局限性也比较明显，即无法使用多处理器的优势，所以此收集适合单处理器机器。当然，此收集器也可以用在小数据量（100M左右）情况下的多处理器机器上。</p>
<p><strong>并行收集:</strong>并行收集使用多线程处理垃圾回收工作，因而速度快，效率高。而且理论上CPU数目越多，越能体现出并行收集器的优势。</p>
<p><strong>并发收集:</strong>相对于串行收集和并行收集而言，前面两个在进行垃圾回收工作时，需要暂停整个运行环境，而只有垃圾回收程序在运行，因此，系统在垃圾回收时会有明显的暂停，而且暂停时间会因为堆越大而越长。</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 01:54:42"datetime="2014-03-07 01:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（三）-基本垃圾回收算法/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JVM调优总结（三）-基本垃圾回收算法" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/44/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/42/">42</a></li><li><a class="page-number" href="/page/43/">43</a></li><li><a class="page-number" href="/page/44/">44</a></li><li class="active"><li><span class="page-number current">45</span></li><li><a class="page-number" href="/page/46/">46</a></li><li><a class="page-number" href="/page/47/">47</a></li><li><a class="page-number" href="/page/48/">48</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/161/">161</a></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="extend next" href="/page/46/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?eaa92c12166944fd3a160103e6c4a8cf"});
</script>


</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-04-14 12:45:07</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
