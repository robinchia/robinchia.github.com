
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 45 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE学习总结思维方式和理念/">J2EE学习总结 思维方式和理念</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE学习总结思维方式和理念/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="j2ee-">J2EE学习总结 思维方式和理念</h1>
<p>J2EE学习总结:思维方式和理念
Webjx网页教学提示：不管怎么样我还是建议从基本的做起，学精J2SE，熟读它的源码，准确了解其设计理念，然后分头击破J2EE――一口吃不成一个胖子!不要贪多贪广!脚踏实地就可以了!</p>
<p>这篇文章写在我研究J2SE、J2EE近三年后。前3年我研究了J2SE的Swing、Applet、Net、RMI、Collections、IO、JNI……研究了J2EE的JDBC、Sevlet、JSP、JNDI…..不久我发现这些好像太浮浅了：首先，我发现自己知道的仅仅是java提供的大量的API，根本不能很好地使用它; 其次，我根本就没有学到任何有助于写程序的知识，此时我也只不过能写个几页的小程序。出于这个幼稚的想法我研究了JDK中Collections、Logger、IO…..的源代码，发现这个世界真的很神奇，竟然有如此的高手――利用java语言最最基本的语法，创造了这些优秀的Framework。</p>
<p>从此一发不可收拾，我继续研究了J2EE的部分，又发现这是一个我根本不能理解的方向(曾经有半年停滞不前)，为什么只有接口没有实现啊!后来由于一直使用Tomcat、Derby等软件突然发现：哦!原来J2EE仅仅是一个标准，只是一个架构。真正的实现是不同提供商提供的。</p>
<p>接着我研究了MOM4J、OpenJMS、Mocki、HSQLD……发现这些就是J2EE的实现啊!原来软件竟会如此复杂，竟会如此做….规范和实现又是如何成为一体的呢?通过上面的研究发现：原来J2EE后面竟然有太多太多理念、太多太多的相似!这些相似就是其背后的理念――设计模式!(很幸运，在我学java的时候，我一般学java的一个方向就会读一些关于设计模式的书!很幸运，到能领略一点的时候能真正知道这是为什么!)其实模式就是一种思维方式、就是一种理念……模式是要运用到程序中的，只有从真正的项目中才能领会模式的含义……
学得越多，发现懂得越少!在学习过程中发现一些很有用，很值得学习的开源项目，今天在此推荐给大家。</p>
<p>一、JavaServlet和JSP方向</p>
<p>很多人都是从Servlet和JSP步入J2EE的。它就是J2EE的表现层，用于向客户呈现服务器上的内容。J2EE很重要的方面。不罗嗦了!大家都知道的!下面就开始推荐吧!</p>
<ol>
<li>Jakarta Tomcat</li>
</ol>
<p>Apache基金会提供的免费的开源的Serlvet容器，它是的Jakarta项目中的一个核心项目，由Apache、Sun和其它一些公司(都是IT界的大鳄哦)及个人共同开发而成，全世界绝大部分Servlet和Jsp的容器都是使用它哦!由于Sun的参与和支持，最新的Servlet和Jsp规范总能在Tomcat中得到体现。</p>
<p>不过它是一个非常非常全的Serlvet容器，全部源码可能有4000页，对于初学者或者一般的老手可能还是比较大了!在你有能力时推荐研究!下载地址：<a href="http://jakarta.apache.org/tomcat/index.html" target="_blank">http://jakarta.apache.org/tomcat/index.html</a></p>
<p>下面推荐两个小一点的吧!</p>
<ol>
<li>Jetty</li>
</ol>
<p>Jetty是一个开放源码的HTTP服务器和Java serverlet容器。源代码只有1000页左右，很值得研究。有兴趣可以去<a href="http://jetty.mortbay.com/下载看看。我曾经翻了一下，只是目前没有时间。(都化在博客上了，等博客基本定型，且内容完整了，再干我热衷的事件吧!" target="_blank">http://jetty.mortbay.com/下载看看。我曾经翻了一下，只是目前没有时间。(都化在博客上了，等博客基本定型，且内容完整了，再干我热衷的事件吧!</a>)</p>
<ol>
<li>Jigsaw</li>
</ol>
<p>Jigsaw是W3C开发的HTTP，基于Java 的服务器，提供了未来 Web 技术发展的蓝图。W3C知道吧!(太有名气了，很多标准都是它制订的!有空经常去看看吧!)下载网址：<a href="http://www.w3.org/Jigsaw代码仅仅1000页左右。" target="_blank">http://www.w3.org/Jigsaw代码仅仅1000页左右。</a></p>
<ol>
<li>Jo!</li>
</ol>
<p>Jo!是一个纯Java的实现了Servlet API 2.2, JSP 1.1, 和HTTP/1.1的Web服务器。它的特性包括支持servlet tag,支持SSI，高级线程管理，虚拟主机，数据缓存，自动压缩text或HTML文件进行传输，国际化支持，自动重新加载Servlet、Jsp，自动重新加载web工程文件(WARs)，支持WAR热部署和一个Swing控制台。jo!可以被用做jboss和jakarta avalon-phoenix的web容器。下载地址<a href="http://www.tagtraum.com/" target="_blank">http://www.tagtraum.com/</a> 。我极力推荐大家在研究Tomcat之前研究该软件，主要是其比Tomcat小多了，且开发者提供比较全的手册。该方向研究这两个也就可以了!</p>
<p>二、JDBC方向</p>
<p>很多人都喜欢JDBC，数据库吗!很深奥的东西，一听就可以糊弄人。其实等你真正研究了数据库的实现后发现，接口其实真的太简单，太完美了!要想设计如此优秀的框架还是需要学习的。下面就推荐几个数据库的实现吧!</p>
<ol>
<li>Hypersonic SQL</li>
</ol>
<p>Hypersonic SQL开源数据库方向比较流行的纯Java开发的关系型数据库。好像不是JDBC兼容的，JDBC的很多高级的特性都没有支持，不过幸好支持ANSI-92 标准 SQL语法。我推荐它主要是它的代码比较少1600页左右，如此小的数据库值得研究，而且他占的空间很小，大约只有160K，拥有快速的数据库引擎。推荐你的第一个开源数据库。下载地址：<a href="http://hsqldb.sourceforge.net/。" target="_blank">http://hsqldb.sourceforge.net/。</a></p>
<ol>
<li>Mckoi DataBase</li>
</ol>
<p>McKoiDB 和Hypersonic SQL差不多，它是GPL 的license的纯Java开发的数据库。他的 JDBC Driver 是使用 JDBC version 3 的 Specifaction。 他也是遵循 SQL-92 的标准，也尽量支持新的 SQL 特色, 并且支持 Transaction 的功能。两个可以选一个吧!下载地址：<a href="http://mckoi.com/database/。" target="_blank">http://mckoi.com/database/。</a></p>
<ol>
<li>Apache Derby</li>
</ol>
<p>学Java的数据库我建议使用Apache Derby ，研究数据库想成为一个数据库的高手我建议你先研究Apache Derby。Apache Derby是一个高质量的、纯 Java开发的嵌入式关系数据库引擎，IBM® 将其捐献给Apache开放源码社区，同时IBM的产品CloudSpace是它对应的产品。Derby是基于文件系统，具有高度的可移植性，并且是轻量级的，这使得它非常便于发布。主要是没有商业用户的很好的界面，没有其太多的功能。不过对于我们使用数据库、研究数据库还是极其有用的。对于中小型的企业说老实话你也不要用什么Oracle、SqlServer了，用Derby就可以了，何况是开源的呢!只要能发挥其长处也不容易啊!下载地址：<a href="http://incubator.apache.org/derby。" target="_blank">http://incubator.apache.org/derby。</a></p>
<p>不过在没有足够的能力前，不要试图读懂它!注释和源代码15000页左右，我一年的阅读量!能读下来并且能真正领会它，绝对高手!你能读完Derby的源代码只有两种可能：1.你成为顶尖的高手――至少是数据库这部分; 2.你疯了。选择吧!!!!作为我自己我先选择Hypersonic SQL这样的数据库先研究，能过这一关，再继续研究Derby!不就是一年的阅读量吗!我可以化3年去研究如何做一个数据库其实还是很值得的!有的人搞IT一辈子自己什么都没有做，也根本没有研究别人的东西!</p>
<p>作为一个IT落后于别国若干年的、从事IT的下游产业“外包”的国家的IT从业人员，我认为还是先研究别人的优秀的东西比较好!可以先研究别人的，然后消化，学为己用!一心闭门造车实在遗憾!</p>
<p>三、JMS方向</p>
<p>JMS可能对大家来说是一个比较陌生的方向!其实JMS是一个比较容易理解，容易上手的方向。主要是Java消息服务，API也是相当简单的。不过在企业应用中相当广泛。下面就介绍几个吧!</p>
<ol>
<li>MOM4J</li>
</ol>
<p>MOM4J是一个完全实现JMS1.1规范的消息中间件并且向下兼容JMS1.0与1.02。它提供了自己的消息处理存储使它独立于关系数据与语言，它的客户端可以用任何语言开发。它可以算是一个小麻雀，很全实现也比较简单!它包含一个命名服务器，一个消息服务器，同时提供自己的持续层。设计也相当的巧妙，完全利用操作系统中文件系统设计的观念。代码也很少，250页左右，最近我在写该实现的源代码阅读方面的书，希望明年年中能与大家见面!下载地址：<a href="http://mom4j.sourceforge.net/index.html。" target="_blank">http://mom4j.sourceforge.net/index.html。</a></p>
<ol>
<li>OpenJMS</li>
</ol>
<p>OpenJMS是一个开源的Java Message Service API 1.0.2 规范的实现，它包含有以下特性：</p>
<ol>
<li><p>它既支持点到点(point-to-point)(PTP)模型和发布/订阅(Pub/Sub)模型。</p>
</li>
<li><p>支持同步与异步消息发送 。</p>
</li>
<li><p>JDBC持久性管理使用数据库表来存储消息 。</p>
</li>
<li><p>可视化管理界面。</p>
</li>
<li><p>Applet支持。</p>
</li>
<li><p>能够与Jakarta Tomcat这样的Servlet容器结合。</p>
</li>
<li><p>支持RMI, TCP, HTTP 与SSL协议。</p>
</li>
<li><p>客户端验证 。</p>
</li>
<li><p>提供可靠消息传输、事务和消息过滤。</p>
</li>
</ol>
<p>很好的JMS方向的开源项目!我目前也在研究它的源代码!学习它可以顺便研究JNDI的实现、以及网络通信的细节。这是我JMS方向研究的第二个开源项目。代码量1600页左右吧!下载地址：<a href="http://openjms.sourceforge.net/index.html" target="_blank">http://openjms.sourceforge.net/index.html</a></p>
<ol>
<li>ActiveMQ</li>
</ol>
<p>ActiveMQ是一个开放源码基于Apache 2.0 licenced 发布并实现了JMS 1.1。它能够与Geronimo，轻量级容器和任Java应用程序无缝的给合。主要是Apache的可以任意的使用和发布哦!个人比较喜欢Apache的源代码!下载地址：<a href="http://activemq.codehaus.org/" target="_blank">http://activemq.codehaus.org/</a></p>
<ol>
<li>JORAM</li>
</ol>
<p>JORAM一个类似于openJMS分布在ObjectWeb之下的JMS消息中间件。ObjectWeb的产品也是非常值得研究的!下面我还会给大家另外一个ObjectWeb的产品。下载地址：<a href="http://joram.objectweb.org/" target="_blank">http://joram.objectweb.org/</a></p>
<p>我个人推荐：OpenJMS和ActiveMQ!</p>
<p>四、EJB方向</p>
<p>EJB一个比较“高级”的方向。Sun公司曾经以此在分布式计算领域重拳出击。不过自从出现了Spring、Hibernation……后似乎没落了!这个方向单独开源的也比较少，主要EJB是和JNDI、JDBC、JMS、JTS、JTA结合在一起的是以很少有单独的。下面推荐两个不过好像也要下载其它类库。</p>
<ol>
<li>EasyBeans</li>
</ol>
<p>ObjectWeb的一个新的项目，一个轻量级的EJB3容器，虽然还没有正式发布，但是已经可以从它们的subversion仓库中检出代码。代码量比较小600页左右，熟读它可以对网络编程、架构、RMI、容器的状态设计比较了解了!即学会EJB又能学习其它设计方法何乐而不为哦!下载地址：<a href="http://easybeans.objectweb.org/" target="_blank">http://easybeans.objectweb.org/</a></p>
<ol>
<li>OpenEJB</li>
</ol>
<p>OpenEJB是一个预生成的、自包含的、可移植的EJB容器系统，可以被插入到任意的服务器环境，包括应用程序服务器，Web服务器，J2EE平台， CORBA ORB和数据库等等。OpenEJB 被用于 Apple的WebObjects。听起来很好，我目前没有研究过。不知道我就不推荐了。下载地址：<a href="http://www.openejb.org/" target="_blank">http://www.openejb.org/</a></p>
<p>五、J2EE容器</p>
<p>上面谈了这么多，都是J2EE的各个方向的。其实J2EE是一个规范，J2EE的产品一般要求专业提供商必须提供它们的实现。这些实现本身就是J2EE容器。市场上流行的J2EE容器很多，在开源领域流行的只有很少，很少。其中最著名的是JBoss。</p>
<ol>
<li>JBoss</li>
</ol>
<p>在J2EE应用服务器领域，Jboss是发展最为迅速的应用服务器。由于Jboss遵循商业友好的LGPL授权分发，并且由开源社区开发，这使得Jboss广为流行。另外，Jboss应用服务器还具有许多优秀的特质。</p>
<p>其一，它将具有革命性的JMX微内核服务作为其总线结构;</p>
<p>其二，它本身就是面向服务的架构(Service-Oriented Architecture，SOA);</p>
<p>其三，它还具有统一的类装载器，从而能够实现应用的热部署和热卸载能力。因此，它是高度模块化的和松耦合的。Jboss用户的积极反馈告诉我们，Jboss应用服务器是健壮的、高质量的，而且还具有良好的性能。为满足企业级市场日益增长的需求，Jboss公司从2003年开始就推出了24/*7、专业级产品支持服务。同时，为拓展Jboss的企业级市场，Jboss公司还签订了许多渠道合作伙伴。比如，Jboss公司同HP、Novell、Computer Associates、Unisys等都是合作伙伴。</p>
<p>在2004年6月，Jboss公司宣布，Jboss应用服务器通过了Sun公司的J2EE认证。这是Jboss应用服务器发展史上至今为止最重要的里程碑。与此同时，Jboss一直在紧跟最新的J2EE规范，而且在某些技术领域引领J2EE规范的开发。因此，无论在商业领域，还是在开源社区，Jboss成为了第一个通过J2EE 1.4认证的主流应用服务器。现在，Jboss应用服务器已经真正发展成具有企业强度(即，支持关键级任务的应用)的应用服务器。</p>
<p>Jboss 4.0作为J2EE认证的重要成果之一，已经于2004年9月顺利发布了。同时，Jboss 4.0还提供了Jboss AOP(Aspect-Oriented Programming，面向方面编程)组件。近来，AOP吸引了大量开发者的关注。它提供的新的编程模式使得用户能够将方面(比如，事务)从底层业务逻辑中分离出来，从而能够缩短软件开发周期。用户能够单独使用Jboss AOP，即能够在Jboss应用服务器外部使用它。或者，用户也可以在应用服务器环境中使用它。Jboss AOP 1.0已经在2004年10月发布了。 很有名吧!可以下载一个用一下，下载地址：<a href="http://www.jboss.org/" target="_blank">http://www.jboss.org/</a></p>
<p>关于JBoss的使用资料也非常多，甚至比商业软件的还多。有机会研究吧!</p>
<ol>
<li>JOnAS</li>
</ol>
<p>JOnAS是一个开放源代码的J2EE实现，在ObjectWeb协会中开发。整合了Tomcat或Jetty成为它的Web容器，以确保符合Servlet 2.3和JSP 1.2规范。JOnAS服务器依赖或实现以下的Java API：JCA、JDBC、JTA 、JMS、JMX、JNDI、JAAS、JavaMail 。下载地址：<a href="http://jonas.objectweb.org/" target="_blank">http://jonas.objectweb.org/</a>
3.Apache Geronimo</p>
<p>Apache Geronimo 是 Apache 软件基金会的开放源码J2EE服务器，它集成了众多先进技术和设计理念。 这些技术和理念大多源自独立的项目，配置和部署模型也各不相同。 Geronimo能将这些项目和方法的配置及部署完全整合到一个统一、易用的模型中。作为符合J2EE标准的服务器，Geronimo提供了丰富的功能集和无责任 Apache 许可，具备“立即部署”式J2EE 1.4容器的各种优点，其中包括：</p>
<ol>
<li><p>符合J2EE1.4标准的服务器 。</p>
</li>
<li><p>预集成的开放源码项目 。</p>
</li>
<li><p>统一的集成模型 。</p>
</li>
<li><p>可伸缩性、可管理性和配置管理功能。</p>
</li>
</ol>
<p>我一直比较推荐Apache的产品。主要是可以任意自由地使用。下载地址：<a href="http://incubator.apache.org/projects/geronimo/" target="_blank">http://incubator.apache.org/projects/geronimo/</a></p>
<p>六、其它</p>
<p>讲了这么多大家可能很厌烦了!是不是很多很多啊!其实不然，我们不会的太多太多了!不会的太多太多了。不管你是不是J2EE高手，还是J2SE高手，有些东西你要绝对很精明的。例如：1.Java的Collections Framework就是java的数据结构了，不仅要吃透它，还要能按照需要扩展它，利用其思想创建一个自己的数据结构。2.网络编程肯定要会吧，现在以及以后很多程序都是不在同一台机器上的，不会网络怎么行哦!3.IO肯定要会的吧!你的程序难道不用输入输出数据啊!整个IO包加NIO也有600多页的源代码哦!4.JDBC你要会吧!数据库都不会，在你的企业应用中你的数据又保存到哪里啊!文件中――太落后了吧!典型的没有学过J2EE。尽管数据库背后也是采用文件保存的。5.Serverlet、JSp你要是做网页做网站，肯定要做到。问你一个简单的问题，网页中如何实现分页啊!有具体方法的就在本文章后发言吧!6. Ant要会吧!java语言中发布的工具，类似与c中的make工具。7.JUnit用过吧!单元测试软件。你不要啊!你的软件就没有bug!你牛!(建议大家研究研究其源代码，很有用的框架，包含大量的设计模式，源代码不到100页!看了只能感叹――高手就是高手)细心的朋友可以看到在你使用的很多IDE工具中都有JUnit哦!就是它。</p>
<p>一切的一切才刚刚开始!有兴趣，有需要你可以研究数据库连接池的框架，如：C3P0、Jakarta DBCP、 DBPool….可以研究J2EE框架Spring……. Web框架Struts……持久层框架Hibernate…..甚至开发工具Eclipse…..Sun领导的点对点通信的JXTA…..报表工具JFreeChart、JasperReports…..分布式网络编程的CORBA、网络通信的JGROUPS、XML解析的xerces…..(在不经意间开源已经步入你的电脑，不信啊!你JDK的安装目录jdk1.6.0 src com sun org apache就是Xerces，一个XML解析的著名的开源 项目)</p>
<p>不管怎么样我还是建议从基本的做起，学精J2SE，熟读它的源码，准确了解其设计理念，然后分头击破J2EE――一口吃不成一个胖子!不要贪多贪广!脚踏实地就可以了!</p>
<hr>
<p><strong><a href="http://www.webjx.com/exam/java-15508.html" target="_blank">http://www.webjx.com/exam/java-15508.html</a></strong></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_总结类/">Java_总结类</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_总结类/" class="label label-success">Java_总结类</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE学习总结思维方式和理念/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_总结类--J2EE学习总结思维方式和理念" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE--Java字节码工具ASM在WebService开发中的应用/">Java字节码工具ASM在Web Service开发中的应用</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE--Java字节码工具ASM在WebService开发中的应用/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-asm-web-service-">Java字节码工具ASM在Web Service开发中的应用</h1>
<p>在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href="http://static.oschina.net/uploads/img/201109/26204312_QD65.jpg" target="_blank"><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。
来源： <a href="[http://www.oschina.net/question/129540_28430](http://www.oschina.net/question/129540_28430)">[http://www.oschina.net/question/129540_28430](http://www.oschina.net/question/129540_28430)</a> </p>
<p>在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE--Java字节码工具ASM在WebService开发中的应用/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE--Java字节码工具ASM在WebService开发中的应用" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--GC策略的调优/">GC策略的调优</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--GC策略的调优/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="gc-">GC策略的调优</h1>
<h1 id="-bluedavy-blog-http-www-blogjava-net-bluedavy-"><a href="http://www.blogjava.net/BlueDavy/" target="_blank">BlueDavy之技术Blog</a></h1>
<p>理论不懂就实践，实践不会就学理论！</p>
<h2 id="-gc-http-www-blogjava-net-bluedavy-archive-2009-10-09-297562-html-"><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/09/297562.html" target="_blank">GC策略的调优</a></h2>
<p>摘自《构建高性能的大型分布式Java应用》第六章，感兴趣的同学们可以看看。</p>
<p>GC策略在G1还没成熟的情况下，目前主要有串行、并行和并发三种，对于大内存的应用而言，串行的性能太低，因此使用到的主要是并行和并发两种，具体这两种GC的策略在深入JVM章节中已讲解， 并行和并发GC的策略通过-XX:+UseParallelGC和-XX:+UseConcMarkSweepGC来指定，还有一些细节的配置参数用来配置策略的执行方式，例如：-XX:ParallelGCThreads、-XX:CMSInitiatingOccupancyFraction等，新生代对象回收只可选择并行，在此就举例来看看两种GC策略在Full GC时的具体表现状况。</p>
<p>测试GC策略状况的代码如下：</p>
<hr>
<p>**public class GCPolicyDemo {</p>
<pre><code>//*/*
 /* @param args
 /*/
public static void main(String[] args) throws Exception{
   System.out.println(&quot;ready to start&quot;);
   Thread.sleep(10000);
   List&lt;GCPolicyDataObject&gt; cacheObjects=new ArrayList&lt;GCPolicyDataObject&gt;();
   for (int i = 0; i &lt; 2048; i++) {
       cacheObjects.add(new GCPolicyDataObject(100));
   }
   System.gc();
   Thread.sleep(1000);
   for (int i = 0; i &lt; 10; i++) {
       System.out.println(&quot;Round: &quot;+(i+1));
       for (int j = 0; j &lt; 5; j++) {
          System.out.println(&quot;put 64M objects&quot;);
          List&lt;GCPolicyDataObject&gt; tmpObjects=new ArrayList&lt;GCPolicyDataObject&gt;();
          for (int m = 0; m &lt; 1024; m++) {
              tmpObjects.add(new GCPolicyDataObject(64));
          }
          tmpObjects=null;
       }
   }
   cacheObjects.size();
   cacheObjects=null;
}
</code></pre><p>}</p>
<p>class GCPolicyDataObject{</p>
<pre><code>byte[] bytes=null;

GCPolicyRefObject object=null;

public GCPolicyDataObject(int factor){
   bytes=new byte[factor/*1024];
   object=new GCPolicyRefObject();
}
</code></pre><p>}</p>
<p>class GCPolicyRefObject{</p>
<pre><code>GCPolicyRefChildObject object;

public GCPolicyRefObject(){
   object=new GCPolicyRefChildObject();
}
</code></pre><p>}</p>
<p>class GCPolicyRefChildObject{</p>
<pre><code>public GCPolicyRefChildObject(){
   ;
}
</code></pre><p>}**</p>
<p>以-Xms680M -Xmx680M -Xmn80M -XX:+UseConcMarkSweepGC -XX:+PrintGCApplicationStoppedTime -XX:+UseCMSCompactAtFullCollection -XX:+UseParNewGC -XX:CMSMaxAbortablePrecleanTime=5参数执行以上代码，通过jstat观察到的GC状况如下：</p>
<p>共触发39次minor GC，耗时为1.197秒，共触发21次Full GC，耗时为0.136秒，GC总耗时为1.333秒。</p>
<p>GC动作造成应用暂停的时间为：1.74秒。</p>
<p>以-Xms680M -Xmx680M -Xmn80M -XX:+PrintGCApplicationStoppedTime –XX:+UseParallelGC参数执行以上代码，通过jstat观察到的GC状况如下：</p>
<p>共触发119次minor GC，耗时为2.774秒，共触发8次Full GC，耗时为0.243秒，GC总耗时为3.016秒。</p>
<p>GC动作造成应用暂停的时间为：3.11秒。</p>
<p>从上面的结果来看，由于CMS GC多数动作是和应用并发做的，采用CMS GC确实可以减小GC动作给应用造成的暂停，但也正因为是并发进行的，因此CMS GC需要耗费更多的CPU，因此对于CPU密集型应用而言，CMS不一定是好的选择。</p>
<p>在采用CMS GC的情况下，尤其要注意的是concurrent mode failure的现象，这可以通过-XX:+PrintGCDetails来观察，当出现concurrent mode failure的现象时，就意味着此时JVM将继续采用Stop-The-World的方式来进行Full GC，这种情况下，采用CMS就没什么意义了，造成concurrent mode failure的原因主要是当minor GC进行时，旧生代所剩下的空间小于Eden区域+From区域的空间，要避免这种现象，可以采用以下三种方法：</p>
<p>l  调低触发CMS GC执行的阀值</p>
<p>CMS GC触发主要由CMSInitiatingOccupancyFraction值决定，默认情况是当旧生代已用空间为68%时，即触发CMS GC。</p>
<p>在出现concurrent mode failure的情况下，可考虑调小这个值，提前CMS GC的触发，以保证旧生代有足够的空间。</p>
<p>l  扩大旧生代空间</p>
<p>调小新生代占用的空间或增大整个JVM Heap的空间可扩大旧生代空间，这对于避免concurrent mode failure现象可以提供很大的帮助。</p>
<p>l  调小CMSMaxAbortablePrecleanTime的值
CMS GC需要经过较多步骤才能完成一次GC的动作，在minor GC较为频繁的情况下，很有可能造成CMS GC尚未完成，从而造成concurrent mode failure，这种情况下，减少minor GC触发的频率是一种方法，另外一种方法则是加快CMS GC执行时间，在CMS的整个步骤中，JDK 5.0+、6.0+的有些版本在CMS-concurrent-abortable-preclean-start和CMS-concurrent-abortable-preclean这两步间有可能会耗费很长的时间，导致可回收的旧生代的对象很长时间后才被回收，这是Sun JDK CMS GC的一个bug<a href="">[1]</a>，如通过PrintGCDetails观察到这两步之间耗费了较长的时间，可以通过-XX: CMSMaxAbortablePrecleanTime设置较小的值，以保证CMS GC尽快完成对象的回收，避免concurrent mode failure的现象。</p>
<p><a href="">[1]</a> 详细bug信息请见：<a href="http://www.nabble.com/CMS-GC-tuning-under-JVM-5.0-td16759819.html" target="_blank">http://www.nabble.com/CMS-GC-tuning-under-JVM-5.0-td16759819.html</a></p>
<p>posted on 2009-10-09 15:57 <a href="http://www.blogjava.net/BlueDavy/" target="_blank">BlueDavy</a> 阅读(9126) <a href="">评论(5)</a>  <a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx?postid=297562" target="_blank">编辑</a>  <a href="http://www.blogjava.net/BlueDavy/AddToFavorite.aspx?id=297562" target="_blank">收藏</a> 所属分类: <a href="http://www.blogjava.net/BlueDavy/category/1366.html" target="_blank">Java</a></p>
<p> <img src="" alt=""></p>
<p><a href=""></a> <a href=""></a></p>
<p>[</p>
<h3 id="-">评论</h3>
<p>]()</p>
<h3 id="-permalink-re-gc-re-gc-2009-10-09-16-36-agraviton-"><a href=""></a><a href="&quot;permalink: re: GC策略的调优&quot;">/#</a> <a href=""></a>re: GC策略的调优  2009-10-09 16:36  <a href="">agraviton</a></h3>
<p>bluedavy 又出手了，出手就不凡。  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=agraviton" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-gc-re-gc-2009-10-09-18-06-glf-"><a href="&quot;permalink: re: GC策略的调优&quot;">/#</a> <a href=""></a>re: GC策略的调优  2009-10-09 18:06  <a href="">glf</a></h3>
<p>书什么时候出啊  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=glf" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-gc-re-gc-2009-10-09-20-10-bluedavy-http-www-blogjava-net-bluedavy-"><a href="&quot;permalink: re: GC策略的调优&quot;">/#</a> <a href=""></a>re: GC策略的调优  2009-10-09 20:10  <a href="http://www.blogjava.net/BlueDavy/">BlueDavy</a></h3>
<p>@glf
这书估计要到明年三月左右才能上市了。  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=BlueDavy" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-gc-re-gc-2009-10-10-13-54-hucq-"><a href="&quot;permalink: re: GC策略的调优&quot;">/#</a> <a href=""></a>re: GC策略的调优  2009-10-10 13:54  <a href="">hucq</a></h3>
<p>期待实体书  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=hucq" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-gc-re-gc-2009-12-21-21-16-study-"><a href="&quot;permalink: re: GC策略的调优&quot;">/#</a> <a href=""></a>re: GC策略的调优<a href=""></a>  2009-12-21 21:16  <a href="">study</a></h3>
<p>太期待了！   <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=study" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a>
<a href="http://www.blogjava.net/RequireRegister.aspx" target="_blank">新用户注册</a>  <a href="">刷新评论列表</a>  </p>
<p><a href=""></a> <a href="http://www.aliyun.com/cps/channel?channel_id=1306&amp;user=0&amp;lv=1">推荐购买云服务器（15%返利+最高千元奖金）</a>   <a href="http://www.cnblogs.com/" target="_blank">博客园</a>  <a href="http://q.cnblogs.com/" target="_blank">博问</a>  <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>  <a href="http://job.cnblogs.com/cate-java_programmer/" target="_blank">Java程序员招聘</a> 标题  请输入标题 姓名  请输入你的姓名 主页 请输入验证码 验证码 /*  <img src="http://www.blogjava.net/Modules/CaptchaImage/JpegImage.aspx?cacheid=20130727130705" alt=""> 内容(请不要发表任何与政治相关的内容) 请输入评论内容 Remember Me?   <a href="http://www.blogjava.net/login.aspx?ReturnURL=http://www.blogjava.net/BlueDavy/archive/2009/10/09/297562.html&amp;SourceURL=/BlueDavy/archive/2009/10/09/297562.html" target="_blank">登录</a>       [使用Ctrl+Enter键可以直接提交]      网站导航:</p>
<p><a href="http://www.cnblogs.com/" title="程序员的网上家园" target="_blank">博客园</a>   <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>   <a href="http://kb.cnblogs.com/" target="_blank">知识库</a>   <a href="http://www.cppblog.com/" target="_blank">C++博客</a>   <a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a>   <a href="http://www.blogjava.net/BlueDavy/archive/2009/10/09/297562.html?opt=admin" target="_blank">管理</a> 相关文章:</p>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/05/25/321796.html" target="_blank">关于《分布式Java应用：基础与实践》一书</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/04/30/319794.html" target="_blank">杭州程序员圆桌交流第二期视频</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03/22/316148.html" target="_blank">第一次杭州程序员交流会总结</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03/19/315989.html" target="_blank">杭州程序员圆桌交流第一期–并发编程PPT</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/12/03/304597.html" target="_blank">GCLogViewer(tool to visualize gc log) V0.2 Release</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11/25/303662.html" target="_blank">Simple Scala actor Vs java Thread Vs Kilim Test</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11/06/301448.html" target="_blank">《构建高性能的大型分布式Java应用》目录&amp;试读样章</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/10/297661.html" target="_blank">动态跟踪Java代码的执行状况工具--BTrace</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/09/297562.html" target="_blank">GC策略的调优</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/08/06/290003.html" target="_blank">Hessian 3.2.0的两个bug</a><br>Powered by: <a href="http://www.blogjava.net/" target="_blank">BlogJava</a> Copyright © BlueDavy<h3 id="-">公告</h3>
</li>
</ul>
<p><a href="http://www.douban.com/subject/3843896/" target="_blank"><img src="" alt=""></a> 
<a href="http://china.osgiusers.org/" target="_blank"><img src="" alt=""></a>
<a href="http://feed.feedsky.com/bluedavy" title="BlogJava-BlueDavy之技术Blog" target="_blank"><img src="" alt=""></a> <a href="http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="feedsky"></a>
<a href="http://www.zhuaxia.com/add_channel.php?url=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="抓虾"></a>
<a href="http://fusion.google.com/add?feedurl=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="google reader"></a>
<a href="http://www.xianguo.com/subscribe.php?url=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="鲜果"></a></p>
<h3 id="-">导航</h3>
<ul>
<li><a href="http://www.blogjava.net/" target="_blank">BlogJava</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/" target="_blank">首页</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx?opt=1" target="_blank">新随笔</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/contact.aspx?id=1" target="_blank">联系</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/rss" target="_blank">聚合</a><a href="http://www.blogjava.net/BlueDavy/rss" target="_blank"><img src="" alt=""></a></li>
<li><a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx" target="_blank">管理</a>
<a href="&quot;转到上一个月&quot;">&lt;</a>2009年10月<a href="&quot;转到下一个月&quot;">&gt;</a>日一二三四五六2728293012345678<a href="http://www.blogjava.net/BlueDavy/archive/2009/10/09.html" target="_blank">9</a><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/10.html" target="_blank">10</a>1112131415161718192021222324252627282930311234567</li>
</ul>
<h3 id="-">统计</h3>
<ul>
<li>随笔 - 294</li>
<li>文章 - 2</li>
<li>评论 - 2068</li>
<li>引用 - 1</li>
</ul>
<h3 id="-">随笔分类</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/category/10609.html" target="_blank">@RIAWork(10)</a> <a href="http://www.blogjava.net/BlueDavy/category/10609.html/rss" title="Subscribe to @RIAWork(10)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/32839.html" target="_blank">Internet(20)</a> <a href="http://www.blogjava.net/BlueDavy/category/32839.html/rss" title="Subscribe to Internet(20)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1366.html" target="_blank">Java(82)</a> <a href="http://www.blogjava.net/BlueDavy/category/1366.html/rss" title="Subscribe to Java(82)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/8127.html" target="_blank">Javascript(7)</a> <a href="http://www.blogjava.net/BlueDavy/category/8127.html/rss" title="Subscribe to Javascript(7)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/18356.html" target="_blank">OSGi、SOA、SCA(81)</a> <a href="http://www.blogjava.net/BlueDavy/category/18356.html/rss" title="Subscribe to OSGi、SOA、SCA(81)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1514.html" target="_blank">Plugin Architecture(10)</a> <a href="http://www.blogjava.net/BlueDavy/category/1514.html/rss" title="Subscribe to Plugin Architecture(10)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1513.html" target="_blank">Workflow(4)</a> <a href="http://www.blogjava.net/BlueDavy/category/1513.html/rss" title="Subscribe to Workflow(4)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/11559.html" target="_blank">业界随想(28)</a> <a href="http://www.blogjava.net/BlueDavy/category/11559.html/rss" title="Subscribe to 业界随想(28)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/22527.html" target="_blank">数据集成(8)</a> <a href="http://www.blogjava.net/BlueDavy/category/22527.html/rss" title="Subscribe to 数据集成(8)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1911.html" target="_blank">系统设计(38)</a> <a href="http://www.blogjava.net/BlueDavy/category/1911.html/rss" title="Subscribe to 系统设计(38)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1367.html" target="_blank">软件工程(22)</a> <a href="http://www.blogjava.net/BlueDavy/category/1367.html/rss" title="Subscribe to 软件工程(22)" target="_blank">(rss)</a></li>
</ul>
<h3 id="-">随笔档案</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/05.html" target="_blank">2010年5月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/04.html" target="_blank">2010年4月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03.html" target="_blank">2010年3月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/02.html" target="_blank">2010年2月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/01.html" target="_blank">2010年1月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/12.html" target="_blank">2009年12月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11.html" target="_blank">2009年11月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10.html" target="_blank">2009年10月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/09.html" target="_blank">2009年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/08.html" target="_blank">2009年8月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/07.html" target="_blank">2009年7月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/06.html" target="_blank">2009年6月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/05.html" target="_blank">2009年5月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04.html" target="_blank">2009年4月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/03.html" target="_blank">2009年3月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/01.html" target="_blank">2009年1月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/11.html" target="_blank">2008年11月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/10.html" target="_blank">2008年10月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09.html" target="_blank">2008年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/08.html" target="_blank">2008年8月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/07.html" target="_blank">2008年7月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/06.html" target="_blank">2008年6月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/05.html" target="_blank">2008年5月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/04.html" target="_blank">2008年4月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/03.html" target="_blank">2008年3月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/02.html" target="_blank">2008年2月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/01.html" target="_blank">2008年1月 (10)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/12.html" target="_blank">2007年12月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/11.html" target="_blank">2007年11月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/10.html" target="_blank">2007年10月 (6)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/09.html" target="_blank">2007年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/08.html" target="_blank">2007年8月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/07.html" target="_blank">2007年7月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/06.html" target="_blank">2007年6月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/05.html" target="_blank">2007年5月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/04.html" target="_blank">2007年4月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/03.html" target="_blank">2007年3月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/02.html" target="_blank">2007年2月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/01.html" target="_blank">2007年1月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/12.html" target="_blank">2006年12月 (6)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/11.html" target="_blank">2006年11月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/10.html" target="_blank">2006年10月 (8)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/09.html" target="_blank">2006年9月 (13)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08.html" target="_blank">2006年8月 (15)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/07.html" target="_blank">2006年7月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/06.html" target="_blank">2006年6月 (7)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/05.html" target="_blank">2006年5月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/04.html" target="_blank">2006年4月 (12)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/03.html" target="_blank">2006年3月 (13)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/02.html" target="_blank">2006年2月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/01.html" target="_blank">2006年1月 (14)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/12.html" target="_blank">2005年12月 (11)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/11.html" target="_blank">2005年11月 (14)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/10.html" target="_blank">2005年10月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/09.html" target="_blank">2005年9月 (10)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/08.html" target="_blank">2005年8月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/07.html" target="_blank">2005年7月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/06.html" target="_blank">2005年6月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/05.html" target="_blank">2005年5月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/02.html" target="_blank">2005年2月 (1)</a></li>
</ul>
<h3 id="-">文章档案</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archives/2005/05.html" target="_blank">2005年5月 (2)</a></li>
</ul>
<h3 id="blogger-s">Blogger&#39;s</h3>
<ul>
<li><a href="http://www.dbanotes.net/" target="_blank">DBANotes</a></li>
<li>大名鼎鼎了，勿需多说</li>
<li><a href="http://www.esbzone.net/" target="_blank">ESBZone</a> <a href="http://www.esbzone.net/feed" title="Subscribe to ESBZone" target="_blank">(rss)</a></li>
<li>SOA实战者，强烈推荐</li>
<li><a href="http://kenwublog.com/" target="_blank">kenwu&#39;s blog[推荐]</a> <a href="http://feed.kenwublog.com/" title="Subscribe to kenwu&#39;s blog[推荐]" target="_blank">(rss)</a></li>
<li>Java底层和JVM的很多文章，强烈推荐。</li>
<li><a href="http://dreamhead.blogbus.com/" target="_blank">梦想风暴</a></li>
<li><a href="http://www.blogjava.net/cenwenchu/" target="_blank">西湖边的穷秀才</a></li>
</ul>
<h3 id="-">搜索</h3>
<p>*</p>
<ul>
<li></li>
</ul>
<h3 id="-http-www-blogjava-net-bluedavy-commentsrss-aspx-">最新评论 <a href="http://www.blogjava.net/BlueDavy/CommentsRSS.aspx" target="_blank"><img src="" alt=""></a></h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/07/19/321796.html#401750" target="_blank">1. re: 关于《分布式Java应用：基础与实践》一书</a></li>
<li>博主 大神啊 这个博客很久没有更新了</li>
<li>--1836567962@qq.com</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/07/11/267970.html#401444" target="_blank">2. re: 网站架构相关PPT、文章整理（更新于2009-7-15）</a></li>
<li>这个文章很有用，收藏</li>
<li>--度哥网</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/28/267968.html#399877" target="_blank">3. re: OSGi Opendoc &amp; Book</a></li>
<li>评论内容较长,点击标题查看</li>
<li>--stono</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/28/267968.html#399865" target="_blank">4. re: OSGi Opendoc &amp; Book</a></li>
<li>我再看《OSGi》原理与最佳实践，可是源码没有办法下载呀；
有没有什么办法呢？</li>
<li>--stono</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/27/321796.html#399801" target="_blank">5. re: 关于《分布式Java应用：基础与实践》一书</a></li>
<li>在这篇blog中放置了我收集的一些网站架构相关的PPT和文章</li>
<li>--色都</li>
</ul>
<h3 id="-">阅读排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09/03/226749.html" target="_blank">1. 大型网站架构演变和知识体系(57638)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04/28/267970.html" target="_blank">2. 网站架构相关PPT、文章整理（更新于2009-7-15）(38732)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/03/27/37582.html" target="_blank">3. Hibernate实践(31780)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/06/13/6037.html" target="_blank">4. 系统设计说明书(架构、概要、详细)目录结构(24258)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08/25/65741.html" target="_blank">5. 发布《OSGi实战》正式版(17725)</a></li>
</ul>
<h3 id="-">评论排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09/03/226749.html" target="_blank">1. 大型网站架构演变和知识体系(96)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/09/07/12340.html" target="_blank">2. 漫谈CMS(88)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04/28/267970.html" target="_blank">3. 网站架构相关PPT、文章整理（更新于2009-7-15）(66)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/09/29/149631.html" target="_blank">4. 《OSGi进阶》预览版发布(59)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08/25/65741.html" target="_blank">5. 发布《OSGi实战》正式版(54)</a></li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--GC策略的调优/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--GC策略的调优" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--GarbageFirst介绍/">Garbage First介绍</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--GarbageFirst介绍/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="garbage-first-">Garbage First介绍</h1>
<h1 id="-bluedavy-blog-http-www-blogjava-net-bluedavy-"><a href="http://www.blogjava.net/BlueDavy/" target="_blank">BlueDavy之技术Blog</a></h1>
<p>理论不懂就实践，实践不会就学理论！</p>
<h2 id="-garbage-first-http-www-blogjava-net-bluedavy-archive-2009-03-11-259230-html-"><a href="http://www.blogjava.net/BlueDavy/archive/2009/03/11/259230.html" target="_blank">Garbage First介绍</a></h2>
<p>本文摘自《构建高性能的大型分布式Java应用》一书，Garbage First简称G1，它的目标是要做到尽量减少GC所导致的应用暂停的时间，让应用达到准实时的效果，同时保持JVM堆空间的利用率，将作为CMS的替代者在JDK 7中闪亮登场，其最大的特色在于允许指定在某个时间段内GC所导致的应用暂停的时间最大为多少，例如在100秒内最多允许GC导致的应用暂停时间为1秒，这个特性对于准实时响应的系统而言非常的吸引人，这样就再也不用担心系统突然会暂停个两三秒了。</p>
<p>G1要做到这样的效果，也是有前提的，一方面是硬件环境的要求，必须是多核的CPU以及较大的内存（从规范来看，512M以上就满足条件了），另外一方面是需要接受吞吐量的稍微降低，对于实时性要求高的系统而言，这点应该是可以接受的。</p>
<p>为了能够达到这样的效果，G1在原有的各种GC策略上进行了吸收和改进，在G1中可以看到增量收集器和CMS的影子，但它不仅仅是吸收原有GC策略的优点，并在此基础上做出了很多的改进，简单来说，G1吸收了增量GC以及CMS的精髓，将整个jvm Heap划分为多个固定大小的region，扫描时采用Snapshot-at-the-beginning的并发marking算法（具体在后面内容详细解释）对整个heap中的region进行mark，回收时根据region中活跃对象的bytes进行排序，首先回收活跃对象bytes小以及回收耗时短（预估出来的时间）的region，回收的方法为将此region中的活跃对象复制到另外的region中，根据指定的GC所能占用的时间来估算能回收多少region，这点和以前版本的Full GC时得处理整个heap非常不同，这样就做到了能够尽量短时间的暂停应用，又能回收内存，由于这种策略在回收时首先回收的是垃圾对象所占空间最多的region，因此称为Garbage First。</p>
<p>看完上面对于G1策略的简短描述，并不能清楚的掌握G1，在继续详细看G1的步骤之前，必须先明白G1对于JVM Heap的改造，这些对于习惯了划分为new generation、old generation的大家来说都有不少的新意。</p>
<p>G1将Heap划分为多个固定大小的region，这也是G1能够实现控制GC导致的应用暂停时间的前提，region之间的对象引用通过remembered set来维护，每个region都有一个remembered set，remembered set中包含了引用当前region中对象的region的对象的pointer，由于同时应用也会造成这些region中对象的引用关系不断的发生改变，G1采用了Card Table来用于应用通知region修改remembered sets，Card Table由多个512字节的Card构成，这些Card在Card Table中以1个字节来标识，每个应用的线程都有一个关联的remembered set log，用于缓存和顺序化线程运行时造成的对于card的修改，另外，还有一个全局的filled RS buffers，当应用线程执行时修改了card后，如果造成的改变仅为同一region中的对象之间的关联，则不记录remembered set log，如造成的改变为跨region中的对象的关联，则记录到线程的remembered set log，如线程的remembered set log满了，则放入全局的filled RS buffers中，线程自身则重新创建一个新的remembered set log，remembered set本身也是一个由一堆cards构成的哈希表。</p>
<p>尽管G1将Heap划分为了多个region，但其默认采用的仍然是分代的方式，只是仅简单的划分为了年轻代（young）和非年轻代，这也是由于G1仍然坚信大多数新创建的对象都是不需要长的生命周期的，对于应用新创建的对象，G1将其放入标识为young的region中，对于这些region，并不记录remembered set logs，扫描时只需扫描活跃的对象，G1在分代的方式上还可更细的划分为：fully young或partially young，fully young方式暂停的时候仅处理young regions，partially同样处理所有的young regions，但它还会根据允许的GC的暂停时间来决定是否要加入其他的非young regions，G1是运行到fully-young方式还是partially young方式，外部是不能决定的，在启动时，G1采用的为fully-young方式，当G1完成一次Concurrent Marking后，则切换为partially young方式，随后G1跟踪每次回收的效率，如果回收fully-young中的regions已经可以满足内存需要的话，那么就切换回fully young方式，但当heap size的大小接近满的情况下，G1会切换到partially young方式，以保证能提供足够的内存空间给应用使用。</p>
<p>除了分代方式的划分外，G1还支持另外一种pure G1的方式，也就是不进行代的划分，pure方式和分代方式的具体不同在下面的具体执行步骤中进行描述。</p>
<p>掌握了这些概念后，继续来看G1的具体执行步骤：</p>
<ol>
<li>Initial Marking</li>
</ol>
<p>G1对于每个region都保存了两个标识用的bitmap，一个为previous marking bitmap，一个为next marking bitmap，bitmap中包含了一个bit的地址信息来指向对象的起始点。</p>
<p>开始Initial Marking之前，首先并发的清空next marking bitmap，然后停止所有应用线程，并扫描标识出每个region中root可直接访问到的对象，将region中top的值放入next top at mark start（TAMS）中，之后恢复所有应用线程。</p>
<p>触发这个步骤执行的条件为：</p>
<p>l  G1定义了一个JVM Heap大小的百分比的阀值，称为h，另外还有一个H，H的值为(1-h)/<em>Heap Size，目前这个h的值是固定的，后续G1也许会将其改为动态的，根据jvm的运行情况来动态的调整，在分代方式下，G1还定义了一个u以及soft limit，soft limit的值为H-u/</em>Heap Size，当Heap中使用的内存超过了soft limit值时，就会在一次clean up执行完毕后在应用允许的GC暂停时间范围内尽快的执行此步骤；</p>
<p>l  在pure方式下，G1将marking与clean up组成一个环，以便clean up能充分的使用marking的信息，当clean up开始回收时，首先回收能够带来最多内存空间的regions，当经过多次的clean up，回收到没多少空间的regions时，G1重新初始化一个新的marking与clean up构成的环。</p>
<ol>
<li>Concurrent Marking</li>
</ol>
<p>按照之前Initial Marking扫描到的对象进行遍历，以识别这些对象的下层对象的活跃状态，对于在此期间应用线程并发修改的对象的以来关系则记录到remembered set logs中，新创建的对象则放入比top值更高的地址区间中，这些新创建的对象默认状态即为活跃的，同时修改top值。</p>
<ol>
<li>Final Marking Pause</li>
</ol>
<p>当应用线程的remembered set logs未满时，是不会放入filled RS buffers中的，在这样的情况下，这些remebered set logs中记录的card的修改就会被更新了，因此需要这一步，这一步要做的就是把应用线程中存在的remembered set logs的内容进行处理，并相应的修改remembered sets，这一步需要暂停应用，并行的运行。</p>
<ol>
<li>Live Data Counting and Cleanup</li>
</ol>
<p>值得注意的是，在G1中，并不是说Final Marking Pause执行完了，就肯定执行Cleanup这步的，由于这步需要暂停应用，G1为了能够达到准实时的要求，需要根据用户指定的最大的GC造成的暂停时间来合理的规划什么时候执行Cleanup，另外还有几种情况也是会触发这个步骤的执行的：</p>
<p>l  G1采用的是复制方法来进行收集，必须保证每次的”to space”的空间都是够的，因此G1采取的策略是当已经使用的内存空间达到了H时，就执行Cleanup这个步骤；</p>
<p>l  对于full-young和partially-young的分代模式的G1而言，则还有情况会触发Cleanup的执行，full-young模式下，G1根据应用可接受的暂停时间、回收young regions需要消耗的时间来估算出一个yound regions的数量值，当JVM中分配对象的young regions的数量达到此值时，Cleanup就会执行；partially-young模式下，则会尽量频繁的在应用可接受的暂停时间范围内执行Cleanup，并最大限度的去执行non-young regions的Cleanup。</p>
<p>这一步中GC线程并行的扫描所有region，计算每个region中低于next TAMS值中marked data的大小，然后根据应用所期望的GC的短延时以及G1对于region回收所需的耗时的预估，排序region，将其中活跃的对象复制到其他region中。</p>
<p>G1为了能够尽量的做到准实时的响应，例如估算暂停时间的算法、对于经常被引用的对象的特殊处理等，G1为了能够让GC既能够充分的回收内存，又能够尽量少的导致应用的暂停，可谓费尽心思，从G1的论文中的性能评测来看效果也是不错的，不过如果G1能允许开发人员在编写代码时指定哪些对象是不用mark的就更完美了，这对于有巨大缓存的应用而言，会有很大的帮助，G1将随JDK 6 Update 14 beta发布。</p>
<p>posted on 2009-03-11 22:18 <a href="http://www.blogjava.net/BlueDavy/" target="_blank">BlueDavy</a> 阅读(5465) <a href="">评论(3)</a>  <a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx?postid=259230" target="_blank">编辑</a>  <a href="http://www.blogjava.net/BlueDavy/AddToFavorite.aspx?id=259230" target="_blank">收藏</a> 所属分类: <a href="http://www.blogjava.net/BlueDavy/category/1366.html" target="_blank">Java</a></p>
<p> <img src="" alt=""></p>
<p><a href=""></a> <a href=""></a></p>
<p>[</p>
<h3 id="-">评论</h3>
<p>]()</p>
<h3 id="-permalink-re-garbage-first-re-garbage-first-2009-03-14-13-37-phpxer-http-www-blogjava-net-phpxer-"><a href=""></a><a href="&quot;permalink: re: Garbage First介绍&quot;">/#</a> <a href=""></a>re: Garbage First介绍  2009-03-14 13:37  <a href="http://www.blogjava.net/phpxer/">phpxer</a></h3>
<p>Mark  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=phpxer" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-garbage-first-re-garbage-first-2009-04-01-12-14-http-www-owner0571-com-about-asp-c-cs-"><a href="&quot;permalink: re: Garbage First介绍&quot;">/#</a> <a href=""></a>re: Garbage First介绍  2009-04-01 12:14  <a href="http://www.owner0571.com/about.asp?c=CS">中国兄弟连</a></h3>
<p>给你踩踩哈!  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=%e4%b8%ad%e5%9b%bd%e5%85%84%e5%bc%9f%e8%bf%9e" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-garbage-first-re-garbage-first-2013-03-04-23-52-http-www-helemao-com-"><a href="&quot;permalink: re: Garbage First介绍&quot;">/#</a> <a href=""></a>re: Garbage First介绍<a href=""></a>  2013-03-04 23:52  <a href="http://www.helemao.com/" target="_blank">呵乐猫</a></h3>
<p>学习了。  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=%e5%91%b5%e4%b9%90%e7%8c%ab" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a>
<a href="http://www.blogjava.net/RequireRegister.aspx" target="_blank">新用户注册</a>  <a href="">刷新评论列表</a>  </p>
<p><a href=""></a> <a href="http://www.aliyun.com/cps/channel?channel_id=1306&amp;user=0&amp;lv=1">推荐购买云服务器（15%返利+最高千元奖金）</a>   <a href="http://www.cnblogs.com/" target="_blank">博客园</a>  <a href="http://q.cnblogs.com/" target="_blank">博问</a>  <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>  <a href="http://job.cnblogs.com/cate-java_programmer/" target="_blank">Java程序员招聘</a> 标题  请输入标题 姓名  请输入你的姓名 主页 请输入验证码 验证码 /*  <img src="http://www.blogjava.net/Modules/CaptchaImage/JpegImage.aspx?cacheid=20130727130737" alt=""> 内容(请不要发表任何与政治相关的内容) 请输入评论内容 Remember Me?   <a href="http://www.blogjava.net/login.aspx?ReturnURL=http://www.blogjava.net/BlueDavy/archive/2009/03/11/259230.html&amp;SourceURL=/BlueDavy/archive/2009/03/11/259230.html" target="_blank">登录</a>       [使用Ctrl+Enter键可以直接提交]      网站导航:</p>
<p><a href="http://www.cnblogs.com/" title="程序员的网上家园" target="_blank">博客园</a>   <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>   <a href="http://kb.cnblogs.com/" target="_blank">知识库</a>   <a href="http://www.cppblog.com/" target="_blank">C++博客</a>   <a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a>   <a href="http://www.blogjava.net/BlueDavy/archive/2009/03/11/259230.html?opt=admin" target="_blank">管理</a> 相关文章:</p>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/05/25/321796.html" target="_blank">关于《分布式Java应用：基础与实践》一书</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/04/30/319794.html" target="_blank">杭州程序员圆桌交流第二期视频</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03/22/316148.html" target="_blank">第一次杭州程序员交流会总结</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03/19/315989.html" target="_blank">杭州程序员圆桌交流第一期–并发编程PPT</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/12/03/304597.html" target="_blank">GCLogViewer(tool to visualize gc log) V0.2 Release</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11/25/303662.html" target="_blank">Simple Scala actor Vs java Thread Vs Kilim Test</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11/06/301448.html" target="_blank">《构建高性能的大型分布式Java应用》目录&amp;试读样章</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/10/297661.html" target="_blank">动态跟踪Java代码的执行状况工具--BTrace</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/09/297562.html" target="_blank">GC策略的调优</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/08/06/290003.html" target="_blank">Hessian 3.2.0的两个bug</a><br>Powered by: <a href="http://www.blogjava.net/" target="_blank">BlogJava</a> Copyright © BlueDavy<h3 id="-">公告</h3>
</li>
</ul>
<p><a href="http://www.douban.com/subject/3843896/" target="_blank"><img src="" alt=""></a> 
<a href="http://china.osgiusers.org/" target="_blank"><img src="" alt=""></a>
<a href="http://feed.feedsky.com/bluedavy" title="BlogJava-BlueDavy之技术Blog" target="_blank"><img src="" alt=""></a> <a href="http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="feedsky"></a>
<a href="http://www.zhuaxia.com/add_channel.php?url=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="抓虾"></a>
<a href="http://fusion.google.com/add?feedurl=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="google reader"></a>
<a href="http://www.xianguo.com/subscribe.php?url=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="鲜果"></a></p>
<h3 id="-">导航</h3>
<ul>
<li><a href="http://www.blogjava.net/" target="_blank">BlogJava</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/" target="_blank">首页</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx?opt=1" target="_blank">新随笔</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/contact.aspx?id=1" target="_blank">联系</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/rss" target="_blank">聚合</a><a href="http://www.blogjava.net/BlueDavy/rss" target="_blank"><img src="" alt=""></a></li>
<li><a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx" target="_blank">管理</a>
<a href="&quot;转到上一个月&quot;">&lt;</a>2009年3月<a href="&quot;转到下一个月&quot;">&gt;</a>日一二三四五六222324252627281234<a href="http://www.blogjava.net/BlueDavy/archive/2009/03/05.html" target="_blank">5</a><a href="http://www.blogjava.net/BlueDavy/archive/2009/03/06.html" target="_blank">6</a>78910<a href="http://www.blogjava.net/BlueDavy/archive/2009/03/11.html" target="_blank">11</a><a href="http://www.blogjava.net/BlueDavy/archive/2009/03/12.html" target="_blank">12</a>1314151617181920212223242526<a href="http://www.blogjava.net/BlueDavy/archive/2009/03/27.html" target="_blank">27</a>282930311234</li>
</ul>
<h3 id="-">统计</h3>
<ul>
<li>随笔 - 294</li>
<li>文章 - 2</li>
<li>评论 - 2068</li>
<li>引用 - 1</li>
</ul>
<h3 id="-">随笔分类</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/category/10609.html" target="_blank">@RIAWork(10)</a> <a href="http://www.blogjava.net/BlueDavy/category/10609.html/rss" title="Subscribe to @RIAWork(10)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/32839.html" target="_blank">Internet(20)</a> <a href="http://www.blogjava.net/BlueDavy/category/32839.html/rss" title="Subscribe to Internet(20)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1366.html" target="_blank">Java(82)</a> <a href="http://www.blogjava.net/BlueDavy/category/1366.html/rss" title="Subscribe to Java(82)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/8127.html" target="_blank">Javascript(7)</a> <a href="http://www.blogjava.net/BlueDavy/category/8127.html/rss" title="Subscribe to Javascript(7)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/18356.html" target="_blank">OSGi、SOA、SCA(81)</a> <a href="http://www.blogjava.net/BlueDavy/category/18356.html/rss" title="Subscribe to OSGi、SOA、SCA(81)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1514.html" target="_blank">Plugin Architecture(10)</a> <a href="http://www.blogjava.net/BlueDavy/category/1514.html/rss" title="Subscribe to Plugin Architecture(10)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1513.html" target="_blank">Workflow(4)</a> <a href="http://www.blogjava.net/BlueDavy/category/1513.html/rss" title="Subscribe to Workflow(4)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/11559.html" target="_blank">业界随想(28)</a> <a href="http://www.blogjava.net/BlueDavy/category/11559.html/rss" title="Subscribe to 业界随想(28)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/22527.html" target="_blank">数据集成(8)</a> <a href="http://www.blogjava.net/BlueDavy/category/22527.html/rss" title="Subscribe to 数据集成(8)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1911.html" target="_blank">系统设计(38)</a> <a href="http://www.blogjava.net/BlueDavy/category/1911.html/rss" title="Subscribe to 系统设计(38)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1367.html" target="_blank">软件工程(22)</a> <a href="http://www.blogjava.net/BlueDavy/category/1367.html/rss" title="Subscribe to 软件工程(22)" target="_blank">(rss)</a></li>
</ul>
<h3 id="-">随笔档案</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/05.html" target="_blank">2010年5月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/04.html" target="_blank">2010年4月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03.html" target="_blank">2010年3月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/02.html" target="_blank">2010年2月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/01.html" target="_blank">2010年1月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/12.html" target="_blank">2009年12月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11.html" target="_blank">2009年11月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10.html" target="_blank">2009年10月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/09.html" target="_blank">2009年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/08.html" target="_blank">2009年8月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/07.html" target="_blank">2009年7月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/06.html" target="_blank">2009年6月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/05.html" target="_blank">2009年5月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04.html" target="_blank">2009年4月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/03.html" target="_blank">2009年3月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/01.html" target="_blank">2009年1月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/11.html" target="_blank">2008年11月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/10.html" target="_blank">2008年10月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09.html" target="_blank">2008年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/08.html" target="_blank">2008年8月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/07.html" target="_blank">2008年7月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/06.html" target="_blank">2008年6月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/05.html" target="_blank">2008年5月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/04.html" target="_blank">2008年4月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/03.html" target="_blank">2008年3月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/02.html" target="_blank">2008年2月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/01.html" target="_blank">2008年1月 (10)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/12.html" target="_blank">2007年12月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/11.html" target="_blank">2007年11月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/10.html" target="_blank">2007年10月 (6)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/09.html" target="_blank">2007年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/08.html" target="_blank">2007年8月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/07.html" target="_blank">2007年7月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/06.html" target="_blank">2007年6月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/05.html" target="_blank">2007年5月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/04.html" target="_blank">2007年4月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/03.html" target="_blank">2007年3月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/02.html" target="_blank">2007年2月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/01.html" target="_blank">2007年1月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/12.html" target="_blank">2006年12月 (6)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/11.html" target="_blank">2006年11月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/10.html" target="_blank">2006年10月 (8)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/09.html" target="_blank">2006年9月 (13)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08.html" target="_blank">2006年8月 (15)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/07.html" target="_blank">2006年7月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/06.html" target="_blank">2006年6月 (7)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/05.html" target="_blank">2006年5月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/04.html" target="_blank">2006年4月 (12)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/03.html" target="_blank">2006年3月 (13)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/02.html" target="_blank">2006年2月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/01.html" target="_blank">2006年1月 (14)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/12.html" target="_blank">2005年12月 (11)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/11.html" target="_blank">2005年11月 (14)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/10.html" target="_blank">2005年10月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/09.html" target="_blank">2005年9月 (10)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/08.html" target="_blank">2005年8月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/07.html" target="_blank">2005年7月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/06.html" target="_blank">2005年6月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/05.html" target="_blank">2005年5月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/02.html" target="_blank">2005年2月 (1)</a></li>
</ul>
<h3 id="-">文章档案</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archives/2005/05.html" target="_blank">2005年5月 (2)</a></li>
</ul>
<h3 id="blogger-s">Blogger&#39;s</h3>
<ul>
<li><a href="http://www.dbanotes.net/" target="_blank">DBANotes</a></li>
<li>大名鼎鼎了，勿需多说</li>
<li><a href="http://www.esbzone.net/" target="_blank">ESBZone</a> <a href="http://www.esbzone.net/feed" title="Subscribe to ESBZone" target="_blank">(rss)</a></li>
<li>SOA实战者，强烈推荐</li>
<li><a href="http://kenwublog.com/" target="_blank">kenwu&#39;s blog[推荐]</a> <a href="http://feed.kenwublog.com/" title="Subscribe to kenwu&#39;s blog[推荐]" target="_blank">(rss)</a></li>
<li>Java底层和JVM的很多文章，强烈推荐。</li>
<li><a href="http://dreamhead.blogbus.com/" target="_blank">梦想风暴</a></li>
<li><a href="http://www.blogjava.net/cenwenchu/" target="_blank">西湖边的穷秀才</a></li>
</ul>
<h3 id="-">搜索</h3>
<p>*</p>
<ul>
<li></li>
</ul>
<h3 id="-http-www-blogjava-net-bluedavy-commentsrss-aspx-">最新评论 <a href="http://www.blogjava.net/BlueDavy/CommentsRSS.aspx" target="_blank"><img src="" alt=""></a></h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/07/19/321796.html#401750" target="_blank">1. re: 关于《分布式Java应用：基础与实践》一书</a></li>
<li>博主 大神啊 这个博客很久没有更新了</li>
<li>--1836567962@qq.com</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/07/11/267970.html#401444" target="_blank">2. re: 网站架构相关PPT、文章整理（更新于2009-7-15）</a></li>
<li>这个文章很有用，收藏</li>
<li>--度哥网</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/28/267968.html#399877" target="_blank">3. re: OSGi Opendoc &amp; Book</a></li>
<li>评论内容较长,点击标题查看</li>
<li>--stono</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/28/267968.html#399865" target="_blank">4. re: OSGi Opendoc &amp; Book</a></li>
<li>我再看《OSGi》原理与最佳实践，可是源码没有办法下载呀；
有没有什么办法呢？</li>
<li>--stono</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/27/321796.html#399801" target="_blank">5. re: 关于《分布式Java应用：基础与实践》一书</a></li>
<li>在这篇blog中放置了我收集的一些网站架构相关的PPT和文章</li>
<li>--色都</li>
</ul>
<h3 id="-">阅读排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09/03/226749.html" target="_blank">1. 大型网站架构演变和知识体系(57638)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04/28/267970.html" target="_blank">2. 网站架构相关PPT、文章整理（更新于2009-7-15）(38732)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/03/27/37582.html" target="_blank">3. Hibernate实践(31780)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/06/13/6037.html" target="_blank">4. 系统设计说明书(架构、概要、详细)目录结构(24258)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08/25/65741.html" target="_blank">5. 发布《OSGi实战》正式版(17725)</a></li>
</ul>
<h3 id="-">评论排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09/03/226749.html" target="_blank">1. 大型网站架构演变和知识体系(96)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/09/07/12340.html" target="_blank">2. 漫谈CMS(88)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04/28/267970.html" target="_blank">3. 网站架构相关PPT、文章整理（更新于2009-7-15）(66)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/09/29/149631.html" target="_blank">4. 《OSGi进阶》预览版发布(59)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08/25/65741.html" target="_blank">5. 发布《OSGi实战》正式版(54)</a></li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--GarbageFirst介绍/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--GarbageFirst介绍" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--IBMWebSphereApplicationServer诊断和调优07年写的-原Java/">IBM WebSphere Application Server 诊断和调优(07年写的</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--IBMWebSphereApplicationServer诊断和调优07年写的-原Java/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="ibm-websphere-application-server-07-javaeye-">IBM WebSphere Application Server 诊断和调优(07年写的,原JavaEye精华帖)</h1>
<p><a href="http://www.iteye.com/" target="_blank">首页</a> <a href="http://www.iteye.com/news" target="_blank">资讯</a> <a href="http://www.iteye.com/magazines" target="_blank">精华</a> <a href="http://www.iteye.com/forums" target="_blank">论坛</a> <a href="http://www.iteye.com/ask" target="_blank">问答</a> <a href="http://www.iteye.com/blogs" target="_blank">博客</a> <a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a> <a href="http://www.iteye.com/groups" target="_blank">群组</a> <a href="">更多 ▼</a></p>
<p><a href="http://job.iteye.com/iteye" target="_blank">招聘</a> <a href="http://www.iteye.com/search" target="_blank">搜索</a></p>
<p><a href="http://zwchen.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://zwchen.iteye.com/login" target="_blank">登录</a> <a href="http://zwchen.iteye.com/signup" target="_blank">注册</a></p>
<h1 id="-zwchen-http-zwchen-iteye-com-"><a href="http://zwchen.iteye.com/" target="_blank">zwchen的博客</a></h1>
<ul>
<li><a href="http://zwchen.iteye.com/" target="_blank"><strong>博客</strong></a></li>
<li><a href="http://zwchen.iteye.com/weibo" target="_blank">微博</a></li>
<li><a href="http://zwchen.iteye.com/album" target="_blank">相册</a></li>
<li><a href="http://zwchen.iteye.com/link" target="_blank">收藏</a></li>
<li><a href="http://zwchen.iteye.com/blog/guest_book" target="_blank">留言</a></li>
<li><a href="http://zwchen.iteye.com/blog/profile" target="_blank">关于我</a></li>
</ul>
<h3 id="-ibm-websphere-application-server-07-javaeye-"><a href="">IBM WebSphere Application Server 诊断和调优(07年写的,原JavaEye精华帖)</a> **</h3>
<p><strong>博客分类：</strong></p>
<ul>
<li><a href="http://zwchen.iteye.com/category/9634" target="_blank">IT技术</a>
<a href="http://www.iteye.com/blogs/tag/IBM" target="_blank">IBM</a><a href="http://www.iteye.com/blogs/tag/Websphere" target="_blank">Websphere</a><a href="http://www.iteye.com/blogs/tag/AIX" target="_blank">AIX</a><a href="http://www.iteye.com/blogs/tag/JVM" target="_blank">JVM</a><a href="http://www.iteye.com/blogs/tag/CMS" target="_blank">CMS</a></li>
</ul>
<p>这是<a href="http://zwchen.iteye.com/blog/646063" target="_blank">上篇文章</a>的续篇，也是07年初发表于JavaEye，被评为精华帖，浏览近四万次，也被各大IT媒体转载（google可查）。基于同样的原因，被删除了）。
对WebSphere一线开发人员，这么珍贵的文章，特别是会员的评论，就被这个商业社会给和谐。
因为，寻找和阅读WebSphere诊断和调优的资料，非常困难，否则，它那高额的服务费哪里来？（IBM的WebSphere服务费：人民币10000元/天）。</p>
<h2 id="-"><img src="&quot;点击查看原始大小图片&quot;" alt=""></h2>
<p>续写这篇文章，已经过去一个半月了。直到现在，系统一直运行平稳。
先说说我接手这项工作的经历吧：该项目大部分是06年10月就部署在客户那边了，到07年3月份，WAS宕机问题实在无法忍受，我才加入进来，前半年有另外一位同事断断续续处理，但对问题一直都无可奈何，而且项目负责人也没有引起足够的重视。可想而知，最后付出的代价是非常惨重的。在这近半年的时间内，服务器宕机63次。每次宕机时，WAS的JVM会dump出一个heapdump.phd文件(heap快照)，然后JVM就死掉了，当然，此时WAS也停止了响应。一般我们的做法是重启，最后是干脆AIX每天晚上定时重启。有时候一天还死多次。大家见附件的截图（all- GC.png）。这是我接手后，用IBM的分析工具得到的截图。对截图的分析，留给后面对应的部分吧。
服务器不稳定、宕机问题，拖延到最后，客户愤怒了，公司高层也害怕了，部门还专门成立了八人攻关组。当然了，我当时的压力也非常大，因为我是技术负责人，也就是实实在在干活、想主意的。
服务器诊断那段时间，从前到后，我们也是沿着一条线走下来，虽然最后发现很多路都走不通。现在就按这个思路，也就是时间先后一步步叙述吧。我想，大家如果也碰到类似应用服务器诊断，应该思路差不多。
术语说明：
IBM Websphere Application Server：WAS，WebSphere本身是一个平台，产品家族
OutOfMemoryError：OOM，内存泄漏，内存溢出
Gabage Collection：GC，自动垃圾回收
Content Management System：CMS，就是给新闻类门户网站编辑们用的系统
我们诊断大体上经历了以下几个阶段：
1、按Job调度线程池引起内存泄漏诊断：因为很多次OOM是发生在某个特定时候，譬如14：30、22：40左右。
2、按应用程序引起内存泄漏诊断：用JProfiler等工具探测：因为总是发生OOM。
3、分离WAS怀疑有OOM的应用：因为每个WAS应用太多，20来个，混一起没法定位。
4、用IBM官方heap、GC分析工具。以及和IBM技术支持联系。WAS、AIX参数优化。
5、隔离出WAS超级恶魔程序：一个CMS产品。
6、WAS、AIX参数优化、设置。
我们走到第5步时，才出现效果。计算一下，那时已经过去一个月了。服务器宕机、系统不稳定，在这个验收的时候，客户已经忍无可忍，以致后来的每一次行动都得胆战心惊得去做。
<strong>一、按Job调度线程池导致内存泄漏诊断</strong>
因为从我们WAS的日志(默认是native_stderr.log)来看，最近半年的宕机时间都有一个明显时间规律。见附件截图Job1-1.png。
我想，做过Java服务器性能调优的朋友，都知道在Web容器里面启线程池是个不太好的做法，因为Web容器本身有一个线程池，譬如Servlet线程池（Tomcat默认起25个），而自启的线程池很容易导致Servlet线程管理混乱，最终导致GC问题。我们的现象似乎和那很符合。如果我们沿着这个思路做下去，具体怎样实施呢？
我们的WAS上部署了20个左右的Web应用，譬如Lucene全文检索、B2B行业数据同步等，都是通过Quartz的Job调度做的，当然还有很多其它调度。当时，由我负责，通知相关负责人，将定时调度暂时去掉。观察了几天，后来发现问题依然存在，不过时间有点随机了。
不过，最后还是发现OOM不是由Job调度引起的。
也就是说，我们这个方案是失败的。而且，我们的很多想法都是臆测的，没有可靠的根据，也没有方向，再加上我是第一次处理这种问题，这导致后来查找问题的艰难。但是，仔细想想，我们又能拿什么做依据呢？出现OOM错误，我想大多数人想到的，除了JVM参数设置，就是内存泄漏。其实，OOM发生有很多种情况，在IBM、Sun、BEA等不同虚拟机上，因为GC机制不一样，所以原因一般都不同，容易定位难度也不一样。下文会谈到。
于是，我们干脆釜底抽薪分析问题吧：用JProfiler检测。
<strong>二、按应用程序导致内存泄漏诊断，JProfiler检测</strong>
如果遇到OOM问题，我想大家都会想到内存检测工具，现在最可靠的还是下面三种分析工具：Borland 的Optimizeit Suite，Quest的JProbe，ej-technologies的JProfiler。但面临三个问题：
1、三个都是商业产品，公司暂时没有买，必须自己下载，而且要找序列号。
2、工具必须支持AIX5.3＋JDK1.42＋WAS6.0，不是Windows平台。
3、工具必须在客户真实环境下部署，对客户的业务不能有冲击，也就是说部署测试工具前，必须做个大量测试，对工具非常熟练，遇到意外可以立即恢复现场。
Note:项目上线后，而不是测试或试运行阶段遇到此类问题，非常考验人；另外一个，就是性能和可伸缩性问题，很可能把整个项目给毁了。
当我决定要这么做后，就立即动手查阅这些工具的官方文档，用emule下载，最终都下载到了。试用后，最终选择了JProfiler4.03，比起其它工具，它界面美观、清晰、功能强大、集成度高(Heap,Memory,CPU,Thread都统一了)。另外，JProbe没有AIX版本，这也是放弃它的一个原因。
JVM的Profiler原理，都是通过JVM内置的的标准C语言Profiler 接口收集数据，然后通过Profiler工具的客户端展现。也就是说各厂商的Profiler工具，都有两个部分，一个部分是Profiler Agent，和JVM绑定，负责收集JVM内部数据，譬如方法调用次数、耗费时间等；另外一个部分就是Profiler front-end。通过Profiler工具的自定义local或remote协议传输到front-end，其实，我们最常用的JavaIDE的debug功能就是在此基础上的（JPDA）。（JProfiler的截图<a href="http://www.ej-technologies.com/products/jprofiler/screenshots.html" target="_blank"><a href="http://www.ej-technologies.com/products/jprofiler/screenshots.html">http://www.ej-technologies.com/products/jprofiler/screenshots.html</a></a>）。
下面是Sun官方文档：
JDK1.42及以前是JVM PI：<a href="http://java.sun.com/j2se/1.4.2/docs/guide/jvmpi/jvmpi.html" target="_blank"><a href="http://java.sun.com/j2se/1.4.2/docs/guide/jvmpi/jvmpi.html">http://java.sun.com/j2se/1.4.2/docs/guide/jvmpi/jvmpi.html</a></a>
JDK1.5是JVM TI：<a href="http://java.sun.com/j2se/1.5.0/docs/guide/jvmti/jvmti.html" target="_blank"><a href="http://java.sun.com/j2se/1.5.0/docs/guide/jvmti/jvmti.html">http://java.sun.com/j2se/1.5.0/docs/guide/jvmti/jvmti.html</a></a>
具体到JProfiler的配置上，专门针对JDK1.4和1.5的JVM配置差别很大。
我用的JProfiler是4.31版本，透露给大家一个万能序列号吧(这东西不太好找)，对各版本应该都支持。深入了解Java，这类工具是不可少的：
Name: License for You
Lincese Code: A-G667/#42616F-10kg1r134fq9m/#2217
为了保证真实环境的检测成功，我做了大量的试验，譬如：
1、Windows系列的本地、远程测试。
2、AIX的远程测试。
3、Tomcat5.0、WebLogic8.14、WebSphere6.02，以及上述两种方式的组合测试，排列组合，场景不下10个。
当时也参阅了大量JVM文档，JProfiler官方几百页英文文档，辅助的JProbe对照。而且也制造过内存泄漏造成的OOM场景。
当然，要是在几个月前，在客户那边部署的测试环境时，就进行测试该多好啊。
在公司内部，我用 JProfiler测试了我们当时部署的几个应用，没有发现内存泄漏，所以，我们最怀疑的是就是CMS系统。因为出问题的那个WAS上它占去了90％的负荷（我们有多台AIX、WAS服务器）。该CMS超级庞大，感觉著名的赛迪网就用它，当时该CMS厂商给我们部署都花了快一个月。所以再重新部署一套测试环境也挺困难。另外，CMS提供商不给lisence。现在测试，客户早就对我们恼火了，当然不怎么配合，这对我们工作的开展就有很大的挑战。
在大致可以确定万无一失的情况下，我们最终决定在客户的真实环境下测试。也就是让JProfiler的agent端直接在WAS的JVM里面启动（北京IDC），然后远程（大连）监控。
本来该模式在另外几个应用的测试都通过了（因为北京IDC那边好几台AIX服务器）。但一部署上，客户的一些编辑用CMS时就感觉超级慢，尽管我们用了JProfiler的最小负载模式。半个小时后，客户实在无法忍受，打电话过来，又把我们部长和经理训了一顿，还要写书面报告。我们被迫马山中止测试，恢复现场。
虽然JProfiler也支持客户那边的环境，但还是有bug，至少负载一高就有严重的性能问题，几乎导致系统挂起，这是我当时没有料到的。JProfiler一启动，WAS的启动时间就由原来的3分钟降到10分钟，而且系统响应明显变慢，我们具体的环境如下（排列组合恐怕不下20种）：
1、AIX5.3，Power PC64位（不是32位）
2、WebSphere6.0
3、IBM JVM1.42
4、Remote 模式
我后来仔细读了一下JProfiler的changeLog，发现对上面的环境支持不够也很正常，因为官方在最近的4.3.x版本下陆续有对IBM JVM和Websphere6.0的features和bug fix：<a href="http://www.ej-technologies.com/download/jprofiler/changelog.html" target="_blank"><a href="http://www.ej-technologies.com/download/jprofiler/changelog.html">http://www.ej-technologies.com/download/jprofiler/changelog.html</a></a>
进行到这一步，我忽然觉得无计可施了 ，此时已经过了三周。
上面的策略，我认为是很正统的处理方法。谁怪我们当初项目上线时没有进行充分的测试呢？其实，这类测试没做也正常，OOM这类问题谁都无法预测。
到这个时候，我想肯定有人会问我？你知道导致JVM的OOM有几种情况吗？在当时，我想到了以下五种：
1、JVM的heap最小、最大值没有设，或不合理。
2、JVM的maxPermSize没有设置（这个IBM的JVM没有，一设置JVM就起不来）。
对于Sun和BEA的JVM，以上两种参数设置，可以排除90％以上的非程序内存溢出导致的OOM。
3、程序内存泄漏
4、有的JVM，当在80%的CPU时间内，不能GC出2%的heap时，也发生OOM（IBM的JVM就是，但我没有验证）
5、JVM本身内存泄漏（JVM有bug不是不可能）
现在的难题是，如果是那个可怕的CMS程序本身有内存溢出，在产品环境下，我们怎么去验证？我们自己开发的10来个web应用，测试并不是很难，在公司测试都可以。但是，我现在最想解决的，就是CMS测试的问题。而且，在我们那种环境下，该CMS产品供应商并没有透露成功案例。
其实，最后发现，并不是内存泄漏造成的，因为我们的heap走势都很平稳。纳闷的是，有1000M的heap，每次在heap只被占用400来M时就发生OOM，没有任何预兆。大家猜猜，会是什么原因 ？这个问题我到后面相关章节再说吧。
既然我们所有的矛头都指向那个可怕的CMS系统，现在就是考虑隔离的问题。如果我们验证这个问题是CMS造成的，那么大部分责任就应该由CMS厂商承担 。
既然CMS我们不敢移（费劲，而且客户在正式用），那我就移我们开发的10来个web系统吧。
<strong>三、移出除CMS系统以外的所有应用
</strong>说起来容易啊，做呢？ 隔离（移动）工作由我负责，具体涉及到10来个相关负责人。
转移工作，必须处理好很多问题，就说几个印象最深的吧：
1、某些应用，如Blog和BBS，都涉及到文件、图片上传目录和产品本身的环境，如 JDBC连接池、Cache位置。
2、目标服务器本身的环境，WAS安装环境、网络等。
3、移植时的先后顺序、调度，各应用内部本身的约束关系。
4、移植后的测试。
当然，还有一个最严峻的问题，客户允许我们这么做吗？对它们目前运行的系统有多大影响？风险如何评估？
这个工作持续了一天，已经完成了80％的工作，到第二天，客户又恼火了：WAS又宕机了。
为什么？这确实是WAS的一个bug：WAS的后台随便一操作，heap就会突然上升几百M，导致JVM内存不够。不过WAS撑住的话，过半小时后就会降下来，我估计是WAS后台对用户操作状态、文件都缓存到Session里面。你们可以检查类似这样的一个文件夹：d:\IBM\WebSphere\AppServer\profiles\AppSrv01\wstemp，我不知道为什么WAS不主动去清除它，它偷偷的就上升到几个G，系统硬盘可能不久就后就会空间不足，WAS莫名迟缓、最后死掉。听过WAS6.0以前这个目录更夸张。大家见我附件的截图WAS_Console.png那个尖峰。
咋办？经理也已经不敢让我们继续铤而走险了。这个方案最终又以失败告终 。
不过，最后我们还是发现问题出在CMS上。我们以前把这个问题向CMS技术支持反映，有大量依据和现象，并且把相关日志都给它们。过了两天，他们最后竟然只回了一句话“从给我的两个日志来看，没有找到任何与XXX有关的东西….”。TMD！我真的很生气 ，它们的产品都折磨我们半年之久了。不过，看他们对IBM的WAS和JVM也不懂，我也就不想再说什么了。下面是我的邮件，公司机密部分都隐去了：
引用
附件是我们这段时间服务器宕机的日志。我们用IBM Pattern Modeling and Analysis Tool for Java Garbage Collector Version 1.3.2分析了一下虚拟机日志，没有发现是内存泄漏导致；用IBM HeapAnalyzer Version 1.4.4 分析heap文件，也没有发现很可疑的内存泄漏。
我想以前你们也这样做过，现在我们分析错误日志，发现有一个现象，在宕机时，总是找不到文件，我看就是Websphere或是AIX IO资源不够，不知道是什么导致的。但是，我们自己的应用，基本上没有什么IO，除了一次load几个配置文件。不过，我觉得你们WCM的IO操作挺多的，不知道你对日志有什么新的发现。
客观的说，这几个月来，宕机那台服务器，除了你们的XXX，就以论坛和blog为主，而且他们都是开源的。在频繁宕机的06年11月份，我们的论坛和blog还没有上线。现在我们不得不每天晚上11点定时重启，但这也不是长久之计。
现在，我们进行分离遇到很大阻力，原来想把你们的XXX单独分离出来，在当前的环境下，不是很现实，如安装、测试（负载、定时服务），所以现在分离我们自己的应用，但当前在产品环境下，客户方阻力也很大。
希望尽快能够得到你们的问题建议和方案。
文中说到了IBM的两个分析工具，这也是我们后来的救星：我们就是需要这种离线分析工具，因为实时检测已经证明不现实。但我始终对该分析出来的结果抱怀疑态度，直到我去深入IBM的JVM以及和IBM的技术支持交流……
柳暗花明啊 ，至少看到了一点希望，不过最后我们还是失望而返。
<strong>四、用IBM的HeapAnalyzer和GarbageCollector检测</strong>
找到这两个工具，已经是够费劲了，因为以前找的IBM HeapRoot工具，让我对这类工具很失望。而且，这两个工具，只有在IBM的Techinical Support网站能够搜索到，但很不容易，因为那两个工具，并不是象IBM的Websphere产品那样宣传，它只在IBM Techinical Support文章的某些角落里出现。要知道，Techinical Support是IBM很重要的收入来源，这类文档，他们并不会让你很轻易就拿到，比起BEA WLS的支持网站dev2dev差远了。
具体诊断细节我就不详述了。我认为，IBM的WAS或JVM出了性能和OOM问题，这两个工具是最有效的，而且是离线分析工具，比起那些实时Profiler工具，某些场合有绝对的优势：譬如我们目前的产品环境，你只能分析宕机后的日志，实时分析前面已经验证是不可行的。
从日志分析，我们最终得出结论，我们购买的CMS系统有严重的碎片（大对象）问题，而该问题是OOM的罪魁祸首，而且IBM工程师也得出了同一结论。不过，在起先我们得出这一结论一周后，我还始终不相信heap碎片会导致OOM，直到IBM工程师总是向我强调。
我想很多人也是不太相信，因为大多数人用的都是Sun的JVM，譬如Windows、Solaris上的hotspot。而且，Sun JVM出问题，如果是配置的问题，一般通过配置heap最大最小值，以及maxPermSize都可以解决。Heap碎片导致的OOM，只有BEA的 JRockit和IBM JVM上发生，不过JRockit有专门文档说明，而且很容易找到（就在jdk的文档里面）。
配置heap最小最大值，我想大多数人都有经验。对于Sun的JVM来说，一般可以设置heap最大最小值一致，也是推荐的做法。因为它的GC策略默认是复制、分代算法。也就是说，它会将heap分成不同的几个区，譬如Solaris JVM中最上面有两个大小相等的区。GC时刻，将一个区的存活对象复制到另外一个对等区，垃圾对象就算遗弃了。这样在heap里面，就不存在碎片问题。另外，根据Java对象的存活期不同，将之转移到不同的区（Tenured区），存活最长的在最底部（火车算法），这也就是分代模型。具体请参考官方文档：<a href="http://java.sun.com/docs/hotspot/gc1.4.2/" target="_blank"><a href="http://java.sun.com/docs/hotspot/gc1.4.2/">http://java.sun.com/docs/hotspot/gc1.4.2/</a></a>
对于maxPermSize（Permanent Generation），主要和那些加载到JVM里面的Java Class对象相关，它的空间不是在Java Heap里面分配。如果你当前的heap有1000M，permSize是200M，那么JVM至少占用1200M。
在这个空间内的对象的生存期和JVM是一样的，譬如JDK的核心类库，它们被System Classloader加载到JVM的Method Area（方法区）后，就不会被GC掉的，这些对象一般是Class对象，而不是普通的实例对象，也就是JVM的元数据。我们在用反射时经常用到它们。所以，对于现在象Spring、Hibernate这些框架经常通过反射创建实例，可能对maxPermSize要求就大了，缺省的64M很多时候是不够的，特别是对于应用服务器里的应用，象JSP就会产生和加载很多classes。不过，如果是它导致的OOM，一般会有类似 perm size提示。
但是，对于IBM的JVM，情况就完全不一样。它的默认GC策略并没有采取复制、分代。这个可以从GC日志分析出来。它不像Sun的JVM那样，有个单独的方法区，它的方法区就放在Java Heap里面。JVM规范里面并没有要求方法区的必须存放的位置，因为它只是一个JVM实现问题。
在IBM的JVM里面，这些对象一般分配在称为k-cluster和p-cluster里（cluster又是属于Heap），而后者一般是临时在heap里面申请。并且，这些cluster是不能GC，或是被移动重排的（Compact过程）。这就导致Java Heap里面就如同马蜂窝，但不同的蜂孔又不能合并，于是，当我们程序里面产生一个大对象，譬如2M的数组(数组必须分配在连续的内存区)时，就没有可分配空间了，于是就报告OOM。这些不能被移动的cluster就称为所谓的碎片。此时，JVM的Heap利用率可能不到50%。
当然，通过一定时期的GC日志，可以计算出cluster的合理大小（专门在Java Heap的底部），另外，还可以为这些大对象专门分配大对象区的（超过64k的对象）。
通过上面的理论介绍，我想大家一定知道了为什么IBM的JVM里面不推荐heap的最大最小值相同，因为这样碎片问题会非常严重：如果我们每次大对象申请内存时，heap都扩展5%，譬如50M，碎片问题很大程度上可以避开，程序性能也高些（寻找可用空隙和分配耗时，以及每次GC时间拉长）。
以上的具体阐述，请参考我在上文推荐的几个URL，另外再推荐三个宝贵的链接：
<a href="http://www-1.ibm.com/support/docview.wss?rs=180&amp;context=SSEQTP&amp;q1=fragmentation&amp;uid=swg21176363&amp;loc=en_US&amp;cs=utf-8&amp;lang=en" target="_blank"><a href="http://www-1.ibm.com/support/docview.wss?rs=180&amp;context=SSEQTP&amp;q1=fragmentation&amp;uid=swg21176363&amp;loc=en_US&amp;cs=utf-8&amp;lang=en">http://www-1.ibm.com/support/docview.wss?rs=180&amp;context=SSEQTP&amp;q1=fragmentation&amp;uid=swg21176363&amp;loc=en_US&amp;cs=utf-8&amp;lang=en</a></a>
<a href="http://www-900.ibm.com/cn/support/viewdoc/detail?DocId=2447476A10000" target="_blank"><a href="http://www-900.ibm.com/cn/support/viewdoc/detail?DocId=2447476A10000">http://www-900.ibm.com/cn/support/viewdoc/detail?DocId=2447476A10000</a></a>（IBM 技术支持告诉我的，太重要了！）
<a href="http://www-900.ibm.com/cn/support/viewdoc/detail?DocId=2847476B08000" target="_blank"><a href="http://www-900.ibm.com/cn/support/viewdoc/detail?DocId=2847476B08000">http://www-900.ibm.com/cn/support/viewdoc/detail?DocId=2847476B08000</a></a>
我想大家应该会问：我怎么能够肯定我的OOM问题是heap碎片造成的呢？下面的方法可以验证。
在OOM发生时，JVM会产生一个heapdump文件。然后用GarbageCollector分析出该OOM发生时刻，JVM去申请的空间，譬如约235k。此时，你再用HeapAnalyzer去分析此时的heap快照里面的gap size大小（空隙大小）和各自的可用数目。你会发现，大于235k的空隙个数为0。这就是碎片导致OOM的证据。
另外，有人会问：我怀疑我的OOM是因为程序内存泄漏造成的，怎么去验证？
你可以用HeapAnalyzer分析发生OOM时刻的heap快照，工具会罗列出哪些对象怀疑有内存泄漏，譬如Cache对象都非常大（但你可以确定它不是内存泄漏）。另外，分析这次宕机（从这次虚拟机启动到宕机这段时间）的heap走势，如果曲线明显是向上倾斜，也就是那种典型的内存泄漏图，就有可能是内存泄漏。当然，还必须结合heap快照。
内存持续上升在JVM开始一段时间很正常，因为JVM对第一次访问到的Class 对象，譬如一个典型的Web应用，就有jdk的class、Spring或Hibernate的class对象，它们都会被缓存下来 (ClassLoader原理)，一般均不会被GC。当大多数class对象缓存差不多（当然还可能有一些Singleton对象，不过不怎么占分量），JVM的Heap就平稳了，呈一水平波浪或锯齿线。
如果可以用JProfiler这类工具实时监控，就更容易确诊了。
经过一番周折，我们终于看到了一线希望了 。
在一定的准备后，我们决定对WAS进行性能调优了。WAS的调优参数，可以分为两个部分：JVM级别和WAS级别：
JVM：主要是GC和Heap。
WAS：Thread Pool，JDBC DataSource。
当然要调节，你需要明白你的目标是什么，调节依据是什么，怎么计算，绝对不是凭空想象的，譬如heap最小值1024M，日志证明，该参数非常不适合我们的环境。具体细节，留给后文吧。
战战兢兢地，中午12:00，我们给产品环境下的WAS调节参数、重启，同时优化了AIX的IO相关参数。
我试着设置了一下JVM的k-cluster和p-cluster。下午15:00左右，WAS挂了，AIX也挂了。这下麻烦可大了。我们都慌了，马山客户的老总就来电话了，一阵哗哗啦啦。实在无奈，让客户那边工作人员通知机房（服务器托管处）工作人员重启AIX。我也不得不强行更改刚才的参数，立即设为另外一个值。
其实，我把那个两个cluster值确实设置太大了，我把它们设置为推荐值的5倍，譬如p-cluster是65k×110%×5。另外一个愚蠢的设置就是把最小heap设置为2048M(AIX有4G内存)。
后来我恢复到约正常的值，也就是去掉那个cluster的5，另外分配了一个30%的大对象区（如果1000M的heap，就是700M＋300M）。
就这样，系统持续正常运行了三天，以前可是一天一down。当在三天后再次宕机时，我们都没有自信了 。不得不通过AIX的cron，继续每天深夜11点的WAS定时重启。
不过，那次宕机，包括以后的几次宕机，再也没有出现OOM错误了，但系统依然不稳定。虽然我可以说OOM问题解决了，但领导和客户需要的并不是这种结果。
其实，在这个时候，我们已经发现我们系统的四大问题：
1、WAS和JVM参数：OOM问题
2、AIX的IO和Paging Spacing不足：AIX日志后来显示错误
3、AIX的WAS分区空间不够：WAS的日志膨胀一周就把那个opt分区塞满了。
4、应用程序的JDBC连接池：我们20来个应用，一个20 connections，DB2数据库有时被撑死。
也就是说，我们最初在客户那儿部署时，用的默认值根本不行。而且，部署涉及多人，人员之间出现断层。如果我们只是按OOM，无疑是走入死胡同，必须全局考虑！
但是，项目组实力薄弱，公司范围内就没有对AIX精通的。不过项目组原来有一个搞银行系统，在AIX下开发，就他熟悉些。我当时对AIX也比较陌生，你们从Linux转到AIX，你就知道它有多别扭了。命令都自定一套（也许因为是Unix元老吧），那个shell也超级别扭，而且参考书特少。不是自诩，我两年前负责一个高负载的Linux服务器管理一年多，也是玩得很转的。
就这样，他负责AIX的相关问题，我负责WAS相关的。
但是，现实环境，已经不允许我们再试验下去了 。我们必须找到一条绝对可靠的对策！
这就是下文的CMS系统大迁移，服务器再次优化。
<strong>五、隔离CMS系统，服务器优化</strong>
从前面的介绍，大家应该记得，我们开始是固定CMS，分离其它应用，但遭遇失败。现在是反过来，干脆把CMS系统赶出WAS平台 。
说实话，项目经理做这个决定，我认为已经是鼓出很大勇气了 。
当时我们想在一个备用AIX机上安装CMS产品测试，但最后还是没有做成：
CMS这类文章发布系统很难安装，也不好测试，又没有liscence，而且还有一堆准备工作。绝对没有著名的openCMS安装那么简单，当然功能远远比它复杂。而且，我们当时也低估了后来的工作，总觉得问题好解决。
在很遥远的06年中期，CMS厂商在客户那边一台AIX的Tomcat上部署了一套CMS产品。但当时客户执意要求将其跑在WAS上，也就是现在的情况。最开始，客户还要求我们必须用WAS的集群(我们买的就是WAS的ND版)，无奈该CMS不支持。要是集群，又是死伤一遍。其实，现在想想，我们当时太被动，CMS这种东西，就供公司的几十个编辑用，一个普通Tomcat就完全够用。而且，把它和面向公网的Internet应用混在一起，完全没有必要。也许，被动是因为我的实力造成的。
我们决定背水一战时，已经做过周密的计划：某年某月某日晚上8:00……
CMS产品负责人现场切换
xx（我）负责WAS相关参数调整
yy负责AIX参数。
zz负责应用的测试
…..
总之，该行动涉及到客户方、产品提供商、公司高层、项目组。每个人都密切关注，不下20人。每个人都守在电脑前，随时听候调遣，当天晚上，我们都没有准备回家睡觉，大家齐心协力。
真没想到，整个式切换工作，一个小时就顺利完成 ！第二天，客户编辑打开浏览器，她们一定想不到昨晚大家准备经历一场厮杀….
系统持续平稳地运行了一周，然后是漫长的五一，我回湖北黄冈老家休息了八天。回来时，一切依旧。
当天晚上，我们这边主要做了两项工作：
1、JVM的Heap参数，共五个。
2、AIX的IO、Paging Space等共六个。
当然还有其他人的工作，譬如测试、监控。
还有一个非常重要的方面：JDBC连接池。我们原来是在每个Web应用里面独立设置，这样20来个应用就有几百个DB连接，一不小心DB就给撑死。现在统一交由WAS内置DataSource处理，总共连接不到30个。其实，我们项目开始部署时，就是这样做的，但当时WAS内置的DataSource对JTA(XA)支持有bug （这个和IBM技术支持确认过，但他们没有给予很好的解决方案），不过Datasource还是配好的。
但是这个工作已经属于WAS性能优化的主题了，而且优化值必须持续观察一段时间，通过专门的分析工具来计算。
优化本身，是一项很考验人的工作，我就简单说一下最实用方法吧，也许是专门针对IBM的产品。
1、清理归零WAS日志。然后启动WAS，生成日志（-verbose:gc默认是开的）
2、让WAS持续运行约两周，让JVM Heap占用曲线平稳一段时间即可（用IBM的Garbage Collector分析观察）。
3、在AIX的shell里，产生heapdump.phd文件，也就是heap快照。命令：kill -3 pid (pid是WAS的PID，通过ps –ef查看)，观察heap当时的碎片情况，是否需要单独分大对象区（一般不需要设置），特别是那个方法区Class对象大小（p-cluster参数）。
4、通过GC工具，观察GC平均时间、Heap实际占用情况。Note: GC是一个Stop The World过程，也就是说GC时系统对外不响应，多CPU也不例外。看你的应用实际需求了，GC持续时间和频率是矛盾的，另外还有性能考虑。一般Web应用，我想让GC持续时间（Pause time）调节到合理值就ok了，譬如0.2到0.4s。
5、根据3可以算出k-cluster值，它是工具推荐值的110%。
6、Heap的最小值是程序刚启动不久的占用值，譬如320M。切记：IBM JVM初始值太大非常不好。
7、Heap的最大值是系统平稳后的100/70。也就是说如果最大值是1000M，那么应该平稳时是700M，还有30%的空余。IBM的JVM默认情下的碎片问题，WAS控制台下操作Heap猛增这种bug，你不得不堤防。Heap最大值不设，AIX下的WAS肯定OOM。
当然啦，我没有考虑到大对象区的计算（虽然我们的应用设置了专门的大对象区），包括IBM JVM支持的分代GC、并行GC，Heap每次expand百分比等。那些情况我们一般不常用，譬如，你的AIX平台一般不是16CPU吧？
一口气写到现在，我忽然觉得该收尾了。下面就说说我对这类工作的整体看法吧。
1、尽量在项目测试和试运行的时候就进行压力、性能测试，当正式投入使用后，如果发现类似问题，代价非常大。躲过算你运气好，一般来说，可能你们系统没多少人用，也不是核心业务系统，譬如一般的电子政务。
2、千万不要低估了技术风险，用IBM的系列产品尤其要慎重，出问题一定不要忘了技术支持。而且，查资料时，建议用google English，因为象WebSphere这类问题，很少有中文资料。
3、程序部署环境建立时，就要考虑到日后的正式环境，譬如AIX的Paging Space、IO、分区大小，默认值往往是不行的，而且在产品环境下改这些值，往往非常难。
4、在项目开发初期，就考虑到日志的问题，因为它分散到每个方法内，必须慎重定义好debug、info、warn、error级别，不要随便忽视异常（catch里面不记录），到真正程序出问题时，它就是我们的最重要的依据之一。当然这主要是功能性问题诊断。另外对于高负载网站，日志文件往往非常大，各级别日志千万不要混在一起，否则找问题就很困难了。
5、怎么说呢，别死扣技术，以为什么都可以通过技术解决。你看我们最大的问题就是把CMS给移到Tomcat下。你要是问我，为什么CMS产品会导致系统这么多的问题，我也不知道，到那时候，我确实也不想深入。我只要知道，赶出你这个应用，我的系统就好控制多了。而且，那个CMS系统，在Tomcat下，就是跑得服服帖帖的，非常稳定。难度是可恶的WAS？不过那CMS，据IBM工程师，包括我们二次开发，都觉得够烂了，每个jsp页面都打开、关闭DB connection（7年前的jsp开发模式），还有那么严重的大对象问题。
好了，以上总结的几点可能也不充分、深入，但如果你仔细读我这篇文章，应该有自己的想法。毕竟，只有经过思考的东西，才会属于自己。
————————————————-
<strong>原文仅存的一点回复（google快照）</strong>
也许有人会说，我看完全文，发现你们遇到的问题还是很基础啊。现在想想，也确实如此。不过，当时确实没有方向。另外，一个人不太可能有这么全面的知识。其实，最难的，还是那个IBM JVM的heap碎片问题，关键是你想不到，网上又很难搜到资料。大家要是用它后，出现OOM问题，一定要前车之鉴啊！
newold 写道
我感觉WAS调优没那么难吧,你们应该在测试系统上做下压力测试,不应该在生产系统上这么折腾.解决这种问题,首先考虑把WAS升级到最新版,然后再考虑是不是程序问题.如果WAS是正版的,IBM应该会帮你们分析日志的,我觉得你解决问题的方式不大对，把事情搞复杂了
1、我接手这个活的时候，系统已经在生产环境几个月了，这是我无法选择的。当初准备切换到正式环境时，没有人对这个问题引起重视，特别是领导，而且我当时也不在该小组。再说，谁会怀疑那个大名鼎鼎的CMS产品，中国恐怕是top 1。
2、把WAS升级到最新版是我在接手这个活的时候已经做了（6.0.0.0到6.0.2.0），所以文中我没有提及。另外，在诊断过程中也准备升级一次（从6.0.2.0到6.0.2.17），但考虑生产环境，风险太大。不过，我当时确实也总怀疑是否是这个原因，仔细读了读官方的bugfix（估计有几千个）。
3、“IBM应该会帮你们分析日志的”，当然了。当我去向IBM技术支持咨询时，他们向我要日志。不过，他们和我对日志的分析结果是一样的，只是他们让我更肯定了某些东西。主要就是文中那几个截图中的工具。另外，就是SystemOut.log日志（看是否有线程挂起）。
不过，对于IBM的技术支持，有点让人失望的是，我们解决了OOM后，但我们的系统还是不稳定，再向他们咨询时，那个WAS技术支持告诉我，他只提供IBM的WAS相关技术支持，如果你们告诉我WebLogic AS下很正常，我无法给你提供帮助，我们对其它公司的类似产品不了解。另外，如果你们怀疑是我们的AIX产品有问题，请咨询我们的AIX技术支持（当前前提是我们的AIX还在服务期，对于那个WAS的售后服务，我们是用公司另外一个项目组的license，因为我们的已经过期了）。
也就是说，IBM无法给你提供全局的技术支持！
4、一开始，我们根本就没有方向，应用系统又多（两个WAS上共30多个应用）。你仔细读文章也会知道，我们的现象和推测往往都是矛盾的。
什么东西，都是解决了，经历过了，再回转头来说，好简单啊，当初我怎么没想到？就像中国股市，要是两年前我都能够预测了现在，我早就暴发了。
而且，直到现在，我都可以坦率得说，不把那个CMS移出WAS，无论我们怎么优化AIX、WAS和JVM，都很难解决问题！
分享到： <a href="&quot;分享到新浪微博&quot;"><img src="" alt=""></a> <a href="&quot;分享到腾讯微博&quot;"><img src="" alt=""></a></p>
<p><a href="http://zwchen.iteye.com/blog/552019" title="回母校，用iPhone拍的几张照片" target="_blank">回母校，用iPhone拍的几张照片</a> | <a href="http://zwchen.iteye.com/blog/551930" title="又半年，技术的探险(2009.7)" target="_blank">又半年，技术的探险(2009.7)</a></p>
<ul>
<li>2009-12-19 11:07</li>
<li>浏览 3762</li>
<li><a href="">评论(5)</a></li>
<li>分类:<a href="http://www.iteye.com/blogs/category/architecture" target="_blank">企业架构</a></li>
<li><a href="http://www.iteye.com/wiki/blog/551933" target="_blank">相关推荐</a></li>
</ul>
<h3 id="-">评论</h3>
<p><a href=""></a></p>
<p>5 楼 <a href="http://txyly998.iteye.com/" title="txyly998" target="_blank">txyly998</a> 2011-08-05  </p>
<p>呵呵 谢谢你，我google下吧。
我们的系统就是数据量太大才导致性能问题频发的，最大的局点有一千几百万用户、一千几百万订购关系等等。
4 楼 <a href="http://zwchen.iteye.com/" title="zwchen" target="_blank">zwchen</a> 2011-08-05  </p>
<p>txyly998 写道</p>
<p>现在就想问你一下，你说的按通用的JVM设置方式调整参数，这个有没有具体点的步骤呢？
google Tomcat的一般参数设置方法，或是选择WAS一般的调优参数。
像你们这种政务系统，一般是因为加个WAS，项目合同可以翻倍，和WAS无关。而且，你们的负载应该是超低的(员工用)。
对于非分布式应用（无RMI、EJB），WAS就是垃圾。
我隐约记得(好几年没关注了)，IBM的JVM的GC和sun的不一样，所以最大和最小的heap可能是设置不同的。</p>
<p>3 楼 <a href="http://txyly998.iteye.com/" title="txyly998" target="_blank">txyly998</a> 2011-08-04  </p>
<p>首先非常感谢你的回复！谢谢！
我们的这个系统在全国有13个局点在用，有些局点基本没怎么出现（在我接触这个1年多的时间内），有些局点则1个月出现一两次，项目组都没多少人懂这类的问题，可能也没有引起足够的重视，最近出现的局点越来越多，而我是在公司支持现网的，现网有问题直接联系我这边，所以想自己试着解决，目前感觉有点无从下手。
对于你说的两周重启一次，这个不行的，现场没事不能随便重启环境的，有特殊情况要重启环境必须要向客户申请。另外，出现问题后，watchdog会自动重启系统或者切换双机的。出现重启或者切换，现场的人就要我们分析原因的。
现在就想问你一下，你说的按通用的JVM设置方式调整参数，这个有没有具体点的步骤呢？
2 楼 <a href="http://zwchen.iteye.com/" title="zwchen" target="_blank">zwchen</a> 2011-08-04  </p>
<p>txyly998 写道</p>
<p>我们一个系统down掉了，生成了javacore和heapdump文件，有IBM Thread and Monitor Dump Analyzer for Java和IBM HeapAnalyzer工具，但是不知道怎么分析这俩文件，能否指教下呢？多谢！
操作系统AIX5.3
JDK 1.5
华为的uniportal平台（Tomcat和Jboss结合到一起的）
如果只是down一次，没有出现规律性的宕机，比如一周一次，暂时不用太考虑，因为你的数据积累不够。
你可以：
1、如果系统一个月宕一两次，你可以两周重启一下服务
2、按通用的JVM设置方式，调整参数
我不太建议直接去分析headdump等问题，它必须对各种JVM的GC有很深入的了解，我当时也是自学过一两个月，摸索着调成功的概率非常低。
如果你们的WAS还在技术支持范围内，咨询IBM北京。
自己去解决这种极其有难度的问题，从公司的角度是很不值的。</p>
<p>1 楼 <a href="http://txyly998.iteye.com/" title="txyly998" target="_blank">txyly998</a> 2011-08-02  </p>
<p>我们一个系统down掉了，生成了javacore和heapdump文件，有IBM Thread and Monitor Dump Analyzer for Java和IBM HeapAnalyzer工具，但是不知道怎么分析这俩文件，能否指教下呢？多谢！
操作系统AIX5.3
JDK 1.5
华为的uniportal平台（Tomcat和Jboss结合到一起的）</p>
<h3 id="-">发表评论</h3>
<p><a href="http://zwchen.iteye.com/login" target="_blank"><img src="" alt=""></a><a href="http://zwchen.iteye.com/login" target="_blank">您还没有登录,请您登录后再发表评论</a></p>
<p><a href="http://zwchen.iteye.com/" target="_blank"><img src="&quot;zwchen的博客: zwchen的博客&quot;" alt="zwchen的博客"></a></p>
<p>zwchen</p>
<ul>
<li>浏览: 411240 次</li>
<li>性别: <img src="&quot;男&quot;" alt="Icon_minigender_1"></li>
<li>来自: 成都</li>
<li><img src="" alt=""><h3 id="-http-zwchen-iteye-com-blog-user_visits-">最近访客 <a href="http://zwchen.iteye.com/blog/user_visits" target="_blank">更多访客&gt;&gt;</a></h3>
</li>
</ul>
<p><a href="http://dylinshi126.iteye.com/" target="_blank"><img src="&quot;dylinshi126的博客: &quot;" alt="dylinshi126的博客"></a></p>
<p><a href="http://dylinshi126.iteye.com/" title="dylinshi126" target="_blank">dylinshi126</a></p>
<p><a href="http://kglgmlldd.iteye.com/" target="_blank"><img src="&quot;kglgmlldd的博客: kglgmlldd&quot;" alt="kglgmlldd的博客"></a></p>
<p><a href="http://kglgmlldd.iteye.com/" title="kglgmlldd" target="_blank">kglgmlldd</a>
<a href="http://frfgzzq.iteye.com/" target="_blank"><img src="&quot;frfgzzq的博客: &quot;" alt="frfgzzq的博客"></a></p>
<p><a href="http://frfgzzq.iteye.com/" title="frfgzzq" target="_blank">frfgzzq</a></p>
<p><a href="http://sungang-1120.iteye.com/" target="_blank"><img src="&quot;sungang_1120的博客: 50&quot;" alt="sungang_1120的博客"></a></p>
<p><a href="http://sungang-1120.iteye.com/" title="sungang_1120" target="_blank">sungang_1120</a></p>
<h3 id="-">文章分类</h3>
<ul>
<li><a href="http://zwchen.iteye.com/" target="_blank">全部博客 (113)</a></li>
<li><a href="http://zwchen.iteye.com/category/9634" target="_blank">IT技术 (25)</a></li>
<li><a href="http://zwchen.iteye.com/category/107180" target="_blank">互联网和电子商务 (13)</a></li>
<li><a href="http://zwchen.iteye.com/category/24390" target="_blank">杂谈 (24)</a></li>
<li><a href="http://zwchen.iteye.com/category/39194" target="_blank">管理和商业 (23)</a></li>
<li><p><a href="http://zwchen.iteye.com/category/12717" target="_blank">我的生活 (28)</a></p>
<h3 id="-">社区版块</h3>
</li>
<li><p><a href="http://zwchen.iteye.com/blog/news" target="_blank">我的资讯</a> (0)</p>
</li>
<li><a href="http://zwchen.iteye.com/blog/post" target="_blank">我的论坛</a> (547)</li>
<li><a href="http://zwchen.iteye.com/blog/answered_problems" target="_blank">我的问答</a> (0)</li>
</ul>
<h3 id="-">存档分类</h3>
<ul>
<li><a href="http://zwchen.iteye.com/blog/monthblog/2013-07" target="_blank">2013-07</a> (1)</li>
<li><a href="http://zwchen.iteye.com/blog/monthblog/2012-11" target="_blank">2012-11</a> (1)</li>
<li><a href="http://zwchen.iteye.com/blog/monthblog/2012-10" target="_blank">2012-10</a> (1)</li>
<li><p><a href="http://zwchen.iteye.com/blog/monthblog_more" target="_blank">更多存档...</a></p>
<h3 id="-">评论排行榜</h3>
</li>
<li><p><a href="http://zwchen.iteye.com/blog/1912647" title="长江三峡游轮之旅(宜昌到重庆)" target="_blank">长江三峡游轮之旅(宜昌到重庆)</a></p>
</li>
<li><a href="http://zwchen.iteye.com/blog/1717111" title="四川燕子沟-雅加格-四姑娘山-巴郎山自驾游" target="_blank">四川燕子沟-雅加格-四姑娘山-巴郎山自驾 ...</a></li>
</ul>
<h3 id="-">最新评论</h3>
<ul>
<li><a href="http://yangfuchao418.iteye.com/" title="yangfuchao418" target="_blank">yangfuchao418</a>： zwchen 写道yangfuchao418 写道不错，只是那 ...
<a href="http://zwchen.iteye.com/blog/1912647#bc2320017" target="_blank">长江三峡游轮之旅(宜昌到重庆)</a></li>
<li><a href="http://zwchen.iteye.com/" title="zwchen" target="_blank">zwchen</a>： yangfuchao418 写道不错，只是那水怎么这么脏，总共 ...
<a href="http://zwchen.iteye.com/blog/1912647#bc2319980" target="_blank">长江三峡游轮之旅(宜昌到重庆)</a></li>
<li><a href="http://zwchen.iteye.com/" title="zwchen" target="_blank">zwchen</a>： yangfuchao418 写道不错，只是那水怎么这么脏，总共 ...
<a href="http://zwchen.iteye.com/blog/1912647#bc2319978" target="_blank">长江三峡游轮之旅(宜昌到重庆)</a></li>
<li><a href="http://yangfuchao418.iteye.com/" title="yangfuchao418" target="_blank">yangfuchao418</a>： 不错，只是那水怎么这么脏，总共花了多少银子？
<a href="http://zwchen.iteye.com/blog/1912647#bc2319921" target="_blank">长江三峡游轮之旅(宜昌到重庆)</a></li>
<li><a href="http://fqsheng.iteye.com/" title="shengfuqiang" target="_blank">shengfuqiang</a>： 每天读你的博客都有收获，都能给我带来不一样的心得。
<a href="http://zwchen.iteye.com/blog/1337350#bc2318900" target="_blank">我的2011</a>
声明：ITeye文章版权属于作者，受法律保护。没有作者书面许可不得转载。若作者同意转载，必须以超链接形式标明文章原始出处和作者。
© 2003-2012 ITeye.com. All rights reserved. [ 京ICP证110151号 京公网安备110105010620 ]
<img src="http://stat.iteye.com/?url=http%3A%2F%2Fzwchen.iteye.com%2Fblog%2F551933&amp;referrer=http%3A%2F%2Fzwchen.iteye.com%2Fcategory%2F9634&amp;user_id=" alt=""></li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--IBMWebSphereApplicationServer诊断和调优07年写的-原Java/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--IBMWebSphereApplicationServer诊断和调优07年写的-原Java" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/44/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/42/">42</a></li><li><a class="page-number" href="/page/43/">43</a></li><li><a class="page-number" href="/page/44/">44</a></li><li class="active"><li><span class="page-number current">45</span></li><li><a class="page-number" href="/page/46/">46</a></li><li><a class="page-number" href="/page/47/">47</a></li><li><a class="page-number" href="/page/48/">48</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/46/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 16:33:41</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
