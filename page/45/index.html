
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 45 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE学习总结思维方式和理念/">J2EE学习总结 思维方式和理念</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE学习总结思维方式和理念/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="j2ee-">J2EE学习总结 思维方式和理念</h1>
<p>J2EE学习总结:思维方式和理念
Webjx网页教学提示：不管怎么样我还是建议从基本的做起，学精J2SE，熟读它的源码，准确了解其设计理念，然后分头击破J2EE――一口吃不成一个胖子!不要贪多贪广!脚踏实地就可以了!</p>
<p>这篇文章写在我研究J2SE、J2EE近三年后。前3年我研究了J2SE的Swing、Applet、Net、RMI、Collections、IO、JNI……研究了J2EE的JDBC、Sevlet、JSP、JNDI…..不久我发现这些好像太浮浅了：首先，我发现自己知道的仅仅是java提供的大量的API，根本不能很好地使用它; 其次，我根本就没有学到任何有助于写程序的知识，此时我也只不过能写个几页的小程序。出于这个幼稚的想法我研究了JDK中Collections、Logger、IO…..的源代码，发现这个世界真的很神奇，竟然有如此的高手――利用java语言最最基本的语法，创造了这些优秀的Framework。</p>
<p>从此一发不可收拾，我继续研究了J2EE的部分，又发现这是一个我根本不能理解的方向(曾经有半年停滞不前)，为什么只有接口没有实现啊!后来由于一直使用Tomcat、Derby等软件突然发现：哦!原来J2EE仅仅是一个标准，只是一个架构。真正的实现是不同提供商提供的。</p>
<p>接着我研究了MOM4J、OpenJMS、Mocki、HSQLD……发现这些就是J2EE的实现啊!原来软件竟会如此复杂，竟会如此做….规范和实现又是如何成为一体的呢?通过上面的研究发现：原来J2EE后面竟然有太多太多理念、太多太多的相似!这些相似就是其背后的理念――设计模式!(很幸运，在我学java的时候，我一般学java的一个方向就会读一些关于设计模式的书!很幸运，到能领略一点的时候能真正知道这是为什么!)其实模式就是一种思维方式、就是一种理念……模式是要运用到程序中的，只有从真正的项目中才能领会模式的含义……
学得越多，发现懂得越少!在学习过程中发现一些很有用，很值得学习的开源项目，今天在此推荐给大家。</p>
<p>一、JavaServlet和JSP方向</p>
<p>很多人都是从Servlet和JSP步入J2EE的。它就是J2EE的表现层，用于向客户呈现服务器上的内容。J2EE很重要的方面。不罗嗦了!大家都知道的!下面就开始推荐吧!</p>
<ol>
<li>Jakarta Tomcat</li>
</ol>
<p>Apache基金会提供的免费的开源的Serlvet容器，它是的Jakarta项目中的一个核心项目，由Apache、Sun和其它一些公司(都是IT界的大鳄哦)及个人共同开发而成，全世界绝大部分Servlet和Jsp的容器都是使用它哦!由于Sun的参与和支持，最新的Servlet和Jsp规范总能在Tomcat中得到体现。</p>
<p>不过它是一个非常非常全的Serlvet容器，全部源码可能有4000页，对于初学者或者一般的老手可能还是比较大了!在你有能力时推荐研究!下载地址：<a href="http://jakarta.apache.org/tomcat/index.html" target="_blank">http://jakarta.apache.org/tomcat/index.html</a></p>
<p>下面推荐两个小一点的吧!</p>
<ol>
<li>Jetty</li>
</ol>
<p>Jetty是一个开放源码的HTTP服务器和Java serverlet容器。源代码只有1000页左右，很值得研究。有兴趣可以去<a href="http://jetty.mortbay.com/下载看看。我曾经翻了一下，只是目前没有时间。(都化在博客上了，等博客基本定型，且内容完整了，再干我热衷的事件吧!" target="_blank">http://jetty.mortbay.com/下载看看。我曾经翻了一下，只是目前没有时间。(都化在博客上了，等博客基本定型，且内容完整了，再干我热衷的事件吧!</a>)</p>
<ol>
<li>Jigsaw</li>
</ol>
<p>Jigsaw是W3C开发的HTTP，基于Java 的服务器，提供了未来 Web 技术发展的蓝图。W3C知道吧!(太有名气了，很多标准都是它制订的!有空经常去看看吧!)下载网址：<a href="http://www.w3.org/Jigsaw代码仅仅1000页左右。" target="_blank">http://www.w3.org/Jigsaw代码仅仅1000页左右。</a></p>
<ol>
<li>Jo!</li>
</ol>
<p>Jo!是一个纯Java的实现了Servlet API 2.2, JSP 1.1, 和HTTP/1.1的Web服务器。它的特性包括支持servlet tag,支持SSI，高级线程管理，虚拟主机，数据缓存，自动压缩text或HTML文件进行传输，国际化支持，自动重新加载Servlet、Jsp，自动重新加载web工程文件(WARs)，支持WAR热部署和一个Swing控制台。jo!可以被用做jboss和jakarta avalon-phoenix的web容器。下载地址<a href="http://www.tagtraum.com/" target="_blank">http://www.tagtraum.com/</a> 。我极力推荐大家在研究Tomcat之前研究该软件，主要是其比Tomcat小多了，且开发者提供比较全的手册。该方向研究这两个也就可以了!</p>
<p>二、JDBC方向</p>
<p>很多人都喜欢JDBC，数据库吗!很深奥的东西，一听就可以糊弄人。其实等你真正研究了数据库的实现后发现，接口其实真的太简单，太完美了!要想设计如此优秀的框架还是需要学习的。下面就推荐几个数据库的实现吧!</p>
<ol>
<li>Hypersonic SQL</li>
</ol>
<p>Hypersonic SQL开源数据库方向比较流行的纯Java开发的关系型数据库。好像不是JDBC兼容的，JDBC的很多高级的特性都没有支持，不过幸好支持ANSI-92 标准 SQL语法。我推荐它主要是它的代码比较少1600页左右，如此小的数据库值得研究，而且他占的空间很小，大约只有160K，拥有快速的数据库引擎。推荐你的第一个开源数据库。下载地址：<a href="http://hsqldb.sourceforge.net/。" target="_blank">http://hsqldb.sourceforge.net/。</a></p>
<ol>
<li>Mckoi DataBase</li>
</ol>
<p>McKoiDB 和Hypersonic SQL差不多，它是GPL 的license的纯Java开发的数据库。他的 JDBC Driver 是使用 JDBC version 3 的 Specifaction。 他也是遵循 SQL-92 的标准，也尽量支持新的 SQL 特色, 并且支持 Transaction 的功能。两个可以选一个吧!下载地址：<a href="http://mckoi.com/database/。" target="_blank">http://mckoi.com/database/。</a></p>
<ol>
<li>Apache Derby</li>
</ol>
<p>学Java的数据库我建议使用Apache Derby ，研究数据库想成为一个数据库的高手我建议你先研究Apache Derby。Apache Derby是一个高质量的、纯 Java开发的嵌入式关系数据库引擎，IBM® 将其捐献给Apache开放源码社区，同时IBM的产品CloudSpace是它对应的产品。Derby是基于文件系统，具有高度的可移植性，并且是轻量级的，这使得它非常便于发布。主要是没有商业用户的很好的界面，没有其太多的功能。不过对于我们使用数据库、研究数据库还是极其有用的。对于中小型的企业说老实话你也不要用什么Oracle、SqlServer了，用Derby就可以了，何况是开源的呢!只要能发挥其长处也不容易啊!下载地址：<a href="http://incubator.apache.org/derby。" target="_blank">http://incubator.apache.org/derby。</a></p>
<p>不过在没有足够的能力前，不要试图读懂它!注释和源代码15000页左右，我一年的阅读量!能读下来并且能真正领会它，绝对高手!你能读完Derby的源代码只有两种可能：1.你成为顶尖的高手――至少是数据库这部分; 2.你疯了。选择吧!!!!作为我自己我先选择Hypersonic SQL这样的数据库先研究，能过这一关，再继续研究Derby!不就是一年的阅读量吗!我可以化3年去研究如何做一个数据库其实还是很值得的!有的人搞IT一辈子自己什么都没有做，也根本没有研究别人的东西!</p>
<p>作为一个IT落后于别国若干年的、从事IT的下游产业“外包”的国家的IT从业人员，我认为还是先研究别人的优秀的东西比较好!可以先研究别人的，然后消化，学为己用!一心闭门造车实在遗憾!</p>
<p>三、JMS方向</p>
<p>JMS可能对大家来说是一个比较陌生的方向!其实JMS是一个比较容易理解，容易上手的方向。主要是Java消息服务，API也是相当简单的。不过在企业应用中相当广泛。下面就介绍几个吧!</p>
<ol>
<li>MOM4J</li>
</ol>
<p>MOM4J是一个完全实现JMS1.1规范的消息中间件并且向下兼容JMS1.0与1.02。它提供了自己的消息处理存储使它独立于关系数据与语言，它的客户端可以用任何语言开发。它可以算是一个小麻雀，很全实现也比较简单!它包含一个命名服务器，一个消息服务器，同时提供自己的持续层。设计也相当的巧妙，完全利用操作系统中文件系统设计的观念。代码也很少，250页左右，最近我在写该实现的源代码阅读方面的书，希望明年年中能与大家见面!下载地址：<a href="http://mom4j.sourceforge.net/index.html。" target="_blank">http://mom4j.sourceforge.net/index.html。</a></p>
<ol>
<li>OpenJMS</li>
</ol>
<p>OpenJMS是一个开源的Java Message Service API 1.0.2 规范的实现，它包含有以下特性：</p>
<ol>
<li><p>它既支持点到点(point-to-point)(PTP)模型和发布/订阅(Pub/Sub)模型。</p>
</li>
<li><p>支持同步与异步消息发送 。</p>
</li>
<li><p>JDBC持久性管理使用数据库表来存储消息 。</p>
</li>
<li><p>可视化管理界面。</p>
</li>
<li><p>Applet支持。</p>
</li>
<li><p>能够与Jakarta Tomcat这样的Servlet容器结合。</p>
</li>
<li><p>支持RMI, TCP, HTTP 与SSL协议。</p>
</li>
<li><p>客户端验证 。</p>
</li>
<li><p>提供可靠消息传输、事务和消息过滤。</p>
</li>
</ol>
<p>很好的JMS方向的开源项目!我目前也在研究它的源代码!学习它可以顺便研究JNDI的实现、以及网络通信的细节。这是我JMS方向研究的第二个开源项目。代码量1600页左右吧!下载地址：<a href="http://openjms.sourceforge.net/index.html" target="_blank">http://openjms.sourceforge.net/index.html</a></p>
<ol>
<li>ActiveMQ</li>
</ol>
<p>ActiveMQ是一个开放源码基于Apache 2.0 licenced 发布并实现了JMS 1.1。它能够与Geronimo，轻量级容器和任Java应用程序无缝的给合。主要是Apache的可以任意的使用和发布哦!个人比较喜欢Apache的源代码!下载地址：<a href="http://activemq.codehaus.org/" target="_blank">http://activemq.codehaus.org/</a></p>
<ol>
<li>JORAM</li>
</ol>
<p>JORAM一个类似于openJMS分布在ObjectWeb之下的JMS消息中间件。ObjectWeb的产品也是非常值得研究的!下面我还会给大家另外一个ObjectWeb的产品。下载地址：<a href="http://joram.objectweb.org/" target="_blank">http://joram.objectweb.org/</a></p>
<p>我个人推荐：OpenJMS和ActiveMQ!</p>
<p>四、EJB方向</p>
<p>EJB一个比较“高级”的方向。Sun公司曾经以此在分布式计算领域重拳出击。不过自从出现了Spring、Hibernation……后似乎没落了!这个方向单独开源的也比较少，主要EJB是和JNDI、JDBC、JMS、JTS、JTA结合在一起的是以很少有单独的。下面推荐两个不过好像也要下载其它类库。</p>
<ol>
<li>EasyBeans</li>
</ol>
<p>ObjectWeb的一个新的项目，一个轻量级的EJB3容器，虽然还没有正式发布，但是已经可以从它们的subversion仓库中检出代码。代码量比较小600页左右，熟读它可以对网络编程、架构、RMI、容器的状态设计比较了解了!即学会EJB又能学习其它设计方法何乐而不为哦!下载地址：<a href="http://easybeans.objectweb.org/" target="_blank">http://easybeans.objectweb.org/</a></p>
<ol>
<li>OpenEJB</li>
</ol>
<p>OpenEJB是一个预生成的、自包含的、可移植的EJB容器系统，可以被插入到任意的服务器环境，包括应用程序服务器，Web服务器，J2EE平台， CORBA ORB和数据库等等。OpenEJB 被用于 Apple的WebObjects。听起来很好，我目前没有研究过。不知道我就不推荐了。下载地址：<a href="http://www.openejb.org/" target="_blank">http://www.openejb.org/</a></p>
<p>五、J2EE容器</p>
<p>上面谈了这么多，都是J2EE的各个方向的。其实J2EE是一个规范，J2EE的产品一般要求专业提供商必须提供它们的实现。这些实现本身就是J2EE容器。市场上流行的J2EE容器很多，在开源领域流行的只有很少，很少。其中最著名的是JBoss。</p>
<ol>
<li>JBoss</li>
</ol>
<p>在J2EE应用服务器领域，Jboss是发展最为迅速的应用服务器。由于Jboss遵循商业友好的LGPL授权分发，并且由开源社区开发，这使得Jboss广为流行。另外，Jboss应用服务器还具有许多优秀的特质。</p>
<p>其一，它将具有革命性的JMX微内核服务作为其总线结构;</p>
<p>其二，它本身就是面向服务的架构(Service-Oriented Architecture，SOA);</p>
<p>其三，它还具有统一的类装载器，从而能够实现应用的热部署和热卸载能力。因此，它是高度模块化的和松耦合的。Jboss用户的积极反馈告诉我们，Jboss应用服务器是健壮的、高质量的，而且还具有良好的性能。为满足企业级市场日益增长的需求，Jboss公司从2003年开始就推出了24/*7、专业级产品支持服务。同时，为拓展Jboss的企业级市场，Jboss公司还签订了许多渠道合作伙伴。比如，Jboss公司同HP、Novell、Computer Associates、Unisys等都是合作伙伴。</p>
<p>在2004年6月，Jboss公司宣布，Jboss应用服务器通过了Sun公司的J2EE认证。这是Jboss应用服务器发展史上至今为止最重要的里程碑。与此同时，Jboss一直在紧跟最新的J2EE规范，而且在某些技术领域引领J2EE规范的开发。因此，无论在商业领域，还是在开源社区，Jboss成为了第一个通过J2EE 1.4认证的主流应用服务器。现在，Jboss应用服务器已经真正发展成具有企业强度(即，支持关键级任务的应用)的应用服务器。</p>
<p>Jboss 4.0作为J2EE认证的重要成果之一，已经于2004年9月顺利发布了。同时，Jboss 4.0还提供了Jboss AOP(Aspect-Oriented Programming，面向方面编程)组件。近来，AOP吸引了大量开发者的关注。它提供的新的编程模式使得用户能够将方面(比如，事务)从底层业务逻辑中分离出来，从而能够缩短软件开发周期。用户能够单独使用Jboss AOP，即能够在Jboss应用服务器外部使用它。或者，用户也可以在应用服务器环境中使用它。Jboss AOP 1.0已经在2004年10月发布了。 很有名吧!可以下载一个用一下，下载地址：<a href="http://www.jboss.org/" target="_blank">http://www.jboss.org/</a></p>
<p>关于JBoss的使用资料也非常多，甚至比商业软件的还多。有机会研究吧!</p>
<ol>
<li>JOnAS</li>
</ol>
<p>JOnAS是一个开放源代码的J2EE实现，在ObjectWeb协会中开发。整合了Tomcat或Jetty成为它的Web容器，以确保符合Servlet 2.3和JSP 1.2规范。JOnAS服务器依赖或实现以下的Java API：JCA、JDBC、JTA 、JMS、JMX、JNDI、JAAS、JavaMail 。下载地址：<a href="http://jonas.objectweb.org/" target="_blank">http://jonas.objectweb.org/</a>
3.Apache Geronimo</p>
<p>Apache Geronimo 是 Apache 软件基金会的开放源码J2EE服务器，它集成了众多先进技术和设计理念。 这些技术和理念大多源自独立的项目，配置和部署模型也各不相同。 Geronimo能将这些项目和方法的配置及部署完全整合到一个统一、易用的模型中。作为符合J2EE标准的服务器，Geronimo提供了丰富的功能集和无责任 Apache 许可，具备“立即部署”式J2EE 1.4容器的各种优点，其中包括：</p>
<ol>
<li><p>符合J2EE1.4标准的服务器 。</p>
</li>
<li><p>预集成的开放源码项目 。</p>
</li>
<li><p>统一的集成模型 。</p>
</li>
<li><p>可伸缩性、可管理性和配置管理功能。</p>
</li>
</ol>
<p>我一直比较推荐Apache的产品。主要是可以任意自由地使用。下载地址：<a href="http://incubator.apache.org/projects/geronimo/" target="_blank">http://incubator.apache.org/projects/geronimo/</a></p>
<p>六、其它</p>
<p>讲了这么多大家可能很厌烦了!是不是很多很多啊!其实不然，我们不会的太多太多了!不会的太多太多了。不管你是不是J2EE高手，还是J2SE高手，有些东西你要绝对很精明的。例如：1.Java的Collections Framework就是java的数据结构了，不仅要吃透它，还要能按照需要扩展它，利用其思想创建一个自己的数据结构。2.网络编程肯定要会吧，现在以及以后很多程序都是不在同一台机器上的，不会网络怎么行哦!3.IO肯定要会的吧!你的程序难道不用输入输出数据啊!整个IO包加NIO也有600多页的源代码哦!4.JDBC你要会吧!数据库都不会，在你的企业应用中你的数据又保存到哪里啊!文件中――太落后了吧!典型的没有学过J2EE。尽管数据库背后也是采用文件保存的。5.Serverlet、JSp你要是做网页做网站，肯定要做到。问你一个简单的问题，网页中如何实现分页啊!有具体方法的就在本文章后发言吧!6. Ant要会吧!java语言中发布的工具，类似与c中的make工具。7.JUnit用过吧!单元测试软件。你不要啊!你的软件就没有bug!你牛!(建议大家研究研究其源代码，很有用的框架，包含大量的设计模式，源代码不到100页!看了只能感叹――高手就是高手)细心的朋友可以看到在你使用的很多IDE工具中都有JUnit哦!就是它。</p>
<p>一切的一切才刚刚开始!有兴趣，有需要你可以研究数据库连接池的框架，如：C3P0、Jakarta DBCP、 DBPool….可以研究J2EE框架Spring……. Web框架Struts……持久层框架Hibernate…..甚至开发工具Eclipse…..Sun领导的点对点通信的JXTA…..报表工具JFreeChart、JasperReports…..分布式网络编程的CORBA、网络通信的JGROUPS、XML解析的xerces…..(在不经意间开源已经步入你的电脑，不信啊!你JDK的安装目录jdk1.6.0 src com sun org apache就是Xerces，一个XML解析的著名的开源 项目)</p>
<p>不管怎么样我还是建议从基本的做起，学精J2SE，熟读它的源码，准确了解其设计理念，然后分头击破J2EE――一口吃不成一个胖子!不要贪多贪广!脚踏实地就可以了!</p>
<hr>
<p><strong><a href="http://www.webjx.com/exam/java-15508.html" target="_blank">http://www.webjx.com/exam/java-15508.html</a></strong></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_总结类/">Java_总结类</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_总结类/" class="label label-success">Java_总结类</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE学习总结思维方式和理念/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_总结类--J2EE学习总结思维方式和理念" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE--Java字节码工具ASM在WebService开发中的应用/">Java字节码工具ASM在Web Service开发中的应用</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE--Java字节码工具ASM在WebService开发中的应用/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-asm-web-service-">Java字节码工具ASM在Web Service开发中的应用</h1>
<p>在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href="http://static.oschina.net/uploads/img/201109/26204312_QD65.jpg" target="_blank"><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。
来源： <a href="[http://www.oschina.net/question/129540_28430](http://www.oschina.net/question/129540_28430)">[http://www.oschina.net/question/129540_28430](http://www.oschina.net/question/129540_28430)</a> </p>
<p>在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE--Java字节码工具ASM在WebService开发中的应用/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE--Java字节码工具ASM在WebService开发中的应用" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--GarbageFirst介绍/">Garbage First介绍</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--GarbageFirst介绍/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="garbage-first-">Garbage First介绍</h1>
<h1 id="-bluedavy-blog-http-www-blogjava-net-bluedavy-"><a href="http://www.blogjava.net/BlueDavy/" target="_blank">BlueDavy之技术Blog</a></h1>
<p>理论不懂就实践，实践不会就学理论！</p>
<h2 id="-garbage-first-http-www-blogjava-net-bluedavy-archive-2009-03-11-259230-html-"><a href="http://www.blogjava.net/BlueDavy/archive/2009/03/11/259230.html" target="_blank">Garbage First介绍</a></h2>
<p>本文摘自《构建高性能的大型分布式Java应用》一书，Garbage First简称G1，它的目标是要做到尽量减少GC所导致的应用暂停的时间，让应用达到准实时的效果，同时保持JVM堆空间的利用率，将作为CMS的替代者在JDK 7中闪亮登场，其最大的特色在于允许指定在某个时间段内GC所导致的应用暂停的时间最大为多少，例如在100秒内最多允许GC导致的应用暂停时间为1秒，这个特性对于准实时响应的系统而言非常的吸引人，这样就再也不用担心系统突然会暂停个两三秒了。</p>
<p>G1要做到这样的效果，也是有前提的，一方面是硬件环境的要求，必须是多核的CPU以及较大的内存（从规范来看，512M以上就满足条件了），另外一方面是需要接受吞吐量的稍微降低，对于实时性要求高的系统而言，这点应该是可以接受的。</p>
<p>为了能够达到这样的效果，G1在原有的各种GC策略上进行了吸收和改进，在G1中可以看到增量收集器和CMS的影子，但它不仅仅是吸收原有GC策略的优点，并在此基础上做出了很多的改进，简单来说，G1吸收了增量GC以及CMS的精髓，将整个jvm Heap划分为多个固定大小的region，扫描时采用Snapshot-at-the-beginning的并发marking算法（具体在后面内容详细解释）对整个heap中的region进行mark，回收时根据region中活跃对象的bytes进行排序，首先回收活跃对象bytes小以及回收耗时短（预估出来的时间）的region，回收的方法为将此region中的活跃对象复制到另外的region中，根据指定的GC所能占用的时间来估算能回收多少region，这点和以前版本的Full GC时得处理整个heap非常不同，这样就做到了能够尽量短时间的暂停应用，又能回收内存，由于这种策略在回收时首先回收的是垃圾对象所占空间最多的region，因此称为Garbage First。</p>
<p>看完上面对于G1策略的简短描述，并不能清楚的掌握G1，在继续详细看G1的步骤之前，必须先明白G1对于JVM Heap的改造，这些对于习惯了划分为new generation、old generation的大家来说都有不少的新意。</p>
<p>G1将Heap划分为多个固定大小的region，这也是G1能够实现控制GC导致的应用暂停时间的前提，region之间的对象引用通过remembered set来维护，每个region都有一个remembered set，remembered set中包含了引用当前region中对象的region的对象的pointer，由于同时应用也会造成这些region中对象的引用关系不断的发生改变，G1采用了Card Table来用于应用通知region修改remembered sets，Card Table由多个512字节的Card构成，这些Card在Card Table中以1个字节来标识，每个应用的线程都有一个关联的remembered set log，用于缓存和顺序化线程运行时造成的对于card的修改，另外，还有一个全局的filled RS buffers，当应用线程执行时修改了card后，如果造成的改变仅为同一region中的对象之间的关联，则不记录remembered set log，如造成的改变为跨region中的对象的关联，则记录到线程的remembered set log，如线程的remembered set log满了，则放入全局的filled RS buffers中，线程自身则重新创建一个新的remembered set log，remembered set本身也是一个由一堆cards构成的哈希表。</p>
<p>尽管G1将Heap划分为了多个region，但其默认采用的仍然是分代的方式，只是仅简单的划分为了年轻代（young）和非年轻代，这也是由于G1仍然坚信大多数新创建的对象都是不需要长的生命周期的，对于应用新创建的对象，G1将其放入标识为young的region中，对于这些region，并不记录remembered set logs，扫描时只需扫描活跃的对象，G1在分代的方式上还可更细的划分为：fully young或partially young，fully young方式暂停的时候仅处理young regions，partially同样处理所有的young regions，但它还会根据允许的GC的暂停时间来决定是否要加入其他的非young regions，G1是运行到fully-young方式还是partially young方式，外部是不能决定的，在启动时，G1采用的为fully-young方式，当G1完成一次Concurrent Marking后，则切换为partially young方式，随后G1跟踪每次回收的效率，如果回收fully-young中的regions已经可以满足内存需要的话，那么就切换回fully young方式，但当heap size的大小接近满的情况下，G1会切换到partially young方式，以保证能提供足够的内存空间给应用使用。</p>
<p>除了分代方式的划分外，G1还支持另外一种pure G1的方式，也就是不进行代的划分，pure方式和分代方式的具体不同在下面的具体执行步骤中进行描述。</p>
<p>掌握了这些概念后，继续来看G1的具体执行步骤：</p>
<ol>
<li>Initial Marking</li>
</ol>
<p>G1对于每个region都保存了两个标识用的bitmap，一个为previous marking bitmap，一个为next marking bitmap，bitmap中包含了一个bit的地址信息来指向对象的起始点。</p>
<p>开始Initial Marking之前，首先并发的清空next marking bitmap，然后停止所有应用线程，并扫描标识出每个region中root可直接访问到的对象，将region中top的值放入next top at mark start（TAMS）中，之后恢复所有应用线程。</p>
<p>触发这个步骤执行的条件为：</p>
<p>l  G1定义了一个JVM Heap大小的百分比的阀值，称为h，另外还有一个H，H的值为(1-h)/<em>Heap Size，目前这个h的值是固定的，后续G1也许会将其改为动态的，根据jvm的运行情况来动态的调整，在分代方式下，G1还定义了一个u以及soft limit，soft limit的值为H-u/</em>Heap Size，当Heap中使用的内存超过了soft limit值时，就会在一次clean up执行完毕后在应用允许的GC暂停时间范围内尽快的执行此步骤；</p>
<p>l  在pure方式下，G1将marking与clean up组成一个环，以便clean up能充分的使用marking的信息，当clean up开始回收时，首先回收能够带来最多内存空间的regions，当经过多次的clean up，回收到没多少空间的regions时，G1重新初始化一个新的marking与clean up构成的环。</p>
<ol>
<li>Concurrent Marking</li>
</ol>
<p>按照之前Initial Marking扫描到的对象进行遍历，以识别这些对象的下层对象的活跃状态，对于在此期间应用线程并发修改的对象的以来关系则记录到remembered set logs中，新创建的对象则放入比top值更高的地址区间中，这些新创建的对象默认状态即为活跃的，同时修改top值。</p>
<ol>
<li>Final Marking Pause</li>
</ol>
<p>当应用线程的remembered set logs未满时，是不会放入filled RS buffers中的，在这样的情况下，这些remebered set logs中记录的card的修改就会被更新了，因此需要这一步，这一步要做的就是把应用线程中存在的remembered set logs的内容进行处理，并相应的修改remembered sets，这一步需要暂停应用，并行的运行。</p>
<ol>
<li>Live Data Counting and Cleanup</li>
</ol>
<p>值得注意的是，在G1中，并不是说Final Marking Pause执行完了，就肯定执行Cleanup这步的，由于这步需要暂停应用，G1为了能够达到准实时的要求，需要根据用户指定的最大的GC造成的暂停时间来合理的规划什么时候执行Cleanup，另外还有几种情况也是会触发这个步骤的执行的：</p>
<p>l  G1采用的是复制方法来进行收集，必须保证每次的”to space”的空间都是够的，因此G1采取的策略是当已经使用的内存空间达到了H时，就执行Cleanup这个步骤；</p>
<p>l  对于full-young和partially-young的分代模式的G1而言，则还有情况会触发Cleanup的执行，full-young模式下，G1根据应用可接受的暂停时间、回收young regions需要消耗的时间来估算出一个yound regions的数量值，当JVM中分配对象的young regions的数量达到此值时，Cleanup就会执行；partially-young模式下，则会尽量频繁的在应用可接受的暂停时间范围内执行Cleanup，并最大限度的去执行non-young regions的Cleanup。</p>
<p>这一步中GC线程并行的扫描所有region，计算每个region中低于next TAMS值中marked data的大小，然后根据应用所期望的GC的短延时以及G1对于region回收所需的耗时的预估，排序region，将其中活跃的对象复制到其他region中。</p>
<p>G1为了能够尽量的做到准实时的响应，例如估算暂停时间的算法、对于经常被引用的对象的特殊处理等，G1为了能够让GC既能够充分的回收内存，又能够尽量少的导致应用的暂停，可谓费尽心思，从G1的论文中的性能评测来看效果也是不错的，不过如果G1能允许开发人员在编写代码时指定哪些对象是不用mark的就更完美了，这对于有巨大缓存的应用而言，会有很大的帮助，G1将随JDK 6 Update 14 beta发布。</p>
<p>posted on 2009-03-11 22:18 <a href="http://www.blogjava.net/BlueDavy/" target="_blank">BlueDavy</a> 阅读(5465) <a href="">评论(3)</a>  <a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx?postid=259230" target="_blank">编辑</a>  <a href="http://www.blogjava.net/BlueDavy/AddToFavorite.aspx?id=259230" target="_blank">收藏</a> 所属分类: <a href="http://www.blogjava.net/BlueDavy/category/1366.html" target="_blank">Java</a></p>
<p> <img src="" alt=""></p>
<p><a href=""></a> <a href=""></a></p>
<p>[</p>
<h3 id="-">评论</h3>
<p>]()</p>
<h3 id="-permalink-re-garbage-first-re-garbage-first-2009-03-14-13-37-phpxer-http-www-blogjava-net-phpxer-"><a href=""></a><a href="&quot;permalink: re: Garbage First介绍&quot;">/#</a> <a href=""></a>re: Garbage First介绍  2009-03-14 13:37  <a href="http://www.blogjava.net/phpxer/">phpxer</a></h3>
<p>Mark  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=phpxer" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-garbage-first-re-garbage-first-2009-04-01-12-14-http-www-owner0571-com-about-asp-c-cs-"><a href="&quot;permalink: re: Garbage First介绍&quot;">/#</a> <a href=""></a>re: Garbage First介绍  2009-04-01 12:14  <a href="http://www.owner0571.com/about.asp?c=CS">中国兄弟连</a></h3>
<p>给你踩踩哈!  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=%e4%b8%ad%e5%9b%bd%e5%85%84%e5%bc%9f%e8%bf%9e" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-garbage-first-re-garbage-first-2013-03-04-23-52-http-www-helemao-com-"><a href="&quot;permalink: re: Garbage First介绍&quot;">/#</a> <a href=""></a>re: Garbage First介绍<a href=""></a>  2013-03-04 23:52  <a href="http://www.helemao.com/" target="_blank">呵乐猫</a></h3>
<p>学习了。  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=%e5%91%b5%e4%b9%90%e7%8c%ab" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a>
<a href="http://www.blogjava.net/RequireRegister.aspx" target="_blank">新用户注册</a>  <a href="">刷新评论列表</a>  </p>
<p><a href=""></a> <a href="http://www.aliyun.com/cps/channel?channel_id=1306&amp;user=0&amp;lv=1">推荐购买云服务器（15%返利+最高千元奖金）</a>   <a href="http://www.cnblogs.com/" target="_blank">博客园</a>  <a href="http://q.cnblogs.com/" target="_blank">博问</a>  <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>  <a href="http://job.cnblogs.com/cate-java_programmer/" target="_blank">Java程序员招聘</a> 标题  请输入标题 姓名  请输入你的姓名 主页 请输入验证码 验证码 /*  <img src="http://www.blogjava.net/Modules/CaptchaImage/JpegImage.aspx?cacheid=20130727130737" alt=""> 内容(请不要发表任何与政治相关的内容) 请输入评论内容 Remember Me?   <a href="http://www.blogjava.net/login.aspx?ReturnURL=http://www.blogjava.net/BlueDavy/archive/2009/03/11/259230.html&amp;SourceURL=/BlueDavy/archive/2009/03/11/259230.html" target="_blank">登录</a>       [使用Ctrl+Enter键可以直接提交]      网站导航:</p>
<p><a href="http://www.cnblogs.com/" title="程序员的网上家园" target="_blank">博客园</a>   <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>   <a href="http://kb.cnblogs.com/" target="_blank">知识库</a>   <a href="http://www.cppblog.com/" target="_blank">C++博客</a>   <a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a>   <a href="http://www.blogjava.net/BlueDavy/archive/2009/03/11/259230.html?opt=admin" target="_blank">管理</a> 相关文章:</p>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/05/25/321796.html" target="_blank">关于《分布式Java应用：基础与实践》一书</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/04/30/319794.html" target="_blank">杭州程序员圆桌交流第二期视频</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03/22/316148.html" target="_blank">第一次杭州程序员交流会总结</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03/19/315989.html" target="_blank">杭州程序员圆桌交流第一期–并发编程PPT</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/12/03/304597.html" target="_blank">GCLogViewer(tool to visualize gc log) V0.2 Release</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11/25/303662.html" target="_blank">Simple Scala actor Vs java Thread Vs Kilim Test</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11/06/301448.html" target="_blank">《构建高性能的大型分布式Java应用》目录&amp;试读样章</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/10/297661.html" target="_blank">动态跟踪Java代码的执行状况工具--BTrace</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/09/297562.html" target="_blank">GC策略的调优</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/08/06/290003.html" target="_blank">Hessian 3.2.0的两个bug</a><br>Powered by: <a href="http://www.blogjava.net/" target="_blank">BlogJava</a> Copyright © BlueDavy<h3 id="-">公告</h3>
</li>
</ul>
<p><a href="http://www.douban.com/subject/3843896/" target="_blank"><img src="" alt=""></a> 
<a href="http://china.osgiusers.org/" target="_blank"><img src="" alt=""></a>
<a href="http://feed.feedsky.com/bluedavy" title="BlogJava-BlueDavy之技术Blog" target="_blank"><img src="" alt=""></a> <a href="http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="feedsky"></a>
<a href="http://www.zhuaxia.com/add_channel.php?url=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="抓虾"></a>
<a href="http://fusion.google.com/add?feedurl=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="google reader"></a>
<a href="http://www.xianguo.com/subscribe.php?url=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="鲜果"></a></p>
<h3 id="-">导航</h3>
<ul>
<li><a href="http://www.blogjava.net/" target="_blank">BlogJava</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/" target="_blank">首页</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx?opt=1" target="_blank">新随笔</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/contact.aspx?id=1" target="_blank">联系</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/rss" target="_blank">聚合</a><a href="http://www.blogjava.net/BlueDavy/rss" target="_blank"><img src="" alt=""></a></li>
<li><a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx" target="_blank">管理</a>
<a href="&quot;转到上一个月&quot;">&lt;</a>2009年3月<a href="&quot;转到下一个月&quot;">&gt;</a>日一二三四五六222324252627281234<a href="http://www.blogjava.net/BlueDavy/archive/2009/03/05.html" target="_blank">5</a><a href="http://www.blogjava.net/BlueDavy/archive/2009/03/06.html" target="_blank">6</a>78910<a href="http://www.blogjava.net/BlueDavy/archive/2009/03/11.html" target="_blank">11</a><a href="http://www.blogjava.net/BlueDavy/archive/2009/03/12.html" target="_blank">12</a>1314151617181920212223242526<a href="http://www.blogjava.net/BlueDavy/archive/2009/03/27.html" target="_blank">27</a>282930311234</li>
</ul>
<h3 id="-">统计</h3>
<ul>
<li>随笔 - 294</li>
<li>文章 - 2</li>
<li>评论 - 2068</li>
<li>引用 - 1</li>
</ul>
<h3 id="-">随笔分类</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/category/10609.html" target="_blank">@RIAWork(10)</a> <a href="http://www.blogjava.net/BlueDavy/category/10609.html/rss" title="Subscribe to @RIAWork(10)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/32839.html" target="_blank">Internet(20)</a> <a href="http://www.blogjava.net/BlueDavy/category/32839.html/rss" title="Subscribe to Internet(20)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1366.html" target="_blank">Java(82)</a> <a href="http://www.blogjava.net/BlueDavy/category/1366.html/rss" title="Subscribe to Java(82)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/8127.html" target="_blank">Javascript(7)</a> <a href="http://www.blogjava.net/BlueDavy/category/8127.html/rss" title="Subscribe to Javascript(7)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/18356.html" target="_blank">OSGi、SOA、SCA(81)</a> <a href="http://www.blogjava.net/BlueDavy/category/18356.html/rss" title="Subscribe to OSGi、SOA、SCA(81)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1514.html" target="_blank">Plugin Architecture(10)</a> <a href="http://www.blogjava.net/BlueDavy/category/1514.html/rss" title="Subscribe to Plugin Architecture(10)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1513.html" target="_blank">Workflow(4)</a> <a href="http://www.blogjava.net/BlueDavy/category/1513.html/rss" title="Subscribe to Workflow(4)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/11559.html" target="_blank">业界随想(28)</a> <a href="http://www.blogjava.net/BlueDavy/category/11559.html/rss" title="Subscribe to 业界随想(28)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/22527.html" target="_blank">数据集成(8)</a> <a href="http://www.blogjava.net/BlueDavy/category/22527.html/rss" title="Subscribe to 数据集成(8)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1911.html" target="_blank">系统设计(38)</a> <a href="http://www.blogjava.net/BlueDavy/category/1911.html/rss" title="Subscribe to 系统设计(38)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1367.html" target="_blank">软件工程(22)</a> <a href="http://www.blogjava.net/BlueDavy/category/1367.html/rss" title="Subscribe to 软件工程(22)" target="_blank">(rss)</a></li>
</ul>
<h3 id="-">随笔档案</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/05.html" target="_blank">2010年5月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/04.html" target="_blank">2010年4月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03.html" target="_blank">2010年3月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/02.html" target="_blank">2010年2月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/01.html" target="_blank">2010年1月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/12.html" target="_blank">2009年12月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11.html" target="_blank">2009年11月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10.html" target="_blank">2009年10月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/09.html" target="_blank">2009年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/08.html" target="_blank">2009年8月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/07.html" target="_blank">2009年7月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/06.html" target="_blank">2009年6月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/05.html" target="_blank">2009年5月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04.html" target="_blank">2009年4月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/03.html" target="_blank">2009年3月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/01.html" target="_blank">2009年1月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/11.html" target="_blank">2008年11月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/10.html" target="_blank">2008年10月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09.html" target="_blank">2008年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/08.html" target="_blank">2008年8月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/07.html" target="_blank">2008年7月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/06.html" target="_blank">2008年6月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/05.html" target="_blank">2008年5月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/04.html" target="_blank">2008年4月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/03.html" target="_blank">2008年3月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/02.html" target="_blank">2008年2月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/01.html" target="_blank">2008年1月 (10)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/12.html" target="_blank">2007年12月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/11.html" target="_blank">2007年11月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/10.html" target="_blank">2007年10月 (6)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/09.html" target="_blank">2007年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/08.html" target="_blank">2007年8月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/07.html" target="_blank">2007年7月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/06.html" target="_blank">2007年6月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/05.html" target="_blank">2007年5月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/04.html" target="_blank">2007年4月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/03.html" target="_blank">2007年3月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/02.html" target="_blank">2007年2月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/01.html" target="_blank">2007年1月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/12.html" target="_blank">2006年12月 (6)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/11.html" target="_blank">2006年11月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/10.html" target="_blank">2006年10月 (8)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/09.html" target="_blank">2006年9月 (13)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08.html" target="_blank">2006年8月 (15)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/07.html" target="_blank">2006年7月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/06.html" target="_blank">2006年6月 (7)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/05.html" target="_blank">2006年5月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/04.html" target="_blank">2006年4月 (12)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/03.html" target="_blank">2006年3月 (13)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/02.html" target="_blank">2006年2月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/01.html" target="_blank">2006年1月 (14)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/12.html" target="_blank">2005年12月 (11)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/11.html" target="_blank">2005年11月 (14)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/10.html" target="_blank">2005年10月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/09.html" target="_blank">2005年9月 (10)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/08.html" target="_blank">2005年8月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/07.html" target="_blank">2005年7月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/06.html" target="_blank">2005年6月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/05.html" target="_blank">2005年5月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/02.html" target="_blank">2005年2月 (1)</a></li>
</ul>
<h3 id="-">文章档案</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archives/2005/05.html" target="_blank">2005年5月 (2)</a></li>
</ul>
<h3 id="blogger-s">Blogger&#39;s</h3>
<ul>
<li><a href="http://www.dbanotes.net/" target="_blank">DBANotes</a></li>
<li>大名鼎鼎了，勿需多说</li>
<li><a href="http://www.esbzone.net/" target="_blank">ESBZone</a> <a href="http://www.esbzone.net/feed" title="Subscribe to ESBZone" target="_blank">(rss)</a></li>
<li>SOA实战者，强烈推荐</li>
<li><a href="http://kenwublog.com/" target="_blank">kenwu&#39;s blog[推荐]</a> <a href="http://feed.kenwublog.com/" title="Subscribe to kenwu&#39;s blog[推荐]" target="_blank">(rss)</a></li>
<li>Java底层和JVM的很多文章，强烈推荐。</li>
<li><a href="http://dreamhead.blogbus.com/" target="_blank">梦想风暴</a></li>
<li><a href="http://www.blogjava.net/cenwenchu/" target="_blank">西湖边的穷秀才</a></li>
</ul>
<h3 id="-">搜索</h3>
<p>*</p>
<ul>
<li></li>
</ul>
<h3 id="-http-www-blogjava-net-bluedavy-commentsrss-aspx-">最新评论 <a href="http://www.blogjava.net/BlueDavy/CommentsRSS.aspx" target="_blank"><img src="" alt=""></a></h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/07/19/321796.html#401750" target="_blank">1. re: 关于《分布式Java应用：基础与实践》一书</a></li>
<li>博主 大神啊 这个博客很久没有更新了</li>
<li>--1836567962@qq.com</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/07/11/267970.html#401444" target="_blank">2. re: 网站架构相关PPT、文章整理（更新于2009-7-15）</a></li>
<li>这个文章很有用，收藏</li>
<li>--度哥网</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/28/267968.html#399877" target="_blank">3. re: OSGi Opendoc &amp; Book</a></li>
<li>评论内容较长,点击标题查看</li>
<li>--stono</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/28/267968.html#399865" target="_blank">4. re: OSGi Opendoc &amp; Book</a></li>
<li>我再看《OSGi》原理与最佳实践，可是源码没有办法下载呀；
有没有什么办法呢？</li>
<li>--stono</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/27/321796.html#399801" target="_blank">5. re: 关于《分布式Java应用：基础与实践》一书</a></li>
<li>在这篇blog中放置了我收集的一些网站架构相关的PPT和文章</li>
<li>--色都</li>
</ul>
<h3 id="-">阅读排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09/03/226749.html" target="_blank">1. 大型网站架构演变和知识体系(57638)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04/28/267970.html" target="_blank">2. 网站架构相关PPT、文章整理（更新于2009-7-15）(38732)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/03/27/37582.html" target="_blank">3. Hibernate实践(31780)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/06/13/6037.html" target="_blank">4. 系统设计说明书(架构、概要、详细)目录结构(24258)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08/25/65741.html" target="_blank">5. 发布《OSGi实战》正式版(17725)</a></li>
</ul>
<h3 id="-">评论排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09/03/226749.html" target="_blank">1. 大型网站架构演变和知识体系(96)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/09/07/12340.html" target="_blank">2. 漫谈CMS(88)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04/28/267970.html" target="_blank">3. 网站架构相关PPT、文章整理（更新于2009-7-15）(66)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/09/29/149631.html" target="_blank">4. 《OSGi进阶》预览版发布(59)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08/25/65741.html" target="_blank">5. 发布《OSGi实战》正式版(54)</a></li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--GarbageFirst介绍/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--GarbageFirst介绍" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--GC策略的调优/">GC策略的调优</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--GC策略的调优/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="gc-">GC策略的调优</h1>
<h1 id="-bluedavy-blog-http-www-blogjava-net-bluedavy-"><a href="http://www.blogjava.net/BlueDavy/" target="_blank">BlueDavy之技术Blog</a></h1>
<p>理论不懂就实践，实践不会就学理论！</p>
<h2 id="-gc-http-www-blogjava-net-bluedavy-archive-2009-10-09-297562-html-"><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/09/297562.html" target="_blank">GC策略的调优</a></h2>
<p>摘自《构建高性能的大型分布式Java应用》第六章，感兴趣的同学们可以看看。</p>
<p>GC策略在G1还没成熟的情况下，目前主要有串行、并行和并发三种，对于大内存的应用而言，串行的性能太低，因此使用到的主要是并行和并发两种，具体这两种GC的策略在深入JVM章节中已讲解， 并行和并发GC的策略通过-XX:+UseParallelGC和-XX:+UseConcMarkSweepGC来指定，还有一些细节的配置参数用来配置策略的执行方式，例如：-XX:ParallelGCThreads、-XX:CMSInitiatingOccupancyFraction等，新生代对象回收只可选择并行，在此就举例来看看两种GC策略在Full GC时的具体表现状况。</p>
<p>测试GC策略状况的代码如下：</p>
<hr>
<p>**public class GCPolicyDemo {</p>
<pre><code>//*/*
 /* @param args
 /*/
public static void main(String[] args) throws Exception{
   System.out.println(&quot;ready to start&quot;);
   Thread.sleep(10000);
   List&lt;GCPolicyDataObject&gt; cacheObjects=new ArrayList&lt;GCPolicyDataObject&gt;();
   for (int i = 0; i &lt; 2048; i++) {
       cacheObjects.add(new GCPolicyDataObject(100));
   }
   System.gc();
   Thread.sleep(1000);
   for (int i = 0; i &lt; 10; i++) {
       System.out.println(&quot;Round: &quot;+(i+1));
       for (int j = 0; j &lt; 5; j++) {
          System.out.println(&quot;put 64M objects&quot;);
          List&lt;GCPolicyDataObject&gt; tmpObjects=new ArrayList&lt;GCPolicyDataObject&gt;();
          for (int m = 0; m &lt; 1024; m++) {
              tmpObjects.add(new GCPolicyDataObject(64));
          }
          tmpObjects=null;
       }
   }
   cacheObjects.size();
   cacheObjects=null;
}
</code></pre><p>}</p>
<p>class GCPolicyDataObject{</p>
<pre><code>byte[] bytes=null;

GCPolicyRefObject object=null;

public GCPolicyDataObject(int factor){
   bytes=new byte[factor/*1024];
   object=new GCPolicyRefObject();
}
</code></pre><p>}</p>
<p>class GCPolicyRefObject{</p>
<pre><code>GCPolicyRefChildObject object;

public GCPolicyRefObject(){
   object=new GCPolicyRefChildObject();
}
</code></pre><p>}</p>
<p>class GCPolicyRefChildObject{</p>
<pre><code>public GCPolicyRefChildObject(){
   ;
}
</code></pre><p>}**</p>
<p>以-Xms680M -Xmx680M -Xmn80M -XX:+UseConcMarkSweepGC -XX:+PrintGCApplicationStoppedTime -XX:+UseCMSCompactAtFullCollection -XX:+UseParNewGC -XX:CMSMaxAbortablePrecleanTime=5参数执行以上代码，通过jstat观察到的GC状况如下：</p>
<p>共触发39次minor GC，耗时为1.197秒，共触发21次Full GC，耗时为0.136秒，GC总耗时为1.333秒。</p>
<p>GC动作造成应用暂停的时间为：1.74秒。</p>
<p>以-Xms680M -Xmx680M -Xmn80M -XX:+PrintGCApplicationStoppedTime –XX:+UseParallelGC参数执行以上代码，通过jstat观察到的GC状况如下：</p>
<p>共触发119次minor GC，耗时为2.774秒，共触发8次Full GC，耗时为0.243秒，GC总耗时为3.016秒。</p>
<p>GC动作造成应用暂停的时间为：3.11秒。</p>
<p>从上面的结果来看，由于CMS GC多数动作是和应用并发做的，采用CMS GC确实可以减小GC动作给应用造成的暂停，但也正因为是并发进行的，因此CMS GC需要耗费更多的CPU，因此对于CPU密集型应用而言，CMS不一定是好的选择。</p>
<p>在采用CMS GC的情况下，尤其要注意的是concurrent mode failure的现象，这可以通过-XX:+PrintGCDetails来观察，当出现concurrent mode failure的现象时，就意味着此时JVM将继续采用Stop-The-World的方式来进行Full GC，这种情况下，采用CMS就没什么意义了，造成concurrent mode failure的原因主要是当minor GC进行时，旧生代所剩下的空间小于Eden区域+From区域的空间，要避免这种现象，可以采用以下三种方法：</p>
<p>l  调低触发CMS GC执行的阀值</p>
<p>CMS GC触发主要由CMSInitiatingOccupancyFraction值决定，默认情况是当旧生代已用空间为68%时，即触发CMS GC。</p>
<p>在出现concurrent mode failure的情况下，可考虑调小这个值，提前CMS GC的触发，以保证旧生代有足够的空间。</p>
<p>l  扩大旧生代空间</p>
<p>调小新生代占用的空间或增大整个JVM Heap的空间可扩大旧生代空间，这对于避免concurrent mode failure现象可以提供很大的帮助。</p>
<p>l  调小CMSMaxAbortablePrecleanTime的值
CMS GC需要经过较多步骤才能完成一次GC的动作，在minor GC较为频繁的情况下，很有可能造成CMS GC尚未完成，从而造成concurrent mode failure，这种情况下，减少minor GC触发的频率是一种方法，另外一种方法则是加快CMS GC执行时间，在CMS的整个步骤中，JDK 5.0+、6.0+的有些版本在CMS-concurrent-abortable-preclean-start和CMS-concurrent-abortable-preclean这两步间有可能会耗费很长的时间，导致可回收的旧生代的对象很长时间后才被回收，这是Sun JDK CMS GC的一个bug<a href="">[1]</a>，如通过PrintGCDetails观察到这两步之间耗费了较长的时间，可以通过-XX: CMSMaxAbortablePrecleanTime设置较小的值，以保证CMS GC尽快完成对象的回收，避免concurrent mode failure的现象。</p>
<p><a href="">[1]</a> 详细bug信息请见：<a href="http://www.nabble.com/CMS-GC-tuning-under-JVM-5.0-td16759819.html" target="_blank">http://www.nabble.com/CMS-GC-tuning-under-JVM-5.0-td16759819.html</a></p>
<p>posted on 2009-10-09 15:57 <a href="http://www.blogjava.net/BlueDavy/" target="_blank">BlueDavy</a> 阅读(9126) <a href="">评论(5)</a>  <a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx?postid=297562" target="_blank">编辑</a>  <a href="http://www.blogjava.net/BlueDavy/AddToFavorite.aspx?id=297562" target="_blank">收藏</a> 所属分类: <a href="http://www.blogjava.net/BlueDavy/category/1366.html" target="_blank">Java</a></p>
<p> <img src="" alt=""></p>
<p><a href=""></a> <a href=""></a></p>
<p>[</p>
<h3 id="-">评论</h3>
<p>]()</p>
<h3 id="-permalink-re-gc-re-gc-2009-10-09-16-36-agraviton-"><a href=""></a><a href="&quot;permalink: re: GC策略的调优&quot;">/#</a> <a href=""></a>re: GC策略的调优  2009-10-09 16:36  <a href="">agraviton</a></h3>
<p>bluedavy 又出手了，出手就不凡。  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=agraviton" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-gc-re-gc-2009-10-09-18-06-glf-"><a href="&quot;permalink: re: GC策略的调优&quot;">/#</a> <a href=""></a>re: GC策略的调优  2009-10-09 18:06  <a href="">glf</a></h3>
<p>书什么时候出啊  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=glf" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-gc-re-gc-2009-10-09-20-10-bluedavy-http-www-blogjava-net-bluedavy-"><a href="&quot;permalink: re: GC策略的调优&quot;">/#</a> <a href=""></a>re: GC策略的调优  2009-10-09 20:10  <a href="http://www.blogjava.net/BlueDavy/">BlueDavy</a></h3>
<p>@glf
这书估计要到明年三月左右才能上市了。  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=BlueDavy" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-gc-re-gc-2009-10-10-13-54-hucq-"><a href="&quot;permalink: re: GC策略的调优&quot;">/#</a> <a href=""></a>re: GC策略的调优  2009-10-10 13:54  <a href="">hucq</a></h3>
<p>期待实体书  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=hucq" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-gc-re-gc-2009-12-21-21-16-study-"><a href="&quot;permalink: re: GC策略的调优&quot;">/#</a> <a href=""></a>re: GC策略的调优<a href=""></a>  2009-12-21 21:16  <a href="">study</a></h3>
<p>太期待了！   <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=study" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a>
<a href="http://www.blogjava.net/RequireRegister.aspx" target="_blank">新用户注册</a>  <a href="">刷新评论列表</a>  </p>
<p><a href=""></a> <a href="http://www.aliyun.com/cps/channel?channel_id=1306&amp;user=0&amp;lv=1">推荐购买云服务器（15%返利+最高千元奖金）</a>   <a href="http://www.cnblogs.com/" target="_blank">博客园</a>  <a href="http://q.cnblogs.com/" target="_blank">博问</a>  <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>  <a href="http://job.cnblogs.com/cate-java_programmer/" target="_blank">Java程序员招聘</a> 标题  请输入标题 姓名  请输入你的姓名 主页 请输入验证码 验证码 /*  <img src="http://www.blogjava.net/Modules/CaptchaImage/JpegImage.aspx?cacheid=20130727130705" alt=""> 内容(请不要发表任何与政治相关的内容) 请输入评论内容 Remember Me?   <a href="http://www.blogjava.net/login.aspx?ReturnURL=http://www.blogjava.net/BlueDavy/archive/2009/10/09/297562.html&amp;SourceURL=/BlueDavy/archive/2009/10/09/297562.html" target="_blank">登录</a>       [使用Ctrl+Enter键可以直接提交]      网站导航:</p>
<p><a href="http://www.cnblogs.com/" title="程序员的网上家园" target="_blank">博客园</a>   <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>   <a href="http://kb.cnblogs.com/" target="_blank">知识库</a>   <a href="http://www.cppblog.com/" target="_blank">C++博客</a>   <a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a>   <a href="http://www.blogjava.net/BlueDavy/archive/2009/10/09/297562.html?opt=admin" target="_blank">管理</a> 相关文章:</p>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/05/25/321796.html" target="_blank">关于《分布式Java应用：基础与实践》一书</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/04/30/319794.html" target="_blank">杭州程序员圆桌交流第二期视频</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03/22/316148.html" target="_blank">第一次杭州程序员交流会总结</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03/19/315989.html" target="_blank">杭州程序员圆桌交流第一期–并发编程PPT</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/12/03/304597.html" target="_blank">GCLogViewer(tool to visualize gc log) V0.2 Release</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11/25/303662.html" target="_blank">Simple Scala actor Vs java Thread Vs Kilim Test</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11/06/301448.html" target="_blank">《构建高性能的大型分布式Java应用》目录&amp;试读样章</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/10/297661.html" target="_blank">动态跟踪Java代码的执行状况工具--BTrace</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/09/297562.html" target="_blank">GC策略的调优</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/08/06/290003.html" target="_blank">Hessian 3.2.0的两个bug</a><br>Powered by: <a href="http://www.blogjava.net/" target="_blank">BlogJava</a> Copyright © BlueDavy<h3 id="-">公告</h3>
</li>
</ul>
<p><a href="http://www.douban.com/subject/3843896/" target="_blank"><img src="" alt=""></a> 
<a href="http://china.osgiusers.org/" target="_blank"><img src="" alt=""></a>
<a href="http://feed.feedsky.com/bluedavy" title="BlogJava-BlueDavy之技术Blog" target="_blank"><img src="" alt=""></a> <a href="http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="feedsky"></a>
<a href="http://www.zhuaxia.com/add_channel.php?url=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="抓虾"></a>
<a href="http://fusion.google.com/add?feedurl=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="google reader"></a>
<a href="http://www.xianguo.com/subscribe.php?url=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="鲜果"></a></p>
<h3 id="-">导航</h3>
<ul>
<li><a href="http://www.blogjava.net/" target="_blank">BlogJava</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/" target="_blank">首页</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx?opt=1" target="_blank">新随笔</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/contact.aspx?id=1" target="_blank">联系</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/rss" target="_blank">聚合</a><a href="http://www.blogjava.net/BlueDavy/rss" target="_blank"><img src="" alt=""></a></li>
<li><a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx" target="_blank">管理</a>
<a href="&quot;转到上一个月&quot;">&lt;</a>2009年10月<a href="&quot;转到下一个月&quot;">&gt;</a>日一二三四五六2728293012345678<a href="http://www.blogjava.net/BlueDavy/archive/2009/10/09.html" target="_blank">9</a><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/10.html" target="_blank">10</a>1112131415161718192021222324252627282930311234567</li>
</ul>
<h3 id="-">统计</h3>
<ul>
<li>随笔 - 294</li>
<li>文章 - 2</li>
<li>评论 - 2068</li>
<li>引用 - 1</li>
</ul>
<h3 id="-">随笔分类</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/category/10609.html" target="_blank">@RIAWork(10)</a> <a href="http://www.blogjava.net/BlueDavy/category/10609.html/rss" title="Subscribe to @RIAWork(10)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/32839.html" target="_blank">Internet(20)</a> <a href="http://www.blogjava.net/BlueDavy/category/32839.html/rss" title="Subscribe to Internet(20)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1366.html" target="_blank">Java(82)</a> <a href="http://www.blogjava.net/BlueDavy/category/1366.html/rss" title="Subscribe to Java(82)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/8127.html" target="_blank">Javascript(7)</a> <a href="http://www.blogjava.net/BlueDavy/category/8127.html/rss" title="Subscribe to Javascript(7)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/18356.html" target="_blank">OSGi、SOA、SCA(81)</a> <a href="http://www.blogjava.net/BlueDavy/category/18356.html/rss" title="Subscribe to OSGi、SOA、SCA(81)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1514.html" target="_blank">Plugin Architecture(10)</a> <a href="http://www.blogjava.net/BlueDavy/category/1514.html/rss" title="Subscribe to Plugin Architecture(10)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1513.html" target="_blank">Workflow(4)</a> <a href="http://www.blogjava.net/BlueDavy/category/1513.html/rss" title="Subscribe to Workflow(4)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/11559.html" target="_blank">业界随想(28)</a> <a href="http://www.blogjava.net/BlueDavy/category/11559.html/rss" title="Subscribe to 业界随想(28)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/22527.html" target="_blank">数据集成(8)</a> <a href="http://www.blogjava.net/BlueDavy/category/22527.html/rss" title="Subscribe to 数据集成(8)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1911.html" target="_blank">系统设计(38)</a> <a href="http://www.blogjava.net/BlueDavy/category/1911.html/rss" title="Subscribe to 系统设计(38)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1367.html" target="_blank">软件工程(22)</a> <a href="http://www.blogjava.net/BlueDavy/category/1367.html/rss" title="Subscribe to 软件工程(22)" target="_blank">(rss)</a></li>
</ul>
<h3 id="-">随笔档案</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/05.html" target="_blank">2010年5月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/04.html" target="_blank">2010年4月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03.html" target="_blank">2010年3月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/02.html" target="_blank">2010年2月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/01.html" target="_blank">2010年1月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/12.html" target="_blank">2009年12月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11.html" target="_blank">2009年11月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10.html" target="_blank">2009年10月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/09.html" target="_blank">2009年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/08.html" target="_blank">2009年8月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/07.html" target="_blank">2009年7月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/06.html" target="_blank">2009年6月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/05.html" target="_blank">2009年5月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04.html" target="_blank">2009年4月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/03.html" target="_blank">2009年3月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/01.html" target="_blank">2009年1月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/11.html" target="_blank">2008年11月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/10.html" target="_blank">2008年10月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09.html" target="_blank">2008年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/08.html" target="_blank">2008年8月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/07.html" target="_blank">2008年7月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/06.html" target="_blank">2008年6月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/05.html" target="_blank">2008年5月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/04.html" target="_blank">2008年4月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/03.html" target="_blank">2008年3月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/02.html" target="_blank">2008年2月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/01.html" target="_blank">2008年1月 (10)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/12.html" target="_blank">2007年12月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/11.html" target="_blank">2007年11月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/10.html" target="_blank">2007年10月 (6)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/09.html" target="_blank">2007年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/08.html" target="_blank">2007年8月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/07.html" target="_blank">2007年7月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/06.html" target="_blank">2007年6月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/05.html" target="_blank">2007年5月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/04.html" target="_blank">2007年4月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/03.html" target="_blank">2007年3月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/02.html" target="_blank">2007年2月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/01.html" target="_blank">2007年1月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/12.html" target="_blank">2006年12月 (6)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/11.html" target="_blank">2006年11月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/10.html" target="_blank">2006年10月 (8)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/09.html" target="_blank">2006年9月 (13)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08.html" target="_blank">2006年8月 (15)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/07.html" target="_blank">2006年7月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/06.html" target="_blank">2006年6月 (7)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/05.html" target="_blank">2006年5月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/04.html" target="_blank">2006年4月 (12)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/03.html" target="_blank">2006年3月 (13)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/02.html" target="_blank">2006年2月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/01.html" target="_blank">2006年1月 (14)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/12.html" target="_blank">2005年12月 (11)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/11.html" target="_blank">2005年11月 (14)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/10.html" target="_blank">2005年10月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/09.html" target="_blank">2005年9月 (10)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/08.html" target="_blank">2005年8月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/07.html" target="_blank">2005年7月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/06.html" target="_blank">2005年6月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/05.html" target="_blank">2005年5月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/02.html" target="_blank">2005年2月 (1)</a></li>
</ul>
<h3 id="-">文章档案</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archives/2005/05.html" target="_blank">2005年5月 (2)</a></li>
</ul>
<h3 id="blogger-s">Blogger&#39;s</h3>
<ul>
<li><a href="http://www.dbanotes.net/" target="_blank">DBANotes</a></li>
<li>大名鼎鼎了，勿需多说</li>
<li><a href="http://www.esbzone.net/" target="_blank">ESBZone</a> <a href="http://www.esbzone.net/feed" title="Subscribe to ESBZone" target="_blank">(rss)</a></li>
<li>SOA实战者，强烈推荐</li>
<li><a href="http://kenwublog.com/" target="_blank">kenwu&#39;s blog[推荐]</a> <a href="http://feed.kenwublog.com/" title="Subscribe to kenwu&#39;s blog[推荐]" target="_blank">(rss)</a></li>
<li>Java底层和JVM的很多文章，强烈推荐。</li>
<li><a href="http://dreamhead.blogbus.com/" target="_blank">梦想风暴</a></li>
<li><a href="http://www.blogjava.net/cenwenchu/" target="_blank">西湖边的穷秀才</a></li>
</ul>
<h3 id="-">搜索</h3>
<p>*</p>
<ul>
<li></li>
</ul>
<h3 id="-http-www-blogjava-net-bluedavy-commentsrss-aspx-">最新评论 <a href="http://www.blogjava.net/BlueDavy/CommentsRSS.aspx" target="_blank"><img src="" alt=""></a></h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/07/19/321796.html#401750" target="_blank">1. re: 关于《分布式Java应用：基础与实践》一书</a></li>
<li>博主 大神啊 这个博客很久没有更新了</li>
<li>--1836567962@qq.com</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/07/11/267970.html#401444" target="_blank">2. re: 网站架构相关PPT、文章整理（更新于2009-7-15）</a></li>
<li>这个文章很有用，收藏</li>
<li>--度哥网</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/28/267968.html#399877" target="_blank">3. re: OSGi Opendoc &amp; Book</a></li>
<li>评论内容较长,点击标题查看</li>
<li>--stono</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/28/267968.html#399865" target="_blank">4. re: OSGi Opendoc &amp; Book</a></li>
<li>我再看《OSGi》原理与最佳实践，可是源码没有办法下载呀；
有没有什么办法呢？</li>
<li>--stono</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/27/321796.html#399801" target="_blank">5. re: 关于《分布式Java应用：基础与实践》一书</a></li>
<li>在这篇blog中放置了我收集的一些网站架构相关的PPT和文章</li>
<li>--色都</li>
</ul>
<h3 id="-">阅读排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09/03/226749.html" target="_blank">1. 大型网站架构演变和知识体系(57638)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04/28/267970.html" target="_blank">2. 网站架构相关PPT、文章整理（更新于2009-7-15）(38732)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/03/27/37582.html" target="_blank">3. Hibernate实践(31780)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/06/13/6037.html" target="_blank">4. 系统设计说明书(架构、概要、详细)目录结构(24258)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08/25/65741.html" target="_blank">5. 发布《OSGi实战》正式版(17725)</a></li>
</ul>
<h3 id="-">评论排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09/03/226749.html" target="_blank">1. 大型网站架构演变和知识体系(96)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/09/07/12340.html" target="_blank">2. 漫谈CMS(88)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04/28/267970.html" target="_blank">3. 网站架构相关PPT、文章整理（更新于2009-7-15）(66)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/09/29/149631.html" target="_blank">4. 《OSGi进阶》预览版发布(59)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08/25/65741.html" target="_blank">5. 发布《OSGi实战》正式版(54)</a></li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--GC策略的调优/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--GC策略的调优" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JDK7中的5种GC类型第一种：SerialGC/">JDK7中的5种GC类型第一种：Serial GC</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JDK7中的5种GC类型第一种：SerialGC/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jdk7-5-gc-serial-gc">JDK7中的5种GC类型第一种：Serial GC</h1>
<h2 id="jdk7-5-gc-">JDK7中的5种GC类型</h2>
<p>第一种：Serial GC</p>
<p><img src="" alt=""></p>
<p>第二种：Parallel GC</p>
<p><img src="" alt=""></p>
<p>第三种：Parallel Old GC (Parallel Compacting GC)</p>
<p><img src="" alt=""></p>
<p>第四种：Concurrent Mark &amp; Sweep GC (CMS GC)</p>
<p><img src="" alt=""></p>
<p>第五种：Garbage First (G1) GC</p>
<p><img src="" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JDK7中的5种GC类型第一种：SerialGC/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JDK7中的5种GC类型第一种：SerialGC" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/44/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/42/">42</a></li><li><a class="page-number" href="/page/43/">43</a></li><li><a class="page-number" href="/page/44/">44</a></li><li class="active"><li><span class="page-number current">45</span></li><li><a class="page-number" href="/page/46/">46</a></li><li><a class="page-number" href="/page/47/">47</a></li><li><a class="page-number" href="/page/48/">48</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/161/">161</a></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="extend next" href="/page/46/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-04-07 17:26:53</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
