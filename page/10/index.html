
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 10 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-服务器-tomcat--Tomcat源码分析/">Tomcat源码分析</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:45.000Z"> <a href="/2014/02/02/2014-02-02-服务器-tomcat--Tomcat源码分析/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="tomcat-">Tomcat源码分析</h1>
<p><a href="http://blog.csdn.net/haojun186/article/details/7464912" target="_blank">Tomcat源码分析</a></p>
<p>TOMCAT源码分析(启动框架)
前言：
   本文是我阅读了TOMCAT源码后的一些心得。 主要是讲解TOMCAT的系统框架， 以及启动流程。若有错漏之处，敬请批评指教！
建议：
   毕竟TOMCAT的框架还是比较复杂的， 单是从文字上理解， 是不那么容易掌握TOMCAT的框架的。 所以得实践、实践、再实践。 建议下载一份TOMCAT的源码， 调试通过， 然后单步跟踪其启动过程。 如果有不明白的地方， 再来查阅本文， 看是否能得到帮助。 我相信这样效果以及学习速度都会好很多！</p>
<ol>
<li><p>Tomcat的整体框架结构
Tomcat的基本框架， 分为4个层次。
Top Level Elements:
 Server
 Service<br>Connector
 HTTP
 AJP
Container
Engine
  Host
Context
Component<br> manager
logger
loader
pipeline
valve</p>
<pre><code>  ...
</code></pre><p>站在框架的顶层的是Server和Service
Server:  其实就是BackGroud程序， 在Tomcat里面的Server的用处是启动和监听服务端事件（诸如重启、关闭等命令。 在tomcat的标准配置文件：server.xml里面， 我们可以看到“<Server port="8005" shutdown="SHUTDOWN" debug="0">;”这里的&quot;SHUTDOWN&quot;就是server在监听服务端事件的时候所使用的命令字）
Service： 在tomcat里面，service是指一类问题的解决方案。  通常我们会默认使用tomcat提供的：Tomcat-Standalone 模式的service。 在这种方式下的service既给我们提供解析jsp和servlet的服务， 同时也提供给我们解析静态文本的服务。</p>
<p>Connector: Tomcat都是在容器里面处理问题的， 而容器又到哪里去取得输入信息呢？
Connector就是专干这个的。 他会把从socket传递过来的数据， 封装成Request, 传递给容器来处理。
通常我们会用到两种Connector,一种叫http connectoer， 用来传递http需求的。 另一种叫AJP， 在我们整合apache与tomcat工作的时候，apache与tomcat之间就是通过这个协议来互动的。 （说到apache与tomcat的整合工作， 通常我们的目的是为了让apache 获取静态资源， 而让tomcat来解析动态的jsp或者servlet。）
Container: 当http connector把需求传递给顶级的container: Engin的时候， 我们的视线就应该移动到Container这个层面来了。
在Container这个层， 我们包含了3种容器：Engin, Host, Context.
Engin: 收到service传递过来的需求， 处理后， 将结果返回给service( service 是通过connector 这个媒介来和Engin互动的).
Host: Engin收到service传递过来的需求后，不会自己处理， 而是交给合适的Host来处理。
Host在这里就是<a href="http://www.honhei.com/" target="_blank">虚拟主机</a>的意思， 通常我们都只会使用一个主机，既“localhost”本地机来处理。
Context: Host接到了从Host传过来的需求后， 也不会自己处理， 而是交给合适的Context来处理。
比如：<a href="http://127.0.0.1:8080/foo/index.jsp" target="_blank">http://127.0.0.1:8080/foo/index.jsp</a>;</p>
<pre><code>  &lt;http://127.0.1:8080/bar/index.jsp&gt;;
</code></pre><p>前者交给foo这个Context来处理， 后者交给bar这个Context来处理。
很明显吧！context的意思其实就是一个web app的意思。
我们通常都会在server.xml里面做这样的配置
<Context path="/foo" docBase="D:/project/foo/web" />;
这个context容器，就是用来干我们该干的事儿的地方的。</p>
<p>Compenent: 接下来， 我们继续讲讲component是干什么用的。
我们得先理解一下容器和组件的关系。
需求被传递到了容器里面， 在合适的时候， 会传递给下一个容器处理。
而容器里面又盛装着各种各样的组件， 我们可以理解为提供各种各样的增值服务。
manager: 当一个容器里面装了manager组件后，这个容器就支持session管理了， 事实上在tomcat里面的session管理， 就是靠的在context里面装的manager component.
logger: 当一个容器里面装了logger组件后， 这个容器里所发生的事情， 就被该组件记录下来啦！ 我们通常会在logs/ 这个目录下看见catalina_log.time.txt 以及localhost.time.txt 和localhost_examples_log.time.txt。 这就是因为我们分别为：engin, host以及context(examples)这三个容器安装了logger组件， 这也是默认安装， 又叫做标配 ：）
loader: loader这个组件通常只会给我们的context容器使用，loader是用来启动context以及管理这个context的classloader用的。
 pipline: pipeline是这样一个东西， 当一个容器决定了要把从上级传递过来的需求交给子容器的时候， 他就把这个需求放进容器的管道(pipeline)里面去。 而需求傻呼呼得在管道里面流动的时候， 就会被管道里面的各个阀门拦截下来。 比如管道里面放了两个阀门。 第一个阀门叫做“access_allow_vavle”， 也就是说需求流过来的时候，它会看这个需求是哪个IP过来的， 如果这个IP已经在黑名单里面了，sure, 杀！ 第二个阀门叫做“defaul_access_valve”它会做例行的检查， 如果通过的话，OK， 把需求传递给当前容器的子容器。 就是通过这种方式， 需求就在各个容器里面传递，流动， 最后抵达目的地的了。
 valve: 就是上面所说的阀门啦。
Tomcat里面大概就是这么些东西， 我们可以简单地这么理解tomcat的框架，它是一种自上而下， 容器里又包含子容器的这样一种结构。</p>
</li>
<li><p>Tomcat的启动流程
这篇文章是讲tomcat怎么启动的，既然我们大体上了解了TOMCAT的框架结构了， 那么我们可以望文生意地就猜到tomcat的启动， 会先启动父容器，然后逐个启动里面的子容器。 启动每一个容器的时候， 都会启动安插在他身上的组件。 当所有的组件启动完毕， 所有的容器启动完毕的时候，tomcat本身也就启动完毕了。
顺理成章地， 我们同样可以猜到，tomcat的启动会分成两大部分， 第一步是装配工作。 第二步是启动工作。
装配工作就是为父容器装上子容器， 为各个容器安插进组件的工作。 这个地方我们会用到digester模式， 至于digester模式什么， 有什么用， 怎么工作的. 请参考<a href="http://software.ccidnet.com/pub/article/c322_a31671_p2.html" target="_blank">http://software.ccidnet.com/pub/article/c322_a31671_p2.html</a>;
启动工作是在装配工作之后， 一旦装配成功了， 我们就只需要点燃最上面的一根导线， 整个tomcat就会被激活起来。 这就好比我们要开一辆已经装配好了的汽车的时候一样，我们只要把钥匙插进钥匙孔，一拧，汽车的引擎就会发动起来，空调就会开起来， 安全装置就会生效， 如此一来，汽车整个就发动起来了。（这个过程确实和TOMCAT的启动过程不谋而和， 让我们不得不怀疑TOMCAT的设计者是在GE做JAVA开发的）。
2.1 一些有意思的名称：
Catalina
Tomcat
Bootstrap
Engin
Host
Context
他们的意思很有意思：
Catalina: 远程轰炸机
Tomcat: 熊猫轰炸机-- 轰炸机的一种（这让我想起了让国人引以为豪的熊猫手机，是不是英文可以叫做tomcat??? ， 又让我想起了另一则广告： 波导-手机中的战斗机、波音-客机中的战斗机 ）
Bootstap: 引导
Engin: 发动机
Host: 主机，领土
Context: 内容， 目标， 上下文</p>
<p>... 在许多许多年后， 现代人类已经灭绝。 后现代生物发现了这些单词零落零落在一块。 一个自以为聪明的家伙把这些东西翻译出来了：
在地勤人员的引导(bootstrap)下， 一架轰炸架(catalina)腾空跃起， 远看是熊猫轰炸机(tomcat)， 近看还是熊猫轰炸机！ 凭借着优秀的发动机技术(engin)， 这架熊猫轰炸机飞临了敌国的领土上空(host)， 对准目标(context)投下了毁天灭地的核弹头，波~ 现代生物就这么隔屁了~</p>
<p>综上所述， 这又不得不让人联想到GE是不是也参与了军事设备的生产呢？
反对美帝国主义！ 反对美霸权主义！ 和平万岁！ 自由万岁！</p>
</li>
</ol>
<p>2.2  历史就是那么惊人的相似！tomcat的启动就是从org.apache.catalina.startup.Bootstrap这个类悍然启动的！
   在Bootstrap里做了两件事：</p>
<ol>
<li>指定了3种类型classloader:
commonLoader: common/classes、common/lib、common/endorsed
catalinaLoader: server/classes、server/lib、commonLoader
sharedLoader：  shared/classes、shared/lib、commonLoader</li>
<li>引导Catalina的启动。
用Reflection技术调用org.apache.catalina.startup.Catalina的process方法， 并传递参数过去。</li>
</ol>
<p>2.3 Catalina.java
   Catalina完成了几个重要的任务：</p>
<ol>
<li>使用Digester技术装配tomcat各个容器与组件。
1.1 装配工作的主要内容是安装各个大件。 比如server下有什么样的servcie。Host会容纳多少个context。Context都会使用到哪些组件等等。
1.2 同时呢， 在装配工作这一步， 还完成了mbeans的配置工作。 在这里，我简单地但不十分精确地描述一下mbean是什么，干什么用的。<pre><code>我们自己生成的对象， 自己管理， 天经地义！ 但是如果我们创建了对象了， 想让别人来管， 怎么办呢？ 我想至少得告诉别人我们都有什么， 以及通过什么方法可以找到  吧！JMX技术给我们提供了一种手段。JMX里面主要有3种东西。Mbean, agent, connector.
</code></pre> Mbean： 用来映射我们的对象。也许mbean就是我们创建的对象， 也许不是， 但有了它， 就可以引用到我们的对象了。
 Agent:  通过它， 就可以找到mbean了。
 Connector: 连接Agent的方式。 可以是http的， 也可以是rmi的，还可以直接通过socket。
发生在tomcat 装配过程中的事情:  GlobalResourcesLifecycleListener 类的初始化会被触发：
   protected static Registry registry = MBeanUtils.createRegistry();  会运行
   MBeanUtils.createRegistry()  会依据/org/apache/catalina/mbeans/mbeans- descriptors.xml这个配置文件创建mbeans. Ok, 外界就有了条途径访问tomcat中的各个组件了。（有点像后门儿）</li>
<li>为top level 的server 做初始化工作。 实际上就是做通常会配置给service的两条connector.(http, ajp)</li>
<li>从server这个容器开始启动， 点燃整个tomcat.</li>
<li>为server做一个hook程序， 检测当server shutdown的时候， 关闭tomcat的各个容器用。</li>
<li>监听8005端口， 如果发送&quot;SHUTDOWN&quot;（默认培植下字符串）过来， 关闭8005serverSocket。
2.4 启动各个容器</li>
<li>Server
触发Server容器启动前(before_start)， 启动中(start)， 启动后(after_start)3个事件， 并运行相应的事件处理器。
启动Server的子容器：Servcie.</li>
<li>Service
启动Service的子容器：Engin
启动Connector</li>
<li><p>Engin
到了Engin这个层次，以及以下级别的容器，Tomcat就使用了比较一致的启动方式了。
首先，  运行各个容器自己特有一些任务
随后，  触发启动前事件
立即，  设置标签，就表示该容器已经启动
接着，  启动容器中的各个组件：loader, logger, manager等等
再接着，启动mapping组件。（注1）
紧跟着，启动子容器。
接下来，启动该容器的管道(pipline)
然后，  触发启动中事件
最后，  触发启动后事件。</p>
<p>Engin大致会这么做，Host大致也会这么做， Context大致还是会这么做。 那么很显然地， 我们需要在这里使用到代码复用的技术。tomcat在处理这个问题的时候， 漂亮地使用了抽象类来处理。ContainerBase. 最后使得这部分完成复杂功能的代码显得干净利落， 干练爽快， 实在是令人觉得叹为观止， 细细品来， 直觉如享佳珍， 另人齿颊留香， 留恋往返啊！</p>
<p>Engin的触发启动前事件里， 会激活绑定在Engin上的唯一一个Listener：EnginConfig。
这个EnginConfig类基本上没有做什么事情， 就是把EnginConfig的调试级别设置为和Engin相当。 另外就是输出几行文本， 表示Engin已经配置完毕， 并没有做什么实质性的工作。
注1: mapping组件的用处是， 当一个需求将要从父容器传递到子容器的时候， 而父容器又有多个子容器的话， 那么应该选择哪个子容器来处理需求呢？ 这个由mapping 组件来定夺。</p>
</li>
<li><p>Host
 同Engin一样， 也是调用ContainerBase里面的start()方法， 不过之前做了些自个儿的任务,就是往Host这个容器的通道（pipline）里面， 安装了一个叫做
“org.apache.catalina.valves.ErrorReportValve”的阀门。
 这个阀门的用处是这样的：  需求在被Engin传递给Host后， 会继续传递给Context做具体的处理。 这里需求其实就是作为参数传递的Request, Response。 所以在context把需求处理完后， 通常会改动response。 而这个org.apache.catalina.valves.ErrorReportValve的作用就是检察response是否包含错误， 如果有就做相应的处理。</p>
</li>
<li>Context
 到了这里， 就终于轮到了tomcat启动中真正的重头戏，启动Context了。
StandardContext.start() 这个启动Context容器的方法被StandardHost调用.
5.1 webappResources 该context所指向的具体目录
5.2 安装defaultContex, DefaultContext 就是默认Context。 如果我们在一个Host下面安装了DefaultContext，而且defaultContext里面又安装了一个数据库连接池资源的话。 那么其他所有的在该Host下的Context, 都可以直接使用这个数据库连接池， 而不用格外做配置了。
5.3 指定Loader. 通常用默认的org.apache.catalina.loader.WebappLoader这个类。   Loader就是用来指定这个context会用到哪些类啊， 哪些jar包啊这些什么的。
5.4 指定Manager. 通常使用默认的org.apache.catalina.session. StandardManager 。Manager是用来管理session的。
其实session的管理也很好实现。 以一种简单的session管理为例。 当需求传递过来的时候， 在Request对象里面有一个sessionId 属性。OK， 得到这个sessionId后， 我们就可以把它作为map的key，而value我们可以放置一个HashMap. HashMap里边儿， 再放我们想放的东西。
5.5 postWorkDirectory (). Tomcat下面有一个work目录。 我们把临时文件都扔在那儿去。 这个步骤就是在那里创建一个目录。 一般说来会在%CATALINA_HOME%/work/Standalone\localhost\ 这个地方生成一个目录。
5.6  Binding thread。到了这里， 就应该发生class Loader 互换了。 之前是看得见tomcat下面所有的class和lib. 接下来需要看得见当前context下的class。 所以要设置contextClassLoader, 同时还要把旧的ClassLoader记录下来，因为以后还要用的。
5.7  启动Loader. 指定这个Context具体要使用哪些classes， 用到哪些jar文件。 如果reloadable设置成了true, 就会启动一个线程来监视classes的变化， 如果有变化就重新启动Context。
5.8  启动logger
5.9  触发安装在它身上的一个监听器。
lifecycle.fireLifecycleEvent(START_EVENT, null);
作为监听器之一，ContextConfig会被启动. ContextConfig就是用来配置web.xml的。 比如这个Context有多少Servlet， 又有多少Filter， 就是在这里给Context装上去的。
5.9.1 defaultConfig. 每个context都得配置tomcat/conf/web.xml 这个文件。
5.9.2 applicationConfig 配置自己的WEB-INF/web.xml 文件
5.9.3 validateSecurityRoles 权限验证。 通常我们在访问/admin 或者/manager的时候，需要用户要么是admin的要么是manager的， 才能访问。 而且我们还可以限制那些资源可以访问， 而哪些不能。 都是在这里实现的。
5.9.4 tldScan: 扫描一下， 需要用到哪些标签(tag lab)
5.10 启动manager
5.11 postWelcomeFiles() 我们通常会用到的3个启动文件的名称：
index.html、index.htm、index.jsp 就被默认地绑在了这个context上
5.12 listenerStart 配置listener
5.13 filterStart 配置filter
5.14 启动带有<load-on-startup>;1</load-on-startup>;的Servlet.
顺序是从小到大：1,2,3… 最后是0
默认情况下， 至少会启动如下3个的Servlet:
org.apache.catalina.servlets.DefaultServlet<br>处理静态资源的Servlet. 什么图片啊，html啊，css啊，js啊都找他
org.apache.catalina.servlets.InvokerServlet
处理没有做Servlet Mapping的那些Servlet.
org.apache.jasper.servlet.JspServlet
处理JSP文件的.
 5.15  标识context已经启动完毕。
走了多少个步骤啊，Context总算是启动完毕喽。
OK! 走到了这里， 每个容器以及组件都启动完毕。Tomcat终于不辞辛劳地为人民服务了！<ol>
<li>参考文献：
<a href="http://jakarta.apache.org/tomcat/" target="_blank">http://jakarta.apache.org/tomcat/</a>;
<a href="http://www.onjava.com/pub/a/onjava/2003/05/14/java_webserver.html" target="_blank">http://www.onjava.com/pub/a/onjava/2003/05/14/java_webserver.html</a>;</li>
</ol>
</li>
</ol>
<ol>
<li><p>后记
 这篇文章是讲解tomcat启动框架的，还有篇文章是讲解TOMCAT里面的消息处理流程的细节的。 文章内容已经写好了， 现在正在整理阶段。 相信很快就可以做出来， 大家共同研究共同进步。
 这篇文章是独自分析TOMCAT<a href="http://www.2cto.com/ym" target="_blank">源码</a>所写的， 所以一定有地方是带有个人主观色彩， 难免会有片面之处。若有不当之处敬请批评指教，这样不仅可以使刚开始研究TOMCAT的兄弟们少走弯路， 我也可以学到东西。</p>
</li>
<li><p>tomcat源码分析(消息处理)</p>
</li>
</ol>
<p>[ZT]TOMCAT源码分析
0：前言
我们知道了tomcat的整体框架了， 也明白了里面都有些什么组件， 以及各个组件是干什么用的了。</p>
<p><a href="http://www.csdn.net/Develop/read_article.[asp](http://www.2cto.com/kf/web/asp/)?id=27225" target="_blank">http://www.csdn.net/Develop/read_article.[asp](http://www.2cto.com/kf/web/asp/)?id=27225</a></p>
<p>我想，接下来我们应该去了解一下tomcat 是如何处理<a href="http://www.2cto.com/kf/web/jsp/" target="_blank">jsp</a>和servlet请求的。</p>
<ol>
<li>我们以一个具体的例子，来跟踪TOMCAT， 看看它是如何把Request一层一层地递交给下一个容器， 并最后交给Wrapper来处理的。</li>
</ol>
<p>以<a href="http://localhost:8080/web/login.jsp为例子" target="_blank">http://localhost:8080/web/login.jsp为例子</a></p>
<p>（以下例子， 都是以tomcat4 源码为参考）</p>
<p>这篇心得主要分为3个部分： 前期， 中期， 和末期。</p>
<p>前期：讲解了在<a href="http://www.2cto.com/os/liulanqi/" target="_blank">浏览器</a>里面输入一个URL，是怎么被tomcat抓住的。</p>
<p>中期：讲解了被tomcat抓住后，又是怎么在各个容器里面穿梭， 最后到达最后的处理地点。</p>
<p>末期：讲解到达最后的处理地点后，又是怎么具体处理的。</p>
<p>2、  前期Request的born.</p>
<pre><code>在这里我先简单讲一下request这个东西。

 我们先看着这个URL：http://localhost:8080/web/login.jsp  它是动用了8080端口来进行socket通讯的。

 我们知道, 通过

   InputStream in = socket.getInputStream() 和

   OutputStream out = socket.getOutputStream()

 就可以实现消息的来来往往了。

 但是如果把Stream给应用层看，显然操作起来不方便。

 所以，在tomcat 的Connector里面，socket被封装成了Request和Response这两个对象。

 我们可以简单地把Request看成管发到服务器来的数据，把Response看成想发出服务器的数据。



 但是这样又有其他问题了啊？Request这个对象是把socket封装起来了， 但是他提供的又东西太多了。

 诸如Request.getAuthorization(), Request.getSocket()。  像Authorization这种东西开发人员拿来基本上用不太着，而像socket这种东西，暴露给开发 人员又有潜在的危险。 而且啊， 在Servlet Specification里面标准的通信类是ServletRequest和HttpServletRequest，而非这个Request类。So, So, So. Tomcat必须得捣持捣持Request才行。 最后tomcat选择了使用捣持模式（应该叫适配器模式）来解决这个问题。它把org.apache.catalina.Request 捣持成了org.apache.coyote.tomcat4.CoyoteRequest。 而CoyoteRequest又实现了ServletRequest和HttpServletRequest 这两种接口。 这样就提供给开发人员需要且刚刚需要的方法了。



ok, 让我们在tomcat的顶层容器- StandardEngin 的invoke()方法这里设置一个断点， 然后访问

http://localhost:8080/web/login.jsp ， 我们来看看在前期都会路过哪些地方：

   1. run(): 536, java.lang.Thread, Thread.java

   CurrentThread

  2.  run():666, org.apache.tomcat.util.threads.ThreadPool$ControlRunnable, ThreadPool.java

           ThreadPool

   3.  runIt():589, org.apache.tomcat.util.net.TcpWorkerThread, PoolTcpEndpoint.java

      ThreadWorker
</code></pre><ol>
<li>processConnection():  549</li>
</ol>
<p>org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler, Http11Protocol.java</p>
<pre><code>              http protocol parser

  5.  Process(): 781, org.apache.coyote.http11.Http11Processor, Http11Processor.java

      http request processor

   6. service(): 193, org.apache.coyote.tomcat4.CoyoteAdapter,CoyoteAdapter.java

      adapter

   7. invoke(): 995, org.apache.catalina.core.ContainerBase, ContainerBase.java
</code></pre><p>   StandardEngin</p>
<pre><code>1. 主线程

2. 启动线程池.

3. 调出线程池里面空闲的工作线程。

4. 把8080端口传过来由httpd协议封装的数据，解析成Request和Response对象。

5. 使用Http11Processor来处理request

6. 在Http11Processor里面， 又会call CoyoteAdapter来进行适配处理，把Request适配成实现了ServletRequest和HttpServletRequest接口的CoyoteRequest.
</code></pre><ol>
<li>到了这里，前期的去毛拔皮工作就基本上搞定，可以交给StandardEngin 做核心的处理工作了。</li>
</ol>
<ol>
<li><p>中期。 在各个容器间的穿梭。</p>
<p> Request在各个容器里面的穿梭大致是这样一种方式：</p>
<p> 每个容器里面都有一个管道（pipline）， 专门用来传送Request用的。</p>
<p> 管道里面又有好几个阀门（valve）， 专门用来过滤Request用的。</p>
<p> 在管道的低部通常都会放上一个默认的阀们。 这个阀们至少会做一件事情，就是把Request交给子容器。</p>
<p> 让我们来想象一下：</p>
<p>  当一个Request进入一个容器后， 它就在管道里面流动，波罗~ 波罗~ 波罗~ 地穿过各个阀门。在流到最后一个阀门的时候，吧唧~ 那个该死的阀门就把它扔给了子容器。 然后又开始 波罗~ 波罗~ 波罗~ ... 吧唧~....  波罗~  波罗~ 波罗~ ....吧唧~....</p>
<p> 就是通过这种方式，Request 走完了所有的容器。（ 感觉有点像消化系统，最后一个地方有点像那里~  ）</p>
<p> OK， 让我们具体看看都有些什么容器， 各个容器里面又都有些什么阀门，这些阀们都对我们的Request做了些什么吧：</p>
</li>
</ol>
<p>3.1 StandardEngin 的pipeline里面放的是：StandardEnginValve</p>
<p>在这里，VALVE做了三件事：</p>
<ol>
<li>验证传递过来的request是不是httpservletRequest.</li>
</ol>
<p>2    验证传递过来的request 是否携带了host header信息.</p>
<p>3    选择相应的host去处理它。（一般我们都只有一个host:localhost，也就是127.0.0.1）。</p>
<p>到了这个地方， 我们的request就已经完成了在Engin这个部分的历史使命， 通向前途未卜的下一站：host了。</p>
<p>3.2 StandardHost 的pipline里面放的是：StandardHostValve</p>
<ol>
<li><p>验证传递过来的request是不是httpservletRequest.</p>
</li>
<li><p>根据Request来确定哪个Context来处理。</p>
</li>
</ol>
<p>Context其实就是webapp， 比如<a href="http://localhost:8080/web/login.jsp" target="_blank">http://localhost:8080/web/login.jsp</a></p>
<p>这里web就是Context罗！</p>
<ol>
<li><p>既然确定了是哪个Context了，那么就应该把那个Context的classloader付给当前线程了。</p>
<p>   Thread.currentThread().setContextClassLoader(context.getLoader().getClassLoader());</p>
<p>这样request就只看得见指定的context下面的classes啊，jar啊这些， 而看不见tomcat本身的类， 什么Engin啊，Valve啊。 不然还得了啊！</p>
</li>
<li><p>既然request到了这里了，看来用户是准备访问web这个web app了，咋们得更新一下这个用户的session不是！Ok , 就由manager更新一下用户的session信息</p>
</li>
<li><p>交给具体的Context 容器去继续处理Request.</p>
</li>
<li><p>Context处理完毕了，把classloader还回来。</p>
</li>
</ol>
<p>3.3 StandardContext 的pipline里面放的是：StandardContextValve</p>
<ol>
<li><p>验证传递过来的request是不是httpservletRequest.</p>
</li>
<li><p>如果request意图不轨，想要访问/meta-inf, /web-inf这些目录下的东西，呵呵，没有用D!</p>
</li>
<li><p>这个时候就会根据Request到底是Servlet，还是jsp，还是静态资源来决定到底用哪种Wrapper来处理这个Reqeust了。</p>
</li>
<li><p>一旦决定了到底用哪种Wrapper，OK，交给那个Wrapper处理。</p>
</li>
</ol>
<ol>
<li>末期。 不同的需求是怎么处理的.</li>
</ol>
<p>StandardWrapper</p>
<p>之前对Wrapper没有做过讲解，其实它是这样一种东西。</p>
<p>我们在处理Request的时候，可以分成3种。</p>
<p>处理静态的：org.apache.catalina.servlets.DefaultServlet  </p>
<p>处理jsp的：org.apache.jasper.servlet.JspServlet</p>
<p>处理servlet的：org.apache.catalina.servlets.InvokerServlet</p>
<p>不同的request就用这3种不同的servlet去处理。</p>
<p>Wrapper就是对它们的一种简单的封装，有了Wrapper后，我们就可以轻松地拦截每次的Request。也可以容易地调用servlet的init()和destroy()方法， 便于管理嘛！</p>
<p>具体情况是这么滴：</p>
<p>   如果request是找jsp文件，StandardWrapper里面就会封装一个org.apache.jasper.servlet.JspServlet去处理它。</p>
<p>   如果request是找 静态资源 ，StandardWrapper里面就会封装一个org.apache.jasper.servlet.DefaultServlet  去处理它。</p>
<p>   如果request是找servlet ，StandardWrapper里面就会封装一个org.apache.jasper.servlet.InvokerServlet 去处理它。</p>
<p>StandardWrapper同样也是容器，既然是容器， 那么里面一定留了一个管道给request去穿，管道低部肯定也有一个阀门(注1)，用来做最后一道拦截工作.</p>
<p>在这最底部的阀门里，其实就主要做了两件事:</p>
<p>   一是启动过滤器，让request在N个过滤器里面筛一通，如果OK！ 那就PASS。 否则就跳到其他地方去了。</p>
<p>   二是servlet.service((HttpServletRequest) request,(HttpServletResponse) response); 这个方法.</p>
<pre><code> 如果是JspServlet， 那么先把jsp文件编译成servlet_xxx, 再invoke servlet_xxx的servie()方法。

 如果是DefaultServlet， 就直接找到静态资源，取出内容， 发送出去。

 如果是InvokerServlet， 就调用那个具体的servlet的service()方法。
</code></pre><p>   ok! 完毕。</p>
<p>注1: StandardWrapper 里面的阀门是最后一道关口了。 如果这个阀门欲意把request交给StandardWrapper 的子容器处理。 对不起， 在设计考虑的时候，Wrapper就被考虑成最末的一个容器， 压根儿就不会给Wrapper添加子容器的机会！ 如果硬是要调用addChild(), 立马抛出IllegalArgumentException！</p>
<p>参考：</p>
<pre><code> &lt;http://jakarta.apache.org/tomcat/&gt;;
</code></pre><p>   <a href="http://www.onjava.com/pub/a/onjava/2003/05/14/java_webserver.html" target="_blank">http://www.onjava.com/pub/a/onjava/2003/05/14/java_webserver.html</a>;</p>
<p><a href="http://www.2cto.com/os/201202/119145.html" target="_blank">http://www.2cto.com/os/201202/119145.html</a>
来源： <a href="[http://blog.csdn.net/haojun186/article/details/7464912](http://blog.csdn.net/haojun186/article/details/7464912)">[http://blog.csdn.net/haojun186/article/details/7464912](http://blog.csdn.net/haojun186/article/details/7464912)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/服务器/">服务器</a></li></span><span class="breadcrumb"><li><a href="/categories/服务器/">服务器</a></li><li><a href="/categories/服务器/tomcat/">tomcat</a></li></span></span> | <span class="tags">Tagged <a href="/tags/tomcat/" class="label label-primary">tomcat</a><a href="/tags/服务器/" class="label label-success">服务器</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:45"datetime="2014-03-07 09:54:45"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-服务器-tomcat--Tomcat源码分析/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-服务器-tomcat--Tomcat源码分析" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-服务器-tomcat--tomcat详解/">tomcat详解</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:45.000Z"> <a href="/2014/02/02/2014-02-02-服务器-tomcat--tomcat详解/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="tomcat-">tomcat详解</h1>
<p><strong>一、Tomcat简介</strong></p>
<hr>
<p><strong>1、Tomcat</strong></p>
<p>Tomcat在严格意义上并不是一个真正的应用服务器，它只是一个可以支持运行Serlvet/JSP的Web容器，不过Tomcat也扩展了一些应用服务器的功能，如JNDI，数据库连接池，用户事务处理等等。Tomcat是Apache组织下Jakarta项目下的一个子项目，目前Tomcat被非常广泛的应用在中小规模的Java Web应用中。</p>
<p>Tomcat 是一种具有JSP环境的Servlet容器。Servlet容器是代替用户管理和调用 Servlet的运行时外壳。作为一个开放源代码的软件， Jakarta -Tomcat有着自己独特的优势：</p>
<p>l         首先，它容易得到。事实上，任何人都可以从互联网上自由地下载这个软件。无论从<a href="http://jakarta.Apache.org还是从其他网站（Jakarta" target="_blank">http://jakarta.Apache.org还是从其他网站（Jakarta</a> Tomcat是Apache软件基金会开发的一个开放源码的应用服务器）。</p>
<p>l         其次，对于开发人员，特别是Java开发人员，Tomcat提供了全部的源代码，包括Servlet引擎、JSP引擎、HTTP服务器。无论是对哪一方面感兴趣的程序员，都可以从这些由世界顶尖的程序员书写的代码中获得收益。</p>
<p>l         最后，由于源代码的开放及世界上许多程序员的卓有成效的工作， Tomcat已经可以和大部分的主流服务器一起工作，而且是以相当高的效率一起工作。如：以模块的形式被载入Apache，以ISAPI形式被载入IIS或PWS，以NSAPI的形式被载入Netscape Enterprise Server。</p>
<p>l         由于Java的跨平台特性，基于Java的Tomcat也具有跨平台性。</p>
<hr>
<hr>
<p><strong>2、Tomcat5.0包含三个主要的部分</strong></p>
<p>包括：
/<em> Catalina - 一个符合Servlet API规范2.3的Servlet Container
/</em> Jasper - 一个符合JSP规范1.2的JSP编译器和运行环境
/* Webapps - Tomcat中包含的一些例子和用于测试的web例程，以及相关文档。</p>
<hr>
<hr>
<p><strong>3、应用服务器（如WebLogic）与Tomcat有何区别。</strong></p>
<pre><code>   应用服务器提供更多的J2EE特征，如EJB，JMS，JAAS等，同时也支持Jsp和Servlet。而Tomcat则功能没有那么强大，它不提供EJB等支持。但如果与JBoss（一个开源的应用服务器）集成到一块，则可以实现J2EE的全部功能。
</code></pre><hr>
<hr>
<p><strong>4、Tomcat 目录的结构</strong></p>
<hr>
<p><strong>（1）Tomcat的安装</strong></p>
<hr>
<pre><code>其实对于完全由Java写成的Tomcat，Win32版本和Linux版本没有多大区别，比如Linux版本，在Solaris下也没有问题。这里，主要以Win32版本作为示例。
</code></pre><p>注意：在安装使用Tomcat之前，先安装JDK，最好是Sun的JDK 1 .2 以上版。</p>
<hr>
<p><strong>（2）Tomcat的目录结构</strong></p>
<p>首先，下载jakarta-tomcat.zip包，解压缩到一个目录下，如：“c:/tomcat”。这时，会得到如下的Tomcat的目录结构：</p>
<ul>
<li><ul>
<li><ul>
<li>jakarta - tomcat</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>| - - - bin             Tomcat执行脚本目录</p>
<p>| - - - Common          放置一些通用类（如JDBC的驱动程序等）</p>
<p>| - - - conf               Tomcat配置文件</p>
<p>| - - - doc                 Tomcat文档</p>
<p>| - - - lib                 Tomcat运行需要的库文件（JARS）</p>
<p>| - - - logs               Tomcat执行时的LOG文件</p>
<p>| - - - src            Tomcat的源代码</p>
<p>| - - - webapps             Tomcat的主要Web发布目录（存放我们自己的JSP,SERVLET,类）</p>
<p>| - - - work            Tomcat的工作目录，Tomcat将翻译JSP文件到的Java文件和class文件放在这里。
<strong>目 录 名</strong></p>
<p><strong>该目录内的文件的一般功能描述</strong>bin</p>
<p>包含有Startup.bat（启动服务器）与shutdown.bat（关闭服务器）文件conf</p>
<p>包含设置部署在Tomcat上的Web应用的变量的初始值的设置文件，包括 <em>server.xml</em> (Tomcat的全局配置文件) 和 <em>web.xml</em> （为不同的Tomcat配置的web应用设置缺省值的文件）doc</p>
<p>包含关于Tomcat的各种各样的文档。common</p>
<p>在其lib目录下，主要存放如JDBC的驱动程序等lib</p>
<p>包含被Tomcat使用的各种各样的jar文件。在UNIX上，任何这个目录中的文件将被附加到Tomcat的classpath中。logs</p>
<p>Tomcat的log文件。src</p>
<p>servlet API的源文件。webapps</p>
<p>包含Web应用的程序 （JSP、Servlet和JavaBean等）work</p>
<p>由Tomcat自动生成，这是Tomcat放置它运行期间的中间(intermediate)文件(诸如编译的JSP文件)地方。 如果当Tomcat运行时，你删除了这个目录那么将不能够执行包含JSP的页面。</p>
<hr>
<p><strong>（3）、各个目录下所应该存放的文件：</strong>按照Tomcat的规范，Tomcat的Web应用程序应该由如下目录组成</p>
<pre><code>     页面内容等文件的存放位置：/*.html, /*.jsp等可以有许多目录层次，由用户的网站结构而定，实现的功能应该是网站的界面，也就是用户主要的可见部分。除了HTML文件、JSP文件外，还有js（JavaScript）文件和css（样式表）文件以及其他多媒体文件等。



     Web-INF/web.xml这是一个Web应用程序的描述文件。这个文件是一个XML文件，描述了Servlet和这个Web应用程序的其他组件信息，此外还包括一些初始化信息和安全约束等等。



    Web-INF/classes/这个目录及其下的子目录应该包括这个Web应用程序的所有JavaBean及Servlet等编译好的Java类文件（/*.class）文件，以及没有被压缩打入JAR包的其他class文件和相关资源。注意，在这个目录下的Java类应该按照其所属的包层次组织目录（即如果该/*.class文件具有包的定义，则该/*.class文件应该放在./WEB-INF/classes/包名下）。









    通常Web-INF/classes/这个目录下的类文件也可以打包成JAR文件,并可以放到WEB-INF下的lib目录下。如将 classes目录下的各个/*.class文件打包成WebMis.jar文件（jar cvf WebMis.jar /*./*）
</code></pre><p><strong>注意：</strong></p>
<p>（1）WEB-INF目录中包含应用软件所使用的资源，但是WEB-INF却不在公共文档根目录之中。在这个目录中所包含的文件都不能被客户机所访问。</p>
<p>（2）类目录中（在WEB-INF下）包含运行Web应用程序时所需的Servlets，Beans等类。</p>
<p>（3）lib目录（在WEB-INF下）包含有Java archive files (JARs)，例如标签库或者Servlets，Beans等类的/*.jar文件。</p>
<p>（4）如果一个类出现在JAR文件中同时也出现在类的目录中，类加载器会加载位于类目录中的那一个。</p>
<pre><code>     common/lib/ 这个目录下包含了所有压缩到JAR文件中的类文件和相关文件。比如：第三方提供的Java库文件、JDBC驱动程序等。

     其中msbase.jar、mssqlserver.jar、msutil.jar文件为SqlServer2000的JDBC驱动程序

     其中servlet-api.jar和jsp-api.jar为Servlet和JSP的API所在的包
</code></pre><p><strong>二、Tomcat的环境配置</strong></p>
<hr>
<hr>
<p><strong>1、启动Tomcat</strong></p>
<p>在Bin目录下，有一个名为startup.bat的脚本文件，执行这个脚本文件，就可以启动Tomcat服务器，不过，在启动服务器之前，还需要进行一些设置。</p>
<p>l         <strong>首先，设置系统的环境变量。</strong></p>
<pre><code>     **TOMCAT_HOME（或者：CATALINA_HOME）值：**
</code></pre><p>d:/jakarta-tomcat-5.0.16 (用TOMCAT_HOME指示Tomcat根目录，下面以Tomcat 5.0.16版为例)。</p>
<pre><code>     **JAVA_HOME值：**
</code></pre><p>c:/j2sdk1.4.0(用JAVA_HOME指示jdk1.4的安装目录)。</p>
<p><strong>注意</strong>：对于设置Windows的系统环境变量，可以打开控制面板中的“系统”程序；在“系统环境变量”中增加两个环境变量项目JAVA_HOME（最好为大写）指向JDK的目录和TOMCAT_HOME（最好为大写）指向所安装的tomcat的目录。</p>
<p><strong>2、启动和关闭Tomcat服务器</strong></p>
<p>（1）启动Tomcat服务器：执行在Bin目录下的名为startup.bat的脚本文件可以启动Tomcat服务器</p>
<p>现在可以运行TOMCAT并作为一个独立的Servlet容器。</p>
<hr>
<p><strong>（2）测试Tomcat的服务器启动与否：</strong></p>
<p>可以在浏览器中输入<a href="http://127.0.0.1:8080/index.html" target="_blank"><a href="http://127.0.0.1:8080/index.jsp">http://127.0.0.1:8080/index.jsp</a></a>，是否出现如下内容。</p>
<hr>
<hr>
<p><strong>（3）启动本站点的JSP页面：</strong>在Tomcat中的JSP文件和JavaBean程序的存放位置</p>
<pre><code>     JSP文件放在“Webapps/站点名称”的目录下

    自定义的JavaBean程序/*.java文件（可以不需要它）及/*.class类文件存放在“Webapps/站点名称/ WEB-INF/classes/”目录下****
</code></pre><p>因此，将/*.jsp文件拷贝到“TOMCAT_HOME/Webapps/站点名称”目录下，然后输入其URL地址</p>
<p><strong>（4）关闭Tomcat服务器：</strong>执行在Bin目录下的名为shutdown.bat的脚本文件可以终止Tomcat服务器。</p>
<hr>
<p><strong>三、配置Tomcat服务器</strong></p>
<hr>
<p><strong>1、概述</strong></p>
<p>Tomcat为用户提供了一系列的配置文件来帮助用户配置自己的Tomcat，Tomcat的配置文件主要是基于XML的；如server.xml、web.xml等，下面将详细讨论Tomcat的主要配置文件以及如何利用这些配置文件解决常见问题。</p>
<hr>
<p><strong>2、server.xml 主配置文件</strong></p>
<p>server.xml是Tomcat的主配置文件，主要完成如下两个目标：</p>
<pre><code>     提供Tomcat组件的初始配置；

     说明Tomcat的结构,含义,使得Tomcat通过实例化组件完成起动及构建自身。
</code></pre><p>观察<strong>server.xml</strong>，可以发现其中有如下的一些元素。</p>
<p>（1）Server元素：</p>
<p>Server元素是<strong>server.xml</strong>文件的最高级别的元素， Server元素描述一个Tomcat服务器，一般来说用户不用关心这个元素。一个Server元素一般会包括Logger和ContextManager两个元素</p>
<pre><code>     Logger：Logger元素定义了一个日志对象，一个日志对象包含有如下属性：
</code></pre><p>1) name：表示这个日志对象的名称。</p>
<p>2) path：表示这个日志对象包含的日志内容要输出到哪一个日志文件。</p>
<p>3) verbosityLevel：表示这个日志文件记录的日志的级别。</p>
<p>一般来说，Logger对象是对Java Servlet、JSP和Tomcat运行期事件的记录</p>
<pre><code>     ContextManager：ContextManager定义了一组ContextInterceptors（ContextManager的事件监听器） , RequestInterceptors（的事件监听器）、Contexts（Web应用程序的上下文目录）和它们的Connectors（连接器）的结构和配置。ContextManager包含如下一些属性：
</code></pre><p>1) debug：记录日志记录调试信息的等级。</p>
<p>2) home：webapps /、conf /、logs /和所有Context的根目录信息。这个属性的作用是从一个不同于TOMCAT _ HOME的目录启动Tomcat。</p>
<p>3) workDir：Tomcat工作目录。</p>
<p>ContextInterceptor 和RequestInterceptors两者都是监听ContextManager的特定事件的拦截器。ContextInterceptor监听Tomcat的启动和结束事件信息。而RequestInterceptors监听用户对服务器发出的请求信息。一般用户无需关心这些拦截器，对于开发人员需要了解这就是全局性的操作得以实现的方法</p>
<hr>
<p><strong>（2）Connector元素：</strong></p>
<p>Connector（连接器）元素描述了一个到用户的连接，不管是直接由Tomcat到用户的浏览器还是通过一个Web服务器。Tomcat的工作进程和由不同的用户建立的连接传来的读/写信息和请求/答复信息都是由连接器对象管理的。对连接器对象的配置中应当包含管理类、TCP/IP端口等内容。<em>**</em></p>
<hr>
<p><strong>（3）Context元素：</strong></p>
<p>每一个Context都描述了一个Tomcat的Web应用程序的目录。这个对象包含以下属性：</p>
<p>1)docBase。这是Context的目录。可以是绝对目录也可以是基于ContextManage的根目录的相对目录。</p>
<p>2)path。这是Context在Web服务时的虚拟目录位置和目录名。</p>
<p>3)debug。日志记录的调试信息记录等级。</p>
<p>4)reloadable。这是为了方便Servlet的开发人员而设置的，当这个属性开关打开的时候，Tomcat将检查Servlet是否被更新而决定是否自动重新载入它</p>
<p>3、<strong>配置实例</strong>：打开Tomcat下的conf文件夹下的server.xml文件</p>
<p>（1）改变Tomcat服务器的端口号</p>
<p>需要使用Connector 元素，Connector表示一个到用户的联接,不管是通过web服务器或直接到用户浏览器(在一个独立配置中)。Connector负责管理Tomcat的工作线程和读/写连接到不同用户的端口的请求/响应。Connector的配置包含如下信息：句柄类、句柄监听的TCP/IP端口、句柄服务器端口的TCP/IP的backlog。修改后，必须重新启动Tomcat的服务器。</p>
<p><strong>注意：</strong>可以将端口号改变为80，单要保证80端口没有被占用；另外，也可以同时分配两个端口号，只要产生两个Connector的配置信息。</p>
<p><strong>    <!-- Define a non-SSL Coyote HTTP/1.1 Connector on port 8080 --></strong></p>
<p><strong>   &lt;Connector port=&quot;8080&quot;    maxThreads=&quot;150&quot; minSpareThreads=&quot;25&quot; maxSpareThreads=&quot;75&quot;</strong></p>
<p><strong>     enableLookups=&quot;false&quot; redirectPort=&quot;8443&quot; acceptCount=&quot;100&quot;  debug=&quot;0&quot; connectionTimeout=&quot;20000&quot;  disableUploadTimeout=&quot;true&quot; /&gt;</strong></p>
<hr>
<p><strong>    <!-- Define a non-SSL Coyote HTTP/1.1 Connector on port 8000 --></strong></p>
<p><strong>    &lt;Connector port=&quot;8000&quot;    maxThreads=&quot;150&quot; minSpareThreads=&quot;25&quot; maxSpareThreads=&quot;75&quot;</strong></p>
<p><strong>enableLookups=&quot;false&quot; redirectPort=&quot;8443&quot; acceptCount=&quot;100&quot;  debug=&quot;0&quot; connectionTimeout=&quot;20000&quot;  disableUploadTimeout=&quot;true&quot; /&gt;</strong></p>
<p>（2）增加新的虚拟目录并指向物理目录</p>
<p>设立一个虚拟工作目录是比较简单的，只需要在server.xml文件中添加一个Context对象就可以了。如，要在webapps/下增加一个WebMis文件夹以存放jsp页面文件，并且让用户可以使用<a href="http://127.0.0.1:8080/WebMis虚拟目录访问，则：需要使用Context" target="_blank">http://127.0.0.1:8080/WebMis虚拟目录访问，则：需要使用Context</a> 元素，每个Context提供一个指向你放置你Web项目的Tomcat的下属目录。每个Context包含如下配置：  </p>
<p>l         Context放置的路径，可以是与ContextManager主目录相关的路径；</p>
<p>l         纪录调试信息的调试级别；</p>
<p>l         可重载的标志，开发Servlet时，重载更改后的Servlet。这是一个非常便利的特性,你可以调试或用Tomcat测试新代码而不用停止或重新启动Tomcat。要打开重载,把reloadable设为true即可。</p>
<p>其中：path=&quot;/WebMis&quot;说明其相对web URL的路径，是一个虚拟的路径，如：<a href="http://127.0.0.1:8080/WebMis" target="_blank"><a href="http://127.0.0.1:8080/WebMis">http://127.0.0.1:8080/WebMis</a></a>，docBase=&quot;WebMis&quot;说明其相对webapps的位置，是物理存在的目录，同时需要在webapps/下增加一个WebMis物理文件夹。</p>
<p>（3）       加入自己的日志文件</p>
<p>添加Logger对象就可以加入自己的日志文件，添加工作相当简单，只需要将作为示例的Logger对象复制一份，然后修改一下前面介绍的几个属性就可以了。在设定了Logger以后，就可以在自己的Servlet中使用ServletContext.log()方法来建立自己的日志文件。</p>
<p>4、<strong>配置实例</strong>：打开conf文件夹下的web.xml文件</p>
<p>（1）web.xml文件：它包含了描述整个Web应用程序（Web应用程序由一整套Web文件jsp、servlet、html、jpg、gif、class等组成）的信息。下面以一个web.xml文件为例，讲解里面的各个对象。</p>
<p>&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN&quot;</p>
<p>&quot;<a href="http://java.sun.com/j2ee/dtds/web-app_2_2.dtd&quot;&gt;" target="_blank">http://java.sun.com/j2ee/dtds/web-app_2_2.dtd&quot;&gt;</a></p>
<web-app>

<p><display-name>My Web Application</display-name></p>
<description>在这里加入Web应用程序的描述信息</description>

<p>&lt;!-</p>
<p>下面定义了Web应用程序的初始化参数，在JSP或Servlet文件中使用下面的语句</p>
<p>来得到初始化参数</p>
<p>String value =</p>
<p>getServletContext().getInitParameter(&quot;name&quot;);</p>
<p>这里可以定义任意多的初始化参数</p>
<p>--&gt;</p>
<context-param>

<p><param-name>webmaster</param-name></p>
<p><param-value>myaddress@mycompany.com</param-value></p>
<description>这里包含了初始化参数的描述</description>

<p></context-param></p>
<p>&lt;!-</p>
<p>下面的定义描述了组成这个Web应用程序的Servlet，还包含初始化参数。在Tomcat中，也可以将放在Web-INF/classes中的Servlet直接以servlet/Servlet名访问，但是一般来说，不推荐这样使用。而且这样的使用方法还会导致Servlet的相关资源组织的复杂性。所以一般来说推荐将所有的Servlet在这里定义出来。初始化参数可以在Servlet中使用如下语句来获得：</p>
<p>String value =getServletConfig().getInitParameter(&quot;name&quot;);</p>
<p>--&gt;</p>
<servlet>

<servlet-name>controller</servlet-name>

<description>这里加入这个Servlet的描述</description>

<servlet-class>com.mycompany.mypackage.ControllerServlet</servlet-class>

<strong><init-param></strong>

<strong><param-name>listOrders</paramName></strong>

<strong><param-value>com.mycompany.myactions.ListOrdersAction</param-value></strong>

<strong></init-param></strong>

<init-param>

<param-name>saveCustomer</paramName>

<param-value>com.mycompany.myactions.SaveCustomerAction</param-value>

</init-param>

&lt;!-

服务器启动后这个Servlet加载的时间

--&gt;

<load-on-startup>5</load-on-startup>

</servlet>

<servlet>

<servlet-name>graph</servlet-name>

<description>这个Servlet的描述</description>

</servlet>

<p>&lt;!-</p>
<p>Servlet映射对应了一个特殊的URI请求到一个特殊的Servlet的关系</p>
<p>--&gt;</p>
<servlet-mapping>

<p><servlet-name>controller</servlet-name></p>
<p><url-pattern>/*.do</url-pattern></p>
<p></servlet-mapping></p>
<servlet-mapping>

<p><servlet-name>graph</servlet-name></p>
<p><url-pattern>/graph</url-pattern></p>
<p></servlet-mapping></p>
<p>&lt;!-</p>
<p>设定缺省的Session过期时间（单位为分）</p>
<p>--&gt;</p>
<session-config>

<p><session-timeout>30</session-timeout></p>
<p></session-config></p>
<p></web-app><em>**</em></p>
<p><strong>（2）配置实例：会话(session)超时修改，</strong>修改conf/web.xml中的如下数据值（单位为分）</p>
<p><strong>5、在Tomcat中实现利用JDBC驱动程序访问SQLServer2000数据库</strong></p>
<p>只需要将SQLServer2000的JDBC驱动程序的三个/<em>.jar（msbase.jar、mssqlserver.jar和msutil.jar）文件放在/common/lib目录下，然后在/</em>.java程序中访问它。</p>
<p><strong>四、在Tomcat5中配置连接池和数据源</strong></p>
<hr>
<p><strong>1、DataSource接口介绍</strong></p>
<hr>
<p><strong>（1）DataSource 概述</strong></p>
<p>JDBC1.0原来是用DriverManager类来产生一个对数据源的连接。JDBC2.0用一种替代的方法，使用DataSource的实现，代码变的更小巧精致，也更容易控制。</p>
<p>一个DataSource对象代表了一个真正的数据源。根据DataSource的实现方法，数据源既可以是从关系数据库，也电子表格，还可以是一个表格形式的文件。当一个DataSource对象注册到名字服务中（JNDI），应用程序就可以通过名字服务获得DataSource对象，并用它来产生一个与DataSource代表的数据源之间的连接。</p>
<p>javax.sql包中的DataSource接口，可以采用三种实现形式：简单的实现（只提供Connection对象）、连接池形式的实现和分布式事务形式的实现。</p>
<p>javax.sql包中的ConnectionPoolDataSource提供对连接池实现的接口。</p>
<p><strong>（2）使用DataSource的优点</strong></p>
<p>l         DataSource与DriverManager的不同</p>
<p>关于数据源的信息和如何来定位数据源，例如数据库服务器的名字，在哪台机器上，端口号等等，都包含在DataSource对象的属性里面去了。这样，对应用程序的设计来说是更方便了，因为并不需要硬性的把驱动的名字写死到程序里面去。通常驱动名字中都包含了驱动提供商的名字，而在DriverManager类中通常是这么做的。</p>
<p>l         可移植性</p>
<p>如果数据源要移植到另一个数据库驱动中，代码也很容易做修改。所需要做的修改只是更改DataSource的相关的属性。而使用DataSource对象的代码不需要做任何改动。</p>
<p><strong>（3）配置DataSource</strong></p>
<p>主要包括设定DataSource的属性，然后将它注册到JNDI名字服务中去。在注册DataSource对象的的过程中，系统管理员需要把DataSource对象和一个逻辑名字关联起来。名字可以是任意的，通常取成能代表数据源并且容易记住的名字。</p>
<p>在下面的例子中，名字起为：WebMisDB，按照惯例，逻辑名字通常都在jdbc的子上下文中。这样，逻辑名字的全名就是：jdbc/WebMisDB。</p>
<p><strong>（4）产生一个与数据源的连接</strong></p>
<p>一旦配置好了数据源对象，应用程序设计者就可以用它来产生一个与数据源的连接。下面的代码片段示例了如何用JNDI上下文获得一个数据源对象，然后如何用数据源对象产生一个与数据源的连接。开始的两行用的是JNDI API，第三行用的才是JDBC的API： 
Context ctx = new InitialContext(); </p>
<p>DataSource ds = (DataSource)ctx.lookup(&quot;jdbc/WebMisDB&quot;);</p>
<p>Connection con = ds.getConnection(&quot;myPassword&quot;, &quot;myUserName&quot;); 
在一个基本的DataSource实现中，DataSource.getConnection方法返回的Connection对象和用DriverManager.getConnection方法返回的Connection对象是一样的。因为DataSource提供的方便性，我们推荐使用DataSource对象来得到一个Connection对象。</p>
<p><strong>（5）DataSource的应用场合</strong></p>
<p>对于普通的应用程序设计者，是否使用DataSource对象只是一个选择问题。但是，对于那些需要用的连接池或者分布式的事务的应用程序设计者来说，就必须使用DataSource对象来获得Connection。需要注意的是对Tomcat而言，在JNDI的名称前面应该加上&quot;java:comp/env/&quot; </p>
<p><strong>（6）数据源（DataSource）的作用</strong></p>
<p>它相当于客户端程序和连接池的中介，想要获得连接池中的连接对象，必须建立一个与该连接池相应的数据源，然后通过该数据源获得连接。</p>
<p><strong>2、JNDI（</strong>JAVA NAMING AND DIRECTORY INTERFACE---Java 命名和目录接口<strong>）</strong></p>
<p><strong>（1）</strong>JNDI简介<em>**</em></p>
<p>分布式计算环境通常使用命名和目录服务来获取共享的组件和资源。命名和目录服务将名称与位置、服务、信息和资源关联起来。它是一个为JAVA应用程序提供命名服务的应用程序编程接口（API）。</p>
<p>命名服务提供了一种为对象命名的机制，这样你就可以在无需知道对象位置的情况下获取和使用对象。只要该对象在命名服务器上注册过，且你必须知道命名服务器的地址和该对象在命名服务器上注册的JNDI名。就可以找到该对象，获得其引用，从而运用它提供的服务。</p>
<p>命名服务提供名称—对象的映射。目录服务提供有关对象的信息，并提供定位这些对象所需的搜索工具。</p>
<p>Java 命名和目录接口或 JNDI 提供了一个用于访问不同的命名和目录服务的公共接口（JAVA API）。运用一个命名服务来查找与一个特定名字相关的一个对象，JDBC可以用JNDI来访问一个关系数据库。</p>
<p><strong>（2）获得JNDI的初始环境</strong></p>
<p>在JNDI中，在目录结构中的每一个结点称为Context 。每一个JNDI名字都是相对于Context 的。这里没有绝对名字的概念存在。对一个应用来说，它可以通过使用InitialContext 类来得到其第一个Context：</p>
<p>Context  ctx = new InitialContext ();</p>
<p>应用可以通过这个初始化的Context经由这个目录树来定位它所需要的资源或对象。InitialContext在网页应用程序初始化时被设置，用来支持网页应用程序组件。所有的入口和资源都放在JNDI命名空间里的java:comp/env段里。</p>
<p><strong>（3）查找已绑定的对象</strong></p>
<p>用ctx..lookup(String name); 根据name找对象</p>
<p>例：</p>
<p>import javax.naming./*;</p>
<p>public class TestJNDI</p>
<p>{    </p>
<p>public static void main(String[] args)</p>
<p>{</p>
<pre><code>    try
</code></pre><p>{</p>
<pre><code>    Context ctx=new InitialContext();

    Object object=ctx.lookup(“JNDIName”);       //根据JNDI名查找绑定的对象

    String str=(String) object;                                 //强制转换

    }
</code></pre><p>catch(NamingException e)</p>
<p>{    e.printStackTrace();</p>
<pre><code>    }
</code></pre><p>catch(ClassCastException e)</p>
<p>{    e.printStackTrace();</p>
<pre><code>    }
</code></pre><p>   }</p>
<p>}<em>**</em></p>
<hr>
<p><strong>3、数据库连接池技术</strong></p>
<hr>
<p><strong>（1）</strong>传统的Web数据库编程模式</p>
<p>l         在主程序（如Servlet、Beans）中建立数据库连接。</p>
<p>l         进行SQL操作，取出数据。</p>
<p>l         断开数据库连接。</p>
<p>使用这种模式开发，存在很多问题。</p>
<p>l         首先，我们要为每一次WEB请求（例如察看某一篇文章的内容）建立一次数据库连接，对于一次或几次操作来讲，或许你觉察不到系统的开销，但是，对于WEB程序来讲，即使在某一较短的时间段内，其操作请求数也远远不是一两次，而是数十上百次（想想全世界的网友都有可能在您的网页上查找资料），在这种情况下，系统开销是相当大的。事实上，在一个基于数据库的WEB系统中，建立数据库连接的操作将是系统中代价最大的操作之一。很多时候，可能您的网站速度瓶颈就在于此。</p>
<p>l         其次，使用传统的模式，你必须去管理每一个连接，确保他们能被正确关闭，如果出现程序异常而导致某些连接未能关闭，将导致数据库系统中的内存泄露，最终我们将不得不重启数据库。<em>**</em></p>
<p>l         频繁的建立、关闭连接，会极大的减低系统的性能，因为对于连接的使用成了系统性能的瓶颈。<em>**</em></p>
<hr>
<p><strong>（2）数据库连接是一种关键的有限的昂贵的资源</strong></p>
<p>这一点在多用户的网页应用程序中体现得尤为突出。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正是针对这个问题提出来的。</p>
<p>连接池是这么一种机制，当应用程序关闭一个Connection的时候，这个连接被回收，而不是被destroy，因为建立一个连接是一个很费资源的操作。如果能把回收的连接重新利用，会减少新创建连接的数目，显著的提高运行的性能。该策略的核心思想是：连接复用。</p>
<p>通过采用连接池的方法，服务器在启动时先打开一定数量的连接。当应用需要连接时，就可以从服务器请求一个连接。当应用结束该连接时，服务器就把它释放到连接池，以备其他客户机使用。
客户获得连接并访问数据库以后结束客户获得连接并访问数据库以后结束客户获得连接并访问数据库以后结束开始停止服务吗</p>
<p>？产生新的连接等待引入的连接结束是服务器监听客户的连接请求                    客户获得连接</p>
<p><strong>（3）连接池的主要作用</strong></p>
<p>l         减少了建立和释放数据库连接的消耗</p>
<p>l         数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而再不是重新建立一个；</p>
<p>l         释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。</p>
<p>l         封装用户信息  使用连接池可以封装连接数据库系统所用的用户信息（帐号和密码），这样客户端程序在建立连接时不用考虑安全信息。</p>
<p><strong>（4）数据库连接池的工作原理</strong></p>
<pre><code>   当程序中需要建立数据库连接时，只须从内存中取一个来用而不用新建。同样，使用完毕后，只需放回内存即可。而连接的建立、断开都有连接池自身来管理。同时，我们还可以通过设置连接池的参数来控制连接池中的连接数、每个连接的最大使用次数等等
</code></pre><p><strong>（5）数据库连接池的最小连接数和最大连接数</strong></p>
<p>数据库连接池的最小连接数和最大连接数的设置要考虑到下列几个因素：</p>
<p>l         最小连接数是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费；</p>
<p>l         最大连接数是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，这会影响之后的数据库操作。</p>
<p>如果最小连接数与最大连接数相差太大，那么最先的连接请求将会获利，之后超过最小连接数量的连接请求等价于建立一个新的数据库连接。不过，这些大于最小连接数的数据库连接在使用完不会马上被释放，它将被放到连接池中等待重复使用或是空闲超时后被释放。</p>
<p><strong>（6）使用连接池得到连接</strong>
假设应用程序需要建立到一个名字为EmpolyeeDB的DataSource的连接。使用连接池得到连接的代码如下： 
Context ctx = new InitialContext(); </p>
<p>DataSource ds = (DataSource)ctx.lookup(&quot;jdbc/EmployeeDB&quot;);</p>
<p>Connection con = ds.getConnection(&quot;myPassword&quot;, &quot;myUserName&quot;);</p>
<p>或者：</p>
<p>Context ctx = new InitialContext(); </p>
<p>ConnectionPoolDataSource ds = (ConnectionPoolDataSource)ctx.lookup(&quot;jdbc/EmployeeDB&quot;);</p>
<p>PooledConnection con = ds.getConnection(&quot;myPassword&quot;, &quot;myUserName&quot;);</p>
<p>是否使用连接池获得一个连接，在应用程序的代码上是看不出不同的。在使用这个Connection连接上也没有什么不一样的地方，唯一的不同是在java的finally语句块中来关闭一个连接。在finally中关闭连接是一个好的编程习惯。这样，即使方法抛出异常，Connection也会被关闭并回收到连接池中去。代码应该如下所示： 
try</p>
<p>{… 
}</p>
<p>catch（）</p>
<p>{… 
}</p>
<p>finally</p>
<p>{ </p>
<p>if（con!=null）</p>
<p>con.close();</p>
<p>}<em>**</em></p>
<hr>
<p><strong>4、在Tomcat中配置数据库的连接池</strong></p>
<hr>
<p><strong>（1）连接池配置(Database Connection Pool (DBCP) Configurations)</strong></p>
<p>DBCP使用的是Jakarta-Commons Database Connection Pool 要使用连接池需要如下的组件即jar文件。</p>
<p>l         Jakarta-Commons DBCP 1.1 对应commons-dbcp-1.1.jar。</p>
<p>l         Jakarta-Commons Collections 2.0 对应commons-collections.jar。</p>
<p>l         Jakarta-Commons Pool 1.1 对应commons-pool-1.1.jar。</p>
<p>这三个jar文件要与你的JDBC驱动程序一起放到【TOMCAT_HOME】/common/lib目录下以便让tomcat和你的web应用都能够找到。</p>
<hr>
<p><strong>注：</strong></p>
<p>l         这三个jar文件是默认存在与【TOMCAT_HOME】/common/lib下的。</p>
<p>l         需要注意的地方：第三方的驱动程序或者其他类只能以/<em>.jar的形式放到Tomcat的common/lib目录中,因为Tomcat只把/</em>.jar文件加到CLASSPATH中。</p>
<p>l         不要把上诉三个文件放到WEB-INF/lib或者其他地方因为这样会引起混淆。<em>**</em></p>
<hr>
<p><strong>（2）通过配置阻止连接池漏洞</strong></p>
<p>数据库连接池创建和管理连接池中建立好的数据库连接，循环使用这些连接以得到更好的效率。这样比始终为一个用户保持一个连接和为用户的请求频繁的建立和销毁数据库连接要高效的多。</p>
<p>这样就有一个问题出现了，一个Web应用程序必须显示的释放ResultSet，Statement和Connection。如果在关闭这些资源的过程中失败将导致这些资源永远不在可用，这就是所谓的连接池漏洞。这个漏洞最终会导致连接池中所有的连接不可用。</p>
<p>通过配置Jakarta Common DBCP可以跟踪和恢复那些被遗弃的数据库连接。</p>
<p>以下是一系列相关配置：</p>
<p>l         通过配置DBCP数据源中的参数removeAbandoned来保证删除被遗弃的连接使其可以被重新利用。</p>
<p>为ResourceParams(见下文的数据源配置)标签添加参数removeAbandoned</p>
<parameter>

<name>removeAbandoned</name>

<value>true</value>

</parameter>

<p>通过这样配置的以后当连接池中的有效连接接近用完时DBCP将试图恢复和重用被遗弃的连接。这个参数的值默认是false。</p>
<p>l         通过设置removeAbandonedTimeout来设置被遗弃的连接的超时的时间，即当一个连接连接被遗弃的时间超过设置的时间时那么它会自动转换成可利用的连接。</p>
<pre><code>&lt;parameter&gt;

 &lt;name&gt;removeAbandonedTimeout&lt;/name&gt;

 &lt;value&gt;60&lt;/value&gt;

 &lt;/parameter&gt;

默认的超时时间是300秒。
</code></pre><p>l         设置logAbandoned参数，以将被遗弃的数据库连接的回收记入日志中</p>
<parameter>

<name>logAbandoned</name>

<value>true</value>

</parameter>

<p>这个参数默认为false。<em>**</em></p>
<p><strong>（3）修改server.xml文件</strong></p>
<pre><code>   &lt;Context path=&quot;/WebMis&quot; docBase=&quot;WebMis&quot; debug=&quot;0&quot; reloadable=&quot;true&quot;&gt;



               &lt;Resource name=&quot;jdbc/webmis&quot; auth=&quot;Container&quot; type=&quot;javax.sql.DataSource&quot;/&gt;  

               &lt;ResourceParams** name=&quot;jdbc/webmis&quot;**&gt;      

                             &lt;parameter&gt;             

                                     &lt;name&gt;

                                            factory

                                     &lt;/name&gt;        

                                     &lt;value&gt;org.apache.commons.dbcp.BasicDataSourceFactory

                                     &lt;/value&gt;        

                          &lt;/parameter&gt;

                          &lt;parameter&gt;             

                                   &lt;name&gt;

                                          driverClassName

                                   &lt;/name&gt;        

                                     &lt;value&gt;**com.microsoft.jdbc.sqlserver.SQLServerDriver**

                                     &lt;/value&gt;        

                              &lt;/parameter&gt;

                             &lt;parameter&gt;      

                                     &lt;name&gt;

                                            url

                                     &lt;/name&gt;        

                           &lt;value&gt;**jdbc:microsoft:sqlserver://127.0.0.1:1433;DatabaseName=DataBase**

                          &lt;/value&gt;

                             &lt;/parameter&gt;            

                             &lt;parameter&gt;

                                        &lt;name&gt;

                                               username

                                         &lt;/name&gt;             

                                     &lt;value&gt;

                                          **sa**

                                     &lt;/value&gt;

                            &lt;/parameter&gt;            

                             &lt;parameter&gt;

                                        &lt;name&gt;

                                               password

                                        &lt;/name&gt;

                                        &lt;value&gt;
</code></pre><p>maxActive 连接池的最大数据库连接数。设为0表示无限制。                                            </value> </p>
<pre><code>                             &lt;/parameter&gt;            

                             &lt;parameter&gt;



                                        &lt;name&gt;

                                               maxActive

                                        &lt;/name&gt;

                                        &lt;value&gt;

                                               20
</code></pre><p>回收被遗弃的（一般是忘了释放的）数据库连接到连接池中，设为－1表示无限制。maxIdle  数据库连接的最大空闲时间。超过此空闲时间，数据库连接将被标记为不可用，然后被释放。设为0表示无限制。                                            </value></p>
<pre><code>                             &lt;/parameter&gt;

                             &lt;parameter&gt;             

                                    &lt;name&gt;

                                             maxIdle

                                      &lt;/name&gt;
</code></pre><p>maxWait 最大建立连接等待时间。如果超过此时间将接到异常。设为－1表示无限制。                                        <value>10</value></p>
<pre><code>                            &lt;/parameter&gt;

                            &lt;parameter&gt;

                                        &lt;name&gt;maxWait&lt;/name&gt;

                                        &lt;value&gt;-1&lt;/value&gt;

                          &lt;/parameter&gt; 
</code></pre><parameter>
  <name>removeAbandoned</name>
  <!-- Abandoned DB connections are removed and recycled -->
  <value>true</value>
 </parameter>
 <parameter>
  <name>removeAbandonedTimeout</name>
  <!-- Use the removeAbandonedTimeout parameter to set the number of seconds a DB connection has been idle before it is considered abandoned.  -->
  <value>60</value>
 </parameter>
 <parameter>
  <name>logAbandoned</name>
  <!-- Log a stack trace of the code which abandoned -->
  <value>false</value>
 </parameter>    

<p>数据库连接过多长时间不用将被视为被遗弃而收回连接池中将被遗弃的数据库连接的回收记入日志                   </ResourceParams></p>
<pre><code>          &lt;/Context&gt;
</code></pre><p>注意：</p>
<p>l         所有的入口和资源都放在JNDI命名空间里的java:comp/env段里</p>
<p>l         设置JNDI资源要在$CATALINA_HOME/conf/server.xml文件里使用下列标志符：
1) <Resource>--设置应用程序可用的资源的名字和类型（同上面说的<resource-ref>等价）。
2) <ResourceParams>--设置Java资源类工厂的名称或将用的JavaBean属性。
上述这些标志符必须放在<Context>和</Context>之间</p>
<hr>
<p><strong>（2）、拷贝SQLServer的JDBC驱动程序到Tomcat的/common/lib目录下</strong></p>
<hr>
<p><strong>（3）、在程序中利用数据源来访问数据库</strong></p>
<pre><code>          try

          {

                 Context initCtx = new InitialContext();

               Context envCtx = (Context) initCtx.lookup(&quot;java:comp/env&quot;);

            DataSource ds = (DataSource)envCtx.lookup(&quot;jdbc/webmis&quot;);

             Connection con=ds.getConnection();

      }

    catch (NamingException e)

       {

               e.printStackTrace();

        }

        catch (SQLException e)

       {

               e.printStackTrace();

         }
</code></pre><hr>
<p><strong>5、在server.xml文件中与数据源的描述相关的标签含义</strong></p>
<p>l         maxActive 连接池的最大数据库连接数。设为0表示无限制。<em>**</em></p>
<p>l         maxIdle  数据库连接的最大空闲时间。超过此空闲时间，数据库连接将被标记为不可用，然后被释放。设为0表示无限制。<em>**</em></p>
<p>l         maxWait 最大建立连接等待时间。如果超过此时间将接到异常。设为－1表示无限制。<em>**</em></p>
<p>l         removeAbandoned 回收被遗弃的（一般是忘了释放的）数据库连接到连接池中。<em>**</em></p>
<p>l         removeAbandonedTimeout 数据库连接过多长时间不用将被视为被遗弃而收回连接池中。<em>**</em></p>
<p>l         logAbandoned 将被遗弃的数据库连接的回收记入日志。<em>**</em></p>
<p>l         driverClassName JDBC驱动程序。<em>**</em></p>
<p>l         url   数据库DSN连接字符串<em>**</em></p>
<p><strong>6**</strong>、在Web应用的web.xml文件中引用该资源**</p>
<p>将下面的标签放在放在<web-app>和</web-app>中间</p>
<p><strong><!-- Database Config start --></strong></p>
<p><strong><resource-ref></strong></p>
<p><strong><description>connectDB test</description></strong></p>
<p><strong><res-ref-name>jdbc/webmis</res-ref-name></strong></p>
<p><strong><res-type>javax.sql.DataSource</res-type></strong></p>
<p><strong><res-auth>Container</res-auth></strong></p>
<p><strong></resource-ref></strong></p>
<p><strong><!-- Database Config end --></strong></p>
<p><strong>4，综合配置实例</strong></p>
<p>首先在C:根目录下建立文件夹mywebapp，作为一个虚拟目录的位置。</p>
<p>建立一个Sql Server数据库DataBonus</p>
<p>找到C:/jakarta-tomcat-5.0.19/conf/server.xml，打开。</p>
<p>加入：</p>
 <Context path="/mywebapp" docBase="C:/mywebapp" debug="0" reloadable="true">



       <Resource name="jdbc/mybonusds" auth="Container" type="javax.sql.DataSource"/><br>
<ResourceParams name="jdbc/mybonusds"><br>
              <parameter><br>
                 <name>factory</name><br>
                 <value>org.apache.commons.dbcp.BasicDataSourceFactory</value><br>
              </parameter>

              <parameter><br>
                 <name>driverClassName</name><br>
                 <value>com.microsoft.jdbc.sqlserver.SQLServerDriver</value><br>
              </parameter>

              <parameter><br>
                  <name>url</name><br>
                  <value>

jdbc:microsoft:sqlserver://127.0.0.1:1433;DatabaseName=DataBonus

                   </value>

               </parameter><br>
               <parameter>

                 <name>username</name><br>
                 <value>sa</value>

                </parameter><br>
                <parameter>

                   <name>password</name>

                   <value></value><br>
                </parameter><br>
                <parameter>

<name>maxActive</name>

                    <value>20</value>

                </parameter>

                <parameter><br>
                   <name>maxIdle</name>

                   <value>10</value>

                </parameter>

                <parameter><br>
                   <name>maxWait</name>

                   <value>-1</value>

                </parameter><br>
<parameter>

             <name>removeAbandoned</name>

             <!-- Abandoned DB connections are removed and recycled -->

             <value>true</value>

          </parameter>

          <parameter>

              <name>removeAbandonedTimeout</name>

  <!-- Use the removeAbandonedTimeout parameter to set the number of seconds a DB connection has been idle before it is considered abandoned.  -->

              <value>60</value>

           </parameter>

           <parameter>

              <name>logAbandoned</name>

            <!-- Log a stack trace of the code which abandoned -->

              <value>false</value>

           </parameter><br>
         </ResourceParams>

</Context>



<p>   做一个JSP页面index.jsp放到mywebapp下面，代码：</p>
<p>&lt;%--字符集设为&quot;gb2312&quot;,使动态页面支持中文--%&gt;</p>
<p>&lt;%@ page contentType=&quot;text/html; charset=GB2312&quot;%&gt;</p>
<!-- 这里使用一个字串变量 ("PAGETITLE") 保持题目和主标题的一致性。-->

<html>

<head>

<title>

&lt;%= pagetitle %&gt;

</title>

</head>



<body bgcolor=/#FFFFFF>



<font face="Helvetica">



<h2>

<font color=/#DB1260>

&lt;%= pagetitle %&gt;

</font>

</h2>



<!-- 导入必要的类和类库 -->



&lt;%@ page import=&quot;

    javax.naming./<em>,

    java.sql./</em>,

    javax.sql.DataSource

&quot;%&gt;



<!-- 声明一个类方法 -->



&lt;%!

//声明变量

//标题

  String pagetitle = &quot;这是JSP调用数据库的例子&quot;;



%&gt;



<!-- 下面这些代码将被插入到servlet中 -->



&lt;%



   java.sql.Connection conn= null;

   java.sql.Statement stmt =null;

   java.sql.ResultSet rs=null;



  try {

    // 通过JNDI获取主接口



     Context initCtx = new InitialContext();

     Context envCtx = (Context) initCtx.lookup(&quot;java:comp/env&quot;);

     DataSource ds = (DataSource)envCtx.lookup(&quot;jdbc/mybonusds&quot;);

     conn=ds.getConnection();



      stmt = conn.createStatement();





           //执行SQL语句

      stmt.execute(&quot;select /* from 奖金&quot;);

    //取得结果集

      rs = stmt.getResultSet();



    %&gt;



  <table border="1">

   <tr>

      <td width="60" height="20">&lt;% out.print(&quot;编号&quot;); %&gt;</td>

      <td width="80" height="20">&lt;% out.print(&quot;姓名&quot;); %&gt;</td>

      <td width="200" height="20">&lt;% out.print(&quot;发奖名称&quot;); %&gt;</td>

      <td width="100" height="20">&lt;% out.print(&quot;金额&quot;); %&gt;</td>

      <td width="200" height="20">&lt;% out.print(&quot;备注&quot;); %&gt;</td>

   </tr>

  &lt;%   while (rs.next()) {



  %&gt;

    <tr>

      <td width="60" height="20">&lt;% out.print(rs.getString(&quot;编号&quot;)); %&gt;</td>

      <td width="80" height="20">&lt;% out.print(rs.getString(&quot;姓名&quot;)); %&gt;</td>

      <td width="200" height="20">&lt;% out.print(rs.getString(&quot;发奖名称&quot;)); %&gt;</td>

      <td width="100" height="20">&lt;% out.print(rs.getString(&quot;金额&quot;)); %&gt;</td>

      <td width="200" height="20">&lt;% out.print(rs.getString(&quot;备注&quot;)); %&gt;</td>

   </tr>

     &lt;%  } %&gt;

  </table>





&lt;%

 // Catch exceptions

  }



  catch (Exception e) {

  }

  finally {



 if (rs != null)

     {

      try{rs.close();}catch(Exception ignore){};

      }



     if (stmt != null)

     {

      try{stmt.close();}catch(Exception ignore){};

      }

     if (conn != null)

     {

      try{conn.close();}catch(Exception ignore){};

      }





 %&gt;





&lt;%

  }

%&gt;



</font>

</body>

</html>



<p>启动Tomcat。</p>
<p>浏览：<a href="http://127.0.0.1:8080/mywebapp/index.jsp" target="_blank">http://127.0.0.1:8080/mywebapp/index.jsp</a></p>
<p><strong>四、在Tomcat中实现系统和Web管理的配置</strong></p>
<hr>
<p><strong>1、配置系统管理（Admin Web Application）</strong></p>
<hr>
<p><strong>（1）概述</strong></p>
<p>大多数商业化的J2EE服务器都提供一个功能强大的管理界面（如Weblogic的管理控制台），且大都采用易于理解的Web应用界面。Tomcat按照自己的方式，同样提供一个成熟的管理工具，并且丝毫不逊于那些商业化的竞争对手。</p>
<p>Tomcat的Admin Web Application最初在4.1版本时出现，当时的功能包括管理context、data source、user和group等。当然也可以管理像初始化参数，user、group、role的多种数据库管理等。在后续的版本中，这些功能将得到很大的扩展，但现有的功能已经非常实用了。</p>
<hr>
<p><strong>（2）系统管理Web应用程序</strong></p>
<p>Tomcat中的Admin Web Application被定义在自动部署文件：C:/jakarta-tomcat-5.0.19/server/webapps/admin/ admin.xml 中（请见下图所示）。</p>
<hr>
<p><strong>（3）编辑admin.xml文件</strong></p>
<p>通过编辑admin.xml文件，以确定Context中的docBase参数设置为Admin Web Application所在的目录路径（应该是绝对路径）。作为另外一种选择，你也可以删除这个自动部署文件，而在C:/jakarta-tomcat-5.0.19/conf/server.xml文件中建立一个Admin Web Application的context，效果是一样的。</p>
<pre><code>   你不能管理Admin Web Application这个应用，换而言之，除了删除CATALINA_BASE/webapps/admin.xml ，你可能什么都做不了。
</code></pre><p><strong>注意：</strong>如果将其中的被注释掉的&lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;</p>
<pre><code>allow=&quot;127.0.0.1&quot;/&gt;打开，将能够限制访问Admin Web Application的程序主机为本机（服务器主机）；当然也可以设置为其它的主机IP地址（如设置为 Web管理员所的工作主机）。
</code></pre><hr>
<p><strong>（4）在C:/jakarta-tomcat-5.0.19/conf/ tomcat-users.xml 文件中添加系统管理员的角色和系统管理员</strong></p>
<p>Tomcat中提供UserDatabaseRealm（默认），这样我们可以根据管理的需要添加不同的用户角色和与该角色相配置的用户名称和密码</p>
<p>l         添加用户角色</p>
<role name="admin"/>

<p>l         添加与该角色相配置的用户名称和密码</p>
<user name="admin" password="12345678" roles="admin"/>

<p>当你完成这些步骤后，请重新启动Tomcat，访问<a href="http://localhost:8080/admin，你将看到一个登录界面。Admin" target="_blank">http://localhost:8080/admin，你将看到一个登录界面。Admin</a> Web Application程序采用基于容器管理的安全机制，并采用了Jakarta Struts框架。下面是在原来的tomcat-users.xml 文件中再添加了两个角色admin和manager，同时也添加了与该两个角色相配置的用户admin和manager。</p>
<p>&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;</p>
<tomcat-users>

  <role rolename="role1"/>

  <role rolename="tomcat"/>

<p><strong>  <role rolename="admin"/></strong></p>
<p><strong>  <role rolename="manager"/></strong></p>
<p>  <strong><user username="admin" password="12345678" roles="admin"/></strong></p>
<p><strong>  <user name="manager" password="12345678" roles="manager"/></strong></p>
  <user username="role1" password="tomcat" roles="role1"/>

  <user username="tomcat" password="tomcat" roles="tomcat"/>

  <user username="both" password="tomcat" roles="tomcat,role1"/>

<p></tomcat-users></p>
<p><strong>（5）登录Admin Web Application程序</strong></p>
<p>输入<a href="http://localhost:8080/admin/" target="_blank"><a href="http://localhost:8080/admin/">http://localhost:8080/admin/</a></a>进入系统管理员的登录页，然后在页中</p>
<p>输入用户名称：admin</p>
<p>密码： 12345678</p>
<pre><code>   将进入系统管理的界面，在该系统管理的程序中将可以配置各种资源如Data Sources、Mail Sessions、Environment Entries，并且也可以管理Users 和Groups 以及Roles等功能。
</code></pre><hr>
<p><strong>2、配置应用管理（Manager Web Application）</strong></p>
<hr>
<p><strong>（1）概述</strong></p>
<p>Tomcat中所提供的Manager Web Application让你通过一个比Admin Web Application更为简单的用户界面，执行一些与Web应用任务相关的一些管理功能。</p>
<hr>
<p><strong>（2）Manager Web Application程序</strong></p>
<p>Manager Web Application被被定义在一个自动部署文件中C:/jakarta-tomcat-5.0.19/server/webapps/manager/manager.xml 。</p>
<hr>
<p><strong>（3）编辑manager.xml文件</strong></p>
<p>通过编辑这个文件，以确保其中的context中的docBase属性参数是C:/jakarta-tomcat-5.0.19/server/webapps/manager的绝对路径。</p>
<hr>
<p><strong>（4）在C:/jakarta-tomcat-5.0.19/conf/ tomcat-users.xml 文件中添加Web管理员的角色和Web管理员</strong></p>
<p>l         添加用户角色</p>
<p><strong><role name=" manager "/></strong></p>
<p>l         添加与该角色相配置的用户名称和密码</p>
<p><strong>  <user name="manager" password="12345678" roles="manager"/></strong></p>
<hr>
<p><strong>（5）登录Web管理员的页面</strong></p>
<p>l         文本型管理界面</p>
<p>然后重新启动Tomcat，输入<a href="http://localhost:8080/manager/" target="_blank"><a href="http://localhost:8080/manager/">http://localhost:8080/manager/</a></a>，将进入看到一个很朴素的文本型管理界面</p>
<p>如果输入<a href="http://localhost:8080/manager/" target="_blank"><a href="http://localhost:8080/manager/">http://localhost:8080/manager/</a></a>list，将进入一个登录管理界面，然后</p>
<p>输入用户名称：manager（前面在tomcat-users.xml中设置的）</p>
<p>密码：12345678</p>
<p>将显示出</p>
<p>l         HTML 型管理界面</p>
<p>输入<a href="http://localhost:8080/manager/html/list" target="_blank"><a href="http://localhost:8080/manager/html/list">http://localhost:8080/manager/html/list</a></a>，将出现如下的页面，然后再</p>
<p>输入用户名称：manager</p>
<p>密码：12345678</p>
<p>将出现Web方式的管理页面</p>
<p>Manager application可以让用户在没有系统管理特权的基础上，部署安装新的Web应用，以用于测试。同时也可以对所部署的Web应用程序的工作状态进行控制（Start 或者 Stop），以免重新启动服务器（这在对web.xml等配置的内容发生改变的情况下，特别有效）。当有用户尝试访问这个被停止的应用时，将看到一个503的错误——“503 - This application is not currently available”。</p>
<hr>
<p><strong>3、配置各种用户角色、用户组和用户</strong></p>
<p>（1）添加用户角色：在 admin的界面中点击左面的Roles节点，然后在右面的下拉列表框中选择Create New Role项目。</p>
<p>然后输入角色的名称和描述</p>
<pre><code>   最后点击“保存”，将存储在C:/jakarta-tomcat-5.0.19/conf/tomcat-users.xml文件中并且在管理界面中显示出。
</code></pre><p><strong>（2）添加用户组：</strong>在 admin的界面中点击左面的Groups节点，然后在右面的下拉列表框中选择Create New Group项目。</p>
<hr>
<p>然后输入组的名称和描述，并且设置该组的角色。所应该注意的是，给组分配角色，则意味着该组中的各个成员（用户）将具有该角色所分配的各种权限。</p>
<hr>
<p>最后点击“Save”以保存它（仍然放在C:/jakarta-tomcat-5.0.19/conf/tomcat-users.xml文件中）</p>
<hr>
<p><strong>（3）添加属于某一用户组内的用户</strong></p>
<p>在 admin的界面中点击左面的Users节点，然后在右面的下拉列表框中选择Create New User项目。</p>
<p>然后该用户的名称同时包括全名称、密谋，并且设置该用户所属的用户组；同时也可以为该用户再设置其它的角色以使该用户除了具有用户组的通用的权利以外，还具有其他方面的权利。</p>
<p>下面对“teacherZhang”这个用户进行设置，同时他也是系统管理员，因此将下面的admin的角色也选中。</p>
<p>最后点击保存（仍然放在C:/jakarta-tomcat-5.0.19/conf/tomcat-users.xml文件中）</p>
<hr>
<p><strong>4、添加其它的系统资源</strong></p>
<hr>
<p><strong>（1）DataSource</strong></p>
<pre><code>   在 admin的界面中点击左面的DataSourcs节点，然后在右面的下拉列表框中选择Create New DataSource项目。

   在各个输入的项目中根据数据库的特性进行输入。最后点击“Save”以保存。
</code></pre><hr>
<p><strong>（2）添加环境变量</strong></p>
<pre><code>   在 admin的界面中点击左面的Environment Entries节点，然后在右面的下拉列表框中选择Create New Env Entry项目。

   在各个输入的项目中根据数据库的特性进行输入。最后点击“Save”以保存。****
</code></pre><hr>
<p><strong>5、对Web应用程序进行管理</strong></p>
<p>（1）输入<a href="http://localhost:8080/manager/html/list" target="_blank"><a href="http://localhost:8080/manager/html/list">http://localhost:8080/manager/html/list</a></a>，将出现登录页并且进行登录，然后再进入Tomcat Web Application Manager</p>
<p>（2）查看在Web服务中所发布的各个Web应用</p>
<hr>
<p><strong>（3）启动或者终止、移除某一Web应用：</strong></p>
<p>点击该 Web应用右面的Stop链接，也可以点击Start再次启动它。Undeploy（移除）一个Web应用，只是指从Tomcat的运行拷贝中删除了该应用，如果你重新启动Tomcat，被删除的应用将再次出现（也就是说，移除并不是指从硬盘上删除）。</p>
<hr>
<p><strong>（4）部署某一Web应用</strong></p>
<p>有三种方式可以在Tomcat系统中部署Web应用。</p>
<p>l         直接拷贝你的WAR文件或者你的Web应用文件夹（包括该Web应用的所有内容）到C:/jakarta-tomcat-5.0.19/webapps目录下。</p>
<p>该文件必须以“.war”作为扩展名。一旦Tomcat监听到这个文件，它将（缺省的）解开该文件包作为一个子目录，并以WAR文件的文件名作为子目录的名字。接下来，Tomcat将在内存中建立一个context，就好象你在server.xml文件里建立一样。当然，其他必需的内容，将从server.xml中的DefaultContext获得。</p>
<p>l         部署web应用的另一种方式是写一个Context XML片断文件，然后把该文件拷贝到C:/jakarta-tomcat-5.0.19/webapps目录下。</p>
<p>一个Context片断并非一个完整的XML文件，而只是一个Context元素，以及对该应用的相应描述。这种片断文件就像是从server.xml中切取出来的context元素一样，所以这种片断被命名为“context片断”。这个web应用本身可以存储在硬盘上的任何地方。</p>
<p>举个例子，如果我们想部署一个名叫JspExamples的Web应用，该应用使用realm作为访问控制方式，我们可以使用下面这个片断：</p>
<!-- 

 Context fragment for deploying JspExamples 

-->

<Context path="/JspExamples" docBase="JspExamples" debug="0" reloadable="true">

<RealmclassName="org.apache.catalina.realm.UserDatabaseRealm"  resourceName="UserDatabase"/>

</Context>

<p>把该片断命名为“JspExamples.xml”，然后拷贝到C:/jakarta-tomcat-5.0.19/webapps目录下。这种Context片断提供了一种便利的方法来部署web应用，你不需要编辑server.xml，除非你想改变缺省的部署特性，安装一个新的Web应用时不需要重启动Tomcat。</p>
<p>l         采用GUI管理界面进行发布</p>
<p>如果提供了该Web应用的/*.war文件，直接浏览并发布它</p>
<p>如果Web应用是以目录形式存在的，则可以：</p>
<p><strong>五、Tomcat服务器的Web安全的解决方法</strong></p>
<hr>
<p><strong>1、概述</strong></p>
<p>在任何一种WEB应用开发中，不论大中小规模的，每个开发者都会遇到一些需要保护程序数据的问题，涉及到用户的LOGIN ID和PASSWORD。那么如何执行验证方式更好呢？实际上，有很多方式来实现。</p>
<p>下面将讨论在Tomcat中实现基本的（BASIC）和基于表单的（FORM-BASED）验证方式。它通过server.xml和web.xml文件提供基本的和基于表单的验证。</p>
<p>对于采用基于表单的（FORM-BASED）验证方式，只是要求在登录的JSP页面中的j_security_check 表单(for FORM-based) 需要两个参数：j_username和j_password。</p>
<p>对于用户的登录的名称和密码在Tomcat中可以以两种形式来存放，一是采用server.xml；另一种也可以采用用户自己的数据库表来存储。</p>
<hr>
<p><strong>2、设计系统中的各种人员的角色</strong></p>
<hr>
<p><strong>（1）设计思想</strong></p>
<p>l         统一用户管理，实现基于角色、粗粒度（基于URL）和细粒度（基于应用组件的方法调用）的访问策略管理体系，</p>
<p>l         基于分级角色的权限管理、统一证书管理和统一资源管理</p>
<hr>
<p><strong>（2）设计目标</strong></p>
<p>一般采用数据库表（对于复杂的也可以采用LDAP）记录每个系统用户的帐号信息、功能权限和数据权限信息，这样能够增加用户管理和权限设置的灵活性，同时也避免多个用户共用一个帐号的情况。</p>
<p><strong>（3）优点</strong></p>
<hr>
<p>l         从用户角度来看，登录所有应用系统都使用唯一的用户名和口令（数字证书）同时在访问系统时，也只需要登录一次（单点登录全网漫游---SSO（Single Sign-On））。</p>
<p>l        从管理者角度来看，提供了统一、集中、有效的用户管理。</p>
<p><strong>七、在Tomcat中采用基于表单的安全验证</strong></p>
<hr>
<p><strong>1、概述</strong></p>
<hr>
<p><strong>（1）基于表单的验证</strong></p>
<p>基于From的安全认证可以通过Tomcat Server对Form表单中所提供的数据进行验证，基于表单的验证使系统开发者可以自定义用户的登陆页面和报错页面。这种验证方法与基本HTTP的验证方法的唯一区别就在于它可以根据用户的要求制定登陆和出错页面。</p>
<p>通过拦截并检查用户的请求，检查用户是否在应用系统中已经创建好login session。如果没有，则将用户转向到认证服务的登录页面。但在Tomcat中的基于表单的验证凭证不被保护并以纯文本发送。</p>
<hr>
<p><strong>（2）在Tomcat 中的实现</strong></p>
<p>在Tomcat中，用户、用户组和角色都是在XML配置文件（C:/jakarta-tomcat-5.0.19/conf/tomcat-users.xml）中指定的，我们只需要提供一个登陆页面，包含一个名为j_security_check的Form表单，一个名为j_username的TextBox和一个名为j_password的PasswordBox，然后在/WEB-INF/web.xml中配置即可使用Tomcat默认的JAAS身份验证。</p>
<p>使用JAAS验证的好处是，验证逻辑从页面中分离，对页面的限制访问是通过/WEB-INF/web.xml中的配置指定的，无需自定义过滤器。</p>
<hr>
<p><strong>（3）为了实现Web应用程序的安全，Tomcat Web容器执行下面的步骤：</strong></p>
<p>l         在受保护的Web资源被访问时，判断用户是否被认证。</p>
<p>l         如果用户没有得到认证，则通过重定向到部署描述符中定义的注册页面，要求用户提供安全信任状。</p>
<p>l         根据为该容器配置的安全领域，确认用户的信任状有效。</p>
<p>l         判断得到认证的用户是否被授权访问部署描述符（web.xml）中定义的Web资源。<em>**</em></p>
<hr>
<hr>
<p><strong>2、设计步骤</strong></p>
<hr>
<hr>
<p><strong>（1）编写登录页面和错误处理页面：</strong>请见FormSafeWebApp 程序中的页面</p>
<hr>
<hr>
<hr>
<p><strong>（2）登录的页面文件的内容如下</strong></p>
<p>基于FORM的用户认证要求你返回一个包括用户名和密码的HTML表单，这个表单相对应与用户名和密码的元素必须是j_username和j_password，并且表单的action描述必须为j_security_check（其实是一个Servlet）。该表单的具体操作以及j_username和j_password名字在Servlet中定义。当这个表单到达服务器的时候，由内部的Tomcat Server安全区对它进行确认。</p>
<p>包括这个表单的资源可以是一个HTML页面、一个JSP页面或者一个Servlet。你可以在<form-login-page>元素中定义。基于表单的认证能够使开发人员定制认证的用户界面。在web.xml的login-config标签项目定义了认证机制的类型、登录的URI和错误页面。</p>
<p>下面为该页面的内容：</p>
<p>&lt;%@ page contentType=&quot;text/html; charset=GBK&quot; %&gt;</p>
<p><strong>注意：</strong>action应该为j_security_check<html><head><title>在Tomcat 中采用Form 验证方式实现的安全Web应用程序的登录页</title></p>
<p></head><body bgcolor="/#ffffff"></p>
<form method="post" name="Login" **action="j_security_check"**>

<p><table width="500" border="1" align="center"> <tr></p>
<p><strong>注意：</strong>用户名称和密码的输入应该为j_username 和j_password    <td colspan="2"> <div align="center"><strong>在Tomcat中采用</strong><strong>基于表单的安全验证的登录表单 </strong> </div></td> </tr></p>
  <tr><td width="224"><div align="right">用户名称：</div></td>

    <td width="260"><input type="text" **name="j_username"**></td> </tr>

  <tr> <td><div align="right">密码：</div></td>

<td><input type="password" **name="j_password"**></td>

  </tr>

<p>  <tr><td><div align="right"><input type="submit" name="Submit" value="提交"></p>
<pre><code>&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;reset&quot; name=&quot;Submit2&quot; value=&quot;重置&quot;&gt;&lt;/td&gt;
</code></pre><p>  </tr></table></form></body></html><em>**</em></p>
<hr>
<p><strong>（3）修改web.xml文件</strong></p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</p>
<p>定义本Web应用的默认启始页面&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;<a href="http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;" target="_blank">http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;</a></p>
<web-app>

<pre><code>   &lt;welcome-file-list&gt;

       &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;

    &lt;/welcome-file-list&gt;
</code></pre> <!-- Security is active on entire directory -->

<p> <strong> <security-constraint></strong></p>
<p><strong>    <display-name>Tomcat Server Form Security Constraint</display-name></strong></p>
<p><strong>    <web-resource-collection></strong></p>
<p><strong>     <web-resource-name>Protected Area</web-resource-name></strong></p>
<p><strong>      <description>A Page of Login Success</description></strong></p>
<p><strong>       <url-pattern>/ProtectedDirOne/index.jsp</url-pattern></strong></p>
<p><strong>      </web-resource-collection></strong></p>
<p><strong>    <auth-constraint></strong></p>
<p>指定Form验证的用户的角色名称<strong>      <!-- Anyone with one of the listed roles may access this area --></strong></p>
<p><strong>      <role-name>admin</role-name></strong></p>
<p><strong>    </auth-constraint></strong></p>
<p>指定验证的方式为Form<strong>  </security-constraint></strong></p>
<p><strong>  <!-- Login configuration uses form-based authentication --></strong></p>
<p><strong>  <login-config></strong></p>
<p><strong>    <auth-method>FORM</auth-method></strong></p>
<p><strong>    <realm-name>Tomcat Server Configuration Form-Based Authentication Area</realm-name></strong></p>
<p><strong>    <form-login-config></strong></p>
<p><strong>             <form-login-page>/login.jsp </form-login-page></strong></p>
<p><strong>              <form-error-page>/Error.htm </form-error-page></strong></p>
<hr>
<p><strong>    </form-login-config></strong></p>
<p><strong>  </login-config></strong></p>
<p><strong>  <!-- Security roles referenced by this web application --></strong></p>
<p><strong>  <security-role></strong></p>
<p>关联Tomcat中的admin的角色<strong>    <description></strong></p>
<p><strong>      The role is Administration</strong></p>
<p><strong>    </description></strong></p>
<p><strong>    <role-name>admin</role-name></strong></p>
<p><strong>  </security-role></strong></p>
<p></web-app></p>
<hr>
<p><strong>（4）在C:/jakarta-tomcat-5.0.19/conf/tomcat-users.xml文件</strong>中配置admin的角色以及与该 admin角色相匹配的用户名称和密码</p>
<hr>
<hr>
<p><strong>（5）执行该页面</strong></p>
<p>在浏览器中直接输入受保护的页面的URL地址：</p>
<p><a href="http://127.0.0.1:8080/FormSafeWebApp/ProtectedDirOne/" target="_blank"><a href="http://127.0.0.1:8080/FormSafeWebApp/ProtectedDirOne/">http://127.0.0.1:8080/FormSafeWebApp/ProtectedDirOne/</a></a>，将出现要求登录的页面。</p>
<hr>
<p>在表单中输入用户名称为admin（前面在tomcat-users.xml文件中所设置的某一用户名称），密码为12345678。然后点击“提交”，将出现如下页面</p>
<p>如果用户名称或者密码输入不正确，将出现如下的页面也就是错误页面</p>
<p><strong>（6）在页面中获得当前登录成功后的用户名称和实体名称</strong></p>
<pre><code>   利用request对象中的getRemoteUser()方法获得当前登录成功后的用户名称和利用getUserPrincipal()方法获得当前登录成功后的实体名称。
</code></pre><hr>
<hr>
<p><strong>八、在Tomcat中配置单点登录（Single Sign-On）</strong></p>
<hr>
<p><strong>1、概述</strong></p>
<p>一旦你设置了realm和验证的方法，你就需要进行实际的用户登录处理。一般说来，对用户而言登录系统是一件很麻烦的事情，你必须尽量减少用户登录验证的次数。作为缺省的情况，当用户第一次请求受保护的资源时，每一个Web应用都会要求用户登录。</p>
<p>如果你运行了多个Web应用，并且每个应用都需要进行单独的用户验证，那这看起来就有点像你在与你的用户搏斗。用户们不知道怎样才能把多个分离的应用整合成一个单独的系统，所有他们也就不知道他们需要访问多少个不同的应用，只是很迷惑，为什么总要不停的登录。</p>
<hr>
<p><strong>2、Tomcat 中的“Single Sign-On”特性及配置</strong></p>
<p>其主要的特性是能够允许用户在访问同一虚拟主机下所有Web应用时，只需登录一次。为了使用这个功能，你只需要在C:/jakarta-tomcat-5.0.19/conf /server.xml文件中的Host标签上添加一个SingleSignOn Valve元素即可，如下所示：</p>
<Valve className="org.apache.catalina.authenticator.SingleSignOn"   debug="0"/>

<p>在Tomcat初始安装后，server.xml的注释里面包括SingleSignOn Valve配置的例子，你只需要去掉注释（<strong>在339行左右</strong>），即可使用。那么，任何用户只要登录过一个应用，则对于同一虚拟主机下的所有应用同样有效。</p>
<hr>
<p><strong>3、测试单点登录</strong></p>
<hr>
<p><strong>（1）      直接进入前面的Form验证所产生的Web应用</strong></p>
<p><strong>（<a href="http://127.0.0.1:8080/FormSafeWebApp/ProtectedDirOne/" target="_blank"><a href="http://127.0.0.1:8080/FormSafeWebApp/ProtectedDirOne/">http://127.0.0.1:8080/FormSafeWebApp/ProtectedDirOne/</a></a>）将出现要求登录的页面</strong></p>
<hr>
<hr>
<p>在表单中输入用户名称为admin（前面在tomcat-users.xml文件中所设置的某一用户名称），密码为12345678。然后点击“提交”，将以用户名admin进行成功登录该Web应用。</p>
<p>（2）再在该浏览器窗口内（不能在新窗口，否则会成为另一用户）直接输入<a href="http://127.0.0.1:8080/admin/frameset.jsp" target="_blank"><a href="http://127.0.0.1:8080/admin/frameset.jsp">http://127.0.0.1:8080/admin/frameset.jsp</a></a>，此时将以admin的用户浏览另一Web应用。观察能否直接进入Tomcat的系统管理的页面，此时应该可以并且出现下面的页面。</p>
<hr>
<pre><code>   如果新开一浏览器窗口并直接输入[http://127.0.0.1:8080/admin/frameset.jsp](http://127.0.0.1:8080/admin/frameset.jsp)，看能否直接进入Tomcat的系统管理的页面，此时将会出现要求登录的页面。
</code></pre><hr>
<hr>
<p><strong>4、使用single sign-on valve所应该注意的问题</strong></p>
<p>l         value必须被配置和嵌套在相同的Host元素里，并且所有需要进行单点验证的web应用（必须通过context元素定义）都位于该Host下。</p>
<p>l         包括共享用户信息的realm必须被设置在同一级Host中或者嵌套之外。</p>
<p>l         不能被context中的realm覆盖。</p>
<p>l         使用单点登录的web应用最好使用一个Tomcat的内置的验证方式（Basic或者Form）（被定义在web.xml中的<auth-method>中），这比自定义的验证方式强。</p>
<p>l         单点登录需要使用cookies。
来源： <a href="[http://blog.csdn.net/haojun186/article/details/7564174](http://blog.csdn.net/haojun186/article/details/7564174)">[http://blog.csdn.net/haojun186/article/details/7564174](http://blog.csdn.net/haojun186/article/details/7564174)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/服务器/">服务器</a></li></span><span class="breadcrumb"><li><a href="/categories/服务器/">服务器</a></li><li><a href="/categories/服务器/tomcat/">tomcat</a></li></span></span> | <span class="tags">Tagged <a href="/tags/tomcat/" class="label label-primary">tomcat</a><a href="/tags/服务器/" class="label label-success">服务器</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:45"datetime="2014-03-07 09:54:45"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-服务器-tomcat--tomcat详解/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-服务器-tomcat--tomcat详解" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-ftp--被动模式下FTP的详细工作过程/">被动模式下FTP的详细工作过程</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:45.000Z"> <a href="/2014/02/02/2014-02-02-ftp--被动模式下FTP的详细工作过程/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-ftp-">被动模式下FTP的详细工作过程</h1>
<p><strong>被动模式下FTP的详细工作过程</strong></p>
<p>PASV FTP在工作的第一步，与PORT FTP一样，会首先使用21端口建立控制连接；但在第二步，由FTP客户端主动发起建立数据传输连接请求，服务器的数据传输端口为随机端口，因此，每次建立的数据传输连接通道，服务器所使用的端口都不相同。</p>
<p>本示例客户端IP是192.168.120.168，服务器IP是192.168.120.240，因为客户端的MS-DOS不支持PASV模式，所以使用FlashFXP软件来连接服务器。通过抓包工具来查看用户从连接FTP服务器到退出FTP服务器经过的所有过程。
使用FlashFXP所做的操作：1.输入FTP服务器的IP，要登入的用户名和密码。2.进入用户家目录，查看.bashrc和.bash_profile两个文件。3.退出FTP。</p>
<p><strong>PASV FTP**</strong>的详细工作过程：**</p>
<p><strong>1.</strong> 因为FTP使用的是TCP协议，所以客户端FlashFXP在连接服务器192.168.120.240时，首先会经历TCP的三次握手来建立控制通道。客户端使用任意的端口N（&gt;1024）来连接FTP服务器默认的21端口。这和PORT模式一样。
<strong>2.</strong> 在TCP三次握手结束后，服务器端正式响应客户端的控制连接请求，控制通道建立。</p>
<p><strong>3.</strong> 客户端向服务器发送含有ACK的数据段来确认控制连接建立并发送用户名。
<strong>4.</strong> 服务器向客户端发送含有ACK的数据段来确认用户名。</p>
<p><strong>5.</strong> 服务器向客户端询问密码。
<strong>6.</strong> 客户端向服务器发送含有ACK的数据段来确认并发送密码，密码为明文。</p>
<p><strong>7.</strong> 服务器向客户端发送含有ACK的数据段来确认密码收到。
<strong>8.</strong> 服务器向客户端发送登陆成功的信息。</p>
<p><strong>9.</strong> 客户端向服务器发送含有ACK的数据段来确认并发送查询系统类型的指令（见图一）。
<strong>10.</strong> 服务器向客户端发送含有ACK的数据段来确认收到指令。</p>
<p><strong>11.</strong> 服务器向客户端回应系统的类型为UNIX（见图二）。
<strong>12.</strong> 客户端向服务器发送列出服务器的所有扩展命令和扩展功能的指令（见图三）。</p>
<p><strong>13.</strong> 服务器响应客户端的FEAT请求（见图四）。
<strong>14.</strong> 服务器响应客户端有EPSV（扩展PASV，支持非IPV4）的扩展功能（见图五）。</p>
<p><strong>15.</strong> 客户端向服务器发送含有ACK的数据段来确认收到信息。
<strong>16.</strong> 服务器响应客户端自己的其他特性（见图六）。MDTM：保留下载文件的日期/时间；REST STREAM：重设文件传输方式为stream形式。</p>
<p><strong>17.</strong> 客户端确认收到服务器的信息。
<strong>18.</strong> 服务器响应客户端进入到用户的家目录（见图七）。</p>
<p><strong>19.</strong> 客户端确认收到服务器的信息。
<strong>20.</strong> 客户端向服务器发送文件传输使用何种模式（Binary、ASCII）的指令（见图八）。</p>
<p><strong>21.</strong> 服务器回应客户端使用Binary模式（见图九）。
<strong>22.</strong> 客户端向服务器询问.bashrc文件的大小（见图十）。</p>
<p><strong>23.</strong> 服务器回应客户端.bashrc文件的大小为124字节（见图十一）。
<strong>24.</strong> 客户端向服务器发出PASV的指令（用来进行数据传输）（见图十二）。</p>
<p><strong>25.</strong> 服务器回应客户端使用PASV模式，并且商量数据传输端口用232x256+151=59543（见图十三）。
<strong>26.</strong> 客户端主动使用N+1端口来连接服务器的59543端口，并且向服务器发送含有SYN的数据段来开始进行数据传输连接的第1次握手（见图十四）。</p>
<p><strong>27.</strong> 服务器向客户端发送含有SYN和ACK的数据段来进行第2次握手（见图十五）。
<strong>28.</strong> 客户端向服务器发送含有ACK的数据段来进行第3次握手（见图十六）。</p>
<p><strong>29.</strong> 3次握手过程完成，客户端向服务器发送查看.bashrc文件的指令（见图十七）。
<strong>30.</strong> 服务器回应客户端使用Binary数据传输模式连接.bashrc文件（见图十八）。</p>
<p><strong>31.</strong> 服务器开始进行数据传输。
<strong>32.</strong> 服务器确定数据传输完毕，然后向客户端发送含有FIN和ACK的数据段来请求断开本次数据连接，第1次断开（见图十九）。</p>
<p><strong>33.</strong> 客户端向服务器发送含有ACK的数据段答应服务器的断接请求，第2次断开（见图二十）。
<strong>34.</strong> 服务器响应客户端文件发送完成的信息（见图二十一）。</p>
<p><strong>35.</strong> 客户端向服务器发送含有ACK的数据段来确认收到信息。
<strong>36.</strong> 客户端向服务器发送含有FIN和ACK的数据段来请求断开客户端到服务器之间的数据连接，第3次断开（见图二十二）。</p>
<p><strong>37.</strong> 服务器向客户端发送含有ACK的数据段确认断开连接，第4次断开（见图二十三）
<strong>38.</strong> 接下来是查看.bash_profile文件的过程。其过程和查看.bashrc文件的过程一样（在此不详述了），只是服务器和客户端的数据传输端口变了。服务器的数据传输端口是随机的；客户端的数据传输端口是N+2。</p>
<p><strong>39.</strong> 客户端在查看完.bash_profile文件并彻底完成该次数据连接的4次断开后，向服务器发送退出的指令（见图二十四）。
<strong>40.</strong> 服务器响应客户端的退出请求（见图二十五）。</p>
<p><strong>41.</strong> 服务器向客户端发送含有FIN和ACK的数据段，请求断开控制连接（见图二十六）。这是第一次断开控制连接。
<strong>42.</strong> 客户端向服务器发送含有ACK的数据段来应答服务器的断接请求（见图二十七）。这是第二次断开控制连接。</p>
<p><strong>43.</strong> 客户端向服务器发送含有FIN和ACK的数据段，请求断开到服务器之间的控制连接（见图二十八）。这是第三次断开控制连接。
<strong>44.</strong> 服务器向客户端发送含有ACK的数据段，来确认客户端的断接请求（见图二十九）。这样本次FTP控制连接完全断开。</p>
<p><strong>通过查看本次示例（被动FTP）的详细过程，我们可以得到以下几点结果：</strong></p>
<p><strong>1.</strong> 服务器的控制连接端口为21，数据传输端口随机（&gt;1024）并且每次的数据传输端口都不一样。
<strong>2.</strong> 客户端的控制连接端口为N（&gt;1024），数据传输端口在第一次进行数据传输时为N+1,在第二次数据传输时为N+2，依次类推。</p>
<p><strong>3.</strong> 服务器主动告诉客户端自己的数据传输端口。
<strong>4.</strong> 客户端主动用数据传输端口N+x去连接服务器的随机数据传输端口。</p>
<p><strong>5.</strong> 在一次FTP连接的过程中，只有一次控制连接，却可以有多次数据传输连接。
<strong>6.</strong> 不管是控制连接还是数据传输连接，在每次从建立到完成都需要经过3次连接和4次断开的过程。（这符合TCP协议的要求）</p>
<p><strong>本文档使用的图例：</strong></p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224935974PU0j.gif" target="_blank"><img src="" alt="11"></a> 
图一：客户端发送查询系统类型的指令</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224935976j9JR.jpg" target="_blank"></a><a href="http://img1.51cto.com/attachment/200810/25/363003_1224935977k2F8.gif"><img src="" alt="13"></a></p>
<p>图二：服务器响应客户端系统类型为UNIX</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224935978q1o9.gif" target="_blank"><img src="" alt="14"></a>
图三：客户端请求服务器列出它的所有扩展命令和扩展功能</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224935983sdRz.gif" target="_blank"><img src="" alt="15"></a></p>
<p>图四：服务器响应客户端的FEAT请求</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936006Aznp.gif" target="_blank"><img src="" alt="16"></a>
图五：服务器响应客户端有EPSV（扩展PASV，支持非IPV4）的扩展功能</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_12249360074yJ5.gif" target="_blank"><img src="" alt="18"></a></p>
<p>图六：服务器响应客户端自己支持的其他特性</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936015iZgn.gif" target="_blank"><img src="" alt="20"></a>
图七：服务器响应客户端进入到用户家目录</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936017ZmNc.gif" target="_blank"><img src="" alt="22"></a></p>
<p>图八：客户端向服务器询问文件传输的模式</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936018IMjR.gif" target="_blank"><img src="" alt="23"></a>
图九：服务器响应客户端使用Binary模式</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936020hNul.gif" target="_blank"><img src="" alt="24"></a></p>
<p>图十：客户端向服务器询问.bashrc文件的大小</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936022sj6P.gif" target="_blank"><img src="" alt="25"></a>
图十一：服务器回应客户端.bashrc文件的大小为124字节</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_12249360237iAu.gif" target="_blank"><img src="" alt="26"></a></p>
<p>图十二：客户端向服务器发送PASV指令</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_12249361801LGh.gif" target="_blank"><img src="" alt="27"></a>
图十三：服务器响应客户端使用PASV模式，并且商量数据传输端口用59543</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936181n4nW.gif" target="_blank"><img src="" alt="28"></a></p>
<p>图十四：第一次数据传输连接之第一次握手</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_122493618223uT.gif" target="_blank"><img src="" alt="29"></a>
图十五：第一次数据传输连接之第二次握手</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936183BjjV.gif" target="_blank"><img src="" alt="30"></a></p>
<p>图十六：第一次数据传输连接之第三次握手</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936185srsz.gif" target="_blank"><img src="" alt="31"></a>
图十七：客户端向服务器发送查看.bashrc文件的指令</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936186ZS1w.gif" target="_blank"><img src="" alt="32"></a></p>
<p>图十八：服务器响应客户端使用Binary数据传输模式来连接.bashrc文件</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936188Q6dX.gif" target="_blank"><img src="" alt="34"></a>
图十九：服务器发送FIN和ACK请求断开本次数据连接（第1次断开）</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936210T20g.gif" target="_blank"><img src="" alt="35"></a></p>
<p>图二十：客户端发送ACK答应服务器的请求（第2次断开）</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936213ulWM.gif" target="_blank"><img src="" alt="36"></a>
图二十一：服务器响应客户端文件发送完毕的信息</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936217J6aY.gif" target="_blank"><img src="" alt="38"></a></p>
<p>图二十二：客户端向服务器发送含有FIN和ACK的数据段请求断开数据连接（第3次断开）</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936218Leca.gif" target="_blank"><img src="" alt="39"></a>
图二十三：服务器向客户端发送含有ACK的数据段确认断开连接（第4次断开）</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936220HQq5.gif" target="_blank"><img src="" alt="56"></a></p>
<p>图二十四：客户端向服务器发出退出的指令</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936221ejql.gif" target="_blank"><img src="" alt="57"></a>
图二十五：服务器响应客户端的退出请求</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936223xMjK.gif" target="_blank"><img src="" alt="58"></a></p>
<p>图二十六：服务器向客户端发送FIN和ACK请求断开控制连接（第1次断开）</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_12249362249BCE.gif" target="_blank"><img src="" alt="59"></a>
图二十七：客户端向服务器发送ACK答应服务器请求（第2次断开）</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936225gvOK.gif" target="_blank"><img src="" alt="60"></a></p>
<p>图二十八：客户端向服务器发送FIN和ACK请求断开控制连接（第3次断开）</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936226MLVx.gif" target="_blank"><img src="" alt="61"></a>
图二十九：服务器向客户端发送ACK答应断开控制连接（第4次断开）</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936227MSuY.gif" target="_blank"><img src="" alt="62"></a></p>
<p>图三十：本次示例全部过程</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/ftp/">ftp</a></li></span></span> | <span class="tags">Tagged <a href="/tags/ftp/" class="label label-primary">ftp</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:45"datetime="2014-03-07 09:54:45"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-ftp--被动模式下FTP的详细工作过程/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-ftp--被动模式下FTP的详细工作过程" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-webservice-CXF--CXF发布Webservice服务，出现异常/">CXF发布Webservice服务，出现异常，请帮忙分析一下 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:45.000Z"> <a href="/2014/02/02/2014-02-02-webservice-CXF--CXF发布Webservice服务，出现异常/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="cxf-webservice-java-java-ee">CXF发布Webservice服务，出现异常，请帮忙分析一下 - Java - Java EE</h1>
<p><a href="http://topic.csdn.net/u/20081012/16/68615908-0c81-480b-8ec2-36c88ed83271.html#" target="_blank"><img src="" alt=""></a></p>
<ul>
<li><a href=""></a></li>
</ul>
<h2 id="-">#</h2>
<h2 id="-">#</h2>
<p>&lt;&lt;&gt;&gt;
<a href="http://www.csdn.net/" target="_blank">CSDN</a>-<a href="http://community.csdn.net/" target="_blank">CSDN社区</a>-<a href="http://forum.csdn.net/BList/Java/" target="_blank">Java</a>-<a href="http://forum.csdn.net/SList/J2EE//" target="_blank">Java EE</a></p>
<ul>
<li><p><a href="">管理菜单</a></p>
</li>
<li><p><a href="http://forum.csdn.net/PointForum/BuildTopic.aspx?topicId=68615908-0c81-480b-8ec2-36c88ed83271&amp;postDate=2008-10-12+16%3a13%3a23&amp;return=" target="_blank">生成帖子</a></p>
</li>
<li><a href="">置顶</a></li>
<li><a href="">推荐</a></li>
<li><a href="">取消推荐</a></li>
<li><a href="">锁定</a></li>
<li><a href="">解锁</a></li>
<li><a href="">移动</a></li>
<li><a href="">编辑</a></li>
<li><a href="">删除</a></li>
<li><a href="">帖子加分</a></li>
<li><a href="">帖子高亮</a></li>
<li><a href="">取消高亮</a></li>
<li><a href="http://forum.csdn.net/PointForum/Manage/TopicManageView.aspx?forumID=2efca177-6b51-42d9-a509-0216fbca231e&amp;topicID=68615908-0c81-480b-8ec2-36c88ed83271&amp;date=2008-10-12+16%3a13%3a23&amp;v=13" target="_blank">结  帖</a></li>
<li><a href="http://forum.csdn.net/PointForum/Forum/PostTopic.aspx?forumID=2efca177-6b51-42d9-a509-0216fbca231e" target="_blank">发  帖</a></li>
<li><p><a href="http://topic.csdn.net/u/20081012/16/68615908-0c81-480b-8ec2-36c88ed83271.html#r_achor" target="_blank">回  复</a></p>
<h1 id="-cxf-webservice-50-ma_liang-"><a href="">收藏</a> 不显示删除回复显示所有回复显示星级回复显示得分回复 <a href=""></a>CXF发布Webservice服务，出现异常，请帮忙分析一下<em>[问题点数:50分，结帖人:ma_liang]</em></h1>
<ul>
<li><a href="http://hi.csdn.net/ma_liang" target="_blank"><img src="" alt=""></a></li>
</ul>
</li>
<li><a href="http://hi.csdn.net/ma_liang" target="_blank">ma_liang</a></li>
<li>(黑马)
*</li>
<li>等　级：<img src="" alt=""></li>
<li>结帖率：93.33%</li>
<li><em>楼主</em>发表于：2008-10-12 16:13:23 使用Cxf发布WebServic出现如下异常，请帮忙分析一下
信息: Creating Service {<a href="http://service.webservice.client.api.workflow.cvicse.com/}WsClient" target="_blank">http://service.webservice.client.api.workflow.cvicse.com/}WsClient</a> from class com.cvicse.workflow.api.client.webservice.service.WsClient
Exception in thread &quot;main&quot; java.lang.AbstractMethodError: org.apache.xerces.dom.DocumentImpl.getInputEncoding()Ljava/lang/String;
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
at java.lang.reflect.Method.invoke(Unknown Source)
at org.apache.ws.commons.schema.utils.DOMUtil.getInputEncoding(DOMUtil.java:602)
at org.apache.ws.commons.schema.SchemaBuilder.build(SchemaBuilder.java:84)
at org.apache.ws.commons.schema.XmlSchemaCollection.read(XmlSchemaCollection.java:424)
at org.apache.ws.commons.schema.XmlSchemaCollection.read(XmlSchemaCollection.java:418)
at org.apache.cxf.common.xmlschema.SchemaCollection.read(SchemaCollection.java:142)
at org.apache.cxf.databinding.AbstractDataBinding.addSchemaDocument(AbstractDataBinding.java:93)
at org.apache.cxf.jaxb.JAXBDataBinding.initialize(JAXBDataBinding.java:336)
at org.apache.cxf.service.factory.ReflectionServiceFactoryBean.buildServiceFromClass(ReflectionServiceFactoryBean.java:354)
at org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean.buildServiceFromClass(JaxWsServiceFactoryBean.java:514)
at org.apache.cxf.service.factory.ReflectionServiceFactoryBean.initializeServiceModel(ReflectionServiceFactoryBean.java:405)
at org.apache.cxf.service.factory.ReflectionServiceFactoryBean.create(ReflectionServiceFactoryBean.java:188)
at org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean.create(JaxWsServiceFactoryBean.java:164)
at org.apache.cxf.frontend.AbstractWSDLBasedEndpointFactory.createEndpoint(AbstractWSDLBasedEndpointFactory.java:100)
at org.apache.cxf.frontend.ServerFactoryBean.create(ServerFactoryBean.java:116)
at org.apache.cxf.jaxws.JaxWsServerFactoryBean.create(JaxWsServerFactoryBean.java:168)
at org.apache.cxf.jaxws.EndpointImpl.getServer(EndpointImpl.java:336)
at org.apache.cxf.jaxws.EndpointImpl.doPublish(EndpointImpl.java:251)
at org.apache.cxf.jaxws.EndpointImpl.publish(EndpointImpl.java:201)
at org.apache.cxf.jaxws.spi.ProviderImpl.createAndPublishEndpoint(ProviderImpl.java:84)
at javax.xml.ws.Endpoint.publish(Endpoint.java:47)
at com.cvicse.workflow.WorkflowWebService.<init>(WorkflowWebService.java:13)
at com.cvicse.workflow.WorkflowWebService.main(WorkflowWebService.java:18) * <a href="">对我有用</a>[0]</li>
<li><a href="">丢个板砖</a>[0]</li>
<li><a href="">引用</a></li>
<li><a href="">举报</a></li>
<li><a href="">管理</a></li>
<li><a href="http://topic.csdn.net/u/20081012/16/68615908-0c81-480b-8ec2-36c88ed83271.html#top" target="_blank">TOP</a>
回复次数：9  * <a href="http://hi.csdn.net/accp206" target="_blank"><img src="&quot;accp206用户自定义头像&quot;" alt="accp206用户头像"></a></li>
<li><a href="http://hi.csdn.net/accp206" target="_blank">accp206</a></li>
<li>(与勋章仅一步之遥，遗憾……没太)
*</li>
<li>等　级：<img src="" alt=""></li>
<li>/#1楼 得分：10回复于：2008-10-12 18:45:58<a href=""></a> 你接口中的某些方法，其参数或返回值类型是否有String数组的？
如果有的话，消除这些类型的参数，用别的方式代替。比如String数组，可换成一个用“,”号分隔的字符串传递。
在开发WebService程序时，尽量不要使用复杂数据类型。 * <a href="">对我有用</a>[0]</li>
<li><a href="">丢个板砖</a>[0]</li>
<li><a href="">引用</a></li>
<li><a href="">举报</a></li>
<li><a href="">管理</a></li>
<li><a href="http://topic.csdn.net/u/20081012/16/68615908-0c81-480b-8ec2-36c88ed83271.html#top" target="_blank">TOP</a>  * <a href="http://hi.csdn.net/ma_liang" target="_blank"><img src="&quot;ma_liang用户自定义头像&quot;" alt="ma_liang用户头像"></a></li>
<li><a href="http://hi.csdn.net/ma_liang" target="_blank">ma_liang</a></li>
<li>(黑马)
*</li>
<li>等　级：<img src="" alt=""></li>
<li>/#2楼 得分：0回复于：2008-10-12 21:17:36<a href=""></a> 接口中的方法里没有数组类型，不过返回值和参数里有接口类型的，我已经将它增加了适配器，如果不用适配器的话发布服务的时候会报JAXB绑定的错误，但是适配了所有后发布服务，报上面的错误，让人不解 * <a href="">对我有用</a>[0]</li>
<li><a href="">丢个板砖</a>[0]</li>
<li><a href="">引用</a></li>
<li><a href="">举报</a></li>
<li><a href="">管理</a></li>
<li><a href="http://topic.csdn.net/u/20081012/16/68615908-0c81-480b-8ec2-36c88ed83271.html#top" target="_blank">TOP</a>  * <a href="http://hi.csdn.net/teamlet" target="_blank"><img src="&quot;teamlet用户自定义头像&quot;" alt="teamlet用户头像"></a></li>
<li><a href="http://hi.csdn.net/teamlet" target="_blank">teamlet</a></li>
<li>(teamlet)
*</li>
<li>等　级：<img src="" alt=""></li>
<li>/#3楼 得分：10回复于：2008-10-13 11:23:08<a href=""></a> 看看classpath路径下有没有 xercesImpl-2.8.1.jar ，如果没有加上试试。
这是由于获取字符集的时候，你所使用的 jar 包中的org.apache.xerces.dom.DocumentImpl没有实现getInputEncoding()这个方法。 * <a href="">对我有用</a>[0]</li>
<li><a href="">丢个板砖</a>[0]</li>
<li><a href="">引用</a></li>
<li><a href="">举报</a></li>
<li><a href="">管理</a></li>
<li><a href="http://topic.csdn.net/u/20081012/16/68615908-0c81-480b-8ec2-36c88ed83271.html#top" target="_blank">TOP</a>  * <a href="http://hi.csdn.net/teamlet" target="_blank"><img src="&quot;teamlet用户自定义头像&quot;" alt="teamlet用户头像"></a></li>
<li><a href="http://hi.csdn.net/teamlet" target="_blank">teamlet</a></li>
<li>(teamlet)
*</li>
<li>等　级：<img src="" alt=""></li>
<li>/#4楼 得分：10回复于：2008-10-13 12:55:22<a href=""></a> 报错后，字符集被设置为 UTF-8 * <a href="">对我有用</a>[0]</li>
<li><a href="">丢个板砖</a>[0]</li>
<li><a href="">引用</a></li>
<li><a href="">举报</a></li>
<li><a href="">管理</a></li>
<li><a href="http://topic.csdn.net/u/20081012/16/68615908-0c81-480b-8ec2-36c88ed83271.html#top" target="_blank">TOP</a>  * <a href="http://hi.csdn.net/ma_liang" target="_blank"><img src="&quot;ma_liang用户自定义头像&quot;" alt="ma_liang用户头像"></a></li>
<li><a href="http://hi.csdn.net/ma_liang" target="_blank">ma_liang</a></li>
<li>(黑马)
*</li>
<li>等　级：<img src="" alt=""></li>
<li>/#5楼 得分：0回复于：2008-10-14 08:38:30<a href=""></a> 我把项目构件路径中的 xercesImpl-2.8.1.jar 去掉了，反而发布成功了，为什么？ * <a href="">对我有用</a>[0]</li>
<li><a href="">丢个板砖</a>[0]</li>
<li><a href="">引用</a></li>
<li><a href="">举报</a></li>
<li><a href="">管理</a></li>
<li><a href="http://topic.csdn.net/u/20081012/16/68615908-0c81-480b-8ec2-36c88ed83271.html#top" target="_blank">TOP</a>  * <a href="http://hi.csdn.net/teamlet" target="_blank"><img src="&quot;teamlet用户自定义头像&quot;" alt="teamlet用户头像"></a></li>
<li><a href="http://hi.csdn.net/teamlet" target="_blank">teamlet</a></li>
<li>(teamlet)
*</li>
<li>等　级：<img src="" alt=""></li>
<li>/#6楼 得分：10回复于：2008-10-14 10:56:15<a href=""></a> <strong>更正一下</strong>
org.apache.xerces.dom.DocumentImpl.getInputEncoding()在其父类CoreDocumentImpl中实现了。
在DOMUtil.java中，通过如下语句调用 getInputEncoding 方法：
Method m = Document.class.getMethod(&quot;getInputEncoding&quot;, new Class[]{});
Document是一个接口，声明了 getInputEncoding 方法。
DocumentImpl继承了CoreDocumentImpl，CoreDocumentImpl实现了Document接口。
在通过Document接口调用DocumentImpl的时候，没有找到getInputEncoding 方法，
因此提示java.lang.AbstractMethodError
你的cxf是哪个版本的？在你的环境下使用的是哪个版本的 xercesImpl？是否存在多个不同的xercesImpl？ * <a href="">对我有用</a>[0]</li>
<li><a href="">丢个板砖</a>[0]</li>
<li><a href="">引用</a></li>
<li><a href="">举报</a></li>
<li><a href="">管理</a></li>
<li><a href="http://topic.csdn.net/u/20081012/16/68615908-0c81-480b-8ec2-36c88ed83271.html#top" target="_blank">TOP</a>  * <a href="http://hi.csdn.net/ma_liang" target="_blank"><img src="&quot;ma_liang用户自定义头像&quot;" alt="ma_liang用户头像"></a></li>
<li><a href="http://hi.csdn.net/ma_liang" target="_blank">ma_liang</a></li>
<li>(黑马)
*</li>
<li>等　级：<img src="" alt=""></li>
<li>/#7楼 得分：0回复于：2008-10-15 08:32:12<a href=""></a> 我的Cxf是用的2.1.2版本，xercesImpl.jar只有一个，在构建路径里去掉就可以正常发布服务，实际上它在原来的项目里伴有重要的角色，去掉之后是可以发布服务了，但是以前的功能有些就不支持了 * <a href="">对我有用</a>[0]</li>
<li><a href="">丢个板砖</a>[0]</li>
<li><a href="">引用</a></li>
<li><a href="">举报</a></li>
<li><a href="">管理</a></li>
<li><a href="http://topic.csdn.net/u/20081012/16/68615908-0c81-480b-8ec2-36c88ed83271.html#top" target="_blank">TOP</a>  * <a href="http://hi.csdn.net/ma_liang" target="_blank"><img src="&quot;ma_liang用户自定义头像&quot;" alt="ma_liang用户头像"></a></li>
<li><a href="http://hi.csdn.net/ma_liang" target="_blank">ma_liang</a></li>
<li>(黑马)
*</li>
<li>等　级：<img src="" alt=""></li>
<li>/#8楼 得分：0回复于：2008-10-15 09:02:58<a href=""></a> 我还有一个疑问是在用Cxf发布服务时，怎么会调用这个类的方法，为什么去掉之后就不去找这个方法了？ * <a href="">对我有用</a>[0]</li>
<li><a href="">丢个板砖</a>[0]</li>
<li><a href="">引用</a></li>
<li><a href="">举报</a></li>
<li><a href="">管理</a></li>
<li><a href="http://topic.csdn.net/u/20081012/16/68615908-0c81-480b-8ec2-36c88ed83271.html#top" target="_blank">TOP</a>  * <a href="http://hi.csdn.net/teamlet" target="_blank"><img src="&quot;teamlet用户自定义头像&quot;" alt="teamlet用户头像"></a></li>
<li><a href="http://hi.csdn.net/teamlet" target="_blank">teamlet</a></li>
<li>(teamlet)
*</li>
<li>等　级：<img src="" alt=""></li>
<li>/#9楼 得分：10回复于：2008-10-15 10:57:07<a href=""></a> 1、在根据Class生成XMLSchema的时候，当涉及到如下的namespace就会调用这个方法：
<a href="http://www.w3.org/2005/02/addressing/wsdl" target="_blank">http://www.w3.org/2005/02/addressing/wsdl</a>
<a href="http://www.w3.org/2005/08/addressing" target="_blank">http://www.w3.org/2005/08/addressing</a>
<a href="http://schemas.xmlsoap.org/ws/2005/02/rm" target="_blank">http://schemas.xmlsoap.org/ws/2005/02/rm</a>
<a href="http://www.w3.org/2005/05/xmlmime" target="_blank">http://www.w3.org/2005/05/xmlmime</a>
每个namespache对应的xsd在classpath中：
&quot;<a href="http://www.w3.org/2005/02/addressing/wsdl&quot;,&quot;classpath:/schemas/wsdl/ws-addr-wsdl.xsd" target="_blank">http://www.w3.org/2005/02/addressing/wsdl&quot;,&quot;classpath:/schemas/wsdl/ws-addr-wsdl.xsd</a>&quot;);
&quot;<a href="http://www.w3.org/2005/08/addressing" target="_blank">http://www.w3.org/2005/08/addressing</a>&quot;, &quot;classpath:/schemas/wsdl/ws-addr.xsd&quot;);
&quot;<a href="http://schemas.xmlsoap.org/ws/2005/02/rm" target="_blank">http://schemas.xmlsoap.org/ws/2005/02/rm</a>&quot;, &quot;classpath:/schemas/wsdl/wsrm.xsd&quot;);
&quot;<a href="http://www.w3.org/2005/05/xmlmime" target="_blank">http://www.w3.org/2005/05/xmlmime</a>&quot;, &quot;classpath:/schemas/wsdl/ws-addr.xsd&quot;);
2、javax.xml.validation.SchemaFactory 是sun提供的一个抽象类，声明了一些抽象的方法；
通过在classpath中查找同名的配置文件可以获得具体的实现。
在xercesImpl.jar中有一个配置文件javax.xml.validation.SchemaFactory，声明使用xercesImpl中的类。
当你去除这个jar的时候，这个配置无法读取，就不去找这个方法了！
但是你的环境中还可以找到其他的 javax.xml.validation.SchemaFactory 文件，绑定的是其他的实现。
如果这些实现只能解析特定的schema ，那么它不能解析的schema声明的功能就无法使用了。 * <a href="">对我有用</a>[0]</li>
<li><a href="">丢个板砖</a>[0]</li>
<li><a href="">引用</a></li>
<li><a href="">举报</a></li>
<li><a href="">管理</a></li>
<li><p><a href="http://topic.csdn.net/u/20081012/16/68615908-0c81-480b-8ec2-36c88ed83271.html#top" target="_blank">TOP</a></p>
</li>
<li><p><a href="">管理菜单</a></p>
</li>
<li><p><a href="http://forum.csdn.net/PointForum/BuildTopic.aspx?topicId=68615908-0c81-480b-8ec2-36c88ed83271&amp;postDate=2008-10-12+16%3a13%3a23&amp;return=" target="_blank">生成帖子</a></p>
</li>
<li><a href="">置顶</a></li>
<li><a href="">推荐</a></li>
<li><a href="">取消推荐</a></li>
<li><a href="">锁定</a></li>
<li><a href="">解锁</a></li>
<li><a href="">移动</a></li>
<li><a href="">编辑</a></li>
<li><a href="">删除</a></li>
<li><a href="">帖子加分</a></li>
<li><a href="">帖子高亮</a></li>
<li><a href="">取消高亮</a></li>
<li><a href="http://forum.csdn.net/PointForum/Manage/TopicManageView.aspx?forumID=2efca177-6b51-42d9-a509-0216fbca231e&amp;topicID=68615908-0c81-480b-8ec2-36c88ed83271&amp;date=2008-10-12+16%3a13%3a23&amp;v=13" target="_blank">结  帖</a></li>
<li><a href="http://forum.csdn.net/PointForum/Forum/PostTopic.aspx?forumID=2efca177-6b51-42d9-a509-0216fbca231e" target="_blank">发  帖</a></li>
<li><a href="http://topic.csdn.net/u/20081012/16/68615908-0c81-480b-8ec2-36c88ed83271.html#r_achor" target="_blank">回  复</a>
相关问题 <a href="http://topic.csdn.net/u/20090513/09/5a3a5401-e059-4963-9147-136b65bce728.html" target="_blank">[求助大家]关于Web Service调用时出现&quot;no jbi part element&quot;的问题</a>    <img src="" alt=""></li>
</ul>
<p><a href="http://topic.csdn.net/u/20081012/16/68615908-0c81-480b-8ec2-36c88ed83271.html#" target="_blank">[关闭]</a>
<a href="http://topic.csdn.net/u/20081012/16/68615908-0c81-480b-8ec2-36c88ed83271.html#" target="_blank">[关闭]</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/webservice/">webservice</a></li></span><span class="breadcrumb"><li><a href="/categories/webservice/">webservice</a></li><li><a href="/categories/webservice/CXF/">CXF</a></li></span></span> | <span class="tags">Tagged <a href="/tags/CXF/" class="label label-primary">CXF</a><a href="/tags/webservice/" class="label label-success">webservice</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:45"datetime="2014-03-07 09:54:45"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-webservice-CXF--CXF发布Webservice服务，出现异常/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-webservice-CXF--CXF发布Webservice服务，出现异常" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--MaxGuest/">MaxGuest</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:44.000Z"> <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--MaxGuest/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="maxguest">MaxGuest</h1>
<h1 id="-algorithm-gossip-"><a href="">Algorithm Gossip: 最大访客数</a></h1>
<h2 id="-">说明</h2>
<p>现将举行一个餐会，让访客事先填写到达时间与离开时间，为了掌握座位的数目，必须先估计不同时间的最大访客数。</p>
<h2 id="-">解法</h2>
<p>这个题目看似有些复杂，其实相当简单，单就计算访客数这个目的，同时考虑同一访客的来访时间与离开时间，反而会使程式变得复杂；只要将来访时间与离开时间分开处理就可以了，假设访客 i 的来访时间为x[i]，而离开时间为y[i]。
在资料输入完毕之后，将x[i]与y[i]分别进行排序（由小到大），道理很简单，只要先计算某时之前总共来访了多少访客，然后再减去某时之前的离开访客，就可以轻易的解出这个问题。</p>
<h2 id="-">实作</h2>
<ul>
<li><p>C
/#include <stdio.h>
/#include <stdlib.h>
/#define MAX 100
/#define SWAP(x,y) {int t; t = x; x = y; y = t;}
int partition(int[], int, int);
void quicksort(int[], int, int); // 快速排序法
int maxguest(int[], int[], int, int);
int main(void) {
int x[MAX] = {0};
int y[MAX] = {0};
int time = 0;
int count = 0;
printf(&quot;\n输入来访与离开125;时间(0~24)：&quot;);
printf(&quot;\n范例：10 15&quot;);
printf(&quot;\n输入-1 -1结束&quot;);
while(count &lt; MAX) {
printf(&quot;\n&gt;&gt;&quot;);
scanf(&quot;%d %d&quot;, &amp;x[count], &amp;y[count]);
if(x[count] &lt; 0)
break;
count++;
}
if(count &gt;= MAX) {
printf(&quot;\n超出最大访客数(%d)&quot;, MAX);
count--;
}
// 预先排序
quicksort(x, 0, count);
quicksort(y, 0, count);
while(time &lt; 25) {
printf(&quot;\n%d 时的最大访客数：%d&quot;,
time, maxguest(x, y, count, time));
time++;
}
printf(&quot;\n&quot;);
return 0;
}
int maxguest(int x[], int y[], int count, int time) {
int i, num = 0;
for(i = 0; i &lt;= count; i++) {
if(time &gt; x[i])
num++;
if(time &gt; y[i])
num--;
}
return num;
}
int partition(int number[], int left, int right) {
int i, j, s;
s = number[right];
i = left - 1;
for(j = left; j &lt; right; j++) {
if(number[j] &lt;= s) {
i++;
SWAP(number[i], number[j]);
}
}
SWAP(number[i+1], number[right]);
return i+1;
}
void quicksort(int number[], int left, int right) {
int q;
if(left &lt; right) {
q = partition(number, left, right);
quicksort(number, left, q-1);
quicksort(number, q+1, right);
}
}</p>
</li>
<li><p>Java
import java.io./<em>;
import java.util./</em>;
public class MaxVisit {
public static int maxGuest(int[] x, int[] y, int time) {
int num = 0;
for(int i = 0; i &lt; x.length; i++) {
if(time &gt; x[i])
num++;
if(time &gt; y[i])
num--;
}
return num;
}
public static void main(String[] args) throws IOException {
BufferedReader buf = new BufferedReader(
new InputStreamReader(System.in));
System.out.println(&quot;输入来访时间与离开时间(0~24)：&quot;);
System.out.println(&quot;范例：10 15&quot;);
System.out.println(&quot;输入-1结束&quot;);
java.util.ArrayList list = new ArrayList();
while(true) {
System.out.print(&quot;&gt;&gt;&quot;);
String input = buf.readLine();
if(input.equals(&quot;-1&quot;))
break;
list.add(input);
}
int[] x = new int[list.size()];
int[] y = new int[list.size()];
for(int i = 0; i &lt; x.length; i++) {
String input = (String) list.get(i);
String[] strs = input.split(&quot; &quot;);
x[i] = Integer.parseInt(strs[0]);
y[i] = Integer.parseInt(strs[1]);
}
Arrays.sort(x);
Arrays.sort(y);
for(int time = 0; time &lt; 25; time++) {
System.out.println(time + &quot; 时的最大访客数：&quot;</p>
</li>
</ul>
<ul>
<li>MaxVisit.maxGuest(x, y, time));
}
}
}</li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/AlgorithmGossip/">AlgorithmGossip</a></li></span></span> | <span class="tags">Tagged <a href="/tags/AlgorithmGossip/" class="label label-primary">AlgorithmGossip</a></span> | <span class="time">recent updated:<time title="2014-03-07 10:36:47"datetime="2014-03-07 10:36:47"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--MaxGuest/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-AlgorithmGossip-AlgorithmGossip--MaxGuest" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/9/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/7/">7</a></li><li><a class="page-number" href="/page/8/">8</a></li><li><a class="page-number" href="/page/9/">9</a></li><li class="active"><li><span class="page-number current">10</span></li><li><a class="page-number" href="/page/11/">11</a></li><li><a class="page-number" href="/page/12/">12</a></li><li><a class="page-number" href="/page/13/">13</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/11/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 13:06:28</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
