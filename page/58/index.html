
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 58 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency2-原子操作/">深入浅出 Java Concurrency (2)</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency2-原子操作/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-concurrency-2-">深入浅出 Java Concurrency (2): 原子操作</h1>
<p>从相对简单的Atomic入手（java.util.concurrent是基于Queue的并发包，而Queue，很多情况下使用到了Atomic操作，因此首先从这里开始）。很多情况下我们只是需要一个简单的、高效的、线程安全的递增递减方案。注意，这里有三个条件：简单，意味着程序员尽可能少的操作底层或者实现起来要比较容易；高效意味着耗用资源要少，程序处理速度要快；线程安全也非常重要，这个在多线程下能保证数据的正确性。这三个条件看起来比较简单，但是实现起来却难以令人满意。</p>
<p>通常情况下，在Java里面，++i或者--i不是线程安全的，这里面有三个独立的操作：或者变量当前值，为该值+1/-1，然后写回新的值。在没有额外资源可以利用的情况下，只能使用加锁才能保证读-改-写这三个操作时“原子性”的。</p>
<p>Doug Lea在未将<a href="http://backport-jsr166.sourceforge.net/" target="_blank">backport-util-concurrent</a>合并到<a href="http://jcp.org/en/jsr/detail?id=166" target="_blank">JSR 166</a>里面来之前，是采用纯Java实现的，于是不可避免的采用了synchronized关键字。</p>
<p>public final synchronized void set(int newValue);</p>
<p>public final synchronized int getAndSet(int newValue);</p>
<p>public final synchronized int incrementAndGet();</p>
<p>同时在变量上使用了volatile （后面会具体来讲volatile到底是个什么东东）来保证get()的时候不用加锁。尽管synchronized的代价还是很高的，但是在没有JNI的手段下纯Java语言还是不能实现此操作的。</p>
<p>JSR 166提上日程后，backport-util-concurrent就合并到JDK 5.0里面了，在这里面重复使用了现代CPU的特性来降低锁的消耗。后本章的最后小结中会谈到这些原理和特性。在此之前先看看API的使用。</p>
<p>一切从java.util.concurrent.atomic.AtomicInteger开始。</p>
<p>int addAndGet(int delta)
          以原子方式将给定值与当前值相加。 实际上就是等于线程安全版本的i =i+delta操作。</p>
<p>boolean compareAndSet(int expect, int update)
          如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 如果成功就返回true，否则返回false，并且不修改原值。</p>
<p>int decrementAndGet()
          以原子方式将当前值减 1。 相当于线程安全版本的--i操作。</p>
<p>int get()
          获取当前值。</p>
<p>int getAndAdd(int delta)
          以原子方式将给定值与当前值相加。 相当于线程安全版本的t=i;i+=delta;return t;操作。</p>
<p>int getAndDecrement()
          以原子方式将当前值减 1。 相当于线程安全版本的i--操作。</p>
<p>int getAndIncrement()
          以原子方式将当前值加 1。 相当于线程安全版本的i++操作。</p>
<p>int getAndSet(int newValue)
          以原子方式设置为给定值，并返回旧值。 相当于线程安全版本的t=i;i=newValue;return t;操作。</p>
<p>int incrementAndGet()
          以原子方式将当前值加 1。 相当于线程安全版本的++i操作。 </p>
<p>void lazySet(int newValue)
          最后设置为给定值。 延时设置变量值，这个等价于set()方法，但是由于字段是volatile类型的，因此次字段的修改会比普通字段（非volatile字段）有稍微的性能延时（尽管可以忽略），所以如果不是想立即读取设置的新值，允许在“后台”修改值，那么此方法就很有用。如果还是难以理解，这里就类似于启动一个后台线程如执行修改新值的任务，原线程就不等待修改结果立即返回（这种解释其实是不正确的，但是可以这么理解）。</p>
<p>void set(int newValue)
          设置为给定值。 直接修改原始值，也就是i=newValue操作。</p>
<p>boolean weakCompareAndSet(int expect, int update)
          如果当前值 == 预期值，则以原子方式将该设置为给定的更新值。JSR规范中说：以原子方式读取和有条件地写入变量但<em>不</em> 创建任何 happen-before 排序，因此不提供与除 weakCompareAndSet 目标外任何变量以前或后续读取或写入操作有关的任何保证。大意就是说调用weakCompareAndSet时并不能保证不存在happen-before的发生（也就是可能存在指令重排序导致此操作失败）。但是从Java源码来看，其实此方法并没有实现JSR规范的要求，最后效果和compareAndSet是等效的，都调用了unsafe.compareAndSwapInt()完成操作。
下面的代码是一个测试样例，为了省事就写在一个方法里面来了。
<img src="" alt="">package xylz.study.concurrency.atomic;
<img src="" alt="">
<img src="" alt="">import java.util.concurrent.atomic.AtomicInteger;
<img src="" alt="">
<img src="" alt="">import org.junit.Test;
<img src="" alt="">
<img src="" alt="">import static org.junit.Assert./*;
<img src="" alt="">
<img src="" alt="">public class AtomicIntegerTest {
<img src="" alt="">
<img src="" alt="">    @Test
<img src="" alt="">    public void testAll() throws InterruptedException{
<img src="" alt="">        final AtomicInteger value = new AtomicInteger(10);
<img src="" alt="">        assertEquals(value.compareAndSet(1, 2), false);
<img src="" alt="">        assertEquals(value.get(), 10);
<img src="" alt="">        assertTrue(value.compareAndSet(10, 3));
<img src="" alt="">        assertEquals(value.get(), 3);
<img src="" alt="">        value.set(0);
<img src="" alt="">        //
<img src="" alt="">        assertEquals(value.incrementAndGet(), 1);
<img src="" alt="">        assertEquals(value.getAndAdd(2),1);
<img src="" alt="">        assertEquals(value.getAndSet(5),3);
<img src="" alt="">        assertEquals(value.get(),5);
<img src="" alt="">        //
<img src="" alt="">        final int threadSize = 10;
<img src="" alt="">        Thread[] ts = new Thread[threadSize];
<img src="" alt="">        for (int i = 0; i &lt; threadSize; i++) {
<img src="" alt="">            ts[i] = new Thread() {
<img src="" alt="">                public void run() {
<img src="" alt="">                    value.incrementAndGet();
<img src="" alt="">                }
<img src="" alt="">            };
<img src="" alt="">        }
<img src="" alt="">        //
<img src="" alt="">        for(Thread t:ts) {
<img src="" alt="">            t.start();
<img src="" alt="">        }
<img src="" alt="">        for(Thread t:ts) {
<img src="" alt="">            t.join();
<img src="" alt="">        }
<img src="" alt="">        //
<img src="" alt="">        assertEquals(value.get(), 5+threadSize);
<img src="" alt="">    }
<img src="" alt="">
<img src="" alt="">}
<img src="" alt="">
 由于这里例子比较简单，这里就不做过多介绍了。
AtomicInteger和AtomicLong、AtomicBoolean、AtomicReference差不多，这里就不介绍了。在下一篇中就介绍下数组、字段等其他方面的原子操作。
 参考资料：
(1)<a href="http://stackoverflow.com/questions/2443239/java-atomicinteger-what-are-the-differences-between-compareandset-and-weakcompar" target="_blank"><a href="http://stackoverflow.com/questions/2443239/java-atomicinteger-what-are-the-differences-between-compareandset-and-weakcompar">http://stackoverflow.com/questions/2443239/java-atomicinteger-what-are-the-differences-between-compareandset-and-weakcompar</a></a>
(2)<a href="http://stackoverflow.com/questions/1468007/atomicinteger-lazyset-and-set" target="_blank"><a href="http://stackoverflow.com/questions/1468007/atomicinteger-lazyset-and-set">http://stackoverflow.com/questions/1468007/atomicinteger-lazyset-and-set</a></a></p>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/01/324988.html](http://www.blogjava.net/xylz/archive/2010/07/01/324988.html)">[http://www.blogjava.net/xylz/archive/2010/07/01/324988.html](http://www.blogjava.net/xylz/archive/2010/07/01/324988.html)</a></p>
<p>在这一部分开始讨论数组原子操作和一些其他的原子操作。</p>
<p><strong>AtomicIntegerArray/AtomicLongArray/AtomicReferenceArray</strong>的API类似，选择有代表性的AtomicIntegerArray来描述这些问题。</p>
<p><strong>int get(int i)</strong></p>
<p>获取位置 </p>
<p>i
 的当前值。很显然，由于这个是数组操作，就有索引越界的问题（IndexOutOfBoundsException异常）。</p>
<p>对于下面的API起始和AtomicInteger是类似的，这种通过方法、参数的名称就能够得到函数意义的写法是非常值得称赞的。在<a href="http://www.china-pub.com/12901" target="_blank">《重构：改善既有代码的设计》</a>和<a href="http://www.china-pub.com/196266" target="_blank">《代码整洁之道》</a>中都非常推崇这种做法。</p>
<p><strong>void set(int i, int newValue)</strong>
<strong>void lazySet(int i, int newValue)
int getAndSet(int i, int newValue)
boolean compareAndSet(int i, int expect, int update)
boolean weakCompareAndSet(int i, int expect, int update)
int getAndIncrement(int i)
int getAndDecrement(int i)
int getAndAdd(int i, int delta)
int incrementAndGet(int i)
int decrementAndGet(int i)
int addAndGet(int i, int delta)</strong></p>
<p>整体来说，数组的原子操作在理解上还是相对比较容易的，这些API就是有多使用才能体会到它们的好处，而不仅仅是停留在理论阶段。</p>
<p>现在关注字段的原子更新。</p>
<p><strong>AtomicIntegerFieldUpdater<T>/AtomicLongFieldUpdater<T>/AtomicReferenceFieldUpdater<T,V></strong>是基于反射的原子更新字段的值。</p>
<p>相应的API也是非常简单的，但是也是有一些约束的。</p>
<p>（1）字段必须是volatile类型的！在后面的章节中会详细说明为什么必须是volatile，volatile到底是个什么东西。</p>
<p>（2）字段的描述类型（修饰符public/protected/default/private）是与调用者与操作对象字段的关系一致。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。但是对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。</p>
<p>（3）只能是实例变量，不能是类变量，也就是说不能加static关键字。</p>
<p>（4）只能是可修改变量，不能使final变量，因为final的语义就是不可修改。实际上final的语义和volatile是有冲突的，这两个关键字不能同时存在。</p>
<p>（5）对于<strong>AtomicIntegerFieldUpdater</strong>和<strong>AtomicLongFieldUpdater</strong>只能修改int/long类型的字段，不能修改其包装类型（Integer/Long）。如果要修改包装类型就需要使用<strong>AtomicReferenceFieldUpdater</strong>。</p>
<p>在下面的例子中描述了操作的方法。</p>
<p><img src="" alt="">package xylz.study.concurrency.atomic; 
<img src="" alt="">
<img src="" alt="">import java.util.concurrent.atomic.AtomicIntegerFieldUpdater; 
<img src="" alt="">
<img src="" alt="">public class AtomicIntegerFieldUpdaterDemo { 
<img src="" alt="">
<img src="" alt="">   class DemoData{
<img src="" alt="">       public volatile int value1 = 1;
<img src="" alt="">       volatile int value2 = 2;
<img src="" alt="">       protected volatile int value3 = 3;
<img src="" alt="">       private volatile int value4 = 4;
<img src="" alt="">   }
<img src="" alt="">    AtomicIntegerFieldUpdater<DemoData> getUpdater(String fieldName) {
<img src="" alt="">        return AtomicIntegerFieldUpdater.newUpdater(DemoData.class, fieldName);
<img src="" alt="">    }
<img src="" alt="">    void doit() {
<img src="" alt="">        DemoData data = new DemoData();
<img src="" alt="">        System.out.println(&quot;1 ==&gt; &quot;+getUpdater(&quot;value1&quot;).getAndSet(data, 10));
<img src="" alt="">        System.out.println(&quot;3 ==&gt; &quot;+getUpdater(&quot;value2&quot;).incrementAndGet(data));
<img src="" alt="">        System.out.println(&quot;2 ==&gt; &quot;+getUpdater(&quot;value3&quot;).decrementAndGet(data));
<img src="" alt="">        System.out.println(&quot;true ==&gt; &quot;+getUpdater(&quot;value4&quot;).compareAndSet(data, 4, 5));
<img src="" alt="">    }
<img src="" alt="">    public static void main(String[] args) {
<img src="" alt="">        AtomicIntegerFieldUpdaterDemo demo = new AtomicIntegerFieldUpdaterDemo();
<img src="" alt="">        demo.doit();
<img src="" alt="">    }
<img src="" alt="">} 
<img src="" alt="">
<img src="" alt=""></p>
<p>在上面的例子中DemoData的字段value3/value4对于AtomicIntegerFieldUpdaterDemo类是不可见的，因此通过反射是不能直接修改其值的。</p>
<p><strong>AtomicMarkableReference</strong>类描述的一个<Object,Boolean>的对，可以原子的修改Object或者Boolean的值，这种数据结构在一些缓存或者状态描述中比较有用。这种结构在单个或者同时修改Object/Boolean的时候能够有效的提高吞吐量。</p>
<p><strong>AtomicStampedReference</strong>类维护带有整数“标志”的对象引用，可以用原子方式对其进行更新。对比<strong>AtomicMarkableReference</strong>类的<Object,Boolean>，<strong>AtomicStampedReference</strong>维护的是一种类似<Object,int>的数据结构，其实就是对对象（引用）的一个并发计数。但是与<strong>AtomicInteger</strong>不同的是，此数据结构可以携带一个对象引用（Object），并且能够对此对象和计数同时进行原子操作。</p>
<p>在后面的章节中会提到“ABA问题”，而<strong>AtomicMarkableReference/**</strong>AtomicStampedReference<strong>在解决“ABA问题”上很有用</strong>。**</p>
<hr>
<p>原子操作的使用大概就是这么多，大体来说还算是比较清晰的，在下一个章节中，将对象原子操作进行总结，重点介绍下原子操作的原理和设计思想。
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/02/325079.html](http://www.blogjava.net/xylz/archive/2010/07/02/325079.html)">[http://www.blogjava.net/xylz/archive/2010/07/02/325079.html](http://www.blogjava.net/xylz/archive/2010/07/02/325079.html)</a> </p>
<p>在这个小结里面重点讨论原子操作的原理和设计思想。</p>
<p>由于在下一个章节中会谈到锁机制，因此此小节中会适当引入锁的概念。</p>
<p>在<a href="http://www.amazon.com/exec/obidos/ASIN/0321349601/ref=nosim/none0b69" title="http://www.amazon.com/exec/obidos/ASIN/0321349601/ref=nosim/none0b69" target="_blank">Java Concurrency in Practice</a>中是这样定义线程安全的：
<strong>当多个线程访问一个类时，如果不用考虑这些线程在运行时环境下的调度和交替运行，并且不需要额外的同步及在调用方代码不必做其他的协调，这个类的行为仍然是正确的，那么这个类就是线程安全的。</strong></p>
<p>显然只有资源竞争时才会导致线程不安全，因此<strong><em>无状态对象永远是线程安全的</em></strong>。</p>
<p>原子操作的描述是： 多个线程执行一个操作时，其中<strong><em>任何一个线程要么完全执行完此操作，要么没有执行此操作的任何步骤</em></strong>，那么这个操作就是原子的。</p>
<p>枯燥的定义介绍完了，下面说更枯燥的理论知识。</p>
<p><strong>指令重排序</strong></p>
<p>Java语言规范规定了JVM线程内部维持顺序化语义，也就是说只要程序的最终结果等同于它在严格的顺序化环境下的结果，那么指令的执行顺序就可能与代码的顺序不一致。这个过程通过叫做指令的重排序。指令重排序存在的意义在于：JVM能够根据处理器的特性（CPU的多级缓存系统、多核处理器等）适当的重新排序机器指令，使机器指令更符合CPU的执行特点，最大限度的发挥机器的性能。</p>
<p>程序执行最简单的模型是按照指令出现的顺序执行，这样就与执行指令的CPU无关，最大限度的保证了指令的可移植性。这个模型的专业术语叫做顺序化一致性模型。但是现代计算机体系和处理器架构都不保证这一点（因为人为的指定并不能总是保证符合CPU处理的特性）。</p>
<p>我们来看最经典的一个案例。
<img src="" alt="">package xylz.study.concurrency.atomic; 
<img src="" alt="">
<img src="" alt="">public class ReorderingDemo { 
<img src="" alt="">
<img src="" alt="">    static int x = 0, y = 0, a = 0, b = 0; 
<img src="" alt="">
<img src="" alt="">    public static void main(String[] args) throws Exception { 
<img src="" alt="">
<img src="" alt="">        for (int i = 0; i &lt; 100; i++) {
<img src="" alt="">            x=y=a=b=0;
<img src="" alt="">            Thread one = new Thread() {
<img src="" alt="">                public void run() {
<img src="" alt="">                    a = 1;
<img src="" alt="">                    x = b;
<img src="" alt="">                }
<img src="" alt="">            };
<img src="" alt="">            Thread two = new Thread() {
<img src="" alt="">                public void run() {
<img src="" alt="">                    b = 1;
<img src="" alt="">                    y = a;
<img src="" alt="">                }
<img src="" alt="">            };
<img src="" alt="">            one.start();
<img src="" alt="">            two.start();
<img src="" alt="">            one.join();
<img src="" alt="">            two.join();
<img src="" alt="">            System.out.println(x + &quot; &quot; + y);
<img src="" alt="">        }
<img src="" alt="">    } 
<img src="" alt="">
<img src="" alt="">}
<img src="" alt="">
<img src="" alt="">
在这个例子中one/two两个线程修改区x,y,a,b四个变量，在执行100次的情况下，可能得到(0 1)或者（1 0）或者（1 1）。事实上按照JVM的规范以及CPU的特性有很可能得到（0 0）。当然上面的代码大家不一定能得到（0 0），因为run()里面的操作过于简单，可能比启动一个线程花费的时间还少，因此上面的例子难以出现（0,0）。但是在现代CPU和JVM上确实是存在的。由于run()里面的动作对于结果是无关的，因此里面的指令可能发生指令重排序，即使是按照程序的顺序执行，数据变化刷新到主存也是需要时间的。假定是按照a=1;x=b;b=1;y=a;执行的，x=0是比较正常的，虽然a=1在y=a之前执行的，但是由于线程one执行a=1完成后还没有来得及将数据1写回主存（这时候数据是在线程one的堆栈里面的），线程two从主存中拿到的数据a可能仍然是0（显然是一个过期数据，但是是有可能的），这样就发生了数据错误。</p>
<p>在两个线程交替执行的情况下数据的结果就不确定了，在机器压力大，多核CPU并发执行的情况下，数据的结果就更加不确定了。</p>
<p><strong>Happens-before法则</strong></p>
<p>Java存储模型有一个happens-before原则，就是如果动作B要看到动作A的执行结果（无论A/B是否在同一个线程里面执行），那么A/B就需要满足happens-before关系。</p>
<p>在介绍happens-before法则之前介绍一个概念：JMM动作（Java Memeory Model Action），Java存储模型动作。一个动作（Action）包括：变量的读写、监视器加锁和释放锁、线程的start()和join()。后面还会提到锁的的。</p>
<p>happens-before完整规则：
（1）同一个线程中的每个Action都happens-before于出现在其后的任何一个Action。</p>
<p>（2）对一个监视器的解锁happens-before于每一个后续对同一个监视器的加锁。</p>
<p>（3）对volatile字段的写入操作happens-before于每一个后续的同一个字段的读操作。</p>
<p>（4）Thread.start()的调用会happens-before于启动线程里面的动作。</p>
<p>（5）Thread中的所有动作都happens-before于其他线程检查到此线程结束或者Thread.join（）中返回或者Thread.isAlive()==false。</p>
<p>（6）一个线程A调用另一个另一个线程B的interrupt（）都happens-before于线程A发现B被A中断（B抛出异常或者A检测到B的isInterrupted（）或者interrupted()）。</p>
<p>（7）一个对象构造函数的结束happens-before与该对象的finalizer的开始</p>
<p>（8）如果A动作happens-before于B动作，而B动作happens-before与C动作，那么A动作happens-before于C动作。</p>
<p><strong>volatile语义</strong></p>
<p>到目前为止，我们多次提到volatile，但是却仍然没有理解volatile的语义。</p>
<p>volatile相当于synchronized的弱实现，也就是说volatile实现了类似synchronized的语义，却又没有锁机制。它确保对volatile字段的更新以可预见的方式告知其他的线程。</p>
<p>volatile包含以下语义：</p>
<p>（1）Java 存储模型不会对valatile指令的操作进行重排序：这个保证对volatile变量的操作时按照指令的出现顺序执行的。</p>
<p>（2）volatile变量不会被缓存在寄存器中（只有拥有线程可见）或者其他对CPU不可见的地方，每次总是从主存中读取volatile变量的结果。也就是说对于volatile变量的修改，其它线程总是可见的，并且不是使用自己线程栈内部的变量。也就是在happens-before法则中，对一个valatile变量的写操作后，其后的任何读操作理解可见此写操作的结果。</p>
<p>尽管volatile变量的特性不错，但是volatile并不能保证线程安全的，也就是说volatile字段的操作不是原子性的，volatile变量只能保证可见性（一个线程修改后其它线程能够理解看到此变化后的结果），要想保证原子性，目前为止只能加锁！</p>
<p>volatile通常在下面的场景：</p>
<p><img src="" alt="">volatile boolean done = false;
<img src="" alt="">
<img src="" alt="">…
<img src="" alt="">
<img src="" alt="">    while( ! done ){
<img src="" alt="">        dosomething();
<img src="" alt="">    }</p>
<p>应用volatile变量的三个原则：
（1）写入变量不依赖此变量的值，或者只有一个线程修改此变量</p>
<p>（2）变量的状态不需要与其它变量共同参与不变约束</p>
<p>（3）访问变量不需要加锁</p>
<p><strong>这一节理论知识比较多，但是这是很面很多章节的基础，在后面的章节中会多次提到这些特性。</strong></p>
<p>本小节中还是没有谈到原子操作的原理和思想，在下一节中将根据上面的一些知识来介绍原子操作。</p>
<p>参考资料：</p>
<p>（1）<a href="http://www.amazon.com/exec/obidos/ASIN/0321349601/ref=nosim/none0b69" title="http://www.amazon.com/exec/obidos/ASIN/0321349601/ref=nosim/none0b69" target="_blank">Java Concurrency in Practice</a></p>
<p>（2）<a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank">正确使用 Volatile 变量</a>
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/03/325168.html](http://www.blogjava.net/xylz/archive/2010/07/03/325168.html)">[http://www.blogjava.net/xylz/archive/2010/07/03/325168.html](http://www.blogjava.net/xylz/archive/2010/07/03/325168.html)</a> </p>
<p>在JDK 5之前Java语言是靠synchronized关键字保证同步的，这会导致有锁（后面的章节还会谈到锁）。</p>
<p>锁机制存在以下问题：</p>
<p>（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p>
<p>（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。</p>
<p>（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p>
<p>volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。</p>
<p>独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</p>
<p><strong>CAS 操作</strong></p>
<p>上面的乐观锁用到的机制就是CAS，Compare and Swap。</p>
<p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<p><strong>非阻塞算法 （nonblocking algorithms）</strong>
一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。</p>
<p>现代的CPU提供了特殊的指令，可以自动更新共享数据，而且能够检测到其他线程的干扰，而 compareAndSet() 就用这些代替了锁定。</p>
<p>拿出AtomicInteger来研究在没有锁的情况下是如何做到数据正确性的。
private volatile int value;</p>
<p>首先毫无以为，在没有锁的机制下可能需要借助volatile原语，保证线程间的数据是可见的（共享的）。</p>
<p>这样才获取变量的值的时候才能直接读取。
public final int get() {
        return value;
    }</p>
<p>然后来看看++i是怎么做到的。</p>
<p>public final int incrementAndGet() {
    for (;;) {
        int current = get();
        int next = current + 1;
        if (compareAndSet(current, next))
            return next;
    }
}</p>
<p>在这里采用了CAS操作，每次从内存中读取数据然后将此数据和+1后的结果进行CAS操作，如果成功就返回结果，否则重试直到成功为止。</p>
<p>而compareAndSet利用JNI来完成CPU指令的操作。
public final boolean compareAndSet(int expect, int update) {<br>    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }</p>
<p>整体的过程就是这样子的，利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。</p>
<p>而整个J.U.C都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。参考资料的文章中介绍了如果利用CAS构建非阻塞计数器、队列等数据结构。</p>
<p>CAS看起来很爽，但是会导致“ABA问题”。</p>
<p>CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</p>
<p>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。如果链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。因此前面提到的原子操作AtomicStampedReference/AtomicMarkableReference就很有用了。这允许一对变化的元素进行原子操作。</p>
<p>参考资料：</p>
<p>（1）<a href="http://www.ibm.com/developerworks/cn/java/j-jtp04186/" target="_blank">非阻塞算法简介</a></p>
<p>（2）<a href="https://www.ibm.com/developerworks/cn/java/j-jtp11234/" target="_blank">流行的原子</a>
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/04/325206.html](http://www.blogjava.net/xylz/archive/2010/07/04/325206.html)">[http://www.blogjava.net/xylz/archive/2010/07/04/325206.html](http://www.blogjava.net/xylz/archive/2010/07/04/325206.html)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency2-原子操作/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency2-原子操作" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-java-com-jacob--jacob合并几个word文件到一个word文件/">jacob合并几个word文件到一个word文件</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-java-com-jacob--jacob合并几个word文件到一个word文件/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jacob-word-word-">jacob合并几个word文件到一个word文件</h1>
<pre><code> 因项目需要将几个word文件合并到一个word文件，后面附项目运用的jar包jacob-1.9
</code></pre><p>jacob运用中，需要将附件内的jacob.dll放到windows/system32下</p>
<pre><code> 直接上代码：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public static void main(String[] args) {  </li>
<li>List list  = new ArrayList();  </li>
<li>String file1= &quot;D:\file1.doc&quot;;  </li>
<li>String file2= &quot;D:\file2.doc&quot;;  </li>
<li>String file3= &quot;D:\file3.doc&quot;;  </li>
<li>list.add(file1);  </li>
<li>list.add(file2);  </li>
<li>list.add(file3);  </li>
<li>uniteDoc(list,&quot;d:\file.doc&quot;);  </li>
<li>}  </li>
<li>public static void uniteDoc(List fileList, String savepaths) {  </li>
<li>if (fileList.size() == 0 || fileList == null) {  </li>
<li>return;  </li>
<li>}  </li>
<li>//打开word  </li>
<li>ActiveXComponent app = new ActiveXComponent(&quot;Word.Application&quot;);//启动word  </li>
<li>try {  </li>
<li>// 设置word不可见  </li>
<li>app.setProperty(&quot;Visible&quot;, new Variant(false));  </li>
<li>//获得documents对象  </li>
<li>Object docs = app.getProperty(&quot;Documents&quot;).toDispatch();  </li>
<li>//打开第一个文件  </li>
<li>Object doc = Dispatch  </li>
<li>.invoke(  </li>
<li>(Dispatch) docs,  </li>
<li>&quot;Open&quot;,  </li>
<li>Dispatch.Method,  </li>
<li>new Object[] { (String) fileList.get(0),  </li>
<li>new Variant(false), new Variant(true) },  </li>
<li>new int[3]).toDispatch();  </li>
<li>//追加文件  </li>
<li>for (int i = 1; i &lt; fileList.size(); i++) {  </li>
<li>Dispatch.invoke(app.getProperty(&quot;Selection&quot;).toDispatch(),  </li>
<li>&quot;insertFile&quot;, Dispatch.Method, new Object[] {  </li>
<li>(String) fileList.get(i), &quot;&quot;,  </li>
<li>new Variant(false), new Variant(false),  </li>
<li>new Variant(false) }, new int[3]);  </li>
<li>}  </li>
<li>//保存新的word文件  </li>
<li>Dispatch.invoke((Dispatch) doc, &quot;SaveAs&quot;, Dispatch.Method,  </li>
<li>new Object[] { savepaths, new Variant(1) }, new int[3]);  </li>
<li>Variant f = new Variant(false);  </li>
<li>Dispatch.call((Dispatch) doc, &quot;Close&quot;, f);  </li>
<li>} catch (Exception e) {  </li>
<li>throw new RuntimeException(&quot;合并word文件出错.原因:&quot; + e);  </li>
<li>} finally {  </li>
<li>app.invoke(&quot;Quit&quot;, new Variant[] {});  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public static void main(String[] args) {</p>
<pre><code>        List list  = new ArrayList();
        String file1= &quot;D:\\file1.doc&quot;;

        String file2= &quot;D:\\file2.doc&quot;;
        String file3= &quot;D:\\file3.doc&quot;;

        list.add(file1);
        list.add(file2);

        list.add(file3);
        uniteDoc(list,&quot;d:\\file.doc&quot;);

}
public static void uniteDoc(List fileList, String savepaths) {

    if (fileList.size() == 0 || fileList == null) {
        return;

    }
    //打开word

    ActiveXComponent app = new ActiveXComponent(&quot;Word.Application&quot;);//启动word
    try {

        // 设置word不可见
        app.setProperty(&quot;Visible&quot;, new Variant(false));

        //获得documents对象
        Object docs = app.getProperty(&quot;Documents&quot;).toDispatch();

        //打开第一个文件
        Object doc = Dispatch

            .invoke(
                    (Dispatch) docs,

                    &quot;Open&quot;,
                    Dispatch.Method,

                    new Object[] { (String) fileList.get(0),
                            new Variant(false), new Variant(true) },

                    new int[3]).toDispatch();
        //追加文件

        for (int i = 1; i &lt; fileList.size(); i++) {
            Dispatch.invoke(app.getProperty(&quot;Selection&quot;).toDispatch(),

                &quot;insertFile&quot;, Dispatch.Method, new Object[] {
                        (String) fileList.get(i), &quot;&quot;,

                        new Variant(false), new Variant(false),
                        new Variant(false) }, new int[3]);

        }
        //保存新的word文件

        Dispatch.invoke((Dispatch) doc, &quot;SaveAs&quot;, Dispatch.Method,
            new Object[] { savepaths, new Variant(1) }, new int[3]);

        Variant f = new Variant(false);
        Dispatch.call((Dispatch) doc, &quot;Close&quot;, f);

    } catch (Exception e) {
        throw new RuntimeException(&quot;合并word文件出错.原因:&quot; + e);

    } finally {
        app.invoke(&quot;Quit&quot;, new Variant[] {});

    }
}
</code></pre>
      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/java-com/">java-com</a></li><li><a href="/categories/Java&J2EE/java-com/jacob/">jacob</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/jacob/" class="label label-success">jacob</a><a href="/tags/java-com/" class="label label-info">java-com</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java-com-jacob--jacob合并几个word文件到一个word文件/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-java-com-jacob--jacob合并几个word文件到一个word文件" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency28-线程池/">深入浅出 Java Concurrency (28)</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency28-线程池/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-concurrency-28-">深入浅出 Java Concurrency (28): 线程池</h1>
<p><a href="http://www.blogjava.net/xylz/archive/2010/12/19/341098.html" target="_blank"> 简介</a></p>
<p>从这一节开始正式进入线程池的部分。其实整个体系已经拖了很长的时间，因此后面的章节会加快速度，甚至只是一个半成品或者简单化，以后有时间的慢慢补充、完善。</p>
<p>其实线程池是并发包里面很重要的一部分，在实际情况中也是使用很多的一个重要组件。</p>
<p>下图描述的是线程池API的一部分。广义上的完整线程池可能还包括Thread/Runnable、Timer/TimerTask等部分。这里只介绍主要的和高级的API以及架构和原理。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-part-1-_8E6F/ThreadPool2_2.png" target="_blank"><img src="&quot;ThreadPool2&quot;" alt="ThreadPool2"></a></p>
<p>大多数并发应用程序是围绕执行任务（Task）进行管理的。所谓任务就是抽象、离散的工作单元（unit of work）。把一个应用程序的工作（work）分离到任务中，可以简化程序的管理；这种分离还在不同事物间划分了自然的分界线，可以方便程序在出现错误时进行恢复；同时这种分离还可以为并行工作提供一个自然的结构，有利于提高程序的并发性。<a href="http://www.blogjava.net/xylz/archive/2010/12/19/341098.html#jcp" target="_blank">[1]</a></p>
<p>并发执行任务的一个很重要前提是拆分任务。把一个大的过程或者任务拆分成很多小的工作单元，每一个工作单元可能相关、也可能无关，这些单元在一定程度上可以充分利用CPU的特性并发的执行，从而提高并发性（性能、响应时间、吞吐量等）。</p>
<p>所谓的任务拆分就是确定每一个执行任务（工作单元）的边界。理想情况下独立的工作单元有最大的吞吐量，这些工作单元不依赖于其它工作单元的状态、结果或者其他资源等。因此将任务尽可能的拆分成一个个独立的工作单元有利于提高程序的并发性。</p>
<p>对于有依赖关系以及资源竞争的工作单元就涉及到任务的调度和负载均衡。工作单元的状态、结果或者其他资源等有关联的工作单元就需要有一个总体的调度者来协调资源和执行顺序。同样在有限的资源情况下，大量的任务也需要一个协调各个工作单元的调度者。这就涉及到任务执行的策略问题。</p>
<p>任务的执行策略包括4W3H部分：</p>
<ul>
<li>任务在什么（What）线程中执行</li>
<li>任务以什么（What）顺序执行（FIFO/LIFO/优先级等）</li>
<li>同时有多少个（How Many）任务并发执行</li>
<li>允许有多少个（How Many）个任务进入执行队列</li>
<li>系统过载时选择放弃哪一个（Which）任务，如何（How）通知应用程序这个动作</li>
<li>任务执行的开始、结束应该做什么（What）处理</li>
</ul>
<p>在后面的章节中会详细分写这些策略是如何实现的。我们先来简单回答些如何满足上面的条件。</p>
<ol>
<li>首先明确一定是在Java里面可以供使用者调用的启动线程类是Thread。因此Runnable或者Timer/TimerTask等都是要依赖Thread来启动的，因此在ThreadPool里面同样也是靠Thread来启动多线程的。</li>
<li>默认情况下Runnable接口执行完毕后是不能拿到执行结果的，因此在ThreadPool里就定义了一个Callable接口来处理执行结果。</li>
<li>为了异步阻塞的获取结果，Future可以帮助调用线程获取执行结果。</li>
<li>Executor解决了向线程池提交任务的入口问题，同时ScheduledExecutorService解决了如何进行重复调用任务的问题。</li>
<li>CompletionService解决了如何按照执行完毕的顺序获取结果的问题，这在某些情况下可以提高任务执行的并发，调用线程不必在长时间任务上等待过多时间。</li>
<li>显然线程的数量是有限的，而且也不宜过多，因此合适的任务队列是必不可少的，BlockingQueue的容量正好可以解决此问题。</li>
<li>固定任务容量就意味着在容量满了以后需要一定的策略来处理过多的任务（新任务），RejectedExecutionHandler正好解决此问题。</li>
<li>一定时间内阻塞就意味着有超时，因此TimeoutException就是为了描述这种现象。TimeUnit是为了描述超时时间方便的一个时间单元枚举类。</li>
<li>有上述问题就意味了配置一个合适的线程池是很复杂的，因此Executors默认的一些线程池配置可以减少这个操作。</li>
</ol>
<p>线程池的基本策略大致就这些，从下一节开始就从线程池的基本原理和执行方法开始描述。</p>
<p><a href="">[1] Java Concurrency in Practice</a>
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/12/19/341098.html](http://www.blogjava.net/xylz/archive/2010/12/19/341098.html)">[http://www.blogjava.net/xylz/archive/2010/12/19/341098.html](http://www.blogjava.net/xylz/archive/2010/12/19/341098.html)</a> <a href="http://www.blogjava.net/xylz/archive/2010/12/21/341281.html" target="_blank">Executor 以及Executors</a>
Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。</p>
<p>下面这张图完整描述了线程池的类体系结构。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-28--part-1-_1302E/Executor-class_2.png" target="_blank"><img src="&quot;Executor-class&quot;" alt="Executor-class"></a></p>
<p>首先Executor的execute方法只是执行一个Runnable的任务，当然了从某种角度上将最后的实现类也是在线程中启动此任务的。根据线程池的执行策略最后这个任务可能在新的线程中执行，或者线程池中的某个线程，甚至是调用者线程中执行（相当于直接运行Runnable的run方法）。这点在后面会详细说明。</p>
<p>ExecutorService在Executor的基础上增加了一些方法，其中有两个核心的方法：</p>
<ul>
<li>Future&lt;?&gt; submit(Runnable task)</li>
<li><T> Future<T> submit(Callable<T> task)</li>
</ul>
<p>这两个方法都是向线程池中提交任务，它们的区别在于Runnable在执行完毕后没有结果，Callable执行完毕后有一个结果。这在多个线程中传递状态和结果是非常有用的。另外他们的相同点在于都返回一个Future对象。Future对象可以阻塞线程直到运行完毕（获取结果，如果有的话），也可以取消任务执行，当然也能够检测任务是否被取消或者是否执行完毕。</p>
<p>在没有Future之前我们检测一个线程是否执行完毕通常使用Thread.join()或者用一个死循环加状态位来描述线程执行完毕。现在有了更好的方法能够阻塞线程，检测任务执行完毕甚至取消执行中或者未开始执行的任务。</p>
<p>ScheduledExecutorService描述的功能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。这包括延迟时间一次性执行、延迟时间周期性执行以及固定延迟时间周期性执行等。当然了继承ExecutorService的ScheduledExecutorService拥有ExecutorService的全部特性。</p>
<p>ThreadPoolExecutor是ExecutorService的默认实现，其中的配置、策略也是比较复杂的，在后面的章节中会有详细的分析。</p>
<p>ScheduledThreadPoolExecutor是继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现，在后面的章节中会有详细的分析。</p>
<p>这里需要稍微提一下的是CompletionService接口，它是用于描述顺序获取执行结果的一个线程池包装器。它依赖一个具体的线程池调度，但是能够根据任务的执行先后顺序得到执行结果，这在某些情况下可能提高并发效率。</p>
<p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供了一些静态工厂，生成一些常用的线程池。</p>
<ul>
<li><strong>newSingleThreadExecutor</strong>：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
<li><strong>newFixedThreadPool</strong>：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li>
<li><strong>newCachedThreadPool</strong>：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</li>
<li><strong>newScheduledThreadPool</strong>：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
<li><strong>newSingleThreadScheduledExecutor</strong>：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<p>在详细讲解ThreadPoolExecutor的时候会具体讨论上述参数配置后的意义和原理。</p>
<p>线程池是一个复杂的任务调度工具，因此它涉及到任务、线程池等的生命周期问题，在下一节中来探讨下这个问题。
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/12/21/341281.html](http://www.blogjava.net/xylz/archive/2010/12/21/341281.html)">[http://www.blogjava.net/xylz/archive/2010/12/21/341281.html](http://www.blogjava.net/xylz/archive/2010/12/21/341281.html)</a> <a href="http://www.blogjava.net/xylz/archive/2011/01/04/342316.html" target="_blank">Executor 生命周期</a></p>
<p>我们知道线程是有多种执行状态的，同样管理线程的线程池也有多种状态。JVM会在所有线程（非后台daemon线程）全部终止后才退出，为了节省资源和有效释放资源关闭一个线程池就显得很重要。有时候无法正确的关闭线程池，将会阻止JVM的结束。</p>
<p>线程池Executor是异步的执行任务，因此任何时刻不能够直接获取提交的任务的状态。这些任务有可能已经完成，也有可能正在执行或者还在排队等待执行。因此关闭线程池可能出现一下几种情况：</p>
<ul>
<li>平缓关闭：已经启动的任务全部执行完毕，同时不再接受新的任务</li>
<li>立即关闭：取消所有正在执行和未执行的任务</li>
</ul>
<p>另外关闭线程池后对于任务的状态应该有相应的反馈信息。</p>
<p>图1 描述了线程池的4种状态。</p>
<ul>
<li>线程池在构造前（new操作）是初始状态，一旦构造完成线程池就进入了执行状态RUNNING。严格意义上讲线程池构造完成后并没有线程被立即启动，只有进行“预启动”或者接收到任务的时候才会启动线程。这个会后面线程池的原理会详细分析。但是线程池是出于运行状态，随时准备接受任务来执行。</li>
<li>线程池运行中可以通过shutdown()和shutdownNow()来改变运行状态。shutdown()是一个平缓的关闭过程，线程池停止接受新的任务，同时等待已经提交的任务执行完毕，包括那些进入队列还没有开始的任务，这时候线程池处于SHUTDOWN状态；shutdownNow()是一个立即关闭过程，线程池停止接受新的任务，同时线程池取消所有执行的任务和已经进入队列但是还没有执行的任务，这时候线程池处于STOP状态。</li>
<li>一旦shutdown()或者shutdownNow()执行完毕，线程池就进入TERMINATED状态，此时线程池就结束了。</li>
<li>isTerminating()描述的是SHUTDOWN和STOP两种状态。</li>
<li>isShutdown()描述的是非RUNNING状态，也就是SHUTDOWN/STOP/TERMINATED三种状态。</li>
</ul>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-part-3-Executor-_12486/Executor-Lifecycle_4.png" target="_blank"><img src="&quot;Executor-Lifecycle&quot;" alt="Executor-Lifecycle"></a></p>
<p>图1</p>
<p>线程池的API如下：</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-part-3-Executor-_12486/ExecutorService-LifeCycle_2.png" target="_blank"><img src="&quot;ExecutorService-LifeCycle&quot;" alt="ExecutorService-LifeCycle"></a></p>
<p>图2</p>
<p>其中shutdownNow()会返回那些已经进入了队列但是还没有执行的任务列表。awaitTermination描述的是等待线程池关闭的时间，如果等待时间线程池还没有关闭将会抛出一个超时异常。</p>
<p>对于关闭线程池期间发生的任务提交情况就会触发一个拒绝执行的操作。这是java.util.concurrent.RejectedExecutionHandler描述的任务操作。下一个小结中将描述这些任务被拒绝后的操作。</p>
<p>总结下这个小节：</p>
<ol>
<li>线程池有运行、关闭、停止、结束四种状态，结束后就会释放所有资源</li>
<li>平缓关闭线程池使用shutdown()</li>
<li>立即关闭线程池使用shutdownNow()，同时得到未执行的任务列表</li>
<li>检测线程池是否正处于关闭中，使用isShutdown()</li>
<li>检测线程池是否已经关闭使用isTerminated()</li>
<li>定时或者永久等待线程池关闭结束使用awaitTermination()操作</li>
</ol>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2011/01/04/342316.html](http://www.blogjava.net/xylz/archive/2011/01/04/342316.html)">[http://www.blogjava.net/xylz/archive/2011/01/04/342316.html](http://www.blogjava.net/xylz/archive/2011/01/04/342316.html)</a></p>
<p><strong>线程池数据结构与线程构造方法</strong></p>
<p>由于已经看到了ThreadPoolExecutor的源码，因此很容易就看到了ThreadPoolExecutor线程池的数据结构。图1描述了这种数据结构。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-32--part-5-_72AF/ThreadPoolExecutor_2.png" target="_blank"><img src="&quot;ThreadPoolExecutor&quot;" alt="ThreadPoolExecutor"></a></p>
<p>图1 ThreadPoolExecutor 数据结构</p>
<p>其实，即使没有上述图形描述ThreadPoolExecutor的数据结构，我们根据线程池的要求也很能够猜测出其数据结构出来。</p>
<ul>
<li>线程池需要支持多个线程并发执行，因此有一个线程集合Collection<Thread>来执行线程任务；</li>
<li>涉及任务的异步执行，因此需要有一个集合来缓存任务队列Collection<Runnable>；</li>
<li>很显然在多个线程之间协调多个任务，那么就需要一个线程安全的任务集合，同时还需要支持阻塞、超时操作，那么BlockingQueue是必不可少的；</li>
<li>既然是线程池，出发点就是提高系统性能同时降低资源消耗，那么线程池的大小就有限制，因此需要有一个核心线程池大小（线程个数）和一个最大线程池大小（线程个数），有一个计数用来描述当前线程池大小；</li>
<li>如果是有限的线程池大小，那么长时间不使用的线程资源就应该销毁掉，这样就需要一个线程空闲时间的计数来描述线程何时被销毁；</li>
<li>前面描述过线程池也是有生命周期的，因此需要有一个状态来描述线程池当前的运行状态；</li>
<li>线程池的任务队列如果有边界，那么就需要有一个任务拒绝策略来处理过多的任务，同时在线程池的销毁阶段也需要有一个任务拒绝策略来处理新加入的任务；</li>
<li>上面种的线程池大小、线程空闲实际那、线程池运行状态等等状态改变都不是线程安全的，因此需要有一个全局的锁（mainLock）来协调这些竞争资源；</li>
<li>除了以上数据结构以外，ThreadPoolExecutor还有一些状态用来描述线程池的运行计数，例如线程池运行的任务数、曾经达到的最大线程数，主要用于调试和性能分析。</li>
</ul>
<p>对于ThreadPoolExecutor而言，一个线程就是一个Worker对象，它与一个线程绑定，当Worker执行完毕就是线程执行完毕，这个在后面详细讨论线程池中线程的运行方式。</p>
<p>既然是线程池，那么就首先研究下线程的构造方法。
public interface ThreadFactory {
    Thread newThread(Runnable r);
}</p>
<p>ThreadPoolExecutor使用一个线程工厂来构造线程。线程池都是提交一个任务Runnable，然后在某一个线程Thread中执行，ThreadFactory 负责如何创建一个新线程。</p>
<p>在J.U.C中有一个通用的线程工厂java.util.concurrent.Executors.DefaultThreadFactory，它的构造方式如下：
static class DefaultThreadFactory implements ThreadFactory {
    static final AtomicInteger poolNumber = new AtomicInteger(1);
    final ThreadGroup group;
    final AtomicInteger threadNumber = new AtomicInteger(1);
    final String namePrefix;
    DefaultThreadFactory() {
        SecurityManager s = System.getSecurityManager();
        group = (s != null)? s.getThreadGroup() :
                             Thread.currentThread().getThreadGroup();
        namePrefix = &quot;pool-&quot; +
                      poolNumber.getAndIncrement() +
                     &quot;-thread-&quot;;
    }
    public Thread newThread(Runnable r) {
        Thread t = new Thread(group, r,
                              namePrefix + threadNumber.getAndIncrement(),
                              0);
        if (t.isDaemon())
            t.setDaemon(false);
        if (t.getPriority() != Thread.NORM_PRIORITY)
            t.setPriority(Thread.NORM_PRIORITY);
        return t;
    }
}</p>
<p>在这个线程工厂中，同一个线程池的所有线程属于同一个线程组，也就是创建线程池的那个线程组，同时线程池的名称都是“pool-<poolNum>-thread-<threadNum>”，其中poolNum是线程池的数量序号，threadNum是此线程池中的线程数量序号。这样如果使用jstack的话很容易就看到了系统中线程池的数量和线程池中线程的数量。另外对于线程池中的所有线程默认都转换为非后台线程，这样主线程退出时不会直接退出JVM，而是等待线程池结束。还有一点就是默认将线程池中的所有线程都调为同一个级别，这样在操作系统角度来看所有系统都是公平的，不会导致竞争堆积。</p>
<p><strong>线程池中线程生命周期</strong></p>
<p>一个线程Worker被构造出来以后就开始处于运行状态。以下是一个线程执行的简版逻辑。
private final class Worker implements Runnable {
    private final ReentrantLock runLock = new ReentrantLock();
    private Runnable firstTask;
    Thread thread;
    Worker(Runnable firstTask) {
        this.firstTask = firstTask;
    }
    private void runTask(Runnable task) {
        final ReentrantLock runLock = this.runLock;
        runLock.lock();
        try {
           task.run();
        } finally {
            runLock.unlock();
        }
    }
    public void run() {
        try {
            Runnable task = firstTask;
            firstTask = null;
            while (task != null || (task = getTask()) != null) {
                runTask(task);
                task = null;
            }
        } finally {
            workerDone(this);
        }
    }
}</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-32--part-5-_72AF/ThreadPoolExecutor-Worker_2.png" target="_blank"><img src="&quot;ThreadPoolExecutor-Worker&quot;" alt="ThreadPoolExecutor-Worker"></a></p>
<p>当提交一个任务时，如果需要创建一个线程（何时需要在下一节中探讨）时，就调用线程工厂创建一个线程，同时将线程绑定到Worker工作队列中。需要说明的是，Worker队列构造的时候带着一个任务Runnable，因此Worker创建时总是绑定着一个待执行任务。换句话说，创建线程的前提是有必要创建线程（任务数已经超出了线程或者强制创建新的线程，至于为何强制创建新的线程后面章节会具体分析），不会无缘无故创建一堆空闲线程等着任务。这是节省资源的一种方式。</p>
<p>一旦线程池启动线程后（调用线程run()）方法，那么线程工作队列Worker就从第1个任务开始执行（这时候发现构造Worker时传递一个任务的好处了），一旦第1个任务执行完毕，就从线程池的任务队列中取出下一个任务进行执行。循环如此，直到线程池被关闭或者任务抛出了一个RuntimeException。</p>
<p>由此可见，线程池的基本原理其实也很简单，无非预先启动一些线程，线程进入死循环状态，每次从任务队列中获取一个任务进行执行，直到线程池被关闭。如果某个线程因为执行某个任务发生异常而终止，那么重新创建一个新的线程而已。如此反复。</p>
<p>其实，线程池原理看起来简单，但是复杂的是各种策略，例如何时该启动一个线程，何时该终止、挂起、唤醒一个线程，任务队列的阻塞与超时，线程池的生命周期以及任务拒绝策略等等。下一节将研究这些策略问题。</p>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2011/01/18/343183.html](http://www.blogjava.net/xylz/archive/2011/01/18/343183.html)">[http://www.blogjava.net/xylz/archive/2011/01/18/343183.html](http://www.blogjava.net/xylz/archive/2011/01/18/343183.html)</a> </p>
<p><strong>线程池任务执行流程</strong></p>
<p>我们从一个API开始接触Executor是如何处理任务队列的。</p>
<p>java.util.concurrent.Executor.execute(Runnable)
Executes the given task sometime in the future. The task may execute in a new thread or in an existing pooled thread. If the task cannot be submitted for execution, either because this executor has been shutdown or because its capacity has been reached, the task is handled by the current RejectedExecutionHandler.</p>
<p>线程池中所有任务执行都依赖于此接口。这段话有以下几个意思：</p>
<ol>
<li>任务可能在将来某个时刻被执行，有可能不是立即执行。为什么这里有两个“可能”？继续往下面看。</li>
<li>任务可能在一个新的线程中执行或者线程池中存在的一个线程中执行。</li>
<li>任务无法被提交执行有以下两个原因：线程池已经关闭或者线程池已经达到了容量限制。</li>
<li>所有失败的任务都将被“当前”的任务拒绝策略RejectedExecutionHandler 处理。</li>
</ol>
<p>回答上面两个“可能“。任务可能被执行，那不可能的情况就是上面说的情况3；可能不是立即执行，是因为任务可能还在队列中排队，因此还在等待分配线程执行。了解完了字面上的问题，我们再来看具体的实现。
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) {
        if (runState == RUNNING &amp;&amp; workQueue.offer(command)) {
            if (runState != RUNNING || poolSize == 0)
                ensureQueuedTaskHandled(command);
        }
        else if (!addIfUnderMaximumPoolSize(command))
            reject(command); // is shutdown or saturated
    }
}</p>
<p>这一段代码看起来挺简单的，其实这就是线程池最重要的一部分，如果能够完全理解这一块，线程池还是挺容易的。整个执行流程是这样的：</p>
<ol>
<li>如果任务command为空，则抛出空指针异常，返回。否则进行2。</li>
<li>如果当前线程池大小 大于或等于 核心线程池大小，进行4。否则进行3。</li>
<li>创建一个新工作队列（线程，参考上一节），成功直接返回，失败进行4。</li>
<li>如果线程池正在运行并且任务加入线程池队列成功，进行5，否则进行7。</li>
<li>如果线程池已经关闭或者线程池大小为0，进行6，否则直接返回。</li>
<li>如果线程池已经关闭则执行拒绝策略返回，否则启动一个新线程来进行执行任务，返回。</li>
<li>如果线程池大小 不大于 最大线程池数量，则启动新线程来进行执行，否则进行拒绝策略，结束。</li>
</ol>
<p>文字描述步骤不够简单？下面图形详细表述了此过程。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-34--part-7--2_BFAE/Executor.execute_8.png" target="_blank"><img src="&quot;Executor.execute&quot;" alt="Executor.execute"></a></p>
<p>老实说这个图比上面步骤更难以理解，那么从何入手呢。</p>
<p>流程的入口很简单，我们就是要执行一个任务（Runnable command)，那么它的结束点在哪或者有哪几个？</p>
<p>根据左边这个图我们知道可能有以下几种出口：</p>
<p>（1）图中的P1、P7，我们根据这条路径可以看到，仅仅是将任务加入任务队列（offer(command)）了；</p>
<p>（2）图中的P3，这条路径不将任务加入任务队列，但是启动了一个新工作线程（Worker）进行扫尾操作，用户处理为空的任务队列；</p>
<p>（3）图中的P4，这条路径没有将任务加入任务队列，但是启动了一个新工作线程（Worker），并且工作现场的第一个任务就是当前任务；</p>
<p>（4）图中的P5、P6，这条路径没有将任务加入任务队列，也没有启动工作线程，仅仅是抛给了任务拒绝策略。P2是任务加入了任务队列却因为线程池已经关闭于是又从任务队列中删除，并且抛给了拒绝策略。</p>
<p>如果上面的解释还不清楚，可以去研究下面两段代码：
java.util.concurrent.ThreadPoolExecutor.addIfUnderCorePoolSize(Runnable)
java.util.concurrent.ThreadPoolExecutor.addIfUnderMaximumPoolSize(Runnable)
java.util.concurrent.ThreadPoolExecutor.ensureQueuedTaskHandled(Runnable)</p>
<p>那么什么时候一个任务被立即执行呢？</p>
<p>在线程池运行状态下，如果线程池大小 小于 核心线程池大小或者线程池已满（任务队列已满）并且线程池大小 小于 最大线程池大小（此时线程池大小 大于 核心线程池大小的），用程序描述为：
runState == RUNNING &amp;&amp; ( poolSize &lt; corePoolSize || poolSize &lt; maxnumPoolSize &amp;&amp; workQueue.isFull())</p>
<p>上面的条件就是一个任务能够被立即执行的条件。</p>
<p>有了execute的基础，我们看看ExecutorService中的几个submit方法的实现。
    public Future&lt;?&gt; submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<Object> ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }
    public <T> Future<T> submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }
    public <T> Future<T> submit(Callable<T> task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }</p>
<p>很简单，不是么？对于一个线程池来说复杂的地方也就在execute方法的执行流程。在下一节中我们来讨论下如何获取任务的执行结果，也就是Future类的使用和原理。</p>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2011/02/11/344091.html](http://www.blogjava.net/xylz/archive/2011/02/11/344091.html)">[http://www.blogjava.net/xylz/archive/2011/02/11/344091.html](http://www.blogjava.net/xylz/archive/2011/02/11/344091.html)</a> </p>
<p><strong>线程池任务执行结果</strong></p>
<p>这一节来探讨下线程池中任务执行的结果以及如何阻塞线程、取消任务等等。
1 package info.imxylz.study.concurrency.future;
2 
3 public class SleepForResultDemo implements Runnable {
4 
5     static boolean result = false;
6 
7     static void sleepWhile(long ms) {
8         try {
9             Thread.sleep(ms);
10         } catch (Exception e) {}
11     }
12 
13     @Override
14     public void run() {
15         //do work
16         System.out.println(&quot;Hello, sleep a while.&quot;);
17         sleepWhile(2000L);
18         result = true;
19     }
20 
21     public static void main(String[] args) {
22         SleepForResultDemo demo = new SleepForResultDemo();
23         Thread t = new Thread(demo);
24         t.start();
25         sleepWhile(3000L);
26         System.out.println(result);
27     }
28 
29 }
30 </p>
<p>在没有线程池的时代里面，使用Thread.sleep(long)去获取线程执行完毕的场景很多。显然这种方式很笨拙，他需要你事先知道任务可能的执行时间，并且还会阻塞主线程，不管任务有没有执行完毕。</p>
<p>1 package info.imxylz.study.concurrency.future;
2 
3 public class SleepLoopForResultDemo implements Runnable {
4 
5     boolean result = false;
6 
7     volatile boolean finished = false;
8 
9     static void sleepWhile(long ms) {
10         try {
11             Thread.sleep(ms);
12         } catch (Exception e) {}
13     }
14 
15     @Override
16     public void run() {
17         //do work
18         try {
19             System.out.println(&quot;Hello, sleep a while.&quot;);
20             sleepWhile(2000L);
21             result = true;
22         } finally {
23             finished = true;
24         }
25     }
26 
27     public static void main(String[] args) {
28         SleepLoopForResultDemo demo = new SleepLoopForResultDemo();
29         Thread t = new Thread(demo);
30         t.start();
31         while (!demo.finished) {
32             sleepWhile(10L);
33         }
34         System.out.println(demo.result);
35     }
36 
37 }
38 </p>
<p>使用volatile与while死循环的好处就是等待的时间可以稍微小一点，但是依然有CPU负载高并且阻塞主线程的问题。最简单的降低CPU负载的方式就是使用Thread.join().</p>
<pre><code>    SleepLoopForResultDemo demo = new SleepLoopForResultDemo();
    Thread t = new Thread(demo);
    t.start();
    t.join();
    System.out.println(demo.result);
</code></pre><p>显然这也是一种不错的方式，另外还有自己写锁使用wait/notify的方式。其实join()从本质上讲就是利用while和wait来实现的。</p>
<p>上面的方式中都存在一个问题，那就是会阻塞主线程并且任务不能被取消。为了解决这个问题，线程池中提供了一个Future接口。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-35--part-8--2_BFEA/ThreadPoolExecutor-Future_2.png" target="_blank"><img src="&quot;ThreadPoolExecutor-Future&quot;" alt="ThreadPoolExecutor-Future"></a></p>
<p>在Future接口中提供了5个方法。</p>
<ul>
<li>V get() throws InterruptedException, ExecutionException： 等待计算完成，然后获取其结果。</li>
<li>V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException。最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）。</li>
<li>boolean cancel(boolean mayInterruptIfRunning)：试图取消对此任务的执行。</li>
<li>boolean isCancelled()：如果在任务正常完成前将其取消，则返回 true。</li>
<li>boolean isDone()：如果任务已完成，则返回 true。 可能由于正常终止、异常或取消而完成，在所有这些情况中，此方法都将返回 true。</li>
</ul>
<p>API看起来容易，来研究下异常吧。get()请求获取一个结果会阻塞当前进程，并且可能抛出以下三种异常：</p>
<ul>
<li>InterruptedException：执行任务的线程被中断则会抛出此异常，此时不能知道任务是否执行完毕，因此其结果是无用的，必须处理此异常。</li>
<li>ExecutionException：任务执行过程中(Runnable/#run()）方法可能抛出RuntimeException，如果提交的是一个java.util.concurrent.Callable<V>接口任务，那么java.util.concurrent.Callable.call()方法有可能抛出任意异常。</li>
<li>CancellationException：实际上get()方法还可能抛出一个CancellationException的RuntimeException，也就是任务被取消了但是依然去获取结果。</li>
</ul>
<p>对于get(long timeout, TimeUnit unit)而言，除了get()方法的异常外，由于有超时机制，因此还可能得到一个TimeoutException。</p>
<p>boolean cancel(boolean mayInterruptIfRunning)方法比较复杂，各种情况比较多：</p>
<ol>
<li>如果任务已经执行完毕，那么返回false。</li>
<li>如果任务已经取消，那么返回false。</li>
<li>循环直到设置任务为取消状态，对于未启动的任务将永远不再执行，对于正在运行的任务，将根据mayInterruptIfRunning是否中断其运行，如果不中断那么任务将继续运行直到结束。</li>
<li>此方法返回后任务要么处于运行结束状态，要么处于取消状态。isDone()将永远返回true，如果cancel()方法返回true，isCancelled()始终返回true。</li>
</ol>
<p>来看看Future接口的实现类java.util.concurrent.FutureTask<V>具体是如何操作的。</p>
<p>在FutureTask中使用了一个<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank">AQS</a>数据结构来完成各种状态以及加锁、阻塞的实现。</p>
<p>在此AQS类java.util.concurrent.FutureTask.Sync中一个任务用4中状态：</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-35--part-8--2_BFEA/ThreadPoolExecutor-FutureTask-state_2.png" target="_blank"><img src="&quot;ThreadPoolExecutor-FutureTask-state&quot;" alt="ThreadPoolExecutor-FutureTask-state"></a></p>
<p>初始情况下任务状态state=0，任务执行(innerRun)后状态变为运行状态RUNNING(state=1)，执行完毕后变成运行结束状态RAN(state=2)。任务在初始状态或者执行状态被取消后就变为状态CANCELLED(state=4)。<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank">AQS</a>最擅长无锁情况下处理几种简单的状态变更的。
        void innerRun() {
            if (!compareAndSetState(0, RUNNING))
                return;
            try {
                runner = Thread.currentThread();
                if (getState() == RUNNING) // recheck after setting thread
                    innerSet(callable.call());
                else
                    releaseShared(0); // cancel
            } catch (Throwable ex) {
                innerSetException(ex);
            }
        }</p>
<p>执行一个任务有四步：设置运行状态、设置当前线程（AQS需要）、执行任务(Runnable/#run或者Callable/#call）、设置执行结果。这里也可以看到，一个任务只能执行一次，因为执行完毕后它的状态不在为初始值0，要么为CANCELLED，要么为RAN。</p>
<p>取消一个任务(cancel)又是怎样进行的呢？对比下前面取消任务的描述是不是很简单，这里无非利用AQS的状态来改变任务的执行状态，最终达到放弃未启动或者正在执行的任务的目的。
boolean innerCancel(boolean mayInterruptIfRunning) {
    for (;;) {
        int s = getState();
        if (ranOrCancelled(s))
            return false;
        if (compareAndSetState(s, CANCELLED))
            break;
    }
    if (mayInterruptIfRunning) {
        Thread r = runner;
        if (r != null)
            r.interrupt();
    }
    releaseShared(0);
    done();
    return true;
}</p>
<p>到目前为止我们依然没有说明到底是如何阻塞获取一个结果的。下面四段代码描述了这个过程。</p>
<p>1     V innerGet() throws InterruptedException, ExecutionException {
2         acquireSharedInterruptibly(0);
3         if (getState() == CANCELLED)
4             throw new CancellationException();
5         if (exception != null)
6             throw new ExecutionException(exception);
7         return result;
8     }
9     //AQS/#acquireSharedInterruptibly
10     public final void acquireSharedInterruptibly(int arg) throws InterruptedException {
11         if (Thread.interrupted())
12             throw new InterruptedException();
13         if (tryAcquireShared(arg) &lt; 0)
14             doAcquireSharedInterruptibly(arg); //park current Thread for result
15     }
16     protected int tryAcquireShared(int ignore) {
17         return innerIsDone()? 1 : -1;
18     }
19 
20     boolean innerIsDone() {
21         return ranOrCancelled(getState()) &amp;&amp; runner == null;
22     }</p>
<p>当调用Future/#get()的时候尝试去获取一个共享变量。这就涉及到AQS的使用方式了。这里获取一个共享变量的状态是任务是否结束(innerIsDone())，也就是任务是否执行完毕或者被取消。如果不满足条件，那么在AQS中就会doAcquireSharedInterruptibly(arg)挂起当前线程，直到满足条件。AQS前面讲过，挂起线程使用的是LockSupport的park方式，因此性能消耗是很低的。</p>
<p>至于将Runnable接口转换成Callable接口，java.util.concurrent.Executors.callable(Runnable, T)也提供了一个简单实现。
    static final class RunnableAdapter<T> implements Callable<T> {
        final Runnable task;
        final T result;
        RunnableAdapter(Runnable  task, T result) {
            this.task = task;
            this.result = result;
        }
        public T call() {
            task.run();
            return result;
        }
    }</p>
<p><strong>延迟、周期性任务调度的实现</strong></p>
<p>java.util.concurrent.ScheduledThreadPoolExecutor是默认的延迟、周期性任务调度的实现。</p>
<p>有了整个线程池的实现，再回头来看延迟、周期性任务调度的实现应该就很简单了，因为所谓的延迟、周期性任务调度，无非添加一系列有序的任务队列，然后按照执行顺序的先后来处理整个任务队列。如果是周期性任务，那么在执行完毕的时候加入下一个时间点的任务即可。</p>
<p>由此可见，ScheduledThreadPoolExecutor和ThreadPoolExecutor的唯一区别在于任务是有序（按照执行时间顺序）的，并且需要到达时间点（临界点）才能执行，并不是任务队列中有任务就需要执行的。也就是说唯一不同的就是任务队列BlockingQueue<Runnable> workQueue不一样。ScheduledThreadPoolExecutor的任务队列是java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue，它是基于java.util.concurrent.DelayQueue<RunnableScheduledFuture>队列的实现。</p>
<p>DelayQueue是基于有序队列<a href="http://www.blogjava.net/xylz/archive/2010/07/30/327582.html" target="_blank">PriorityQueue</a>实现的。<a href="http://www.blogjava.net/xylz/archive/2010/07/30/327582.html" target="_blank">PriorityQueue</a> 也叫优先级队列，按照自然顺序对元素进行排序，类似于TreeMap/Collections.sort一样。</p>
<p>同样是有序队列，DelayQueue和<a href="http://www.blogjava.net/xylz/archive/2010/07/30/327582.html" target="_blank">PriorityQueue</a>区别在什么地方？</p>
<p>由于DelayQueue在获取元素时需要检测元素是否“可用”，也就是任务是否达到“临界点”（指定时间点），因此加入元素和移除元素会有一些额外的操作。</p>
<p>典型的，移除元素需要检测元素是否达到“临界点”，增加元素的时候如果有一个元素比“头元素”更早达到临界点，那么就需要通知任务队列。因此这需要一个条件变量final Condition available 。</p>
<p>移除元素（出队列）的过程是这样的：</p>
<ul>
<li>总是检测队列的头元素（顺序最小元素，也是最先达到临界点的元素）</li>
<li>检测头元素与当前时间的差，如果大于0，表示还未到底临界点，因此等待响应时间（使用条件变量available)</li>
<li>如果小于或者等于0，说明已经到底临界点或者已经过了临界点，那么就移除头元素，并且唤醒其它等待任务队列的线程。
  public E take() throws InterruptedException {<pre><code>  final ReentrantLock lock = this.lock;
  lock.lockInterruptibly();
  try {
      for (;;) {
          E first = q.peek();
          if (first == null) {
              available.await();
          } else {
              long delay =  first.getDelay(TimeUnit.NANOSECONDS);
              if (delay &gt; 0) {
                  long tl = available.awaitNanos(delay);
              } else {
                  E x = q.poll();
                  assert x != null;
                  if (q.size() != 0)
                      available.signalAll(); // wake up other takers
                  return x;
              }
          }
      }
  } finally {
      lock.unlock();
  }
</code></pre>  }</li>
</ul>
<p>同样加入元素也会有相应的条件变量操作。当前仅当队列为空或者要加入的元素比队列中的头元素还小的时候才需要唤醒“等待线程”去检测元素。因为头元素都没有唤醒那么比头元素更延迟的元素就更加不会唤醒。</p>
<pre><code>public boolean offer(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        E first = q.peek();
        q.offer(e);
        if (first == null || e.compareTo(first) &lt; 0)
            available.signalAll();
        return true;
    } finally {
        lock.unlock();
    }
}
</code></pre><p>有了任务队列后再来看Future在ScheduledThreadPoolExecutor中是如何操作的。</p>
<p>java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask<V>是继承java.util.concurrent.FutureTask<V>的，区别在于执行任务是否是周期性的。
        private void runPeriodic() {
            boolean ok = ScheduledFutureTask.super.runAndReset();
            boolean down = isShutdown();
            // Reschedule if not cancelled and not shutdown or policy allows
            if (ok &amp;&amp; (!down ||
                       (getContinueExistingPeriodicTasksAfterShutdownPolicy() &amp;&amp;
                        !isStopped()))) {
                long p = period;
                if (p &gt; 0)
                    time += p;
                else
                    time = now() - p;
                ScheduledThreadPoolExecutor.super.getQueue().add(this);
            }
            // This might have been the final executed delayed
            // task.  Wake up threads to check.
            else if (down)
                interruptIdleWorkers();
        }
        //<em>/</em>
         /<em> Overrides FutureTask version so as to reset/requeue if periodic.
         /</em>/
        public void run() {
            if (isPeriodic())
                runPeriodic();
            else
                ScheduledFutureTask.super.run();
        }
    }</p>
<p>如果不是周期性任务调度，那么就和java.util.concurrent.FutureTask.Sync的调度方式是一样的。如果是周期性任务（isPeriodic()）那么就稍微有所不同的。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-35--part-8--2_BFEA/ScheduledThreadPoolExecutor-ScheduledFutureTask_4.png" target="_blank"><img src="&quot;ScheduledThreadPoolExecutor-ScheduledFutureTask&quot;" alt="ScheduledThreadPoolExecutor-ScheduledFutureTask"></a></p>
<p>先从功能/结构上分析下。第一种情况假设提交的任务每次执行花费10s，间隔（delay/period)为20s，对于scheduleAtFixedRate而言，每次执行开始时间20s，对于scheduleWithFixedDelay来说每次执行开始时间30s。第二种情况假设提交的任务每次执行时间花费20s，间隔（delay/period)为10s，对于scheduleAtFixedRate而言，每次执行开始时间10s，对于scheduleWithFixedDelay来说每次执行开始时间30s。（具体分析可以参考<a href="http://www.blogjava.net/xylz/archive/2011/01/10/342738.html" target="_blank">这里</a>）</p>
<p>也就是说scheduleWithFixedDelay的执行开始时间为(delay+cost)，而对于scheduleAtFixedRate来说执行开始时间为max(period,cost)。</p>
<p>回头再来看上面源码runPeriodic()就很容易了。但特别要提醒的，如果任务的任何一个执行遇到异常，则后续执行都会被取消，这从runPeriodic()就能看出。要强调的第二点就是<strong>同一个周期性任务不会被同时执行</strong>。就比如说尽管上面第二种情况的scheduleAtFixedRate任务每隔10s执行到达一个时间点，但是由于每次执行时间花费为20s，因此每次执行间隔为20s，只不过执行的任务次数会多一点。但从本质上讲就是每隔20s执行一次，如果任务队列不取消的话。</p>
<p>为什么不会同时执行？</p>
<p>这是因为ScheduledFutureTask执行的时候会将任务从队列中移除来，执行完毕以后才会添加下一个同序列的任务，因此任务队列中其实最多只有同序列的任务的一份副本，所以永远不会同时执行（尽管要执行的时间在过去）。</p>
<p>ScheduledThreadPoolExecutor使用一个无界（容量无限，整数的最大值）的容器（DelayedWorkQueue队列），根据<a href="http://www.blogjava.net/xylz/archive/2011/02/11/344091.html" target="_blank">ThreadPoolExecutor</a>的原理，只要当容器满的时候才会启动一个大于corePoolSize的线程数。因此实际上ScheduledThreadPoolExecutor是一个固定线程大小的线程池，固定大小为corePoolSize，构造函数里面的Integer.MAX_VALUE其实是不生效的（尽管<a href="http://www.blogjava.net/xylz/archive/2010/07/30/327582.html" target="_blank">PriorityQueue</a>使用数组实现有<a href="http://www.blogjava.net/xylz/archive/2010/07/30/327582.html" target="_blank">PriorityQueue</a>大小限制，如果你的任务数超过了2147483647就会导致OutOfMemoryError，这个参考<a href="http://www.blogjava.net/xylz/archive/2010/07/30/327582.html" target="_blank">PriorityQueue</a>的grow方法）。</p>
<p>再回头看scheduleAtFixedRate等方法就容易多了。无非就是往任务队列中添加一个未来某一时刻的ScheduledFutureTask任务，如果是scheduleAtFixedRate那么period/delay就是正数，如果是scheduleWithFixedDelay那么period/delay就是一个负数，如果是0那么就是一次性任务。直接调用父类<a href="http://www.blogjava.net/xylz/archive/2011/02/11/344091.html" target="_blank">ThreadPoolExecutor</a>的execute/submit等方法就相当于period/delay是0，并且initialDelay也是0。
    public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit) {
        if (command == null || unit == null)
            throw new NullPointerException();
        if (period &lt;= 0)
            throw new IllegalArgumentException();
        if (initialDelay &lt; 0) initialDelay = 0;
        long triggerTime = now() + unit.toNanos(initialDelay);
        RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,
            new ScheduledFutureTask<Object>(command,
                                            null,
                                            triggerTime,
                                            unit.toNanos(period)));
        delayedExecute(t);
        return t;
    }</p>
<p>另外需要补充说明的一点，前面说过java.util.concurrent.FutureTask.Sync任务只能执行一次，那么在runPeriodic()里面怎么又将执行过的任务加入队列中呢？这是因为java.util.concurrent.FutureTask.Sync提供了一个innerRunAndReset()方法，此方法不仅执行任务还将任务的状态还原成0（初始状态）了，所以此任务就可以重复执行。这就是为什么runPeriodic()里面调用runAndRest()的缘故。</p>
<pre><code>    boolean innerRunAndReset() {
        if (!compareAndSetState(0, RUNNING))
            return false;
        try {
            runner = Thread.currentThread();
            if (getState() == RUNNING)
                callable.call(); // don&#39;t set result
            runner = null;
            return compareAndSetState(RUNNING, 0);
        } catch (Throwable ex) {
            innerSetException(ex);
            return false;
        }
    }
</code></pre><p><strong>后话</strong></p>
<p>整个并发实践原理和实现（源码）上的东西都讲完了，后面几个小节是一些总结和扫尾的工作，包括超时机制、异常处理等一些细节问题。也就是说大部分只需要搬出一些理论和最佳实践知识出来就好了，不会有大量费脑筋的算法分析和原理、思想探讨之类的。后面的章节也会加快一些进度。</p>
<p>老实说从刚开始的好奇到中间的兴奋，再到现在的彻悟，收获还是很多，个人觉得这是最认真、最努力也是自我最满意的一次技术研究和探讨，同时在这个过程中将很多技术细节都串联起来了，慢慢就有了那种技术相通的感觉。原来有了理论以后再去实践、再去分析问题、解决问题和那种纯解决问题得到的经验完全不一样。整个专辑下来不仅仅是并发包这一点点知识，设计到硬件、软件、操作系统、网络、安全、性能、算法、理论等等，总的来说这也算是一次比较成功的研究切入点，这比<a href="http://www.blogjava.net/xylz/archive/2009/12/22/306955.html" target="_blank">Guice</a>那次探讨要深入和持久的多。
来源： <a href="[http://www.blogjava.net/xylz/archive/2011/02/13/344207.html](http://www.blogjava.net/xylz/archive/2011/02/13/344207.html)">[http://www.blogjava.net/xylz/archive/2011/02/13/344207.html](http://www.blogjava.net/xylz/archive/2011/02/13/344207.html)</a> </p>
<p><a href="http://www.blogjava.net/xylz/archive/2011/07/12/354206.html" target="_blank">并发操作异常体系</a> </p>
<p>并发包引入的工具类很多方法都会抛出一定的异常，这些异常描述了任务在线程池中执行时发生的例外情况，而通常这些例外需要应用程序进行捕捉和处理。</p>
<p>例如在Future接口中有如下一个API：</p>
<p>java.util.concurrent.Future.get(long, TimeUnit) throws InterruptedException, ExecutionException, TimeoutException;</p>
<p>在<a href="http://www.blogjava.net/xylz/archive/2011/02/13/344207.html" target="_blank">前面的章节</a>中描述了Future类的具体实现原理。这里不再讨论，但是比较好奇的抛出的三个异常。</p>
<p>这里有一篇文章（<a href="http://www.ibm.com/developerworks/cn/java/j-jtp05236.html" target="_blank">Java 理论与实践: 处理 InterruptedException</a>）描述了InterruptedException的来源和处理方式。简单的说就是线程在执行的过程中被自己或者别人中断了。这时候为了响应中断就需要处理当前的异常。</p>
<p>对于java.lang.Thread而言，InterruptedException也是一个很诡异的问题。</p>
<p>中断一个线程Thread.<strong>interrupt()</strong>时会触发下面一种情况：
如果线程在调用 Object 类的 wait()、wait(long) 或 wait(long, int) 方法，或者该类的 join()、join(long)、join(long, int)、sleep(long) 或 sleep(long, int) 方法过程中受阻，则其中断状态将被清除，它还将收到一个 InterruptedException。</p>
<p>检测一个线程的中断状态描述是这样的Thread.<strong>interrupted()：</strong></p>
<p>测试当前线程是否已经中断。线程的<em>中断状态</em> 由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回 false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。 </p>
<p>也就是说如果检测到一个线程已经被中断了，那么线程的使用方（挂起、等待或者正在执行）都将应该得到一个中断异常，同时将会清除异常中断状态。</p>
<p>V innerGet(long nanosTimeout) throws InterruptedException, ExecutionException, TimeoutException {
    if (!tryAcquireSharedNanos(0, nanosTimeout))
        throw new TimeoutException();
    if (getState() == CANCELLED)
        throw new CancellationException();
    if (exception != null)
        throw new ExecutionException(exception);
    return result;
}</p>
<p>上面获取任务结果的方法实现中，将在获取锁的过程中得到一个中断异常。代码java.util.concurrent.locks.AbstractQueuedSynchronizer.tryAcquireSharedNanos(int, long)描述了这种情况：
    public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    return tryAcquireShared(arg) &gt;= 0 ||
        doAcquireSharedNanos(arg, nanosTimeout);
    }</p>
<p>这里在获取锁的时候检测线程中断情况，如果被中断则清除中断位，同时抛出一个中断异常。为什么如此做？因为我们的线程在线程池中是被重复执行的，所以一旦线程被中断后并不会退出线程，而是设置中断位，等候任务队列自己处理线程，从而达到线程被重复利用的目的。有兴趣的可以参考代码java.util.concurrent.ThreadPoolExecutor.Worker.runTask(Runnable)。这里在关闭线程池时就会导致中断所有线程。</p>
<p>除了InterruptedException 异常我们还发现了一个全新的异常java.util.concurrent.TimeoutException，此异常是用来描述任务执行时间超过了期望等待时间，也许是一直没有获取到锁，也许是还没有执行完成。</p>
<p>在innerGet代码片段中我们看到，如果线程在指定的时间无法获取到锁，那么就会得到一个超时异常。这个很好理解，比如如果执行一个非常耗时的网络任务，我们不希望任务一直等待从而占用大量的资源，可能在一定时间后就会希望取消此操作。此时超时异常很好的描述了这种需求。</p>
<p>与此同时，如果取消了一个任务，那么再次从任务中获取执行结果，那么将会得到一个任务被取消的异常java.util.concurrent.CancellationException。</p>
<p>除了上述异常外，还将得到一个java.util.concurrent.ExecutionException异常，</p>
<p>这是因为我们的提交的任务java.util.concurrent.Callable在call()方法中允许抛出任何异常，另外常规的线程执行也可能抛出一个RuntimeException，所以这里简单包装了下所有异常，当作执行过程中发生的异常ExecutionException抛出。</p>
<p>以上就是整个异常体系，所有并发操作的异常都可以归结于上述几类。</p>
<p>很多情况下处理时间长度都是用<strong>java.util.concurrent.TimeUnit</strong>，这是一个枚举类型，用来描述时间长度。其中内置了一些长度的单位。其中包括纳秒、微秒、毫秒、秒、分、时、天。例如超时操作5秒，可以使用</p>
<p>Future.get(5,TimeUnit.SECONDS) 或者 Future.get(5000L,TimeUnit.MILLISECONDS)</p>
<p>当然一种单位的时间转换成另一种单位的时间也是非常方便的。另外还有线程的sleep/join以及对象的wait操作的便捷操作。
来源： <a href="[http://www.blogjava.net/xylz/archive/2011/07/12/354206.html](http://www.blogjava.net/xylz/archive/2011/07/12/354206.html)">[http://www.blogjava.net/xylz/archive/2011/07/12/354206.html](http://www.blogjava.net/xylz/archive/2011/07/12/354206.html)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency28-线程池/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency28-线程池" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency3-锁机制/">深入浅出 Java Concurrency (3)</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency3-锁机制/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-concurrency-3-">深入浅出 Java Concurrency (3): 锁机制</h1>
<p>前面的章节主要谈谈原子操作，至于与原子操作一些相关的问题或者说陷阱就放到最后的总结篇来整体说明。从这一章开始花少量的篇幅谈谈锁机制。</p>
<p><a href="http://www.blogjava.net/xylz/archive/2010/07/04/325206.html" target="_blank">上一个章节</a>中谈到了锁机制，并且针对于原子操作谈了一些相关的概念和设计思想。接下来的文章中，尽可能的深入研究锁机制，并且理解里面的原理和实际应用场合。</p>
<p>尽管synchronized在语法上已经足够简单了，在JDK 5之前只能借助此实现，但是由于是独占锁，性能却不高，因此JDK 5以后就开始借助于JNI来完成更高级的锁实现。</p>
<p>JDK 5中的锁是接口<strong>java.util.concurrent.locks.Lock</strong>。另外<strong>java.util.concurrent.locks.ReadWriteLock</strong>提供了一对可供读写并发的锁。根据前面的规则，我们从<strong>java.util.concurrent.locks.Lock</strong>的API开始。</p>
<p><strong>void lock();</strong></p>
<p>获取锁。</p>
<p>如果锁不可用，出于线程调度目的，将禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态。</p>
<p><strong>void lockInterruptibly() throws InterruptedException;</strong></p>
<p>如果当前线程未被中断，则获取锁。</p>
<p>如果锁可用，则获取锁，并立即返回。</p>
<p>如果锁不可用，出于线程调度目的，将禁用当前线程，并且在发生以下两种情况之一以前，该线程将一直处于休眠状态：</p>
<ul>
<li>锁由当前线程获得；或者</li>
<li>其他某个线程<a href="http://www.blogjava.net/xylz/java/lang/Thread.html#interrupt(" target="_blank">中断</a>)当前线程，并且支持对锁获取的中断。</li>
</ul>
<p>如果当前线程：</p>
<ul>
<li>在进入此方法时已经设置了该线程的中断状态；或者</li>
<li>在获取锁时被<a href="http://www.blogjava.net/xylz/java/lang/Thread.html#interrupt(" target="_blank">中断</a>)，并且支持对锁获取的中断，
则将抛出 </li>
</ul>
<p>InterruptedException
，并清除当前线程的已中断状态。</p>
<p><strong>Condition newCondition();</strong></p>
<p>返回绑定到此 </p>
<p>Lock
 实例的新 </p>
<p>Condition
 实例。下一小节中会重点谈Condition，此处不做过多的介绍。</p>
<p><strong>boolean tryLock();</strong></p>
<p>仅在调用时锁为空闲状态才获取该锁。</p>
<p>如果锁可用，则获取锁，并立即返回值 </p>
<p>true
。如果锁不可用，则此方法将立即返回值 </p>
<p>false
。</p>
<p>通常对于那些不是必须获取锁的操作可能有用。</p>
<p><strong>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</strong></p>
<p>如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁。</p>
<p>如果锁可用，则此方法将立即返回值 </p>
<p>true
。如果锁不可用，出于线程调度目的，将禁用当前线程，并且在发生以下三种情况之一前，该线程将一直处于休眠状态：</p>
<ul>
<li>锁由当前线程获得；或者</li>
<li>其他某个线程中断当前线程，并且支持对锁获取的中断；或者</li>
<li>已超过指定的等待时间</li>
</ul>
<p>如果获得了锁，则返回值 </p>
<p>true
。</p>
<p>如果当前线程：</p>
<ul>
<li>在进入此方法时已经设置了该线程的中断状态；或者</li>
<li>在获取锁时被中断，并且支持对锁获取的中断，
则将抛出 </li>
</ul>
<p>InterruptedException
，并会清除当前线程的已中断状态。</p>
<p>如果超过了指定的等待时间，则将返回值 </p>
<p>false
。如果 time 小于等于 0，该方法将完全不等待。</p>
<p><strong>void unlock();</strong></p>
<p>释放锁。对应于lock()、tryLock()、tryLock(xx)、lockInterruptibly()等操作，如果成功的话应该对应着一个unlock()，这样可以避免死锁或者资源浪费。</p>
<p>相对于比较空洞的API，来看一个实际的例子。下面的代码实现了一个类似于AtomicInteger的操作。
package xylz.study.concurrency.lock;</p>
<p>import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;</p>
<p>public class AtomicIntegerWithLock {</p>
<pre><code>private int value;

private Lock lock = new ReentrantLock();

public AtomicIntegerWithLock() {
    super();
}

public AtomicIntegerWithLock(int value) {
    this.value = value;
}

public final int get() {
    lock.lock();
    try {
        return value;
    } finally {
        lock.unlock();
    }
}

public final void set(int newValue) {
    lock.lock();
    try {
        value = newValue;
    } finally {
        lock.unlock();
    }

}

public final int getAndSet(int newValue) {
    lock.lock();
    try {
        int ret = value;
        value = newValue;
        return ret;
    } finally {
        lock.unlock();
    }
}

public final boolean compareAndSet(int expect, int update) {
    lock.lock();
    try {
        if (value == expect) {
            value = update;
            return true;
        }
        return false;
    } finally {
        lock.unlock();
    }
}

public final int getAndIncrement() {
    lock.lock();
    try {
        return value++;
    } finally {
        lock.unlock();
    }
}

public final int getAndDecrement() {
    lock.lock();
    try {
        return value--;
    } finally {
        lock.unlock();
    }
}

public final int incrementAndGet() {
    lock.lock();
    try {
        return ++value;
    } finally {
        lock.unlock();
    }
}

public final int decrementAndGet() {
    lock.lock();
    try {
        return --value;
    } finally {
        lock.unlock();
    }
}

public String toString() {
    return Integer.toString(get());
}
</code></pre><p>}</p>
<p>类<strong>AtomicIntegerWithLock</strong>是线程安全的，此结构中大量使用了Lock对象的lock/unlock方法对。同样可以看到的是对于自增和自减操作使用了++/--。之所以能够保证线程安全，是因为Lock对象的lock()方法保证了只有一个线程能够只有此锁。需要说明的是对于任何一个lock()方法，都需要一个unlock()方法与之对于，通常情况下为了保证unlock方法总是能够得到执行，unlock方法被置于finally块中。另外这里使用了<strong>java.util.concurrent.locks.ReentrantLock.ReentrantLock</strong>对象，下一个小节中会具体描述此类作为Lock的唯一实现是如何设计和实现的。</p>
<p>尽管synchronized实现Lock的相同语义，并且在语法上比Lock要简单多，但是前者却比后者的开销要大得多。做一个简单的测试。
public static void main(String[] args) throws Exception{
     final int max = 10;
     final int loopCount = 100000;
     long costTime = 0;
     for (int m = 0; m &lt; max; m++) {
         long start1 = System.nanoTime();
         final AtomicIntegerWithLock value1 = new AtomicIntegerWithLock(0);
         Thread[] ts = new Thread[max];
         for(int i=0;i&lt;max;i++) {
             ts[i] = new Thread() {
                 public void run() {
                     for (int i = 0; i &lt; loopCount; i++) {
                         value1.incrementAndGet();
                     }
                 }
             };
         }
         for(Thread t:ts) {
             t.start();
         }
         for(Thread t:ts) {
             t.join();
         }
         long end1 = System.nanoTime();
         costTime += (end1-start1);
     }
     System.out.println(&quot;cost1: &quot; + (costTime));
     //
     System.out.println();
     costTime = 0;
     //
     final Object lock = new Object();
     for (int m = 0; m &lt; max; m++) {
         staticValue=0;
         long start1 = System.nanoTime();
         Thread[] ts = new Thread[max];
         for(int i=0;i&lt;max;i++) {
             ts[i] = new Thread() {
                 public void run() {
                     for (int i = 0; i &lt; loopCount; i++) {
                         synchronized(lock) {
                             ++staticValue;
                         }
                     }
                 }
             };
         }
         for(Thread t:ts) {
             t.start();
         }
         for(Thread t:ts) {
             t.join();
         }
         long end1 = System.nanoTime();
         costTime += (end1-start1);
     }
     //
     System.out.println(&quot;cost2: &quot; + (costTime));
}</p>
<p>static int staticValue = 0;</p>
<p>在这个例子中每次启动10个线程，每个线程计算100000次自增操作，重复测试10次，下面是某此测试的结果：</p>
<p>cost1: 624071136</p>
<p>cost2: 2057847833</p>
<p>尽管上面的例子不是非常正式的测试案例，但上面的例子在于说明，Lock的性能比synchronized的要好得多。如果可以的话总是使用Lock替代synchronized是一个明智的选择。</p>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/05/325274.html](http://www.blogjava.net/xylz/archive/2010/07/05/325274.html)">[http://www.blogjava.net/xylz/archive/2010/07/05/325274.html](http://www.blogjava.net/xylz/archive/2010/07/05/325274.html)</a> </p>
<p>在理解J.U.C原理以及锁机制之前，我们来介绍J.U.C框架最核心也是最复杂的一个基础类：<strong>java.util.concurrent.locks.AbstractQueuedSynchronizer</strong>。</p>
<p><strong>AQS</strong></p>
<p>AbstractQueuedSynchronizer，简称AQS，是J.U.C最复杂的一个类，导致绝大多数讲解并发原理或者实战的时候都不会提到此类。但是虚心的作者愿意借助自己有限的能力和精力来探讨一二（参考资源中也有一些作者做了部分的分析。）。</p>
<p>首先从理论知识开始，在了解了相关原理后会针对源码进行一些分析，最后加上一些实战来描述。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency72_93BD/image_2.png" target="_blank"><img src="&quot;image&quot;" alt="image"></a></p>
<p>上面的继承体系中，AbstractQueuedSynchronizer是CountDownLatch/FutureTask/ReentrantLock/RenntrantReadWriteLock/Semaphore的基础，因此AbstractQueuedSynchronizer是Lock/Executor实现的前提。公平锁、不公平锁、Condition、CountDownLatch、Semaphore等放到后面的篇幅中说明。</p>
<p>完整的设计原理可以参考Doug Lea的论文 <a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank"><em>The java</em>.<em>util</em>.<em>concurrent Synchronizer Framework</em></a> ，这里做一些简要的分析。</p>
<p>基本的思想是表现为一个同步器，支持下面两个操作：</p>
<p>获取锁：首先判断当前状态是否允许获取锁，如果是就获取锁，否则就阻塞操作或者获取失败，也就是说如果是独占锁就可能阻塞，如果是共享锁就可能失败。另外如果是阻塞线程，那么线程就需要进入阻塞队列。当状态位允许获取锁时就修改状态，并且如果进了队列就从队列中移除。
while(synchronization state does not allow acquire){</p>
<pre><code>enqueue current thread if not already queued;

possibly block current thread;
</code></pre><p>}</p>
<p>dequeue current thread if it was queued;</p>
<p>释放锁:这个过程就是修改状态位，如果有线程因为状态位阻塞的话就唤醒队列中的一个或者更多线程。</p>
<p>update synchronization state;</p>
<p>if(state may permit a blocked thread to acquire)</p>
<pre><code>unlock one or more queued threads;
</code></pre><p>要支持上面两个操作就必须有下面的条件：</p>
<ul>
<li>原子性操作同步器的状态位</li>
<li>阻塞和唤醒线程</li>
<li>一个有序的队列</li>
</ul>
<p>目标明确，要解决的问题也清晰了，那么剩下的就是解决上面三个问题。</p>
<p><strong>状态位的原子操作</strong></p>
<p>这里使用一个32位的整数来描述状态位，前面章节的原子操作的理论知识整好派上用场，在这里依然使用CAS操作来解决这个问题。事实上这里还有一个64位版本的同步器（AbstractQueuedLongSynchronizer），这里暂且不谈。</p>
<p><strong>阻塞和唤醒线程</strong></p>
<p>标准的JAVA API里面是无法挂起（阻塞）一个线程，然后在将来某个时刻再唤醒它的。JDK 1.0的API里面有Thread.suspend和Thread.resume，并且一直延续了下来。但是这些都是过时的API，而且也是不推荐的做法。</p>
<p>在JDK 5.0以后利用JNI在LockSupport类中实现了此特性。
LockSupport.park()
LockSupport.park(Object)
LockSupport.parkNanos(Object, long)
LockSupport.parkNanos(long)
LockSupport.parkUntil(Object, long)
LockSupport.parkUntil(long)
LockSupport.unpark(Thread)</p>
<p>上面的API中park()是在当前线程中调用，导致线程阻塞，带参数的Object是挂起的对象，这样监视的时候就能够知道此线程是因为什么资源而阻塞的。由于park()立即返回，所以通常情况下需要在循环中去检测竞争资源来决定是否进行下一次阻塞。park()返回的原因有三：</p>
<ul>
<li>其他某个线程调用将当前线程作为目标调用 <a href="http://www.blogjava.net/xylz/java/util/concurrent/locks/LockSupport.html#unpark(java.lang.Thread">
unpark
</a>)；</li>
<li>其他某个线程<a href="http://www.blogjava.net/xylz/java/lang/Thread.html#interrupt(" target="_blank">中断</a>)当前线程；</li>
<li>该调用不合逻辑地（即毫无理由地）返回。</li>
</ul>
<p>其实第三条就决定了需要循环检测了，类似于通常写的while(checkCondition()){Thread.sleep(time);}类似的功能。</p>
<p><strong>有序队列</strong></p>
<p>在AQS中采用CHL列表来解决有序的队列的问题。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency72_93BD/image_6.png" target="_blank"><img src="&quot;image&quot;" alt="image"></a>AQS采用的CHL模型采用下面的算法完成FIFO的入队列和出队列过程。</p>
<p>对于入队列(<em>enqueue)：</em>采用CAS操作，每次比较尾结点是否一致，然后插入的到尾结点中。
do {</p>
<pre><code>    pred = tail;
</code></pre><p>}while ( !compareAndSet(pred,tail,node) );</p>
<p>对于出队列(<em>dequeue</em>):由于每一个节点也缓存了一个状态，决定是否出队列，因此当不满足条件时就需要自旋等待，一旦满足条件就将头结点设置为下一个节点。</p>
<p>while (pred.status != RELEASED) ;</p>
<p>head  = node;</p>
<p>实际上这里自旋等待也是使用LockSupport.park()来实现的。</p>
<p>AQS里面有三个核心字段：
private volatile int state;</p>
<p>private transient volatile Node head;</p>
<p>private transient volatile Node tail;</p>
<p>其中state描述的有多少个线程取得了锁，对于互斥锁来说state&lt;=1。head/tail加上CAS操作就构成了一个CHL的FIFO队列。下面是Node节点的属性。</p>
<p><strong><em>volatile int waitStatus;</em></strong> 节点的等待状态，一个节点可能位于以下几种状态：</p>
<ul>
<li>CANCELLED = 1： 节点操作因为超时或者对应的线程被interrupt。节点不应该留在此状态，一旦达到此状态将从CHL队列中踢出。</li>
<li>SIGNAL = -1： 节点的继任节点是（或者将要成为）BLOCKED状态（例如通过LockSupport.park()操作），因此一个节点一旦被释放（解锁）或者取消就需要唤醒（LockSupport.unpack()）它的继任节点。</li>
<li>CONDITION = -2：表明节点对应的线程因为不满足一个条件（Condition）而被阻塞。</li>
<li>0： 正常状态，新生的非CONDITION节点都是此状态。</li>
<li>非负值标识节点不需要被通知（唤醒）。</li>
</ul>
<p><strong><em>volatile Node prev;</em></strong>此节点的前一个节点。节点的waitStatus依赖于前一个节点的状态。</p>
<p><strong><em>volatile Node next;</em></strong>此节点的后一个节点。后一个节点是否被唤醒（uppark()）依赖于当前节点是否被释放。</p>
<p><strong><em>volatile Thread thread;</em></strong>节点绑定的线程。</p>
<p><strong><em>Node nextWaiter;</em></strong>下一个等待条件（Condition）的节点，由于Condition是独占模式，因此这里有一个简单的队列来描述Condition上的线程节点。</p>
<p><strong>AQS 在J.U.C里面是一个非常核心的工具，而且也非常复杂，里面考虑到了非常多的逻辑实现，所以在后面的章节中总是不断的尝试介绍AQS的特性和实现。</strong></p>
<p>这一个小节主要介绍了一些理论背景和相关的数据结构，在下一个小节中将根据以上知识来了解Lock.lock/unlock是如何实现的。</p>
<p>参考资料：</p>
<p>（1）<a href="http://www.cnblogs.com/MichaelPeng/archive/2010/02/12/1667947.html" target="_blank">ReentrantLock代码剖析之ReentrantLock.lock</a> <a href="http://www.cnblogs.com/MichaelPeng/archive/2010/02/17/1668986.html" target="_blank">ReentrantLock代码剖析之ReentrantLock.unlock</a> <a href="http://www.cnblogs.com/MichaelPeng/archive/2010/02/18/1669150.html" target="_blank">ReentrantLock代码剖析之ReentrantLock.lockInterruptibly</a></p>
<p>（2）<a href="http://wagtto.javaeye.com/blog/607848" target="_blank">java多线程--java.util.concurrent.locks.AbstractQueuedSynchronizer解析(只包含多线程同步示例)</a></p>
<p>（3）<a href="http://www.ibm.com/developerworks/cn/java/j-jtp05236.html" target="_blank">处理 InterruptedException</a></p>
<p>（4）<a href="http://hi.baidu.com/gefforey520/blog/item/6f64eb442300a446500ffe3f.html" target="_blank">AbstractQueuedSynchronizer源码解析之ReentrantLock(一)</a>  <a href="http://hi.baidu.com/gefforey520/blog/item/ce633582511217a80df4d26c.html" target="_blank">AbstractQueuedSynchronizer源码解析之ReentrantLock(二)</a></p>
<p>（5）<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank"><em>The java</em>.<em>util</em>.<em>concurrent Synchronizer Framework</em></a>
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/06/325390.html](http://www.blogjava.net/xylz/archive/2010/07/06/325390.html)">[http://www.blogjava.net/xylz/archive/2010/07/06/325390.html](http://www.blogjava.net/xylz/archive/2010/07/06/325390.html)</a> </p>
<p>接上篇，这篇从Lock.lock/unlock开始。特别说明在没有特殊情况下所有程序、API、文档都是基于JDK 6.0的。</p>
<p><strong>public void java.util.concurrent.locks.ReentrantLock.lock()</strong>
<em>获取锁。</em></p>
<p><em>如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。</em></p>
<p><em>如果当前线程已经保持该锁，则将保持计数加 1，并且该方法立即返回。</em></p>
<p><em>如果该锁被另一个线程保持，则出于线程调度的目的，禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态，此时锁保持计数被设置为 1。</em></p>
<p>从上面的文档可以看出ReentrantLock是可重入锁的实现。而内部是委托java.util.concurrent.locks.ReentrantLock.Sync.lock()实现的。java.util.concurrent.locks.ReentrantLock.Sync是抽象类，有java.util.concurrent.locks.ReentrantLock.FairSync和java.util.concurrent.locks.ReentrantLock.NonfairSync两个实现，也就是常说的公平锁和不公平锁。</p>
<p><strong>公平锁和非公平锁</strong>
如果获取一个锁是按照请求的顺序得到的，那么就是公平锁，否则就是非公平锁。</p>
<p>在没有深入了解内部机制及实现之前，先了解下为什么会存在公平锁和非公平锁。公平锁保证一个阻塞的线程最终能够获得锁，因为是有序的，所以总是可以按照请求的顺序获得锁。不公平锁意味着后请求锁的线程可能在其前面排列的休眠线程恢复前拿到锁，这样就有可能提高并发的性能。这是因为通常情况下挂起的线程重新开始与它真正开始运行，二者之间会产生严重的延时。因此非公平锁就可以利用这段时间完成操作。这是非公平锁在某些时候比公平锁性能要好的原因之一。</p>
<p>二者在实现上的区别会在后面介绍，我们先从公平锁（FairSync）开始。</p>
<p>前面说过<strong>java.util.concurrent.locks.AbstractQueuedSynchronizer （AQS)</strong>是Lock的基础，对于一个FairSync而言，lock()就直接调用AQS的acquire(int arg);
<strong>public final void acquire(int arg)</strong> <em>以独占模式获取对象，忽略中断。通过至少调用一次 </em><a href="http://www.blogjava.net/xylz/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int">
<em>tryAcquire(int)</em>
</a>)<em> 来实现此方法，并在成功时返回。否则在成功之前，一直调用 </em><a href="http://www.blogjava.net/xylz/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int">
<em>tryAcquire(int)</em>
</a>)<em> 将线程加入队列，线程可能重复被阻塞或不被阻塞。</em></p>
<p>在介绍实现之前先要补充上一节的知识，对于一个AQS的实现而言，通常情况下需要实现以下方法来描述如何锁定线程。</p>
<ul>
<li><strong>tryAcquire(int)</strong> 
试图在独占模式下获取对象状态。此方法应该查询是否允许它在独占模式下获取对象状态，如果允许，则获取它。</li>
</ul>
<p>此方法总是由执行 acquire 的线程来调用。如果此方法报告失败，则 acquire 方法可以将线程加入队列（如果还没有将它加入队列），直到获得其他某个线程释放了该线程的信号。也就是说此方法是一种尝试性方法，如果成功获取锁那最好，如果没有成功也没有关系，直接返回false。</p>
<ul>
<li><strong>tryRelease(int)</strong> 
试图设置状态来反映独占模式下的一个释放。 此方法总是由正在执行释放的线程调用。释放锁可能失败或者抛出异常，这个在后面会具体分析。</li>
<li><strong>tryAcquireShared(int)</strong> 试图在共享模式下获取对象状态。</li>
<li><strong>tryReleaseShared(int)</strong> 试图设置状态来反映共享模式下的一个释放。</li>
<li><strong>isHeldExclusively()</strong> 如果对于当前（正调用的）线程，同步是以独占方式进行的，则返回         true    。</li>
</ul>
<p>除了tryAcquire(int)外，其它方法会在后面具体介绍。首先对于ReentrantLock而言，不管是公平锁还是非公平锁，都是独占锁，也就是说同时能够有一个线程持有锁。因此对于acquire(int arg)而言，arg==1。在AQS中acquire的实现如下：</p>
<p>public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}</p>
<p>这个看起来比较复杂，我们分解以下4个步骤。</p>
<ol>
<li>如果tryAcquire(arg)成功，那就没有问题，已经拿到锁，整个lock()过程就结束了。如果失败进行操作2。</li>
<li>创建一个独占节点（Node）并且此节点加入CHL队列末尾。进行操作3。</li>
<li>自旋尝试获取锁，失败根据前一个节点来决定是否挂起（park()），直到成功获取到锁。进行操作4。</li>
<li>如果当前线程已经中断过，那么就中断当前线程（清除中断位）。</li>
</ol>
<p>这是一个比较复杂的过程，我们按部就班一个一个分析。</p>
<p><strong>tryAcquire(acquires)</strong></p>
<p>对于公平锁而言，它的实现方式如下：
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (isFirst(current) &amp;&amp;
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc &lt; 0)
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            setState(nextc);
            return true;
        }
        return false;
    }
}</p>
<p>在这段代码中，前面说明对于AQS存在一个state来描述当前有多少线程持有锁。由于AQS支持共享锁（例如读写锁，后面会继续讲），所以这里state&gt;=0，但是由于ReentrantLock是独占锁，所以这里不妨理解为0&lt;=state，acquires=1。isFirst(current)是一个很复杂的逻辑，包括踢出无用的节点等复杂过程，这里暂且不提，大体上的意思是说判断AQS是否为空或者当前线程是否在队列头（为了区分公平与非公平锁）。</p>
<ol>
<li>如果当前锁有其它线程持有，c!=0，进行操作2。否则，如果当前线程在AQS队列头部，则尝试将AQS状态state设为acquires（等于1），成功后将AQS独占线程设为当前线程返回true，否则进行2。这里可以看到compareAndSetState就是使用了CAS操作。</li>
<li>判断当前线程与AQS的独占线程是否相同，如果相同，那么就将当前状态位加1（这里+1后结果为负数后面会讲，这里暂且不理它），修改状态位，返回true，否则进行3。这里之所以不是将当前状态位设置为1，而是修改为旧值+1呢？这是因为ReentrantLock是可重入锁，同一个线程每持有一次就+1。</li>
<li>返回false。</li>
</ol>
<p>比较非公平锁的tryAcquire实现java.util.concurrent.locks.ReentrantLock.Sync.nonfairTryAcquire(int)，公平锁多了一个判断当前节点是否在队列头，这个就保证了是否按照请求锁的顺序来决定获取锁的顺序（同一个线程的多次获取锁除外）。</p>
<p>现在再回头看公平锁和非公平锁的lock()方法。公平锁只有一句acquire(1)；而非公平锁的调用如下：
final void lock() {
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}</p>
<p>很显然，非公平锁在第一次获取锁，或者其它线程释放锁后（可能等待），优先采用compareAndSetState(0,1)然后设置AQS独占线程而持有锁，这样有时候比acquire(1)顺序检查锁持有而要高效。即使在重入锁上，也就是compareAndSetState(0,1)失败，但是是当前线程持有锁上，非公平锁也没有问题。</p>
<p><strong>addWaiter(mode)</strong></p>
<p>tryAcquire失败就意味着入队列了。此时AQS的队列中节点Node就开始发挥作用了。一般情况下AQS支持独占锁和共享锁，而独占锁在Node中就意味着条件（Condition）队列为空（上一篇中介绍过相关概念）。在java.util.concurrent.locks.AbstractQueuedSynchronizer.Node中有两个常量，
static final Node EXCLUSIVE = null; //独占节点模式</p>
<p>static final Node SHARED = new Node(); //共享节点模式</p>
<p>addWaiter(mode)中的mode就是节点模式，也就是共享锁还是独占锁模式。</p>
<p>前面一再强调ReentrantLock是独占锁模式。
private Node addWaiter(Node mode) {
     Node node = new Node(Thread.currentThread(), mode);
     // Try the fast path of enq; backup to full enq on failure
     Node pred = tail;
     if (pred != null) {
         node.prev = pred;
         if (compareAndSetTail(pred, node)) {
             pred.next = node;
             return node;
         }
     }
     enq(node);
     return node;
}</p>
<p>上面是节点如队列的一部分。当前仅当队列不为空并且将新节点插入尾部成功后直接返回新节点。否则进入enq(Node)进行操作。</p>
<p>private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        if (t == null) { // Must initialize
            Node h = new Node(); // Dummy header
            h.next = node;
            node.prev = h;
            if (compareAndSetHead(h)) {
                tail = node;
                return h;
            }
        }
        else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}</p>
<p>enq(Node)去队列操作实现了CHL队列的算法，如果为空就创建头结点，然后同时比较节点尾部是否是改变来决定CAS操作是否成功，当且仅当成功后才将为不节点的下一个节点指向为新节点。可以看到这里仍然是CAS操作。</p>
<p><strong>acquireQueued(node,arg)</strong></p>
<p>自旋请求锁，如果可能的话挂起线程，直到得到锁，返回当前线程是否中断过（如果park()过并且中断过的话有一个interrupted中断位）。
final boolean acquireQueued(final Node node, int arg) {
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } catch (RuntimeException ex) {
        cancelAcquire(node);
        throw ex;
    }
}</p>
<p>下面的分析就需要用到上节节点的状态描述了。acquireQueued过程是这样的：</p>
<ol>
<li>如果当前节点是AQS队列的头结点（如果第一个节点是DUMP节点也就是傀儡节点，那么第二个节点实际上就是头结点了），就尝试在此获取锁tryAcquire(arg)。如果成功就将头结点设置为当前节点（不管第一个结点是否是DUMP节点），返回中断位。否则进行2。</li>
<li>检测当前节点是否应该park()，如果应该park()就挂起当前线程并且返回当前线程中断位。进行操作1。</li>
</ol>
<p>一个节点是否该park()是关键，这是由方法java.util.concurrent.locks.AbstractQueuedSynchronizer.shouldParkAfterFailedAcquire(Node, Node)实现的。
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int s = pred.waitStatus;
    if (s &lt; 0) return true;
    if (s &gt; 0) {
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
    } else compareAndSetWaitStatus(pred, 0, Node.SIGNAL);
    return false;
}</p>
<ol>
<li>如果前一个节点的等待状态waitStatus&lt;0，也就是前面的节点还没有获得到锁，那么返回true，表示当前节点（线程）就应该park()了。否则进行2。</li>
<li>如果前一个节点的等待状态waitStatus&gt;0，也就是前一个节点被CANCELLED了，那么就将前一个节点去掉，递归此操作直到所有前一个节点的waitStatus&lt;=0，进行4。否则进行3。</li>
<li>前一个节点等待状态waitStatus=0，修改前一个节点状态位为SINGAL，表示后面有节点等待你处理，需要根据它的等待状态来决定是否该park()。进行4。</li>
<li>返回false，表示线程不应该park()。</li>
</ol>
<p><strong>selfInterrupt()</strong>
private static void selfInterrupt() {
    Thread.currentThread().interrupt();
}</p>
<p>如果线程曾经中断过（或者阻塞过）（比如手动interrupt()或者超时等等，那么就再中断一次，中断两次的意思就是清除中断位）。</p>
<p>大体上整个Lock.lock()就这样一个流程。除了lock()方法外，还有lockInterruptibly()/tryLock()/unlock()/newCondition()等，在接下来的章节中会一一介绍。
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/07/325410.html](http://www.blogjava.net/xylz/archive/2010/07/07/325410.html)">[http://www.blogjava.net/xylz/archive/2010/07/07/325410.html](http://www.blogjava.net/xylz/archive/2010/07/07/325410.html)</a> </p>
<p>本小节介绍锁释放Lock.unlock()。</p>
<p><strong>Release/TryRelease</strong></p>
<p>unlock操作实际上就调用了<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank"><strong>AQS</strong></a>的release操作，释放持有的锁。
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}</p>
<p>前面提到过<strong><em>tryRelease(arg)</em></strong>操作，此操作里面总是尝试去释放锁，如果成功，说明锁确实被当前线程持有，那么就看<strong>AQS</strong>队列中的头结点是否为空并且能否被唤醒，如果可以的话就唤醒继任节点（下一个非CANCELLED节点，下面会具体分析）。</p>
<p>对于独占锁而言，java.util.concurrent.locks.ReentrantLock.Sync.tryRelease(int)展示了如何尝试释放锁(<strong><em>tryRelease</em></strong>)操作。
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}</p>
<p>整个<strong><em>tryRelease</em></strong>操作是这样的：</p>
<ol>
<li>判断持有锁的线程是否是当前线程，如果不是就抛出IllegalMonitorStateExeception()，因为一个线程是不能释放另一个线程持有的锁（否则锁就失去了意义）。否则进行2。</li>
<li>将AQS状态位减少要释放的次数（对于独占锁而言总是1），如果剩余的状态位0（也就是没有线程持有锁），那么当前线程就是最后一个持有锁的线程，清空AQS持有锁的独占线程。进行3。</li>
<li>将剩余的状态位写回AQS，如果没有线程持有锁就返回true，否则就是false。</li>
</ol>
<p>参考上一节的分析就可以知道，这里c==0决定了是否完全释放了锁。由于<strong><em>ReentrantLock</em></strong>是可重入锁，因此同一个线程可能多重持有锁，那么当且仅当最后一个持有锁的线程释放锁是才能将AQS中持有锁的独占线程清空，这样接下来的操作才需要唤醒下一个需要锁的<strong>AQS</strong>节点（Node），否则就只是减少锁持有的计数器，并不能改变其他操作。</p>
<p>当<strong><em>tryRelease</em></strong>操作成功后（也就是完全释放了锁），release操作才能检查是否需要唤醒下一个继任节点。这里的前提是<strong>AQS</strong>队列的头结点需要锁(<em>waitStatus!=0</em>)，如果头结点需要锁，就开始检测下一个继任节点是否需要锁操作。</p>
<p>在上一节中说道<strong><em>acquireQueued</em></strong>操作完成后（拿到了锁），会将当前持有锁的节点设为头结点，所以一旦头结点释放锁，那么就需要寻找头结点的下一个需要锁的继任节点，并唤醒它。
private void unparkSuccessor(Node node) {
        //此时node是需要是需要释放锁的头结点</p>
<pre><code>    //清空头结点的waitStatus，也就是不再需要锁了
    compareAndSetWaitStatus(node, Node.SIGNAL, 0);

    //从头结点的下一个节点开始寻找继任节点，当且仅当继任节点的waitStatus&lt;=0才是有效继任节点，否则将这些waitStatus&gt;0（也就是CANCELLED的节点）从AQS队列中剔除  
   //这里并没有从head-&gt;tail开始寻找，而是从tail-&gt;head寻找最后一个有效节点。
   //解释在这里 http://www.blogjava.net/xylz/archive/2010/07/08/325540.html/#377512

    Node s = node.next;
    if (s == null || s.waitStatus &gt; 0) {
        s = null;
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
            if (t.waitStatus &lt;= 0)
                s = t;
    }

    //如果找到一个有效的继任节点，就唤醒此节点线程
    if (s != null)
        LockSupport.unpark(s.thread);
}
</code></pre><p>这里再一次把<strong><em>acquireQueued</em></strong>的过程找出来。对比<strong><em>unparkSuccessor</em></strong>，一旦头节点的继任节点被唤醒，那么继任节点就会尝试去获取锁（在<strong><em>acquireQueued</em></strong>中node就是有效的继任节点，p就是唤醒它的头结点），如果成功就会将头结点设置为自身，并且将头结点的前任节点清空，这样前任节点（已经过时了）就可以被GC释放了。</p>
<p>final boolean acquireQueued(final Node node, int arg) {
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } catch (RuntimeException ex) {
        cancelAcquire(node);
        throw ex;
    }
}</p>
<p>在<strong><em>setHead</em></strong>中，将头结点的前任节点清空并且将头结点的线程清空就是为了更好的GC，防止内存泄露。</p>
<p>private void setHead(Node node) {
    head = node;
    node.thread = null;
    node.prev = null;
}</p>
<p>对比lock()操作，unlock()操作还是比较简单的，主要就是释放响应的资源，并且唤醒<strong>AQS</strong>队列中有效的继任节点。这样所就按照请求的顺序去尝试获取锁了。</p>
<p>整个lock()/unlock()过程完成了，我们再回头看公平锁(FairSync)和非公平锁(NonfairSync)。</p>
<p>公平锁和非公平锁只是在获取锁的时候有差别，其它都是一样的。
final void lock() {
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}</p>
<p>在上面非公平锁的代码中总是优先尝试当前是否有线程持有锁，一旦没有任何线程持有锁，那么非公平锁就霸道的尝试将锁“占为己有”。如果在抢占锁的时候失败就和公平锁一样老老实实的去排队。</p>
<p>也即是说公平锁和非公平锁只是在入<strong>AQS</strong>的<strong>CLH</strong>队列之前有所差别，一旦进入了队列，所有线程都是按照队列中先来后到的顺序请求锁。</p>
<p><strong>Condition</strong></p>
<p>条件变量很大一个程度上是为了解决Object.wait/notify/notifyAll难以使用的问题。</p>
<p>条件（也称为<em>条件队列</em> 或<em>条件变量</em>）为线程提供了一个含义，以便在某个状态条件现在可能为 true 的另一个线程通知它之前，一直挂起该线程（即让其“等待”）。因为访问此共享状态信息发生在不同的线程中，所以它必须受保护，因此要将某种形式的锁与该条件相关联。等待提供一个条件的主要属性是：<em>以原子方式</em> 释放相关的锁，并挂起当前线程，就像 </p>
<p>Object.wait
 做的那样。</p>
<p>上述API说明表明条件变量需要与锁绑定，而且多个Condition需要绑定到同一锁上。前面的<strong>Lock</strong>中提到，获取一个条件变量的方法是<strong>Lock.newCondition()</strong>。
void await() throws InterruptedException;
void awaitUninterruptibly();
long awaitNanos(long nanosTimeout) throws InterruptedException;
boolean await(long time, TimeUnit unit) throws InterruptedException;
boolean awaitUntil(Date deadline) throws InterruptedException;
void signal();
void signalAll();</p>
<p>以上是<strong>Condition</strong>接口定义的方法，<em>await/**对应于</em>Object.wait<em>，</em>signal<em>对应于</em>Object.notify<em>，</em>signalAll<em>对应于</em>Object.notifyAll<em>。特别说明的是<strong>Condition</strong>的接口改变名称就是为了避免与Object中的</em>wait/notify/notifyAll<em>的语义和使用上混淆，因为Condition同样有</em>wait/notify/notifyAll*方法。</p>
<p>每一个<strong>Lock</strong>可以有任意数据的<strong>Condition</strong>对象，<strong>Condition</strong>是与<strong>Lock</strong>绑定的，所以就有<strong>Lock</strong>的公平性特性：如果是公平锁，线程为按照FIFO的顺序从<em>Condition.await</em>中释放，如果是非公平锁，那么后续的锁竞争就不保证FIFO顺序了。</p>
<p>一个使用Condition实现生产者消费者的模型例子如下。
package xylz.study.concurrency.lock;</p>
<p>import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;</p>
<p>public class ProductQueue<T> {</p>
<pre><code>private final T[] items;

private final Lock lock = new ReentrantLock();

private Condition notFull = lock.newCondition();

private Condition notEmpty = lock.newCondition();

//
private int head, tail, count;

public ProductQueue(int maxSize) {
    items = (T[]) new Object[maxSize];
}

public ProductQueue() {
    this(10);
}

public void put(T t) throws InterruptedException {
    lock.lock();
    try {
        while (count == getCapacity()) {
            notFull.await();
        }
        items[tail] = t;
        if (++tail == getCapacity()) {
            tail = 0;
        }
        ++count;
        notEmpty.signalAll();
    } finally {
        lock.unlock();
    }
}

public T take() throws InterruptedException {
    lock.lock();
    try {
        while (count == 0) {
            notEmpty.await();
        }
        T ret = items[head];
        items[head] = null;//GC
        //
        if (++head == getCapacity()) {
            head = 0;
        }
        --count;
        notFull.signalAll();
        return ret;
    } finally {
        lock.unlock();
    }
}

public int getCapacity() {
    return items.length;
}

public int size() {
    lock.lock();
    try {
        return count;
    } finally {
        lock.unlock();
    }
}
</code></pre><p>}</p>
<p>在这个例子中消费<em>take()</em>需要 队列不为空，如果为空就挂起（<em>await()</em>），直到收到<em>notEmpty</em>的信号；生产<em>put()</em>需要队列不满，如果满了就挂起（<em>await()</em>），直到收到<em>notFull</em>的信号。</p>
<p>可能有人会问题，如果一个线程<em>lock()</em>对象后被挂起还没有<em>unlock</em>，那么另外一个线程就拿不到锁了（<em>lock()</em>操作会挂起），那么就无法通知(<em>notify</em>)前一个线程，这样岂不是“死锁”了？</p>
<p><strong>await/* 操作</strong></p>
<p>上一节中说过多次<em>ReentrantLock</em>是独占锁，一个线程拿到锁后如果不释放，那么另外一个线程肯定是拿不到锁，所以在<em>lock.lock()</em>和<em>lock.unlock()</em>之间可能有一次释放锁的操作（同样也必然还有一次获取锁的操作）。我们再回头看代码，不管<em>take()</em>还是<em>put()</em>，在进入<em>lock.lock()</em>后唯一可能释放锁的操作就是<em>await()</em>了。也就是说<em>await()</em>操作实际上就是释放锁，然后挂起线程，一旦条件满足就被唤醒，再次获取锁！
public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    Node node = addConditionWaiter();
    int savedState = fullyRelease(node);
    int interruptMode = 0;
    while (!isOnSyncQueue(node)) {
        LockSupport.park(this);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null)
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}</p>
<p>上面是<em>await()</em>的代码片段。上一节中说过，<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank"><strong>AQS</strong></a>在获取锁的时候需要有一个<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank"><strong>CHL</strong></a>的FIFO队列，所以对于一个<em>Condition.await()</em>而言，如果释放了锁，要想再一次获取锁那么就需要进入队列，等待被通知获取锁。完整的await()操作是安装如下步骤进行的：</p>
<ol>
<li>将当前线程加入<em>Condition</em>锁队列。特别说明的是，这里不同于<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank"><strong>AQS</strong></a>的队列，这里进入的是<em>Condition</em>的FIFO队列。后面会具体谈到此结构。进行2。</li>
<li>释放锁。这里可以看到将锁释放了，否则别的线程就无法拿到锁而发生死锁。进行3。</li>
<li>自旋(while)挂起，直到被唤醒或者超时或者CACELLED等。进行4。</li>
<li>获取锁(<em>acquireQueued</em>)。并将自己从<em>Condition</em>的FIFO队列中释放，表明自己不再需要锁（我已经拿到锁了）。</li>
</ol>
<p>这里再回头介绍<em>Condition</em>的数据结构。我们知道一个<em>Condition</em>可以在多个地方被<em>await/</em>()<em>，那么就需要一个FIFO的结构将这些</em>Condition<em>串联起来，然后根据需要唤醒一个或者多个（通常是所有）。所以在</em>Condition*内部就需要一个FIFO的队列。
private transient Node firstWaiter;
private transient Node lastWaiter;</p>
<p>上面的两个节点就是描述一个FIFO的队列。我们再结合<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank">前面</a>提到的<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank">节点（Node）数据结构</a>。我们就发现<em>Node.nextWaiter</em>就派上用场了！<em>nextWaiter</em>就是将一系列的<em>Condition.await/*</em>串联起来组成一个FIFO的队列。</p>
<p><strong>signal/signalAll 操作</strong></p>
<p><em>await/</em>()<em>清楚了，现在再来看</em>signal/signalAll<em>就容易多了。按照</em>signal/signalAll<em>的需求，就是要将</em>Condition.await/<em>()</em>中FIFO队列中第一个<strong>Node</strong>唤醒（或者全部<strong>Node</strong>）唤醒。尽管所有<strong>Node</strong>可能都被唤醒，但是要知道的是仍然只有一个线程能够拿到锁，其它没有拿到锁的线程仍然需要自旋等待，就上上面提到的第4步(acquireQueued)。
private void doSignal(Node first) {
    do {
        if ( (firstWaiter = first.nextWaiter) == null)
            lastWaiter = null;
        first.nextWaiter = null;
    } while (!transferForSignal(first) &amp;&amp;
             (first = firstWaiter) != null);
}</p>
<p>private void doSignalAll(Node first) {
    lastWaiter = firstWaiter  = null;
    do {
        Node next = first.nextWaiter;
        first.nextWaiter = null;
        transferForSignal(first);
        first = next;
    } while (first != null);
}</p>
<p>上面的代码很容易看出来，<em>signal</em>就是唤醒<strong>Condition</strong>队列中的第一个非CANCELLED节点线程，而signalAll就是唤醒所有非CANCELLED节点线程。当然了遇到CANCELLED线程就需要将其从FIFO队列中剔除。</p>
<p>final boolean transferForSignal(Node node) {
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;</p>
<pre><code>Node p = enq(node);
int c = p.waitStatus;
if (c &gt; 0 || !compareAndSetWaitStatus(p, c, Node.SIGNAL))
    LockSupport.unpark(node.thread);
return true;
</code></pre><p>}</p>
<p>上面就是唤醒一个<em>await/</em>()<em>线程的过程，根据前面的小节介绍的，如果要</em>unpark<em>线程，并使线程拿到锁，那么就需要线程节点进入<strong>AQS</strong>的队列。所以可以看到在</em>LockSupport.unpark<em>之前调用了</em>enq(node)<em>操作，将当前节点加入到<em>*AQS</em></em>队列。</p>
<p>整个锁机制的原理就介绍完了，从下一节开始就进入了锁机制的应用了。</p>
<p>此小节介绍几个与锁有关的有用工具。</p>
<p><strong>闭锁（Latch）</strong></p>
<p>闭锁（Latch）：一种同步方法，可以延迟线程的进度直到线程到达某个终点状态。通俗的讲就是，一个闭锁相当于一扇大门，在大门打开之前所有线程都被阻断，一旦大门打开所有线程都将通过，但是一旦大门打开，所有线程都通过了，那么这个闭锁的状态就失效了，门的状态也就不能变了，只能是打开状态。也就是说闭锁的状态是一次性的，它确保在闭锁打开之前所有特定的活动都需要在闭锁打开之后才能完成。</p>
<p><strong>CountDownLatch</strong>是JDK 5+里面闭锁的一个实现，允许一个或者多个线程等待某个事件的发生。<strong>CountDownLatch</strong>有一个正数计数器，<em>countDown</em>方法对计数器做减操作，<em>await</em>方法等待计数器达到0。所有<em>await</em>的线程都会阻塞直到计数器为0或者等待线程中断或者超时。</p>
<p><strong>CountDownLatch</strong>的API如下。</p>
<ul>
<li>public void await() throws InterruptedException</li>
<li>public boolean await(long timeout, TimeUnit unit) throws InterruptedException</li>
<li>public void countDown()</li>
<li>public long getCount()</li>
</ul>
<p>其中<em>getCount()</em>描述的是当前计数，通常用于调试目的。</p>
<p>下面的例子中描述了闭锁的两种常见的用法。
package xylz.study.concurrency.lock;</p>
<p>import java.util.concurrent.CountDownLatch;</p>
<p>public class PerformanceTestTool {</p>
<pre><code>public long timecost(final int times, final Runnable task) throws InterruptedException {
    if (times &lt;= 0) throw new IllegalArgumentException();
    final CountDownLatch startLatch = new CountDownLatch(1);
    final CountDownLatch overLatch = new CountDownLatch(times);
    for (int i = 0; i &lt; times; i++) {
        new Thread(new Runnable() {
            public void run() {
                try {
                    startLatch.await();
                    //
                    task.run();
                } catch (InterruptedException ex) {
                    Thread.currentThread().interrupt();
                } finally {
                    overLatch.countDown();
                }
            }
        }).start();
    }
    //
    long start = System.nanoTime();
    startLatch.countDown();
    overLatch.await();
    return System.nanoTime() - start;
}
</code></pre><p>}</p>
<p>在上面的例子中使用了两个闭锁，第一个闭锁确保在所有线程开始执行任务前，所有准备工作都已经完成，一旦准备工作完成了就调用<em>startLatch.countDown()</em>打开闭锁，所有线程开始执行。第二个闭锁在于确保所有任务执行完成后主线程才能继续进行，这样保证了主线程等待所有任务线程执行完成后才能得到需要的结果。在第二个闭锁当中，初始化了一个N次的计数器，每个任务执行完成后都会将计数器减一，所有任务完成后计数器就变为了0，这样主线程闭锁overLatch拿到此信号后就可以继续往下执行了。</p>
<p>根据前面的<a href="http://www.blogjava.net/xylz/archive/2010/07/03/325168.html" target="_blank">happend-before法则</a>可以知道闭锁有以下特性：
**内存一致性效果：线程中调用 </p>
<p>countDown()
 之前的操作 <strong><a href="http://www.blogjava.net/xylz/archive/2010/07/03/325168.html" target="_blank">happen-before</a><strong>**</strong></strong> 紧跟在从另一个线程中对应 </p>
<p>await()
 成功返回的操作。**</p>
<p>在上面的例子中第二个闭锁相当于把一个任务拆分成N份，每一份独立完成任务，主线程等待所有任务完成后才能继续执行。这个特性在后面的线程池框架中会用到，其实<strong>FutureTask</strong>就可以看成一个闭锁。后面的章节还会具体分析<strong>FutureTask</strong>的。</p>
<p>同样基于探索精神，仍然需要“窥探”下<strong>CountDownLatch</strong>里面到底是如何实现<em>await/**和</em>countDown*的。</p>
<p>首先，研究下<em>await()</em>方法。内部直接调用了<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank"><strong>AQS</strong></a>的<em>acquireSharedInterruptibly(1)</em>。
public final void acquireSharedInterruptibly(int arg) throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireSharedInterruptibly(arg);
}</p>
<p>前面一直提到的都是独占锁（排它锁、互斥锁），现在就用到了另外一种锁，共享锁。</p>
<p>所谓共享锁是说所有共享锁的线程共享同一个资源，一旦任意一个线程拿到共享资源，那么所有线程就都拥有的同一份资源。也就是通常情况下共享锁只是一个标志，所有线程都等待这个标识是否满足，一旦满足所有线程都被激活（相当于所有线程都拿到锁一样）。这里的闭锁<strong>CountDownLatch</strong>就是基于共享锁的实现。</p>
<p>闭锁中关于<strong>AQS</strong>的<em>tryAcquireShared</em>的实现是如下代码（<strong>java.util.concurrent.CountDownLatch.Sync.tryAcquireShared</strong>）：
public int tryAcquireShared(int acquires) {
    return getState() == 0? 1 : -1;
}</p>
<p>在这份逻辑中，对于闭锁而言第一次await时tryAcquireShared应该总是-1，因为对于闭锁<strong>CountDownLatch</strong>而言<em>state</em>的值就是初始化的<em>count</em>值。这也就解释了为什么在<em>countDown</em>调用之前闭锁的<em>count</em>总是&gt;0。</p>
<p>private void doAcquireSharedInterruptibly(int arg)
    throws InterruptedException {
    final Node node = addWaiter(Node.SHARED);
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r &gt;= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                break;
        }
    } catch (RuntimeException ex) {
        cancelAcquire(node);
        throw ex;
    }
    // Arrive here only if interrupted
    cancelAcquire(node);
    throw new InterruptedException();
}</p>
<p>上面的逻辑展示了如何通过<em>await</em>将所有线程串联并挂起，直到被唤醒或者条件满足或者被中断。整个过程是这样的：</p>
<ol>
<li>将当前线程节点以共享模式加入<strong>AQS</strong>的<strong>CLH</strong>队列中（相关概念参考<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank">这里</a>和<a href="http://www.blogjava.net/xylz/archive/2010/07/07/325410.html" target="_blank">这里</a>）。进行2。</li>
<li>检查当前节点的前任节点，如果是头结点并且当前闭锁计数为0就将当前节点设置为头结点，唤醒继任节点，返回（结束线程阻塞）。否则进行3。</li>
<li>检查线程是否该阻塞，如果应该就阻塞(park)，直到被唤醒（unpark）。重复2。</li>
<li>如果2、3有异常就抛出异常（结束线程阻塞）。</li>
</ol>
<p>这里有一点值得说明下，设置头结点并唤醒继任节点<em>setHeadAndPropagate</em>。由于前面<em>tryAcquireShared</em>总是返回1或者-1，而进入<em>setHeadAndPropagate</em>时总是<em>propagate&gt;=0</em>，所以这里<em>propagate==1</em>。后面唤醒继任节点操作就非常熟悉了。
private void setHeadAndPropagate(Node node, int propagate) {
    setHead(node);
    if (propagate &gt; 0 &amp;&amp; node.waitStatus != 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            unparkSuccessor(node);
    }
}</p>
<p>从上面的所有逻辑可以看出<em>countDown</em>应该就是在条件满足（计数为0）时唤醒头结点（时间最长的一个节点），然后头结点就会根据FIFO队列唤醒整个节点列表（如果有的话）。</p>
<p>从<strong>CountDownLatch</strong>的<em>countDown</em>代码中看到，直接调用的是<strong>AQS</strong>的<em>releaseShared(1)</em>，参考前面的知识，这就印证了上面的说法。</p>
<p><strong><em>tryReleaseShared</em></strong>中正是采用CAS操作减少计数（每次减-1）。
public boolean tryReleaseShared(int releases) {
    for (;;) {
        int c = getState();
        if (c == 0)
            return false;
        int nextc = c-1;
        if (compareAndSetState(c, nextc))
            return nextc == 0;
    }
}</p>
<p>整个<strong>CountDownLatch</strong>就是这个样子的。其实有了前面原子操作和<strong>AQS</strong>的原理及实现，分析<strong>CountDownLatch</strong>还是比较容易的。</p>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/09/325612.html](http://www.blogjava.net/xylz/archive/2010/07/09/325612.html)">[http://www.blogjava.net/xylz/archive/2010/07/09/325612.html](http://www.blogjava.net/xylz/archive/2010/07/09/325612.html)</a> </p>
<p>如果说<a href="http://www.blogjava.net/xylz/archive/2010/07/09/325612.html" target="_blank">CountDownLatch</a>是一次性的，那么<strong>CyclicBarrier</strong>正好可以循环使用。它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。所谓屏障点就是一组任务执行完毕的时刻。</p>
<p><strong><em>清单1 一个使用CyclicBarrier的例子</em></strong>
package xylz.study.concurrency.lock;</p>
<p>import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;</p>
<p>public class CyclicBarrierDemo {</p>
<pre><code>final CyclicBarrier barrier;

final int MAX_TASK;

public CyclicBarrierDemo(int cnt) {
    barrier = new CyclicBarrier(cnt + 1);
    MAX_TASK = cnt;
}

public void doWork(final Runnable work) {
    new Thread() {

        public void run() {
            work.run();
            try {
                int index = barrier.await();
                doWithIndex(index);
            } catch (InterruptedException e) {
                return;
            } catch (BrokenBarrierException e) {
                return;
            }
        }
    }.start();
}

private void doWithIndex(int index) {
    if (index == MAX_TASK / 3) {
        System.out.println(&quot;Left 30%.&quot;);
    } else if (index == MAX_TASK / 2) {
        System.out.println(&quot;Left 50%&quot;);
    } else if (index == 0) {
        System.out.println(&quot;run over&quot;);
    }
}

public void waitForNext() {
    try {
        doWithIndex(barrier.await());
    } catch (InterruptedException e) {
        return;
    } catch (BrokenBarrierException e) {
        return;
    }
}

public static void main(String[] args) {
    final int count = 10;
    CyclicBarrierDemo demo = new CyclicBarrierDemo(count);
    for (int i = 0; i &lt; 100; i++) {
        demo.doWork(new Runnable() {

            public void run() {
                //do something
                try {
                    Thread.sleep(1000L);
                } catch (Exception e) {
                    return;
                }
            }
        });
        if ((i + 1) % count == 0) {
            demo.waitForNext();
        }
    }
}
</code></pre><p>}</p>
<p>清单1描述的是一个周期性处理任务的例子，在这个例子中有一对的任务（100个），希望每10个为一组进行处理，当前仅当上一组任务处理完成后才能进行下一组，另外在每一组任务中，当任务剩下50%，30%以及所有任务执行完成时向观察者发出通知。</p>
<p>在这个例子中，CyclicBarrierDemo 构建了一个count+1的任务组（其中一个任务时为了外界方便挂起主线程）。每一个子任务里，人物本身执行完毕后都需要等待同组内其它任务执行完成后才能继续。同时在剩下任务50%、30%已经0时执行特殊的其他任务（发通知）。</p>
<p>很显然CyclicBarrier有以下几个特点：</p>
<ul>
<li>await()方法将挂起线程，直到同组的其它线程执行完毕才能继续</li>
<li>await()方法返回线程执行完毕的索引，注意，索引时从任务数-1开始的，也就是第一个执行完成的任务索引为parties-1,最后一个为0，这个parties为总任务数，清单中是cnt+1</li>
<li>CyclicBarrier 是可循环的，显然名称说明了这点。在清单1中，每一组任务执行完毕就能够执行下一组任务。</li>
</ul>
<p>另外除了CyclicBarrier除了以上特点外，还有以下几个特点：</p>
<ul>
<li>如果屏障操作不依赖于挂起的线程，那么任何线程都可以执行屏障操作。在清单1中可以看到并没有指定那个线程执行50%、30%、0%的操作，而是一组线程（cnt+1）个中任何一个线程只要到达了屏障点都可以执行相应的操作</li>
<li>CyclicBarrier 的构造函数允许携带一个任务，这个任务将在0%屏障点执行，它将在await()==0后执行。</li>
<li>CyclicBarrier 如果在await时因为中断、失败、超时等原因提前离开了屏障点，那么任务组中的其他任务将立即被中断，以InterruptedException异常离开线程。</li>
<li>所有await()之前的操作都将在屏障点之前运行，也就是CyclicBarrier 的内存一致性效果</li>
</ul>
<p>CyclicBarrier 的所有API如下：</p>
<ul>
<li><em>public CyclicBarrier(int parties)</em> 创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。</li>
<li><em>public CyclicBarrier(int parties, Runnable barrierAction)</em> 创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier 时执行给定的屏障操作，该操作由最后一个进入 barrier 的线程执行。</li>
<li><em>public int await() throws InterruptedException, BrokenBarrierException</em> 在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。</li>
<li><em>public int await(long timeout,TimeUnit unit) throws InterruptedException, BrokenBarrierException,TimeoutException</em> 在所有参与者都已经在此屏障上调用 await 方法之前将一直等待,或者超出了指定的等待时间。</li>
<li><em>public int getNumberWaiting() </em>返回当前在屏障处等待的参与者数目。此方法主要用于调试和断言。</li>
<li><em>public int getParties()</em> 返回要求启动此 barrier 的参与者数目。</li>
<li><em>public boolean isBroken()</em> 查询此屏障是否处于损坏状态。</li>
<li><em>public void reset()</em> 将屏障重置为其初始状态。</li>
</ul>
<p>针对以上API，下面来探讨下CyclicBarrier 的实现原理，以及为什么有这样的API。</p>
<p><strong><em>清单2 CyclicBarrier.await/</em>()的实现片段*</strong>
    private int dowait(boolean timed, long nanos)
    throws InterruptedException, BrokenBarrierException,
           TimeoutException {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        final Generation g = generation;
        if (g.broken)
            throw new BrokenBarrierException();</p>
<pre><code>    if (Thread.interrupted()) {
        breakBarrier();
        throw new InterruptedException();
    }

   int index = --count;
   if (index == 0) {  // tripped
       boolean ranAction = false;
       try {
           final Runnable command = barrierCommand;
           if (command != null)
               command.run();
           ranAction = true;
           nextGeneration();
           return 0;
       } finally {
           if (!ranAction)
               breakBarrier();
       }
   }

    // loop until tripped, broken, interrupted, or timed out
    for (;;) {
        try {
            if (!timed)
                trip.await();
            else if (nanos &gt; 0L)
                nanos = trip.awaitNanos(nanos);
        } catch (InterruptedException ie) {
            if (g == generation &amp;&amp; ! g.broken) {
                breakBarrier();
                throw ie;
            } else {
                Thread.currentThread().interrupt();
            }
        }

        if (g.broken)
            throw new BrokenBarrierException();

        if (g != generation)
            return index;

        if (timed &amp;&amp; nanos &lt;= 0L) {
            breakBarrier();
            throw new TimeoutException();
        }
    }
} finally {
    lock.unlock();
}
</code></pre><p>}</p>
<p>清单2有点复杂，这里一点一点的剖析，并且还原到最原始的状态。</p>
<p>利用前面学到的知识，我们知道要想让线程等待其他线程执行完毕，那么已经执行完毕的线程（进入await/*()方法）就需要park()，直到超时或者被中断，或者被其它线程唤醒。</p>
<p>前面说过CyclicBarrier 的特点是要么大家都正常执行完毕，要么大家都异常被中断，不会其中有一个被中断而其它正常执行完毕的现象存在。这种特点叫all-or-none。类似的概念是原子操作中的要么大家都执行完，要么一个操作都不执行完。当前这其实是两个概念了。要完成这样的特点就必须有一个状态来描述曾经是否有过线程被中断（broken)了，这样后面执行完的线程就该知道是否需要继续等待了。而在CyclicBarrier 中Generation 就是为了完成这件事情的。Generation的定义非常简单，整个结构就只有一个变量<em>boolean broken = false;，</em>定义是否发生了broken操作。</p>
<p>由于有竞争资源的存在（broken/index），所以毫无疑问需要一把锁lock。拿到锁后整个过程是这样的：</p>
<ol>
<li>检查是否存在中断位(broken)，如果存在就立即以BrokenBarrierException异常返回。此异常描述的是线程进入屏障被破坏的等待状态。否则进行2。</li>
<li>检查当前线程是否被中断，如果是那么就设置中断位（使其它将要进入等待的线程知道），另外唤醒已经等待的线程，同时以InterruptedException异常返回，表示线程要处理中断。否则进行3。</li>
<li>将剩余任务数减1，如果此时剩下的任务数为0，也就是达到了公共屏障点，那么就执行屏障点任务（如果有的话），同时创建新的Generation（在这个过程中会唤醒其它所有线程，因此当前线程是屏障点线程，那么其它线程就都应该在等待状态）。否则进行4。</li>
<li>到这里说明还没有到达屏障点，那么此时线程就应该park()。很显然在下面的for循环中就是要park线程。这里park线程采用的是Condition.await()方法。也就是trip.await/<em>()。为什么需要Condition？因为所有的await/</em>()其实等待的都是一个条件，一旦条件满足就应该都被唤醒，所以Condition整好满足这个特点。所以到这里就会明白为什么在步骤3中到达屏障点时创建新的Generation的时候是一定要唤醒其它线程的原因了。</li>
</ol>
<p>上面4个步骤其实只是描述主体结构，事实上整个过程中有非常多的逻辑来处理异常引发的问题，比如执行屏障点任务引发的异常，park线程超时引发的中断异常和超时异常等等。所以对于await()而言，异常的处理比业务逻辑的处理更复杂，这就解释了为什么await()的时候可能引发<em>InterruptedException,BrokenBarrierException,TimeoutException</em> 三种异常。</p>
<p><strong><em>清单3 生成下一个循环周期并唤醒其它线程</em></strong>
private void nextGeneration() {
     trip.signalAll();
     count = parties;
     generation = new Generation();
}</p>
<p>清单3 描述了如何生成下一个循环周期的过程，在这个过程中当然需要使用Condition.signalAll()唤醒所有已经执行完成并且正在等待的线程。另外这里count描述的是还有多少线程需要执行，是为了线程执行完毕索引计数。</p>
<p>isBroken() 方法描述的就是generation.broken，也即线程组是否发生了异常。这里再一次解释下为什么要有这个状态的存在。</p>
<p>如果一个将要位于屏障点或者已经位于屏障点的而执行屏障点任务的线程发生了异常，那么即使唤醒了其它等待的线程，其它等待的线程也会因为循环等待而“死去”，因为再也没有一个线程来唤醒这些第二次进行park的线程了。还有一个意图是，如果屏障点都已经损坏了，那么其它将要等待屏障点的再线程挂起就没有意义了。
<em><a href="http://www.imxylz.info/p/336.html" target="_blank">写到这里的时候非常不幸，用了4年多了台灯终于“寿终正寝了”。</a></em></p>
<p>其实CyclicBarrier 还有一个reset方法，描述的是手动立即将所有线程中断，恢复屏障点，进行下一组任务的执行。也就是与重新创建一个新的屏障点相比，可能维护的代价要小一些（减少同步，减少上一个CyclicBarrier 的管理等等）。</p>
<p>本来是想和Semaphore 一起将的，最后发现铺开后就有点长了，而且也不利于理解和吸收，所以放到下一篇吧。</p>
<p><strong>参考资料：</strong></p>
<ol>
<li><a href="http://blog.sina.com.cn/s/blog_5ce5700e0100e44l.html" target="_blank">使用 CyclicBarrier 做线程间同步</a></li>
<li><a href="http://spring21.javaeye.com/blog/363149" target="_blank">CyclicBarrier And CountDownLatch Tutorial</a></li>
<li><a href="http://www.blogjava.net/kissyan4916/articles/307091.html" target="_blank">线程—CyclicBarrier</a></li>
<li><a href="http://www.javaeye.com/topic/657295" target="_blank">Java线程学习笔记（十）CountDownLatch 和CyclicBarrier</a></li>
<li><a href="http://www.jspcn.net/htmlnews/11500653090781610.html" target="_blank">关于多线程同步的初步教程－－Barrier的设计及使用</a></li>
<li><a href="http://tech.puredanger.com/2007/11/11/thread-coord/" target="_blank">Thread coordination with CountDownLatch and CyclicBarrier</a></li>
<li><a href="http://flysnow.javaeye.com/blog/711162" target="_blank">如何充分利用多核CPU，计算很大的List中所有整数的和</a>
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/12/325913.html](http://www.blogjava.net/xylz/archive/2010/07/12/325913.html)">[http://www.blogjava.net/xylz/archive/2010/07/12/325913.html](http://www.blogjava.net/xylz/archive/2010/07/12/325913.html)</a> </li>
</ol>
<p>Semaphore 是一个计数信号量。从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 </p>
<p>acquire()
，然后再获取该许可。每个 </p>
<p>release()
 添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，</p>
<p>Semaphore
 只对可用许可的号码进行计数，并采取相应的行动。</p>
<p>说白了，Semaphore是一个计数器，在计数器不为0的时候对线程就放行，一旦达到0，那么所有请求资源的新线程都会被阻塞，包括增加请求到许可的线程，也就是说Semaphore不是可重入的。每一次请求一个许可都会导致计数器减少1，同样每次释放一个许可都会导致计数器增加1，一旦达到了0，新的许可请求线程将被挂起。</p>
<p>缓存池整好使用此思想来实现的，比如链接池、对象池等。</p>
<p><strong><em>清单1 对象池</em></strong>
package xylz.study.concurrency.lock;</p>
<p>import java.util.concurrent.Semaphore;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;</p>
<p>public class ObjectCache<T> {</p>
<pre><code>public interface ObjectFactory&lt;T&gt; {

    T makeObject();
}

class Node {

    T obj;

    Node next;
}

final int capacity;

final ObjectFactory&lt;T&gt; factory;

final Lock lock = new ReentrantLock();

final Semaphore semaphore;

private Node head;

private Node tail;

public ObjectCache(int capacity, ObjectFactory&lt;T&gt; factory) {
    this.capacity = capacity;
    this.factory = factory;
    this.semaphore = new Semaphore(this.capacity);
    this.head = null;
    this.tail = null;
}

public T getObject() throws InterruptedException {
    semaphore.acquire();
    return getNextObject();
}

private T getNextObject() {
    lock.lock();
    try {
        if (head == null) {
            return factory.makeObject();
        } else {
            Node ret = head;
            head = head.next;
            if (head == null) tail = null;
            ret.next = null;//help GC
            return ret.obj;
        }
    } finally {
        lock.unlock();
    }
}

private void returnObjectToPool(T t) {
    lock.lock();
    try {
        Node node = new Node();
        node.obj = t;
        if (tail == null) {
            head = tail = node;
        } else {
            tail.next = node;
            tail = node;
        }

    } finally {
        lock.unlock();
    }
}

public void returnObject(T t) {
    returnObjectToPool(t);
    semaphore.release();
}
</code></pre><p>}</p>
<p>清单1描述了一个基于信号量Semaphore的对象池实现。此对象池最多支持capacity个对象，这在构造函数中传入。对象池有一个基于FIFO的队列，每次从对象池的头结点开始取对象，如果头结点为空就直接构造一个新的对象返回。否则将头结点对象取出，并且头结点往后移动。特别要说明的如果对象的个数用完了，那么新的线程将被阻塞，直到有对象被返回回来。返还对象时将对象加入FIFO的尾节点并且释放一个空闲的信号量，表示对象池中增加一个可用对象。</p>
<p>实际上对象池、线程池的原理大致上就是这样的，只不过真正的对象池、线程池要处理比较复杂的逻辑，所以实现起来还需要做很多的工作，例如超时机制，自动回收机制，对象的有效期等等问题。</p>
<p>这里特别说明的是信号量只是在信号不够的时候挂起线程，但是并不能保证信号量足够的时候获取对象和返还对象是线程安全的，所以在清单1中仍然需要锁Lock来保证并发的正确性。</p>
<p>将信号量初始化为 1，使得它在使用时最多只有一个可用的许可，从而可用作一个相互排斥的锁。这通常也称为<em>二进制信号量</em>，因为它只能有两种状态：一个可用的许可，或零个可用的许可。按此方式使用时，二进制信号量具有某种属性（与很多 </p>
<p>Lock
 实现不同），即可以由线程释放“锁”，而不是由所有者（因为信号量没有所有权的概念）。在某些专门的上下文（如死锁恢复）中这会很有用。</p>
<p>上面这段话的意思是说当某个线程A持有信号量数为1的信号量时，其它线程只能等待此线程释放资源才能继续，这时候持有信号量的线程A就相当于持有了“锁”，其它线程的继续就需要这把锁，于是线程A的释放才能决定其它线程的运行，相当于扮演了“锁”的角色。</p>
<p>另外同公平锁非公平锁一样，信号量也有公平性。如果一个信号量是公平的表示线程在获取信号量时按FIFO的顺序得到许可，也就是按照请求的顺序得到释放。这里特别说明的是：所谓请求的顺序是指在请求信号量而进入FIFO队列的顺序，有可能某个线程先请求信号而后进去请求队列，那么次线程获取信号量的顺序就会晚于其后请求但是先进入请求队列的线程。这个在公平锁和非公平锁中谈过很多。</p>
<p>除了acquire以外，Semaphore还有几种类似的acquire方法，这些方法可以更好的处理中断和超时或者异步等特性，可以参考JDK API。</p>
<p>按照同样的学习原则，下面对主要的实现进行分析。Semaphore的acquire方法实际上访问的是<strong>AQS</strong>的<em>acquireSharedInterruptibly(arg)</em>方法。这个可以参考<a href="http://www.blogjava.net/xylz/archive/2010/07/09/325612.html" target="_blank"><strong>CountDownLatch</strong></a>一节或者<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank"><strong>AQS</strong></a>一节。</p>
<p>所以Semaphore的await实现也是比较简单的。与CountDownLatch不同的是，Semaphore区分公平信号和非公平信号。</p>
<p><strong><em>清单2 公平信号获取方法</em></strong>
protected int tryAcquireShared(int acquires) {
    Thread current = Thread.currentThread();
    for (;;) {
        Thread first = getFirstQueuedThread();
        if (first != null &amp;&amp; first != current)
            return -1;
        int available = getState();
        int remaining = available - acquires;
        if (remaining &lt; 0 ||
            compareAndSetState(available, remaining))
            return remaining;
    }
}</p>
<p><strong><em>清单3 非公平信号获取方法</em></strong></p>
<p>protected int tryAcquireShared(int acquires) {
    return nonfairTryAcquireShared(acquires);
}</p>
<p>final int nonfairTryAcquireShared(int acquires) {
    for (;;) {
        int available = getState();
        int remaining = available - acquires;
        if (remaining &lt; 0 ||
            compareAndSetState(available, remaining))
            return remaining;
    }
}</p>
<p>对比清单2和清单3可以看到，公平信号和非公平信号在于第一次尝试能否获取信号时，公平信号量总是将当前线程进入AQS的CLH队列进行排队（因为第一次尝试时队列的头结点线程很有可能不是当前线程，当然不排除同一个线程第二次进入信号量），从而根据AQS的CLH队列的顺序FIFO依次获取信号量；而对于非公平信号量，第一次立即尝试能否拿到信号量，一旦信号量的剩余数available大于请求数（acquires通常为1），那么线程就立即得到了释放，而不需要进行AQS队列进行排队。只有remaining&lt;0的时候（也就是信号量不够的时候）才会进入AQS队列。</p>
<p>所以非公平信号量的吞吐量总是要比公平信号量的吞吐量要大，但是需要强调的是非公平信号量和非公平锁一样存在“饥渴死”的现象，也就是说活跃线程可能总是拿到信号量，而非活跃线程可能难以拿到信号量。而对于公平信号量由于总是靠请求的线程的顺序来获取信号量，所以不存在此问题。</p>
<p> <strong>参考资料：</strong></p>
<ol>
<li><a href="http://blog.csdn.net/java2000_net/archive/2009/03/17/3997449.aspx" target="_blank">信号量(Semaphore)在生产者和消费者模式的使用</a></li>
<li><a href="http://stackoverflow.com/questions/771347/what-is-mutex-and-semaphore-in-java-what-is-the-main-difference" target="_blank">What is mutex and semaphore in Java ? What is the main difference ?</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-5things5.html" target="_blank">关于 java.util.concurrent 您不知道的 5 件事，第 2 部分</a></li>
<li><a href="http://tutorials.jenkov.com/java-concurrency/semaphores.html" target="_blank">Semahores</a></li>
</ol>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/13/326021.html](http://www.blogjava.net/xylz/archive/2010/07/13/326021.html)">[http://www.blogjava.net/xylz/archive/2010/07/13/326021.html](http://www.blogjava.net/xylz/archive/2010/07/13/326021.html)</a></p>
<p>从这一节开始介绍锁里面的最后一个工具：读写锁(ReadWriteLock)。</p>
<p>ReentrantLock 实现了标准的互斥操作，也就是一次只能有一个线程持有锁，也即所谓独占锁的概念。前面的章节中一直在强调这个特点。显然这个特点在一定程度上面减低了吞吐量，实际上独占锁是一种保守的锁策略，在这种情况下任何“读/读”，“写/读”，“写/写”操作都不能同时发生。但是同样需要强调的一个概念是，锁是有一定的开销的，当并发比较大的时候，锁的开销就比较客观了。所以如果可能的话就尽量少用锁，非要用锁的话就尝试看能否改造为读写锁。</p>
<p>ReadWriteLock描述的是：一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程。也就是说读写锁使用的场合是一个共享资源被大量读取操作，而只有少量的写操作（修改数据）。清单1描述了ReadWriteLock的API。</p>
<p> <strong><em>清单1 ReadWriteLock 接口</em></strong>
public interface ReadWriteLock {
    Lock readLock();
    Lock writeLock();
}</p>
<p>清单1描述的ReadWriteLock结构，这里需要说明的是ReadWriteLock并不是Lock的子接口，只不过ReadWriteLock借助Lock来实现读写两个视角。在ReadWriteLock中每次读取共享数据就需要读取锁，当需要修改共享数据时就需要写入锁。看起来好像是两个锁，但其实不尽然，在下一节中的分析中会解释这点奥秘。</p>
<p>在JDK 6里面ReadWriteLock的实现是ReentrantReadWriteLock。</p>
<p><strong><em>清单2 SimpleConcurrentMap</em></strong>
package xylz.study.concurrency.lock;</p>
<p>import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;</p>
<p>public class SimpleConcurrentMap<K, V> implements Map<K, V> {</p>
<pre><code>final ReadWriteLock lock = new ReentrantReadWriteLock();

final Lock r = lock.readLock();

final Lock w = lock.writeLock();

final Map&lt;K, V&gt; map;

public SimpleConcurrentMap(Map&lt;K, V&gt; map) {
    this.map = map;
    if (map == null) throw new NullPointerException();
}

public void clear() {
    w.lock();
    try {
        map.clear();
    } finally {
        w.unlock();
    }
}

public boolean containsKey(Object key) {
    r.lock();
    try {
        return map.containsKey(key);
    } finally {
        r.unlock();
    }
}

public boolean containsValue(Object value) {
    r.lock();
    try {
        return map.containsValue(value);
    } finally {
        r.unlock();
    }
}

public Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt; entrySet() {
    throw new UnsupportedOperationException();
}

public V get(Object key) {
    r.lock();
    try {
        return map.get(key);
    } finally {
        r.unlock();
    }
}

public boolean isEmpty() {
    r.lock();
    try {
        return map.isEmpty();
    } finally {
        r.unlock();
    }
}

public Set&lt;K&gt; keySet() {
    r.lock();
    try {
        return new HashSet&lt;K&gt;(map.keySet());
    } finally {
        r.unlock();
    }
}

public V put(K key, V value) {
    w.lock();
    try {
        return map.put(key, value);
    } finally {
        w.unlock();
    }
}

public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
    w.lock();
    try {
        map.putAll(m);
    } finally {
        w.unlock();
    }
}

public V remove(Object key) {
    w.lock();
    try {
        return map.remove(key);
    } finally {
        w.unlock();
    }
}

public int size() {
    r.lock();
    try {
        return map.size();
    } finally {
        r.unlock();
    }
}

public Collection&lt;V&gt; values() {
    r.lock();
    try {
        return new ArrayList&lt;V&gt;(map.values());
    } finally {
        r.unlock();
    }
}
</code></pre><p>}</p>
<p>清单2描述的是用读写锁实现的一个线程安全的Map。其中需要特别说明的是并没有实现entrySet()方法，这是因为实现这个方法比较复杂，在后面章节中讲到ConcurrentHashMap的时候会具体谈这些细节。另外这里keySet()和values()也没有直接返回Map的视图，而是一个映射原有元素的新视图，其实这个entrySet()一样，是为了保护原始Map的数据逻辑，防止不正确的修改导致原始Map发生数据错误。特别说明的是在没有特别需求的情况下没有必要按照清单2写一个线程安全的Map实现，因为ConcurrentHashMap已经完成了此操作。</p>
<p>ReadWriteLock需要严格区分读写操作，如果读操作使用了写入锁，那么降低读操作的吞吐量，如果写操作使用了读取锁，那么就可能发生数据错误。</p>
<p>另外ReentrantReadWriteLock还有以下几个特性：</p>
<ul>
<li><p><strong>公平性</strong></p>
</li>
<li><p>非公平锁（默认） 这个和独占锁的非公平性一样，由于读线程之间没有锁竞争，所以读操作没有公平性和非公平性，写操作时，由于写操作可能立即获取到锁，所以会推迟一个或多个读操作或者写操作。因此非公平锁的吞吐量要高于公平锁。</p>
</li>
<li>公平锁 利用AQS的CLH队列，释放当前保持的锁（读锁或者写锁）时，优先为等待时间最长的那个写线程分配写入锁，当前前提是写线程的等待时间要比所有读线程的等待时间要长。同样一个线程持有写入锁或者有一个写线程已经在等待了，那么试图获取公平锁的（非重入）所有线程（包括读写线程）都将被阻塞，直到最先的写线程释放锁。如果读线程的等待时间比写线程的等待时间还有长，那么一旦上一个写线程释放锁，这一组读线程将获取锁。</li>
<li><p><strong>重入性</strong></p>
</li>
<li><p>读写锁允许读线程和写线程按照请求锁的顺序重新获取读取锁或者写入锁。当然了只有写线程释放了锁，读线程才能获取重入锁。</p>
</li>
<li>写线程获取写入锁后可以再次获取读取锁，但是读线程获取读取锁后却不能获取写入锁。</li>
<li>另外读写锁最多支持65535个递归写入锁和65535个递归读取锁。</li>
<li><p><strong>锁降级</strong></p>
</li>
<li><p>写线程获取写入锁后可以获取读取锁，然后释放写入锁，这样就从写入锁变成了读取锁，从而实现锁降级的特性。</p>
</li>
<li><p>锁升级</p>
</li>
<li><p>读取锁是不能直接升级为写入锁的。因为获取一个写入锁需要释放所有读取锁，所以如果有两个读取锁视图获取写入锁而都不释放读取锁时就会发生死锁。</p>
</li>
<li><p><strong>锁获取中断</strong></p>
</li>
<li><p>读取锁和写入锁都支持获取锁期间被中断。这个和独占锁一致。</p>
</li>
<li><p><strong>条件变量</strong></p>
</li>
<li><p>写入锁提供了条件变量(Condition)的支持，这个和独占锁一致，但是读取锁却不允许获取条件变量，将得到一个</p>
</li>
</ul>
<p>UnsupportedOperationException
异常。</p>
<ul>
<li><p><strong>重入数</strong></p>
</li>
<li><p>读取锁和写入锁的数量最大分别只能是65535（包括重入数）。这在下节中有介绍。</p>
</li>
</ul>
<p>上面几个特性对读写锁的理解很有帮助，而且也是必要的，另外在下一节中讲ReadWriteLock的实现会用到这些知识的。
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/14/326080.html](http://www.blogjava.net/xylz/archive/2010/07/14/326080.html)">[http://www.blogjava.net/xylz/archive/2010/07/14/326080.html](http://www.blogjava.net/xylz/archive/2010/07/14/326080.html)</a> </p>
<p>这一节主要是谈谈读写锁的实现。</p>
<p>上一节中提到，ReadWriteLock看起来有两个锁：readLock/writeLock。如果真的是两个锁的话，它们之间又是如何相互影响的呢？</p>
<p>事实上在ReentrantReadWriteLock里锁的实现是靠java.util.concurrent.locks.ReentrantReadWriteLock.Sync完成的。这个类看起来比较眼熟，实际上它是AQS的一个子类，这中类似的结构在CountDownLatch、ReentrantLock、Semaphore里面都存在。同样它也有两种实现：公平锁和非公平锁，也就是java.util.concurrent.locks.ReentrantReadWriteLock.FairSync和java.util.concurrent.locks.ReentrantReadWriteLock.NonfairSync。这里暂且不提。</p>
<p>在ReentrantReadWriteLock里面的锁主体就是一个Sync，也就是上面提到的FairSync或者NonfairSync，所以说实际上只有一个锁，只是在获取读取锁和写入锁的方式上不一样，所以前面才有读写锁是独占锁的两个不同视图一说。</p>
<p>ReentrantReadWriteLock里面有两个类：ReadLock/WriteLock，这两个类都是Lock的实现。</p>
<p><strong><em>清单1 ReadLock 片段</em></strong>
public static class ReadLock implements Lock, java.io.Serializable  {
    private final Sync sync;</p>
<pre><code>protected ReadLock(ReentrantReadWriteLock lock) {
    sync = lock.sync;
}

public void lock() {
    sync.acquireShared(1);
}

public void lockInterruptibly() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}

public  boolean tryLock() {
    return sync.tryReadLock();
}

public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
}

public  void unlock() {
    sync.releaseShared(1);
}

public Condition newCondition() {
    throw new UnsupportedOperationException();
}
</code></pre><p>}</p>
<p><strong><em>清单2 WriteLock 片段</em></strong></p>
<p>public static class WriteLock implements Lock, java.io.Serializable  {
    private final Sync sync;
    protected WriteLock(ReentrantReadWriteLock lock) {
        sync = lock.sync;
    }
    public void lock() {
        sync.acquire(1);
    }</p>
<pre><code>public void lockInterruptibly() throws InterruptedException {
    sync.acquireInterruptibly(1);
}

public boolean tryLock( ) {
    return sync.tryWriteLock();
}

public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
    return sync.tryAcquireNanos(1, unit.toNanos(timeout));
}

public void unlock() {
    sync.release(1);
}

public Condition newCondition() {
    return sync.newCondition();
}

public boolean isHeldByCurrentThread() {
    return sync.isHeldExclusively();
}

public int getHoldCount() {
    return sync.getWriteHoldCount();
}
</code></pre><p>}</p>
<p>清单1描述的是读锁的实现，清单2描述的是写锁的实现。显然WriteLock就是一个独占锁，这和ReentrantLock里面的实现几乎相同，都是使用了AQS的acquire/release操作。当然了在内部处理方式上与ReentrantLock还是有一点不同的。对比清单1和清单2可以看到，ReadLock获取的是共享锁，WriteLock获取的是独占锁。</p>
<p>在AQS章节中介绍到AQS中有一个state字段（int类型，32位）用来描述有多少线程获持有锁。在独占锁的时代这个值通常是0或者1（如果是重入的就是重入的次数），在共享锁的时代就是持有锁的数量。在上一节中谈到，ReadWriteLock的读、写锁是相关但是又不一致的，所以需要两个数来描述读锁（共享锁）和写锁（独占锁）的数量。显然现在一个state就不够用了。于是在ReentrantReadWrilteLock里面将这个字段一分为二，高位16位表示共享锁的数量，低位16位表示独占锁的数量（或者重入数量）。2^16-1=65536，这就是上节中提到的为什么共享锁和独占锁的数量最大只能是65535的原因了。</p>
<p>有了上面的知识后再来分析读写锁的获取和释放就容易多了。</p>
<p><strong><em>清单3 写入锁获取片段</em></strong>
protected final boolean tryAcquire(int acquires) {
    Thread current = Thread.currentThread();
    int c = getState();
    int w = exclusiveCount(c);
    if (c != 0) {
        if (w == 0 || current != getExclusiveOwnerThread())
            return false;
        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
    }
    if ((w == 0 &amp;&amp; writerShouldBlock(current)) ||
        !compareAndSetState(c, c + acquires))
        return false;
    setExclusiveOwnerThread(current);
    return true;
}</p>
<p>清单3 是写入锁获取的逻辑片段，整个工作流程是这样的：</p>
<ol>
<li>持有锁线程数非0（c=getState()不为0），如果写线程数（w）为0（那么读线程数就不为0）或者独占锁线程（持有锁的线程）不是当前线程就返回失败，或者写入锁的数量（其实是重入数）大于65535就抛出一个Error异常。否则进行2。</li>
<li>如果当且写线程数位0（那么读线程也应该为0，因为步骤1已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果增加写线程数失败也返回失败。否则进行3。</li>
<li>设置独占线程（写线程）为当前线程，返回true。</li>
</ol>
<p>清单3 中 exclusiveCount(c)就是获取写线程数（包括重入数），也就是state的低16位值。另外这里有一段逻辑是当前写线程是否需要阻塞writerShouldBlock(current)。清单4 和清单5 就是公平锁和非公平锁中是否需要阻塞的片段。很显然对于非公平锁而言总是不阻塞当前线程，而对于公平锁而言如果AQS队列不为空或者当前线程不是在AQS的队列头那么就阻塞线程，直到队列前面的线程处理完锁逻辑。</p>
<p><strong><em>清单4 公平读写锁写线程是否阻塞</em></strong>
final boolean writerShouldBlock(Thread current) {
    return !isFirst(current);
}</p>
<p><strong><em>清单5 非公平读写锁写线程是否阻塞</em></strong></p>
<p>final boolean writerShouldBlock(Thread current) {
    return false;
}</p>
<p>写入锁的获取逻辑清楚后，释放锁就比较简单了。清单6 描述的写入锁释放逻辑片段，其实就是检测下剩下的写入锁数量，如果是0就将独占锁线程清空（意味着没有线程获取锁），否则就是说当前是重入锁的一次释放，所以不能将独占锁线程清空。然后将剩余线程状态数写回AQS。</p>
<p><strong><em>清单6 写入锁释放逻辑片段</em></strong>
protected final boolean tryRelease(int releases) {
    int nextc = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    if (exclusiveCount(nextc) == 0) {
        setExclusiveOwnerThread(null);
        setState(nextc);
        return true;
    } else {
        setState(nextc);
        return false;
    }
}</p>
<p>清单3~6 描述的写入锁的获取释放过程。读取锁的获取和释放过程要稍微复杂些。 清单7描述的是读取锁的获取过程。</p>
<p><strong><em>清单7 读取锁获取过程片段</em></strong>
protected final int tryAcquireShared(int unused) {
    Thread current = Thread.currentThread();
    int c = getState();
    if (exclusiveCount(c) != 0 &amp;&amp;
        getExclusiveOwnerThread() != current)
        return -1;
    if (sharedCount(c) == MAX_COUNT)
        throw new Error(&quot;Maximum lock count exceeded&quot;);
    if (!readerShouldBlock(current) &amp;&amp;
        compareAndSetState(c, c + SHARED_UNIT)) {
        HoldCounter rh = cachedHoldCounter;
        if (rh == null || rh.tid != current.getId())
            cachedHoldCounter = rh = readHolds.get();
        rh.count++;
        return 1;
    }
    return fullTryAcquireShared(current);
}</p>
<p>final int fullTryAcquireShared(Thread current) {
    HoldCounter rh = cachedHoldCounter;
    if (rh == null || rh.tid != current.getId())
        rh = readHolds.get();
    for (;;) {
        int c = getState();
        int w = exclusiveCount(c);
        if ((w != 0 &amp;&amp; getExclusiveOwnerThread() != current) ||
            ((rh.count | w) == 0 &amp;&amp; readerShouldBlock(current)))
            return -1;
        if (sharedCount(c) == MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        if (compareAndSetState(c, c + SHARED_UNIT)) {
            cachedHoldCounter = rh; // cache for release
            rh.count++;
            return 1;
        }
    }
}</p>
<p>读取锁获取的过程是这样的：</p>
<ol>
<li>如果写线程持有锁（也就是独占锁数量不为0），并且独占线程不是当前线程，那么就返回失败。因为允许写入线程获取锁的同时获取读取锁。否则进行2。</li>
<li>如果读线程请求锁数量达到了65535（包括重入锁），那么就跑出一个错误Error，否则进行3。</li>
<li>如果读线程不用等待（实际上是是否需要公平锁），并且增加读取锁状态数成功，那么就返回成功，否则进行4。</li>
<li>步骤3失败的原因是CAS操作修改状态数失败，那么就需要循环不断尝试去修改状态直到成功或者锁被写入线程占有。实际上是过程3的不断尝试直到CAS计数成功或者被写入线程占有锁。</li>
</ol>
<p>在清单7 中有一个对象HoldCounter，这里暂且不提这是什么结构和为什么存在这样一个结构。</p>
<p>接下来根据清单8 我们来看如何释放一个读取锁。同样先不理HoldCounter，关键的在于for循环里面，其实就是一个不断尝试的CAS操作，直到修改状态成功。前面说过state的高16位描述的共享锁（读取锁）的数量，所以每次都需要减去2^16，这样就相当于读取锁数量减1。实际上SHARED_UNIT=1&lt;&lt;16。</p>
<p><strong><em>清单8 读取锁释放过程</em></strong>
protected final boolean tryReleaseShared(int unused) {
    HoldCounter rh = cachedHoldCounter;
    Thread current = Thread.currentThread();
    if (rh == null || rh.tid != current.getId())
        rh = readHolds.get();
    if (rh.tryDecrement() &lt;= 0)
        throw new IllegalMonitorStateException();
    for (;;) {
        int c = getState();
        int nextc = c - SHARED_UNIT;
        if (compareAndSetState(c, nextc))
            return nextc == 0;
    }
}</p>
<p>好了，现在回头看HoldCounter到底是一个什么东西。首先我们可以看到只有在获取共享锁（读取锁）的时候加1，也只有在释放共享锁的时候减1有作用，并且在释放锁的时候抛出了一个IllegalMonitorStateException异常。而我们知道IllegalMonitorStateException通常描述的是一个线程操作一个不属于自己的监视器对象的引发的异常。也就是说这里的意思是一个线程释放了一个不属于自己或者不存在的共享锁。</p>
<p>前面的章节中一再强调，对于共享锁，其实并不是锁的概念，更像是计数器的概念。一个共享锁就相对于一次计数器操作，一次获取共享锁相当于计数器加1，释放一个共享锁就相当于计数器减1。显然只有线程持有了共享锁（也就是当前线程携带一个计数器，描述自己持有多少个共享锁或者多重共享锁），才能释放一个共享锁。否则一个没有获取共享锁的线程调用一次释放操作就会导致读写锁的state（持有锁的线程数，包括重入数）错误。</p>
<p>明白了HoldCounter的作用后我们就可以猜到它的作用其实就是当前线程持有共享锁（读取锁）的数量，包括重入的数量。那么这个数量就必须和线程绑定在一起。</p>
<p>在Java里面将一个对象和线程绑定在一起，就只有ThreadLocal才能实现了。所以毫无疑问HoldCounter就应该是绑定到线程上的一个计数器。</p>
<p><strong><em>清单9 线程持有读取锁数量的计数器</em></strong>
static final class HoldCounter {
    int count;
    final long tid = Thread.currentThread().getId();
    int tryDecrement() {
        int c = count;
        if (c &gt; 0)
            count = c - 1;
        return c;
    }
}</p>
<p>static final class ThreadLocalHoldCounter
    extends ThreadLocal<HoldCounter> {
    public HoldCounter initialValue() {
        return new HoldCounter();
    }
}</p>
<p>清单9 描述的是线程持有读取锁数量的计数器。可以看到这里使用ThreadLocal将HoldCounter绑定到当前线程上，同时HoldCounter也持有线程Id，这样在释放锁的时候才能知道ReadWriteLock里面缓存的上一个读取线程（cachedHoldCounter）是否是当前线程。这样做的好处是可以减少ThreadLocal.get()的次数，因为这也是一个耗时操作。需要说明的是这样HoldCounter绑定线程id而不绑定线程对象的原因是避免HoldCounter和ThreadLocal互相绑定而GC难以释放它们（尽管GC能够智能的发现这种引用而回收它们，但是这需要一定的代价），所以其实这样做只是为了帮助GC快速回收对象而已。</p>
<p>除了readLock()和writeLock()外，Lock对象还允许tryLock()，那么ReadLock和WriteLock的tryLock()不一样。清单10 和清单11 分别描述了读取锁的tryLock()和写入锁的tryLock()。</p>
<p>读取锁tryLock()也就是tryReadLock()成功的条件是：没有写入锁或者写入锁是当前线程，并且读线程共享锁数量没有超过65535个。</p>
<p>写入锁tryLock()也就是tryWriteLock()成功的条件是: 没有写入锁或者写入锁是当前线程，并且尝试一次修改state成功。</p>
<p><strong><em>清单10 读取锁的tryLock()</em></strong>
final boolean tryReadLock() {
    Thread current = Thread.currentThread();
    for (;;) {
        int c = getState();
        if (exclusiveCount(c) != 0 &amp;&amp;
            getExclusiveOwnerThread() != current)
            return false;
        if (sharedCount(c) == MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        if (compareAndSetState(c, c + SHARED_UNIT)) {
            HoldCounter rh = cachedHoldCounter;
            if (rh == null || rh.tid != current.getId())
                cachedHoldCounter = rh = readHolds.get();
            rh.count++;
            return true;
        }
    }
}</p>
<p><strong><em>清单11 写入锁的tryLock()</em></strong></p>
<p>final boolean tryWriteLock() {
    Thread current = Thread.currentThread();
    int c = getState();
    if (c != 0) {
        int w = exclusiveCount(c);
        if (w == 0 ||current != getExclusiveOwnerThread())
            return false;
        if (w == MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
    }
    if (!compareAndSetState(c, c + 1))
        return false;
    setExclusiveOwnerThread(current);
    return true;
}</p>
<p>整个读写锁的逻辑大概就这么多，其实真正研究起来也不是很复杂，真正复杂的东西都在AQS里面。</p>
<p>锁部分的原理和思想都介绍完了，下一节里面会对锁机进行小节，并对线程并发也会有一些简单的小节。
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/15/326152.html](http://www.blogjava.net/xylz/archive/2010/07/15/326152.html)">[http://www.blogjava.net/xylz/archive/2010/07/15/326152.html](http://www.blogjava.net/xylz/archive/2010/07/15/326152.html)</a> </p>
<p>主要谈谈锁的性能以及其它一些理论知识，内容主要的出处是《<a href="http://www.amazon.com/exec/obidos/ASIN/0321349601/ref=nosim/none0b69" target="_blank">Java Concurrency in Practice</a>》，结合自己的理解和实际应用对锁机制进行一个小小的总结。</p>
<p>首先需要强调的一点是：所有锁（包括内置锁和高级锁）都是有性能消耗的，也就是说在高并发的情况下，由于锁机制带来的上下文切换、资源同步等消耗是非常可观的。在某些极端情况下，线程在锁上的消耗可能比线程本身的消耗还要多。所以如果可能的话，在任何情况下都尽量少用锁，如果不可避免那么采用非阻塞算法是一个不错的解决方案，但是却也不是绝对的。</p>
<p><strong>内部锁</strong></p>
<p>Java语言通过synchronized关键字来保证原子性。这是因为每一个Object都有一个隐含的锁，这个也称作监视器对象。在进入synchronized之前自动获取此内部锁，而一旦离开此方式（不管通过和中方式离开此方法）都会自动释放锁。显然这是一个独占锁，每个锁请求之间是互斥的。相对于前面介绍的众多高级锁（Lock/ReadWriteLock等），synchronized的代价都比后者要高。但是synchronized的语法比较简单，而且也比较容易使用和理解，不容易写法上的错误。而我们知道Lock一旦调用了lock()方法获取到锁而未正确释放的话很有可能就死锁了。所以Lock的释放操作总是跟在finally代码块里面，这在代码结构上也是一次调整和冗余。另外前面介绍中说过Lock的实现已经将硬件资源用到了极致，所以未来可优化的空间不大，除非硬件有了更高的性能。但是synchronized只是规范的一种实现，这在不同的平台不同的硬件还有很高的提升空间，未来Java在锁上的优化也会主要在这上面。</p>
<p><strong>性能</strong></p>
<p>由于锁总是带了性能影响，所以是否使用锁和使用锁的场合就变得尤为重要。如果在一个高并发的Web请求中使用了强制的独占锁，那么就可以发现Web的吞吐量将急剧下降。</p>
<p>为了利用并发来提高性能，出发点就是：更有效的利用现有的资源，同时让程序尽可能的开拓更多可用的资源。这意味着机器尽可能的处于忙碌的状态，通常意义是说CPU忙于计算，而不是等待。当然CPU要做有用的事情，而不是进行无谓的循环。当然在实践中通常会预留一些资源出来以便应急特殊情况，这在以后的线程池并发中可以看到很多例子。</p>
<p><strong>线程阻塞</strong></p>
<p>锁机制的实现通常需要操作系统提供支持，显然这会增加开销。当锁竞争的时候，失败的线程必然会发生阻塞。JVM既能自旋等待（不断尝试，知道成功，很多CAS就是这样实现的），也能够在操作系统中挂起阻塞的线程，直到超时或者被唤醒。通常情况下这取决于上下文切换的开销以及与获取锁需要等待的时间二者之间的关系。自旋等待适合于比较短的等待，而挂起线程比较适合那些比较耗时的等待。</p>
<p>挂起一个线程可能是因为无法获取到锁，或者需要某个特定的条件，或者耗时的I/O操作。挂起一个线程需要两次额外的上下文切换以及操作系统、缓存等多资源的配合：如果线程被提前换出，那么一旦拿到锁或者条件满足，那么又需要将线程换回执行队列，这对线程而言，两次上下文切换可能比较耗时。</p>
<hr>
<p><strong>锁竞争</strong></p>
<p>影响锁竞争性的条件有两个：锁被请求的频率和每次持有锁的时间。显然当而这二者都很小的时候，锁竞争不会成为主要的瓶颈。但是如果锁使用不当，导致二者都比较大，那么很有可能CPU不能有效的处理任务，任务被大量堆积。</p>
<p>所以减少锁竞争的方式有下面三种：</p>
<ol>
<li>减少锁持有的时间</li>
<li>减少锁请求的频率</li>
<li>采用共享锁取代独占锁</li>
</ol>
<p><strong>死锁</strong></p>
<p>如果一个线程永远不释放另外一个线程需要的资源那么就会导致死锁。这有两种情况：一种情况是线程A永远不释放锁，结果B一直拿不到锁，所以线程B就“死掉”了；第二种情况下，线程A拥有线程B需要的锁Y，同时线程B拥有线程A需要的锁X，那么这时候线程A/B互相依赖对方释放锁，于是二者都“死掉”了。</p>
<p>还有一种情况为发生死锁，如果一个线程总是不能被调度，那么等待此线程结果的线程可能就死锁了。这种情况叫做线程饥饿死锁。比如说在前面介绍的非公平锁中，如果某些线程非常活跃，在高并发情况下这类线程可能总是拿到锁，那么那些活跃度低的线程可能就一直拿不到锁，这样就发生了“饥饿死”。</p>
<p>避免死锁的解决方案是：尽可能的按照锁的使用规范请求锁，另外锁的请求粒度要小（不要在不需要锁的地方占用锁，锁不用了尽快释放）；在高级锁里面总是使用tryLock或者定时机制（这个以后会讲，就是指定获取锁超时的时间，如果时间到了还没有获取到锁那么就放弃）。高级锁（Lock）里面的这两种方式可以有效的避免死锁。</p>
<p><strong>活锁</strong></p>
<p>活锁描述的是线程总是尝试某项操作却总是失败的情况。这种情况下尽管线程没有被阻塞，但是人物却总是不能被执行。比如在一个死循环里面总是尝试做某件事，结果却总是失败，现在线程将永远不能跳出这个循环。另外一种情况是在一个队列中每次从队列头取出一个任务来执行，每次都失败，然后将任务放入队列头，接下来再一次从队列头取出任务执行，仍然失败。</p>
<p>还有一种活锁方式发生在“碰撞协让”情况下：两个人过独木桥，如果在半路相撞，双方礼貌退出去然后再试一次。如果总是失败，那么这两个任务将一直无法得到执行。</p>
<p><strong>总之解决锁问题的关键就是：从简单的开始，先保证正确，然后再开始优化。</strong>
<strong>来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/16/326246.html](http://www.blogjava.net/xylz/archive/2010/07/16/326246.html)">[http://www.blogjava.net/xylz/archive/2010/07/16/326246.html](http://www.blogjava.net/xylz/archive/2010/07/16/326246.html)</a> </strong></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency3-锁机制/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency3-锁机制" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-java-com-jacob--java操作word文档jacob-poi/">java操作word文档(jacob</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-java-com-jacob--java操作word文档jacob-poi/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-word-jacob-poi-">java操作word文档(jacob,poi)</h1>
<p>项目需要，用户从系统里面下载word文档，该文档进行了填写限制和加密，用户只能在固定位置填写内容。现要求系统验证上传的附件是否从系统上下载下来的。</p>
<p>思路：系统上面的文档都加入一个固定书签，用户上传文档的时候，检验文档里是否包含这个书签。</p>
<p>采用jacob操作word文档</p>
<p>JACOB（java -com bridge）是一个 JAVA到微软的COM接口的桥梁。使用JACOB允许任何JVM访问COM对象，从而使JAVA应用程序能够调用COM对象。</p>
<p>下载地址：<a href="http://sourceforge.net/projects/jacob-project/" target="_blank"><a href="http://sourceforge.net/projects/jacob-project/">http://sourceforge.net/projects/jacob-project/</a></a></p>
<p>其中jacob-1.16.1-x64.dll 是用于64位机器上的，jacob-1.16.1-x86.dll用于32位的。</p>
<p>该dll放于 C:\Windows\system32 目录下。jacob.jar放于应用lib底下</p>
<p>测试代码
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>ActiveXComponent    word = null;  </li>
<li>try {  </li>
<li>word = new ActiveXComponent(&quot;Word.Application&quot;);  </li>
<li>System.out.println(&quot;jacob当前版本：&quot;+word.getBuildVersion());  </li>
<li>}catch(Exception e ){  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
</ol>
<p>ActiveXComponent    word = null;</p>
<p>try {
        word = new ActiveXComponent(&quot;Word.Application&quot;);</p>
<pre><code>    System.out.println(&quot;jacob当前版本：&quot;+word.getBuildVersion());
</code></pre><p>}catch(Exception e ){</p>
<pre><code>     e.printStackTrace();
</code></pre><p>}</p>
<p>下面再贴出网上常见的代码+自己整理的几个方法（模糊查询书签等）</p>
<p>注意插入书签+书签值的方法，要先插入书签值再选中书签值，之后插入书签。这样根据书签名才能取得书签值。否则根据网络上很多方法，都取不到书签值或者取到空。因为书签值可以是一个点也可以是一大段内容。
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>import java.io.File;  </li>
<li>import java.util.HashMap;  </li>
<li>import java.util.Map;  </li>
<li></li>
<li>import com.gdcn.bpaf.common.helper.StringHelper;  </li>
<li>import com.jacob.activeX.ActiveXComponent;  </li>
<li>import com.jacob.com.ComThread;  </li>
<li>import com.jacob.com.Dispatch;  </li>
<li>import com.jacob.com.Variant;  </li>
<li>//<em>/</em> </li>
<li>/<em>  /</em> </li>
<li>/* <p>Description: {jacob操作word类}    </p> </li>
<li>/* </li>
<li>/* <p>Copyright: Copyright (c) 2011</p> </li>
<li>/*  </li>
<li>/* <p>CreateDate: 2012-6-28</p> </li>
<li>/* </li>
<li>/* @author Beny </li>
<li>/* @version 1.0 </li>
<li>/*/  </li>
<li></li>
<li>public class JacobHelper {  </li>
<li>// word文档  </li>
<li>private Dispatch doc;  </li>
<li></li>
<li>// word运行程序对象  </li>
<li>private ActiveXComponent word;  </li>
<li></li>
<li>// 所有word文档集合  </li>
<li>private Dispatch documents;  </li>
<li></li>
<li>// 选定的范围或插入点  </li>
<li>private Dispatch selection;  </li>
<li></li>
<li>private boolean saveOnExit = true;  </li>
<li></li>
<li>public JacobHelper(boolean visible) throws Exception {  </li>
<li>ComThread.InitSTA();//线程启动  </li>
<li>if (word == null) {  </li>
<li>word = new ActiveXComponent(&quot;Word.Application&quot;);  </li>
<li>word.setProperty(&quot;Visible&quot;, new Variant(visible)); // 不可见打开word  </li>
<li>word.setProperty(&quot;AutomationSecurity&quot;, new Variant(3)); // 禁用宏  </li>
<li>}  </li>
<li>if (documents == null)  </li>
<li>documents = word.getProperty(&quot;Documents&quot;).toDispatch();  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 设置退出时参数 </li>
<li>/*  </li>
<li>/* @param saveOnExit </li>
<li>/*            boolean true-退出时保存文件，false-退出时不保存文件 </li>
<li>/*/  </li>
<li>public void setSaveOnExit(boolean saveOnExit) {  </li>
<li>this.saveOnExit = saveOnExit;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 创建一个新的word文档 </li>
<li>/*  </li>
<li>/*/  </li>
<li>public void createNewDocument() {  </li>
<li>doc = Dispatch.call(documents, &quot;Add&quot;).toDispatch();  </li>
<li>selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 打开一个已存在的文档 </li>
<li>/*  </li>
<li>/* @param docPath </li>
<li>/*/  </li>
<li>public void openDocument(String docPath) {  </li>
<li>//      closeDocument();  </li>
<li>doc = Dispatch.call(documents, &quot;Open&quot;, docPath).toDispatch();  </li>
<li>selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 只读方式打开一个加密的文档 </li>
<li>/*  </li>
<li>/* @param docPath-文件全名 </li>
<li>/* @param pwd-密码 </li>
<li>/*/  </li>
<li>public void openDocumentOnlyRead(String docPath, String pwd)  </li>
<li>throws Exception {  </li>
<li>//      closeDocument();  </li>
<li>doc = Dispatch.callN(  </li>
<li>documents,  </li>
<li>&quot;Open&quot;,  </li>
<li>new Object[] { docPath, new Variant(false), new Variant(true),  </li>
<li>new Variant(true), pwd, &quot;&quot;, new Variant(false) })  </li>
<li>.toDispatch();  </li>
<li>selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();  </li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 打开一个加密的文档 </li>
<li>/* @param docPath </li>
<li>/* @param pwd </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public void openDocument(String docPath, String pwd) throws Exception {  </li>
<li>//      closeDocument();  </li>
<li>doc = Dispatch.callN(  </li>
<li>documents,  </li>
<li>&quot;Open&quot;,  </li>
<li>new Object[] { docPath, new Variant(false), new Variant(false),  </li>
<li>new Variant(true), pwd }).toDispatch();  </li>
<li>selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 从选定内容或插入点开始查找文本 </li>
<li>/*  </li>
<li>/* @param toFindText </li>
<li>/*            要查找的文本 </li>
<li>/* @return boolean true-查找到并选中该文本，false-未查找到文本 </li>
<li>/*/  </li>
<li>@SuppressWarnings(&quot;static-access&quot;)  </li>
<li>public boolean find(String toFindText) {  </li>
<li>if (toFindText == null || toFindText.equals(&quot;&quot;))  </li>
<li>return false;  </li>
<li>// 从selection所在位置开始查询  </li>
<li>Dispatch find = word.call(selection, &quot;Find&quot;).toDispatch();  </li>
<li>// 设置要查找的内容  </li>
<li>Dispatch.put(find, &quot;Text&quot;, toFindText);  </li>
<li>// 向前查找  </li>
<li>Dispatch.put(find, &quot;Forward&quot;, &quot;True&quot;);  </li>
<li>// 设置格式  </li>
<li>Dispatch.put(find, &quot;Format&quot;, &quot;True&quot;);  </li>
<li>// 大小写匹配  </li>
<li>Dispatch.put(find, &quot;MatchCase&quot;, &quot;True&quot;);  </li>
<li>// 全字匹配  </li>
<li>Dispatch.put(find, &quot;MatchWholeWord&quot;, &quot;false&quot;);  </li>
<li>// 查找并选中  </li>
<li>return Dispatch.call(find, &quot;Execute&quot;).getBoolean();  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 把选定选定内容设定为替换文本 </li>
<li>/*  </li>
<li>/* @param toFindText </li>
<li>/*            查找字符串 </li>
<li>/* @param newText </li>
<li>/*            要替换的内容 </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public boolean replaceText(String toFindText, String newText) {  </li>
<li>if (!find(toFindText))  </li>
<li>return false;  </li>
<li>Dispatch.put(selection, &quot;Text&quot;, newText);  </li>
<li>return true;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 全局替换文本 </li>
<li>/*  </li>
<li>/* @param toFindText </li>
<li>/*            查找字符串 </li>
<li>/* @param newText </li>
<li>/*            要替换的内容 </li>
<li>/*/  </li>
<li>public void replaceAllText(String toFindText, String newText) {  </li>
<li>while (find(toFindText)) {  </li>
<li>Dispatch.put(selection, &quot;Text&quot;, newText);  </li>
<li>Dispatch.call(selection, &quot;MoveRight&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 在当前插入点插入字符串 </li>
<li>/*  </li>
<li>/* @param newText </li>
<li>/*            要插入的新字符串 </li>
<li>/*/  </li>
<li>public void insertText(String newText) {  </li>
<li>Dispatch.put(selection, &quot;Text&quot;, newText);  </li>
<li>}  </li>
<li></li>
<li></li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 设置当前选定内容的字体 </li>
<li>/*  </li>
<li>/* @param boldSize </li>
<li>/* @param italicSize </li>
<li>/* @param underLineSize </li>
<li>/*            下划线 </li>
<li>/* @param colorSize </li>
<li>/*            字体颜色 </li>
<li>/* @param size </li>
<li>/*            字体大小 </li>
<li>/* @param name </li>
<li>/*            字体名称 </li>
<li>/* @param hidden </li>
<li>/*            是否隐藏 </li>
<li>/*/  </li>
<li>public void setFont(boolean bold, boolean italic, boolean underLine,  </li>
<li>String colorSize, String size, String name,boolean hidden) {  </li>
<li>Dispatch font = Dispatch.get(selection, &quot;Font&quot;).toDispatch();  </li>
<li>Dispatch.put(font, &quot;Name&quot;, new Variant(name));  </li>
<li>Dispatch.put(font, &quot;Bold&quot;, new Variant(bold));  </li>
<li>Dispatch.put(font, &quot;Italic&quot;, new Variant(italic));  </li>
<li>Dispatch.put(font, &quot;Underline&quot;, new Variant(underLine));  </li>
<li>Dispatch.put(font, &quot;Color&quot;, colorSize);  </li>
<li>Dispatch.put(font, &quot;Size&quot;, size);  </li>
<li>Dispatch.put(font, &quot;Hidden&quot;, hidden);  </li>
<li>}  </li>
<li></li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 文件保存或另存为 </li>
<li>/*  </li>
<li>/* @param savePath </li>
<li>/*            保存或另存为路径 </li>
<li>/*/  </li>
<li>public void save(String savePath) {  </li>
<li>Dispatch.call(Dispatch.call(word, &quot;WordBasic&quot;).getDispatch(),  </li>
<li>&quot;FileSaveAs&quot;, savePath);  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 文件保存为html格式 </li>
<li>/*  </li>
<li>/* @param savePath </li>
<li>/* @param htmlPath </li>
<li>/*/  </li>
<li>public void saveAsHtml(String htmlPath) {  </li>
<li>Dispatch.invoke(doc, &quot;SaveAs&quot;, Dispatch.Method, new Object[] {  </li>
<li>htmlPath, new Variant(8) }, new int[1]);  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 关闭文档 </li>
<li>/*  </li>
<li>/* @param val </li>
<li>/*            0不保存修改 -1 保存修改 -2 提示是否保存修改 </li>
<li>/*/  </li>
<li>public void closeDocument(int val) {  </li>
<li>Dispatch.call(doc, &quot;Close&quot;, new Variant(val));//注 是documents而不是doc  </li>
<li>documents = null;  </li>
<li>doc = null;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 关闭当前word文档 </li>
<li>/*  </li>
<li>/*/  </li>
<li>public void closeDocument() {  </li>
<li>if (documents != null) {  </li>
<li>Dispatch.call(documents, &quot;Save&quot;);  </li>
<li>Dispatch.call(documents, &quot;Close&quot;, new Variant(saveOnExit));  </li>
<li>documents = null;  </li>
<li>doc = null;  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>public void closeDocumentWithoutSave() {  </li>
<li>if (documents != null) {  </li>
<li>Dispatch.call(documents, &quot;Close&quot;, new Variant(false));  </li>
<li>documents = null;  </li>
<li>doc = null;  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 保存并关闭全部应用 </li>
<li>/*  </li>
<li>/*/  </li>
<li>public void close() {  </li>
<li>closeDocument(-1);  </li>
<li>if (word != null) {  </li>
<li>//          Dispatch.call(word, &quot;Quit&quot;);  </li>
<li>word.invoke(&quot;Quit&quot;, new Variant[] {});  </li>
<li>word = null;  </li>
<li>}  </li>
<li>selection = null;  </li>
<li>documents = null;  </li>
<li>ComThread.Release();//释放com线程。根据jacob的帮助文档，com的线程回收不由java的垃圾回收器处理  </li>
<li></li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 打印当前word文档 </li>
<li>/*  </li>
<li>/*/  </li>
<li>public void printFile() {  </li>
<li>if (doc != null) {  </li>
<li>Dispatch.call(doc, &quot;PrintOut&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 保护当前档,如果不存在, 使用expression.Protect(Type, NoReset, Password) </li>
<li>/*  </li>
<li>/* @param pwd </li>
<li>/* @param type </li>
<li>/*            WdProtectionType 常量之一(int 类型，只读)： </li>
<li>/*            1-wdAllowOnlyComments  仅批注 </li>
<li>/*            2-wdAllowOnlyFormFields 仅填写窗体 </li>
<li>/*            0-wdAllowOnlyRevisions 仅修订 </li>
<li>/*            -1-wdNoProtection 无保护,  </li>
<li>/*            3-wdAllowOnlyReading 只读 </li>
<li>/*  </li>
<li>/*/  </li>
<li>public void protectedWord(String pwd,String type) {  </li>
<li>String protectionType = Dispatch.get(doc, &quot;ProtectionType&quot;).toString();  </li>
<li>if (protectionType.equals(&quot;-1&quot;)) {  </li>
<li>Dispatch.call(doc, &quot;Protect&quot;, Integer.parseInt(type), new Variant(true),pwd);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 解除文档保护,如果存在 </li>
<li>/*  </li>
<li>/* @param pwd </li>
<li>/*            WdProtectionType 常量之一(int 类型，只读)： </li>
<li>/*            1-wdAllowOnlyComments  仅批注 </li>
<li>/*            2-wdAllowOnlyFormFields 仅填写窗体 </li>
<li>/*            0-wdAllowOnlyRevisions 仅修订 </li>
<li>/*            -1-wdNoProtection 无保护,  </li>
<li>/*            3-wdAllowOnlyReading 只读 </li>
<li>/*  </li>
<li>/*/  </li>
<li>public void unProtectedWord(String pwd) {  </li>
<li>String protectionType = Dispatch.get(doc, &quot;ProtectionType&quot;).toString();  </li>
<li>if (!protectionType.equals(&quot;0&quot;)&amp;&amp;!protectionType.equals(&quot;-1&quot;)) {  </li>
<li>Dispatch.call(doc, &quot;Unprotect&quot;, pwd);  </li>
<li>}  </li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 返回文档的保护类型 </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public String getProtectedType(){  </li>
<li>return Dispatch.get(doc, &quot;ProtectionType&quot;).toString();  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 设置word文档安全级别 </li>
<li>/*  </li>
<li>/* @param value </li>
<li>/*            1-msoAutomationSecurityByUI 使用“安全”对话框指定的安全设置。 </li>
<li>/*            2-msoAutomationSecurityForceDisable </li>
<li>/*            在程序打开的所有文件中禁用所有宏，而不显示任何安全提醒。 3-msoAutomationSecurityLow </li>
<li>/*            启用所有宏，这是启动应用程序时的默认值。 </li>
<li>/*/  </li>
<li>public void setAutomationSecurity(int value) {  </li>
<li>word.setProperty(&quot;AutomationSecurity&quot;, new Variant(value));  </li>
<li>}  </li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 在word中插入标签 labelName是标签名，labelValue是标签值 </li>
<li>/* @param labelName </li>
<li>/* @param labelValue </li>
<li>/*/  </li>
<li>public  void insertLabelValue(String labelName,String labelValue) {  </li>
<li></li>
<li>Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();  </li>
<li>boolean isExist = Dispatch.call(bookMarks, &quot;Exists&quot;, labelName).getBoolean();  </li>
<li>if (isExist == true) {  </li>
<li>Dispatch rangeItem1 = Dispatch.call(bookMarks, &quot;Item&quot;, labelName).toDispatch();  </li>
<li>Dispatch range1 = Dispatch.call(rangeItem1, &quot;Range&quot;).toDispatch();  </li>
<li>String bookMark1Value = Dispatch.get(range1, &quot;Text&quot;).toString();  </li>
<li>System.out.println(&quot;书签内容：&quot;+bookMark1Value);  </li>
<li>} else {  </li>
<li>System.out.println(&quot;当前书签不存在,重新建立!&quot;);  </li>
<li>//TODO 先插入文字，再查找选中文字，再插入标签  </li>
<li>this.insertText(labelValue);  </li>
<li>//          this.find(labelValue);//查找文字，并选中  </li>
<li>this.setFont(true, true,true,&quot;102,92,38&quot;, &quot;20&quot;, &quot;&quot;,true);  </li>
<li>Dispatch.call(bookMarks, &quot;Add&quot;, labelName, selection);  </li>
<li>Dispatch.call(bookMarks, &quot;Hidden&quot;, labelName);  </li>
<li>}  </li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 在word中插入标签 labelName是标签名 </li>
<li>/* @param labelName </li>
<li>/*/  </li>
<li>public  void insertLabel(String labelName) {  </li>
<li></li>
<li>Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();  </li>
<li>boolean isExist = Dispatch.call(bookMarks, &quot;Exists&quot;, labelName).getBoolean();  </li>
<li>if (isExist == true) {  </li>
<li>System.out.println(&quot;书签已存在&quot;);  </li>
<li>} else {  </li>
<li>System.out.println(&quot;建立书签：&quot;+labelName);  </li>
<li>Dispatch.call(bookMarks, &quot;Add&quot;, labelName, selection);  </li>
<li>}  </li>
<li>}     </li>
<li>//<em>/</em> </li>
<li>/* 查找书签 </li>
<li>/* @param labelName </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public boolean findLabel(String labelName) {  </li>
<li>Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();  </li>
<li>boolean isExist = Dispatch.call(bookMarks, &quot;Exists&quot;, labelName).getBoolean();  </li>
<li>if (isExist == true) {  </li>
<li>return true;  </li>
<li>} else {  </li>
<li>System.out.println(&quot;当前书签不存在!&quot;);  </li>
<li>return false;  </li>
<li>}  </li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 模糊查找书签,并返回准确的书签名称 </li>
<li>/* @param labelName </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public String findLabelLike(String labelName) {  </li>
<li>Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();  </li>
<li>int count = Dispatch.get(bookMarks, &quot;Count&quot;).getInt(); // 书签数  </li>
<li>Dispatch rangeItem = null;  </li>
<li>String lname = &quot;&quot;;  </li>
<li>for(int i=1;i&lt;=count;i++){  </li>
<li>rangeItem = Dispatch.call(bookMarks, &quot;Item&quot;, new Variant(i)).toDispatch();  </li>
<li>lname = Dispatch.call(rangeItem, &quot;Name&quot;).toString();//书签名称  </li>
<li>if(lname.startsWith(labelName)){//前面匹配  </li>
<li>//             return lname.replaceFirst(labelName, &quot;&quot;);//返回后面值  </li>
<li>return lname;  </li>
<li>}  </li>
<li>}  </li>
<li>return &quot;&quot;;  </li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 模糊删除书签 </li>
<li>/* @param labelName </li>
<li>/*/  </li>
<li>public void deleteLableLike(String labelName){  </li>
<li>Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();  </li>
<li>int count = Dispatch.get(bookMarks, &quot;Count&quot;).getInt(); // 书签数  </li>
<li>Dispatch rangeItem = null;  </li>
<li>String lname = &quot;&quot;;  </li>
<li>for(int i=1;i&lt;=count;i++){  </li>
<li>rangeItem = Dispatch.call(bookMarks, &quot;Item&quot;, new Variant(i)).toDispatch();  </li>
<li>lname = Dispatch.call(rangeItem, &quot;Name&quot;).toString();//书签名称  </li>
<li>if(lname.startsWith(labelName)){//前面匹配  </li>
<li>Dispatch.call(rangeItem, &quot;Delete&quot;);  </li>
<li>count--;//书签已被删除，书签数目和当前书签都要相应减1，否则会报错:集合找不到  </li>
<li>i--;  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 获取书签内容 </li>
<li>/* @param labelName </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public String getLableValue(String labelName){  </li>
<li>if(this.findLabel(labelName)){  </li>
<li>Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();  </li>
<li>Dispatch rangeItem1 = Dispatch.call(bookMarks, &quot;Item&quot;, labelName).toDispatch();  </li>
<li>Dispatch range1 = Dispatch.call(rangeItem1, &quot;Range&quot;).toDispatch();  </li>
<li>Dispatch font = Dispatch.get(range1, &quot;Font&quot;).toDispatch();  </li>
<li>Dispatch.put(font, &quot;Hidden&quot;, new Variant(false)); //显示书签内容  </li>
<li>String bookMark1Value = Dispatch.get(range1, &quot;Text&quot;).toString();  </li>
<li>System.out.println(&quot;书签内容：&quot;+bookMark1Value);  </li>
<li>//            font = Dispatch.get(range1, &quot;Font&quot;).toDispatch();  </li>
<li>//              Dispatch.put(font, &quot;Hidden&quot;, new Variant(true)); //隐藏书签内容  </li>
<li>return bookMark1Value;  </li>
<li>}  </li>
<li>return &quot;&quot;;  </li>
<li>}  </li>
<li></li>
<li></li>
<li>public static void main(String[] args) throws Exception {  </li>
<li></li>
<li>}     </li>
<li></li>
<li>}  </li>
</ol>
<p>import java.io.File;</p>
<p>import java.util.HashMap;
import java.util.Map;</p>
<p>import com.gdcn.bpaf.common.helper.StringHelper;</p>
<p>import com.jacob.activeX.ActiveXComponent;
import com.jacob.com.ComThread;</p>
<p>import com.jacob.com.Dispatch;
import com.jacob.com.Variant;</p>
<p>//<em>/</em>
 /<em>  /</em></p>
<p> /<em> <p>Description: {jacob操作word类}    </p>
/</em></p>
<p>/<em> <p>Copyright: Copyright (c) 2011</p>
/</em></p>
<p>/<em> <p>CreateDate: 2012-6-28</p>
/</em></p>
<p>/<em> @author Beny
/</em> @version 1.0</p>
<p>/*/</p>
<p>public class JacobHelper {
    // word文档</p>
<pre><code>private Dispatch doc;


// word运行程序对象
private ActiveXComponent word;


// 所有word文档集合

private Dispatch documents;


// 选定的范围或插入点
private Dispatch selection;


private boolean saveOnExit = true;


public JacobHelper(boolean visible) throws Exception {

    ComThread.InitSTA();//线程启动
    if (word == null) {

        word = new ActiveXComponent(&quot;Word.Application&quot;);
        word.setProperty(&quot;Visible&quot;, new Variant(visible)); // 不可见打开word

        word.setProperty(&quot;AutomationSecurity&quot;, new Variant(3)); // 禁用宏
    }

    if (documents == null)
        documents = word.getProperty(&quot;Documents&quot;).toDispatch();

}


//*/*
 /* 设置退出时参数

 /*
 /* @param saveOnExit

 /*            boolean true-退出时保存文件，false-退出时不保存文件
 /*/

public void setSaveOnExit(boolean saveOnExit) {
    this.saveOnExit = saveOnExit;

}


//*/*
 /* 创建一个新的word文档

 /*
 /*/

public void createNewDocument() {
    doc = Dispatch.call(documents, &quot;Add&quot;).toDispatch();

    selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();
}


//*/*

 /* 打开一个已存在的文档
 /*

 /* @param docPath
 /*/

public void openDocument(String docPath) {
</code></pre><p>//        closeDocument();</p>
<pre><code>    doc = Dispatch.call(documents, &quot;Open&quot;, docPath).toDispatch();
    selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();

}


//*/*
 /* 只读方式打开一个加密的文档

 /*
 /* @param docPath-文件全名

 /* @param pwd-密码
 /*/

public void openDocumentOnlyRead(String docPath, String pwd)
        throws Exception {
</code></pre><p>//        closeDocument();
        doc = Dispatch.callN(</p>
<pre><code>            documents,
            &quot;Open&quot;,

            new Object[] { docPath, new Variant(false), new Variant(true),
                    new Variant(true), pwd, &quot;&quot;, new Variant(false) })

            .toDispatch();
    selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();

}
//*/*

 /* 打开一个加密的文档
 /* @param docPath

 /* @param pwd
 /* @throws Exception

 /*/
public void openDocument(String docPath, String pwd) throws Exception {
</code></pre><p>//        closeDocument();
        doc = Dispatch.callN(</p>
<pre><code>            documents,
            &quot;Open&quot;,

            new Object[] { docPath, new Variant(false), new Variant(false),
                    new Variant(true), pwd }).toDispatch();

    selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();
}


//*/*

 /* 从选定内容或插入点开始查找文本
 /*

 /* @param toFindText
 /*            要查找的文本

 /* @return boolean true-查找到并选中该文本，false-未查找到文本
 /*/

@SuppressWarnings(&quot;static-access&quot;)
public boolean find(String toFindText) {

    if (toFindText == null || toFindText.equals(&quot;&quot;))
        return false;

    // 从selection所在位置开始查询
    Dispatch find = word.call(selection, &quot;Find&quot;).toDispatch();

    // 设置要查找的内容
    Dispatch.put(find, &quot;Text&quot;, toFindText);

    // 向前查找
    Dispatch.put(find, &quot;Forward&quot;, &quot;True&quot;);

    // 设置格式
    Dispatch.put(find, &quot;Format&quot;, &quot;True&quot;);

    // 大小写匹配
    Dispatch.put(find, &quot;MatchCase&quot;, &quot;True&quot;);

    // 全字匹配
    Dispatch.put(find, &quot;MatchWholeWord&quot;, &quot;false&quot;);

    // 查找并选中
    return Dispatch.call(find, &quot;Execute&quot;).getBoolean();

}


//*/*
 /* 把选定选定内容设定为替换文本

 /*
 /* @param toFindText

 /*            查找字符串
 /* @param newText

 /*            要替换的内容
 /* @return

 /*/
public boolean replaceText(String toFindText, String newText) {

    if (!find(toFindText))
        return false;

    Dispatch.put(selection, &quot;Text&quot;, newText);
    return true;

}


//*/*
 /* 全局替换文本

 /*
 /* @param toFindText

 /*            查找字符串
 /* @param newText

 /*            要替换的内容
 /*/

public void replaceAllText(String toFindText, String newText) {
    while (find(toFindText)) {

        Dispatch.put(selection, &quot;Text&quot;, newText);
        Dispatch.call(selection, &quot;MoveRight&quot;);

    }
}


//*/*

 /* 在当前插入点插入字符串
 /*

 /* @param newText
 /*            要插入的新字符串

 /*/
public void insertText(String newText) {

    Dispatch.put(selection, &quot;Text&quot;, newText);
}





//*/*

 /* 设置当前选定内容的字体
 /*

 /* @param boldSize
 /* @param italicSize

 /* @param underLineSize
 /*            下划线

 /* @param colorSize
 /*            字体颜色

 /* @param size
 /*            字体大小

 /* @param name
 /*            字体名称

 /* @param hidden
 /*            是否隐藏

 /*/
public void setFont(boolean bold, boolean italic, boolean underLine,

        String colorSize, String size, String name,boolean hidden) {
    Dispatch font = Dispatch.get(selection, &quot;Font&quot;).toDispatch();

    Dispatch.put(font, &quot;Name&quot;, new Variant(name));
    Dispatch.put(font, &quot;Bold&quot;, new Variant(bold));

    Dispatch.put(font, &quot;Italic&quot;, new Variant(italic));
    Dispatch.put(font, &quot;Underline&quot;, new Variant(underLine));

    Dispatch.put(font, &quot;Color&quot;, colorSize);
    Dispatch.put(font, &quot;Size&quot;, size);

    Dispatch.put(font, &quot;Hidden&quot;, hidden);
}




//*/*
 /* 文件保存或另存为

 /*
 /* @param savePath

 /*            保存或另存为路径
 /*/

public void save(String savePath) {
    Dispatch.call(Dispatch.call(word, &quot;WordBasic&quot;).getDispatch(),

            &quot;FileSaveAs&quot;, savePath);
}


//*/*

 /* 文件保存为html格式
 /*

 /* @param savePath
 /* @param htmlPath

 /*/
public void saveAsHtml(String htmlPath) {

    Dispatch.invoke(doc, &quot;SaveAs&quot;, Dispatch.Method, new Object[] {
            htmlPath, new Variant(8) }, new int[1]);

}


//*/*
 /* 关闭文档

 /*
 /* @param val

 /*            0不保存修改 -1 保存修改 -2 提示是否保存修改
 /*/

public void closeDocument(int val) {
    Dispatch.call(doc, &quot;Close&quot;, new Variant(val));//注 是documents而不是doc

    documents = null;
    doc = null;

}


//*/*
 /* 关闭当前word文档

 /*
 /*/

public void closeDocument() {
    if (documents != null) {

        Dispatch.call(documents, &quot;Save&quot;);
        Dispatch.call(documents, &quot;Close&quot;, new Variant(saveOnExit));

        documents = null;
        doc = null;

    }
}


public void closeDocumentWithoutSave() {

    if (documents != null) {
        Dispatch.call(documents, &quot;Close&quot;, new Variant(false));

        documents = null;
        doc = null;

    }
}


//*/*

 /* 保存并关闭全部应用
 /*

 /*/
public void close() {

    closeDocument(-1);
    if (word != null) {
</code></pre><p>//            Dispatch.call(word, &quot;Quit&quot;);
            word.invoke(&quot;Quit&quot;, new Variant[] {});</p>
<pre><code>        word = null;
    }

    selection = null;
    documents = null;

    ComThread.Release();//释放com线程。根据jacob的帮助文档，com的线程回收不由java的垃圾回收器处理


}
//*/*

 /* 打印当前word文档
 /*

 /*/
public void printFile() {

    if (doc != null) {
        Dispatch.call(doc, &quot;PrintOut&quot;);

    }
}


//*/*

 /* 保护当前档,如果不存在, 使用expression.Protect(Type, NoReset, Password)
 /*

 /* @param pwd
 /* @param type

 /*            WdProtectionType 常量之一(int 类型，只读)：
 /*            1-wdAllowOnlyComments  仅批注

 /*            2-wdAllowOnlyFormFields 仅填写窗体
 /*            0-wdAllowOnlyRevisions 仅修订

 /*            -1-wdNoProtection 无保护,
 /*            3-wdAllowOnlyReading 只读

 /*
 /*/

public void protectedWord(String pwd,String type) {
    String protectionType = Dispatch.get(doc, &quot;ProtectionType&quot;).toString();

    if (protectionType.equals(&quot;-1&quot;)) {
        Dispatch.call(doc, &quot;Protect&quot;, Integer.parseInt(type), new Variant(true),pwd);

    }
}


//*/*

 /* 解除文档保护,如果存在
 /*

 /* @param pwd
 /*            WdProtectionType 常量之一(int 类型，只读)：

 /*            1-wdAllowOnlyComments  仅批注
 /*            2-wdAllowOnlyFormFields 仅填写窗体

 /*            0-wdAllowOnlyRevisions 仅修订
 /*            -1-wdNoProtection 无保护,

 /*            3-wdAllowOnlyReading 只读
 /*

 /*/
public void unProtectedWord(String pwd) {

    String protectionType = Dispatch.get(doc, &quot;ProtectionType&quot;).toString();
    if (!protectionType.equals(&quot;0&quot;)&amp;&amp;!protectionType.equals(&quot;-1&quot;)) {

        Dispatch.call(doc, &quot;Unprotect&quot;, pwd);
    }

}
//*/*

 /* 返回文档的保护类型
 /* @return

 /*/
public String getProtectedType(){

    return Dispatch.get(doc, &quot;ProtectionType&quot;).toString();
}


//*/*

 /* 设置word文档安全级别
 /*

 /* @param value
 /*            1-msoAutomationSecurityByUI 使用“安全”对话框指定的安全设置。

 /*            2-msoAutomationSecurityForceDisable
 /*            在程序打开的所有文件中禁用所有宏，而不显示任何安全提醒。 3-msoAutomationSecurityLow

 /*            启用所有宏，这是启动应用程序时的默认值。
 /*/

public void setAutomationSecurity(int value) {
    word.setProperty(&quot;AutomationSecurity&quot;, new Variant(value));

}






//*/*

 /* 在word中插入标签 labelName是标签名，labelValue是标签值
 /* @param labelName

 /* @param labelValue
 /*/

public  void insertLabelValue(String labelName,String labelValue) {


   Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();
   boolean isExist = Dispatch.call(bookMarks, &quot;Exists&quot;, labelName).getBoolean();

    if (isExist == true) {
        Dispatch rangeItem1 = Dispatch.call(bookMarks, &quot;Item&quot;, labelName).toDispatch();

        Dispatch range1 = Dispatch.call(rangeItem1, &quot;Range&quot;).toDispatch();
        String bookMark1Value = Dispatch.get(range1, &quot;Text&quot;).toString();

          System.out.println(&quot;书签内容：&quot;+bookMark1Value);
    } else {

        System.out.println(&quot;当前书签不存在,重新建立!&quot;);
        //TODO 先插入文字，再查找选中文字，再插入标签

        this.insertText(labelValue);
</code></pre><p>//            this.find(labelValue);//查找文字，并选中</p>
<pre><code>        this.setFont(true, true,true,&quot;102,92,38&quot;, &quot;20&quot;, &quot;&quot;,true);
         Dispatch.call(bookMarks, &quot;Add&quot;, labelName, selection);

         Dispatch.call(bookMarks, &quot;Hidden&quot;, labelName);
    }

}
//*/*

 /* 在word中插入标签 labelName是标签名
 /* @param labelName

 /*/
public  void insertLabel(String labelName) {


   Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();

   boolean isExist = Dispatch.call(bookMarks, &quot;Exists&quot;, labelName).getBoolean();
    if (isExist == true) {

          System.out.println(&quot;书签已存在&quot;);
    } else {

        System.out.println(&quot;建立书签：&quot;+labelName);
         Dispatch.call(bookMarks, &quot;Add&quot;, labelName, selection);

    }
}   

//*/*
 /* 查找书签

 /* @param labelName
 /* @return

 /*/
public boolean findLabel(String labelName) {

   Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();
   boolean isExist = Dispatch.call(bookMarks, &quot;Exists&quot;, labelName).getBoolean();

   if (isExist == true) {
          return true;

    } else {
        System.out.println(&quot;当前书签不存在!&quot;);

        return false;
    }

}
//*/*

 /* 模糊查找书签,并返回准确的书签名称
 /* @param labelName

 /* @return
 /*/

public String findLabelLike(String labelName) {
   Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();

   int count = Dispatch.get(bookMarks, &quot;Count&quot;).getInt(); // 书签数
   Dispatch rangeItem = null;

   String lname = &quot;&quot;;
   for(int i=1;i&lt;=count;i++){

       rangeItem = Dispatch.call(bookMarks, &quot;Item&quot;, new Variant(i)).toDispatch();
       lname = Dispatch.call(rangeItem, &quot;Name&quot;).toString();//书签名称

       if(lname.startsWith(labelName)){//前面匹配
</code></pre><p>//               return lname.replaceFirst(labelName, &quot;&quot;);//返回后面值</p>
<pre><code>           return lname;
       }

   }
   return &quot;&quot;;

}
//*/*

 /* 模糊删除书签
 /* @param labelName

 /*/
public void deleteLableLike(String labelName){

    Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();
   int count = Dispatch.get(bookMarks, &quot;Count&quot;).getInt(); // 书签数

   Dispatch rangeItem = null;
   String lname = &quot;&quot;;

   for(int i=1;i&lt;=count;i++){
       rangeItem = Dispatch.call(bookMarks, &quot;Item&quot;, new Variant(i)).toDispatch();

       lname = Dispatch.call(rangeItem, &quot;Name&quot;).toString();//书签名称
       if(lname.startsWith(labelName)){//前面匹配

           Dispatch.call(rangeItem, &quot;Delete&quot;);
           count--;//书签已被删除，书签数目和当前书签都要相应减1，否则会报错:集合找不到

           i--;
       }

   }
}

//*/*
 /* 获取书签内容

 /* @param labelName
 /* @return

 /*/
public String getLableValue(String labelName){

    if(this.findLabel(labelName)){
        Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();

        Dispatch rangeItem1 = Dispatch.call(bookMarks, &quot;Item&quot;, labelName).toDispatch();
        Dispatch range1 = Dispatch.call(rangeItem1, &quot;Range&quot;).toDispatch();

        Dispatch font = Dispatch.get(range1, &quot;Font&quot;).toDispatch();
        Dispatch.put(font, &quot;Hidden&quot;, new Variant(false)); //显示书签内容

        String bookMark1Value = Dispatch.get(range1, &quot;Text&quot;).toString();
          System.out.println(&quot;书签内容：&quot;+bookMark1Value);
</code></pre><p>//            font = Dispatch.get(range1, &quot;Font&quot;).toDispatch();
//              Dispatch.put(font, &quot;Hidden&quot;, new Variant(true)); //隐藏书签内容</p>
<pre><code>          return bookMark1Value;
    }

    return &quot;&quot;;
}




public static void main(String[] args) throws Exception {


}   
</code></pre><p>}</p>
<p> 采用jacob方式操作文档，经常会出现卡机的现象，所以最后采用poi方式来操作书签。若单纯的操作书签用poi方式还是比较简单的，但要操作表格、文档格式之类的还是用jacob功能比较强大。
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>InputStream input = null;  </li>
<li>File docFile = new File( fileName );  </li>
<li>HWPFDocument document = null;  </li>
<li>try{  </li>
<li>input = new FileInputStream(docFile);//加载 doc 文档  </li>
<li>document = new HWPFDocument(input);//文件流方式创建hwpf  </li>
<li>Bookmarks bookmarks =  document.getBookmarks();//文档书签  </li>
<li>for(int i=0,length=bookmarks.getBookmarksCount();i&lt;length;i++){  </li>
<li>bookmarkName = bookmarks.getBookmark(i).getName();  </li>
<li>//.....  </li>
<li>}  </li>
<li></li>
<li>}catch( Exception e){  </li>
<li></li>
<li>}finally{  </li>
<li>if( null != input )  </li>
<li>input.close();  </li>
<li>}  </li>
</ol>
<p>InputStream input = null;</p>
<p>File docFile = new File( fileName );
HWPFDocument document = null;</p>
<p>try{
    input = new FileInputStream(docFile);//加载 doc 文档</p>
<pre><code>document = new HWPFDocument(input);//文件流方式创建hwpf
Bookmarks bookmarks =  document.getBookmarks();//文档书签

for(int i=0,length=bookmarks.getBookmarksCount();i&lt;length;i++){
    bookmarkName = bookmarks.getBookmark(i).getName();

    //.....
}
</code></pre><p>}catch( Exception e){</p>
<p>}finally{</p>
<pre><code>if( null != input )
        input.close();
</code></pre><p>}</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/java-com/">java-com</a></li><li><a href="/categories/Java&J2EE/java-com/jacob/">jacob</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/jacob/" class="label label-success">jacob</a><a href="/tags/java-com/" class="label label-info">java-com</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java-com-jacob--java操作word文档jacob-poi/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-java-com-jacob--java操作word文档jacob-poi" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/57/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/55/">55</a></li><li><a class="page-number" href="/page/56/">56</a></li><li><a class="page-number" href="/page/57/">57</a></li><li class="active"><li><span class="page-number current">58</span></li><li><a class="page-number" href="/page/59/">59</a></li><li><a class="page-number" href="/page/60/">60</a></li><li><a class="page-number" href="/page/61/">61</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/59/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 15:12:18</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
