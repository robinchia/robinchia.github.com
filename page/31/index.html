
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 31 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-Flex--如何避免层被其它对象挡住/">如何避免层被其它对象挡住</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:44.000Z"> <a href="/2014/02/02/2014-02-02-Flex--如何避免层被其它对象挡住/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">如何避免层被其它对象挡住</h1>
<p><a href="http://www.javaeye.com/" target="_blank">首页</a> <a href="http://www.javaeye.com/news" target="_blank">新闻</a> <a href="http://www.javaeye.com/forums" target="_blank">论坛</a> <a href="http://www.javaeye.com/ask" target="_blank">问答</a> <a href="http://www.javaeye.com/blogs" target="_blank">博客</a> <a href="http://www.javaeye.com/job" target="_blank">招聘</a> <a href="http://wangpingsx.javaeye.com/blog/468349#" target="_blank">更多 ▼</a></p>
<p><a href="http://www.javaeye.com/wiki" target="_blank">专栏</a> <a href="http://www.javaeye.com/groups" target="_blank">圈子</a> <a href="http://www.javaeye.com/search" target="_blank">搜索</a></p>
<p><a href="http://wangpingsx.javaeye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://www.javaeye.com/all" target="_blank">我的应用</a> <a href="http://wangpingsx.javaeye.com/login" target="_blank">登录</a> <a href="http://wangpingsx.javaeye.com/signup" target="_blank">注册</a></p>
<h1 id="-wangpingsx-http-wangpingsx-javaeye-com-"><a href="http://wangpingsx.javaeye.com/" target="_blank">wangpingsx</a></h1>
<p>永久域名 <a href="http://wangpingsx.javaeye.com/" target="_blank"><a href="http://wangpingsx.javaeye.com/">http://wangpingsx.javaeye.com/</a></a></p>
<p><a href="http://wangpingsx.javaeye.com/blog/480848" title="在Eclipse中查看android 源代码的方法！" target="_blank">在Eclipse中查看android 源代码的方法！</a> | <a href="http://wangpingsx.javaeye.com/blog/466800" title="写 treeItemrenderer 还是有点儿难度的" target="_blank">写 treeItemrenderer 还是有点儿难度的</a></p>
<p>2009-09-14</p>
<h3 id="-http-wangpingsx-javaeye-com-blog-468349-"><a href="http://wangpingsx.javaeye.com/blog/468349" target="_blank">如何避免层被其它对象挡住</a></h3>
<p>关键字: div被底层的东西挡住
来自于：</p>
<p><a href="http://www2.flash8.net/teach/3959.htm" target="_blank">http://www2.flash8.net/teach/3959.htm</a></p>
<p>我找了好多地方，只有这个文章的内容对我有帮助。</p>
<p>之前先列另一个文章出来：</p>
<ol>
<li>避免Flash挡住Div层的方式：增加 <param name="wmode" value="transparent">，另外增加<embed wmode="transparent" ...其他选项></li>
<li>select和flash挡住div，可以采取移除节点的方式防止挡住</li>
<li>select和flash采用display:none的方式防止挡住</li>
<li>在select和flash上面加一层隐藏的iframe对象，因为iframe对象跟select和flash界面显示平级，然后把目标div放在iframe上面</li>
<li>如果是按钮、提交、图片按钮，采用 button 标签来取代input标签，其他一致</li>
</ol>
<p>wmode=&quot;transparent&quot; 不管用，要用 wmode 为opaque  要用下边文章中写的样子。</p>
<p><img src="" alt=""> 如何避免层被其它对象挡住
<img src="" alt="">解决思路 ：
    根据挡隔对象的不同，解决办法也不同。
<img src="" alt="">具体步骤 ：
1.被Flash挡住。
设置Flash的wmode属性值 为opaque或transparent，代码示例：</p>
<p><object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab/#version=6,0,29,0" width="468" height="60"><param name="movie" value="http://pepsi.flash8.net/pepsi46860.swf"></p>
<p><param name="wmode" value="opaque"><param name="quality" value="high"><embed src="http://pepsi.flash8.net/pepsi46860.swf" quality="high" pluginspage="http://www.macromedia.com/go/getflashplayer" type="application/x-shockwave-flash" width="468" height="60" wmode="opaque"></embed></object></p>
<p><div style="position:absolute;left:150;top:50;width:100px;height:50px;background:green">
</div>
2.被图片挡住。
这个估计是因为图片也放在层中，而图片所在层的Z轴索引值比该层大，所以被挡住，解决办法是更改该层的Z轴索引值至比图片层大。
代码示例：</p>
<p><div style="position:absolute;left:0;top:20;z-index:2;background:red;width:120px;height:70px">
1<img src="http://www.flash8.net/images/logo.gif">
</div></p>
<p><div style="position:absolute;left:50;top:50;z-index:2;background:green;width:120px;height:70px">
2<img src="http://www.flash8.net/images/logo.gif">
</div></p>
<p><div style="position:absolute;left:90;top:80;z-index:2;background:blue;width:120px;height:70px">
3<img src="http://www.flash8.net/images/logo.gif">
</div>
3.被表单控件挡住
这个目前还没有完美的解决方法，一般都是在设计排版时就尽量避免这种情况，如果是万不得已，就在层经过表单控件时让表单控件隐藏，过后再让它显示：
代码示例：</p>
<p><button onClick="oSelect.style.display=’none’;oLayer.style.display=’inline’">显示层隐藏下拉选项
</button></p>
<p><button onClick="oSelect.style.display=’inline’;oLayer.style.display=’none’">显示下拉选项隐藏层</button></p>
<p><div style="position:absolute;left:0;top:50;z-index:2;background:red;width:120px;height:50px">
z-index:1<select id="oSelect"><option>1<option>1<option>1<option>1<option>1<option>1<option>1<option>1<option>1<option>1<option>1</select>
</div></p>
<p><div id="oLayer" style="position:absolute;left:30;top:60;z-index:2;background:green;width:120px;height:70px;display:none">
z-index:2<img src="http://www.flash8.net/images/logo.gif">
</div>
4.当然还有用优先级别较高的控件来代替层的方法解决，但控件并非是每台机器上都有安装，而且控件的可定制性也差，在兼容性上也存在问题。
(1)hhctrl.ocx控件：
 <OBJECT id=hhctrl type="application/x-oleobject" classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11" codebase="<I>file:</I>hhctrl.ocx/#Version=4,0,0,24" width=80 height=20>
 <PARAM name="Command" value="Related Topics, MENU">
 <PARAM name="Button" value="Menu">
 <PARAM name="Item1" value="[X-Eyes];http://x-lover.com/forums/">
 <PARAM name="Item2" value="闪客之吧;http://www.flash8.net">
 <PARAM name="Item3" value="零刻联盟;http://www.linkmeng.com/">
 <PARAM name="Item4" value="蓝色理想;http://www.blueidea.com/">
 <PARAM name="Item5" value="5D多媒体;http://www.5d.cn">
 </OBJECT>
 <select></select><iframe></iframe>
(2)X-Scriptlet控件
 <object style="position:absolute;top:150;left:20;width:100;height:50;border:1px
 solid /#000000" type="text/x-scriptlet" data="demo.gif"></object>
 <SELECT></SELECT><iframe></iframe>
 或
 <object style="position:absolute;top:150;left:20;width:100;height:50;border:1px solid /#000000" type="text/html" data="demo.gif"></object>
 <select></select><iframe></iframe>
(3) window.createPopup()
  <SCRIPT>
 var oPopup = window.createPopup();
 function showPopupWin(){
     var oPopBody = oPopup.document.body;
     oPopBody.style.backgroundColor = &quot;green&quot;;
     oPopup.show(50, 120, 180, 65,document.body);
 }
 </SCRIPT>
 <BUTTON onclick="showPopupWin()">显示窗口</BUTTON><select></select><iframe></iframe>
    注意：用createPopup方法打开的Popup窗口需要IE5.5以上浏览器的支持。
特别提示
本例所给代码的运行效果分别如图1.3.17~图1.3.22所示。
<img src="" alt="">
图 1.3.17 层与Flash的优先级别控制
<img src="" alt="">
图 1.3.18 层与层间的优先级别控制
<img src="" alt="">
图1.3.19层与表单控件的优先级别控制
<img src="" alt="">
图 1.3.20 HHCtrl控件与其它控件的优先级测试
<img src="" alt="">
图1.3.21X-Scriptlet控件与其它控件的优先级别测试
<img src="" alt="">
图1.3.22 Popup窗口与其它控件的优先级别测试</p>
<h3 id="-">特别说明</h3>
<p>本例问题的解决方式需要根据实际情况而定，一般来说用前三种方法就可以了，除非必要，否则尽量不要用后面的三种方法。</p>
<p>总结：</p>
<pre><code> 在网上可以找到一些代码，但有些代码只能在ie 下运行，到了firefox里就变了。
</code></pre><p>以下是一段例子，用z轴的方式来解决问题。但不适合我们的项目。</p>
<p>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;" target="_blank">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</a> <html xmlns="http://www.w3.org/1999/xhtml"> <head> <meta http-equiv="Content-Type" content="text/html; charset=gb2312" /> <title></title> <style type="text/css"> /*{margin:0; padding:0;} body {background:/#298DC8;color:/#333;font-size:12px;font-family:Arial, Helvetica, Verdana, sans-serif;line-height:150%;} /#t-iframe{ background:/#fff; position:relative; z-index:1;} .box{ position:relative; background:/#f7f7f7; border:solid 1px /#f09; width:200px; height:200px;} pre{ padding:8px; color:/#f09;} </style> </head> <body> <div class="box" style="z-index:5; top:50px;"> <pre> 利用pre这个标签可以将 其包起来的文字排版、格 式，原封不动的呈现出来 。算是相当好用的标签之 一。也就是说你输入的东 西被原封不动的输出,包 括你输入的空格之类的, 不用和等来表示空格或者 回车 </pre> </div> <iframe id="t-iframe" scrolling="no" frameborder="0" height="300" width="100%" src="http://www.baidu.com"></iframe> <div style="position:relative; z-index:3;"> <embed height="80" width="750" wmode="opaque" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash" quality="autohigh" src="http://gg.blueidea.com/2009/hp/3/home.swf"/> </div> <div class="box" style="z-index:2; top:-230px;"> <pre> 利用pre这个标签可以将其包起来的文 字排版、格式，原封不动的 呈现出来。算是相当好用的标签之一。也 就是说你输入的东西被原封不动的输出,包 括你输入的空格之类的,不用和等来 表示空格或者回车了 </pre> </div> <div class="box" style="z-index:4; top:-220px;"> <pre> 利用pre这个标签可以将其包起来的文 字排版、格式，原封不动的 呈现出来。算是相当好用的标签之一。也 就是说你输入的东西被原封不动的输出,包 括你输入的空格之类的,不用和等来 表示ddd </pre> </div> </body> </html> </p>
<p>以下是我在项目里的代码：</p>
<p>&lt;%@page contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page language=&quot;java&quot;%&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;% String map_URL = (String)request.getParameter(&quot;map_URL&quot;); if(map_URL == null){ Object tempURL = request.getAttribute(&quot;map_URL&quot;); if(tempURL == null){ map_URL = &quot;com.wxxr.web.ui.config.systemConfig&quot;;//TODO test code //map_URL = &quot;&quot;; //TODO if user not support any url system will use default url. }else{ map_URL = tempURL + &quot;&quot;; } } String contextPath = request.getContextPath(); %&gt; <!-- saved from url=(0014)about:internet --> <html lang="en"> <!-- Smart developers always View Source. This application was built using Adobe Flex, an open source framework for building rich Internet applications that get delivered via the Flash Player or to desktops via Adobe AIR. Learn more about Flex at http://flex.org // --> <head> <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> <!-- BEGIN Browser History required section --> <link rel="stylesheet" type="text/css" href="<%=contextPath%>/history/history.css" /> <!-- END Browser History required section --> <title></title> <STYLE> /#_iframe{ position: relative; display: none; top: 20px; left: 30px; background-color: /#ffffff; text-align: center; border: solid 1px; padding: 10px; z-index: 1; } </STYLE> <script src="<%=contextPath%>/AC_OETags.js" language="javascript"></script> <!-- BEGIN Browser History required section --> <script src="<%=contextPath%>/history/history.js" language="javascript"></script> <!-- END Browser History required section --> <script src="<%=contextPath%>/MxIframe.js" language="javascript"></script> <style> body { margin: 0px; overflow:hidden } </style> <script language="JavaScript" type="text/javascript"> <!-- // ----------------------------------------------------------------------------- // Globals // Major version of Flash required var requiredMajorVersion = 9; // Minor version of Flash required var requiredMinorVersion = 0; // Minor version of Flash required var requiredRevision = 28; // ----------------------------------------------------------------------------- // --> </script> </head> <body scroll="no"> <script language="JavaScript" type="text/javascript"> <!-- // Version check for the Flash Player that has the ability to start Player Product Install (6.0r65) var hasProductInstall = DetectFlashVer(6, 0, 65); // Version check based upon the values defined in globals var hasRequestedVersion = DetectFlashVer(requiredMajorVersion, requiredMinorVersion, requiredRevision); if ( hasProductInstall && !hasRequestedVersion ) { // DO NOT MODIFY THE FOLLOWING FOUR LINES // Location visited after installation is complete if installation is required var MMPlayerType = (isIE == true) ? "ActiveX" : "PlugIn"; var MMredirectURL = window.location; document.title = document.title.slice(0, 47) + " - Flash Player Installation"; var MMdoctitle = document.title; AC_FL_RunContent( "src", "<%=contextPath%>/playerProductInstall", "FlashVars", "MMredirectURL="+MMredirectURL+'&MMplayerType='+MMPlayerType+'&MMdoctitle='+MMdoctitle+"", "width", "100%", "height", "100%", "align", "middle", "id", "workbench", "quality", "high", "wmode", "opaque", "bgcolor", "/#869ca7", "name", "workbench", "allowScriptAccess","sameDomain", "type", "application/x-shockwave-flash", "base","<%=contextPath%>/", "pluginspage", "http://www.adobe.com/go/getflashplayer" ); } else if (hasRequestedVersion) { // if we've detected an acceptable version // embed the Flash Content SWF when all tests are passed AC_FL_RunContent( "src", "<%=contextPath%>/workbench", "width", "100%", "height", "100%", "align", "middle", "id", "workbench", "quality", "high", "wmode", "opaque", "bgcolor", "/#869ca7", "name", "workbench", "allowScriptAccess","sameDomain", "type", "application/x-shockwave-flash", "base","<%=contextPath%>/", "pluginspage", "http://www.adobe.com/go/getflashplayer", "flashvars","map_URL=<%=map_URL%>" ); } else { // flash is too old or we can't detect the plugin var alternateContent = 'Alternate HTML content should be placed here. ' + 'This content requires the Adobe Flash Player. ' + '<a href=http://www.adobe.com/go/getflash/>Get Flash</a>'; document.write(alternateContent); // insert non-flash content } // --> </script> <div id="_iframe"> <DIV align=center> <IFRAME id="_frame" frameBorder=0 marginwidth=0 marginheight=0 scrolling=no width=100% height=100% scrolling=no ALLOWTRANSPARENCY="true"> </IFRAME> <a href="javascript:iframe_close();">close</a> </DIV> </div> <noscript> <object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" id="workbench" width="100%" height="100%" codebase="http://fpdownload.macromedia.com/get/flashplayer/current/swflash.cab"> <param name="movie" value="<%=contextPath%>/workbench.swf" /> <param name="quality" value="high" /> <param name="bgcolor" value="/#869ca7" /> <param name="allowScriptAccess" value="sameDomain" /> <embed src="<%=contextPath%>/workbench.swf" quality="high" bgcolor="/#869ca7" width="100%" height="100%" name="workbench" align="middle" play="true" loop="false" quality="high" allowScriptAccess="sameDomain" type="application/x-shockwave-flash" pluginspage="http://www.adobe.com/go/getflashplayer"> </embed> </object> </noscript> </body> </html> </p>
<p><a href="http://wangpingsx.javaeye.com/blog/480848" title="在Eclipse中查看android 源代码的方法！" target="_blank">在Eclipse中查看android 源代码的方法！</a> | <a href="http://wangpingsx.javaeye.com/blog/466800" title="写 treeItemrenderer 还是有点儿难度的" target="_blank">写 treeItemrenderer 还是有点儿难度的</a></p>
<ul>
<li>14:04</li>
<li>浏览 (408)</li>
<li><a href="http://wangpingsx.javaeye.com/blog/468349#comments" target="_blank">评论</a> (0)</li>
<li>分类: <a href="http://wangpingsx.javaeye.com/category/79328" target="_blank">html+flash</a></li>
<li><a href="http://www.javaeye.com/wiki/topic/468349" target="_blank">相关推荐</a></li>
</ul>
<h3 id="-">评论</h3>
<p><a href=""></a></p>
<h3 id="-">发表评论</h3>
<p>您还没有登录，请<a href="http://wangpingsx.javaeye.com/login" target="_blank">登录</a>后发表评论(快捷键 Alt+S / Ctrl+Enter)</p>
<p><a href="http://wangpingsx.javaeye.com/" target="_blank"><img src="&quot;wangpingsx的博客: wangpingsx&quot;" alt="wangpingsx的博客"></a></p>
<p>wangpingsx</p>
<ul>
<li>浏览: 5856 次</li>
<li>性别: <img src="&quot;男&quot;" alt="Icon_minigender_1"></li>
<li>来自: 北京</li>
<li><img src="" alt=""></li>
<li><a href="http://wangpingsx.javaeye.com/blog/profile" target="_blank">详细资料</a> <a href="http://wangpingsx.javaeye.com/blog/guest_book" target="_blank">留言簿</a></li>
</ul>
<h3 id="-">搜索本博客</h3>
<h3 id="-http-wangpingsx-javaeye-com-blog-user_visits-">最近访客 <a href="http://wangpingsx.javaeye.com/blog/user_visits" target="_blank">&gt;&gt;更多访客</a></h3>
<p><a href="http://davidgchen1.javaeye.com/" target="_blank"><img src="&quot;davidgchen1的博客: &quot;" alt="davidgchen1的博客"></a></p>
<p><a href="http://davidgchen1.javaeye.com/" target="_blank">davidgchen1</a></p>
<p><a href="http://whj222126.javaeye.com/" target="_blank"><img src="&quot;whj222126的博客: &quot;" alt="whj222126的博客"></a></p>
<p><a href="http://whj222126.javaeye.com/" target="_blank">whj222126</a>
<a href="http://pengchen617.javaeye.com/" target="_blank"><img src="&quot;pengchen617的博客: pengchen617&quot;" alt="pengchen617的博客"></a></p>
<p><a href="http://pengchen617.javaeye.com/" target="_blank">pengchen617</a></p>
<p><a href="http://ruyuntao.javaeye.com/" target="_blank"><img src="&quot;入云涛的博客: 今天的一切是为了明天更美好！&quot;" alt="入云涛的博客"></a></p>
<p><a href="http://ruyuntao.javaeye.com/" target="_blank">入云涛</a></p>
<h3 id="-">博客分类</h3>
<ul>
<li><a href="http://wangpingsx.javaeye.com/" target="_blank">全部博客 (14)</a></li>
<li><a href="http://wangpingsx.javaeye.com/category/77170" target="_blank">Flex as3 (2)</a></li>
<li><a href="http://wangpingsx.javaeye.com/category/77171" target="_blank">java (0)</a></li>
<li><a href="http://wangpingsx.javaeye.com/category/77172" target="_blank">android (1)</a></li>
<li><a href="http://wangpingsx.javaeye.com/category/77173" target="_blank">ophone (0)</a></li>
<li><a href="http://wangpingsx.javaeye.com/category/77189" target="_blank">android与ophone入门 (6)</a></li>
<li><a href="http://wangpingsx.javaeye.com/category/78994" target="_blank">B/S架构，B端cache (3)</a></li>
<li><a href="http://wangpingsx.javaeye.com/category/79328" target="_blank">html+flash (1)</a></li>
<li><p><a href="http://wangpingsx.javaeye.com/category/106957" target="_blank">eclipse (1)</a></p>
<h3 id="-">其他分类</h3>
</li>
<li><p><a href="http://wangpingsx.javaeye.com/blog/favorite" target="_blank">我的收藏</a> (10)</p>
</li>
<li><a href="http://wangpingsx.javaeye.com/blog/topic" target="_blank">我的论坛主题贴</a> (1)</li>
<li><a href="http://wangpingsx.javaeye.com/blog/post" target="_blank">我的所有论坛贴</a> (2)</li>
<li><a href="http://wangpingsx.javaeye.com/blog/article" target="_blank">我的精华良好贴</a> (0)</li>
</ul>
<h3 id="-">最近加入圈子</h3>
<ul>
<li><p><a href="http://jsfgroup.group.javaeye.com/" target="_blank">JSF</a></p>
<h3 id="-">存档</h3>
</li>
<li><p><a href="http://wangpingsx.javaeye.com/blog/monthblog/2010-05" target="_blank">2010-05</a> (1)</p>
</li>
<li><a href="http://wangpingsx.javaeye.com/blog/monthblog/2009-09" target="_blank">2009-09</a> (7)</li>
<li><a href="http://wangpingsx.javaeye.com/blog/monthblog/2009-08" target="_blank">2009-08</a> (6)</li>
<li><a href="http://wangpingsx.javaeye.com/blog/monthblog_more" target="_blank">更多存档...</a></li>
</ul>
<h3 id="-">评论排行榜</h3>
<ul>
<li><a href="http://wangpingsx.javaeye.com/blog/466551" title="ehcache " target="_blank">ehcache</a></li>
<li><a href="http://wangpingsx.javaeye.com/blog/466699" title="B/S架构，B端cache" target="_blank">B/S架构，B端cache</a></li>
<li><a href="http://wangpingsx.javaeye.com/blog/466711" title="资料xxxx" target="_blank">资料xxxx</a></li>
<li><a href="http://wangpingsx.javaeye.com/blog/480848" title="在Eclipse中查看android 源代码的方法！" target="_blank">在Eclipse中查看android 源代码的方法！</a></li>
<li><a href="http://wangpingsx.javaeye.com/blog/466800" title="写 treeItemrenderer 还是有点儿难度的" target="_blank">写 treeItemrenderer 还是有点儿难度的</a></li>
<li><a href="http://wangpingsx.javaeye.com/rss" target="_blank"><img src="" alt="Rss"></a></li>
<li><a href="http://fusion.google.com/add?feedurl=http://wangpingsx.javaeye.com/rss" target="_blank"><img src="" alt="Rss_google"></a></li>
<li><a href="http://www.xianguo.com/subscribe.php?url=http://wangpingsx.javaeye.com/rss" target="_blank"><img src="" alt="Rss_xianguo"></a></li>
<li><a href="http://www.google.com/search?hl=zh-CN&amp;q=RSS" target="_blank">[什么是RSS?]</a>
声明：JavaEye文章版权属于作者，受法律保护。没有作者书面许可不得转载。若作者同意转载，必须以超链接形式标明文章原始出处和作者。
© 2003-2010 JavaEye.com. All rights reserved. 上海炯耐计算机软件有限公司 [ 沪ICP备05023328号 ]</li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Flex/">Flex</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Flex/" class="label label-primary">Flex</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:44"datetime="2014-03-07 09:54:44"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-Flex--如何避免层被其它对象挡住/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-Flex--如何避免层被其它对象挡住" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--CrapsGame/">CrapsGame</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:44.000Z"> <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--CrapsGame/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="crapsgame">CrapsGame</h1>
<h1 id="-algorithm-gossip-craps-"><a href="">Algorithm Gossip: Craps赌博游戏</a></h1>
<h2 id="-">说明</h2>
<p>一个简单的赌博游戏，游戏规则如下：玩家掷两个骰子，点数为1到6，如果第一次点数和为7或11，则玩家胜，如果点数和为2、3或12，则玩家输，如果和 为其它点数，则记录第一次的点数和，然后继续掷骰，直至点数和等于第一次掷出的点数和，则玩家胜，如果在这之前掷出了点数和为7，则玩家输。</p>
<h2 id="-">解法</h2>
<p>规则看来有些复杂，但是其实只要使用switch配合if条件判断来撰写即可，小心不要弄错胜负顺序即可。</p>
<h2 id="-">实作</h2>
<ul>
<li><p>C
/#include <stdio.h>
/#include <stdlib.h>
/#include <time.h>
/#define WON 0
/#define LOST 1
/#define CONTINUE 2
int rollDice() {
return (rand() % 6) + (rand() % 6) + 2;
}
int main(void) {
int firstRoll = 1;
int gameStatus = CONTINUE;
int die1, die2, sumOfDice;
int firstPoint = 0;
char c;
srand(time(0));
printf(&quot;Craps赌博游戏，按Enter键开始游戏/<em>/</em>/<em>/</em>&quot;);
while(1) {
getchar();
if(firstRoll) {
sumOfDice = rollDice();
printf(&quot;\n玩家掷出点数和：%d\n&quot;, sumOfDice);
switch(sumOfDice) {
case 7: case 11:
gameStatus = WON; break;
case 2: case 3: case 12:
gameStatus = LOST; break;
default:
firstRoll = 0;
gameStatus = CONTINUE;
firstPoint = sumOfDice;
break;
}
}
else {
sumOfDice = rollDice();
printf(&quot;\n玩家掷出点数和：%d\n&quot;, sumOfDice);
if(sumOfDice == firstPoint)
gameStatus = WON;
else if(sumOfDice == 7)
gameStatus = LOST;
}
if(gameStatus == CONTINUE)
puts(&quot;未分胜负，再掷一次/<em>/</em>/<em>/</em>\n&quot;);
else {
if(gameStatus == WON)
puts(&quot;玩家胜&quot;);
else
puts(&quot;玩家输&quot;);
printf(&quot;再玩一次？&quot;);
scanf(&quot;%c&quot;, &amp;c);
if(c == &#39;n&#39;) {
puts(&quot;游戏结束&quot;);
break;
}
firstRoll = 1;
}
}
return 0;
}</p>
</li>
<li><p>Java
import java.io./<em>;
public class Craps {
public static void main(String[] args)
throws IOException {
final int WON = 0, LOST = 1, CONTINUE = 2;
boolean firstRoll = true;
int gameStatus = CONTINUE;
int die1, die2, sumOfDice;
int firstPoint = 0;
System.out.print(
&quot;Craps赌博游戏，按Enter键开始游戏/</em>/<em>/</em>/<em>&quot;);
while(true) {
System.in.read();
if(firstRoll) {
sumOfDice = rollDice();
System.out.println(
&quot;\n玩家掷出点数和：&quot; + sumOfDice);
switch(sumOfDice) {
case 7: case 11:
gameStatus = WON; break;
case 2: case 3: case 12:
gameStatus = LOST; break;
default:
firstRoll = false;
gameStatus = CONTINUE;
firstPoint = sumOfDice;
break;
}
}
else {
sumOfDice = rollDice();
System.out.println(
&quot;\n玩家掷出点数和：&quot; + sumOfDice);
if(sumOfDice == firstPoint)
gameStatus = WON;
else if(sumOfDice == 7)
gameStatus = LOST;
}
if(gameStatus == CONTINUE)
System.out.println(&quot;未分胜负，再掷一次/</em>/<em>/</em>/<em>&quot;);
else {
if(gameStatus == WON)
System.out.println(&quot;玩家胜&quot;);
else
System.out.println(&quot;玩家输&quot;);
System.out.print(&quot;再玩一次？&quot;);
if(System.in.read() == &#39;n&#39;) {
System.out.println(&quot;游戏结束&quot;);
break;
}
firstRoll = true;
}
}
}
public static int rollDice() {
int roll = ((int)(Math.random() /</em> 6) +
(int)(Math.random() /* 6));
if(roll &lt; 2) {
roll = 2;
}
return roll;
}
}</p>
</li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/AlgorithmGossip/">AlgorithmGossip</a></li></span></span> | <span class="tags">Tagged <a href="/tags/AlgorithmGossip/" class="label label-primary">AlgorithmGossip</a></span> | <span class="time">recent updated:<time title="2014-03-07 10:38:20"datetime="2014-03-07 10:38:20"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--CrapsGame/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-AlgorithmGossip-AlgorithmGossip--CrapsGame" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--ShuffleCard/">ShuffleCard</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:44.000Z"> <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--ShuffleCard/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="shufflecard">ShuffleCard</h1>
<h1 id="-algorithm-gossip-"><a href="">Algorithm Gossip: 洗扑克牌（乱数排列）</a></h1>
<h2 id="-">说明</h2>
<p>洗扑克牌的原理其实与乱数排列是相同的，都是将一组数字（例如1～N）打乱重新排列，只不过洗扑克牌多了一个花色判断的动作而已。</p>
<h2 id="-">解法</h2>
<p>初学者通常会直接想到，随机产生1～N的乱数并将之存入阵列中，后来产生的乱数存入阵列前必须先检查阵列中是否已有重复的数字，如果有这个数就不存入，再重新产生下一个数，运气不好的话，重复的次数就会很多，程式的执行速度就很慢了，这不是一个好方法。
以1～52的乱数排列为例好了，可以将阵列先依序由1到52填入，然后使用一个回圈走访阵列，并随机产生1～52的乱数，将产生的乱数当作索引取出阵列值，并与目前阵列走访到的值相交换，如此就不用担心乱数重复的问题了，阵列走访完毕后，所有的数字也就重新排列了。
至于如何判断花色？这只是除法的问题而已，取商数判断花色，取余数判断数字，您可以直接看程式比较清楚。</p>
<h2 id="-">实作</h2>
<ul>
<li><p>C
/#include <stdio.h>
/#include <stdlib.h>
/#include <time.h>
/#define N 52
int main(void) {
int poker[N + 1];
int i, j, tmp, remain;
// 初始化阵列
for(i = 1; i &lt;= N; i++)
poker[i] = i;
srand(time(0));
// 洗牌
for(i = 1; i &lt;= N; i++) {
j = rand() % 52 + 1;
tmp = poker[i];
poker[i] = poker[j];
poker[j] = tmp;
}
for(i = 1; i &lt;= N; i++) {
// 判断花色
switch((poker[i]-1) / 13) {
case 0:
printf(&quot;桃&quot;); break;
case 1:
printf(&quot;心&quot;); break;
case 2:
printf(&quot;砖&quot;); break;
case 3:
printf(&quot;梅&quot;); break;
}
// 扑克牌数字
remain = poker[i] % 13;
switch(remain) {
case 0:
printf(&quot;K &quot;); break;
case 12:
printf(&quot;Q &quot;); break;
case 11:
printf(&quot;J &quot;); break;
default:
printf(&quot;%d &quot;, remain); break;
}
if(i % 13 == 0)
printf(&quot;\n&quot;);
}
return 0;
}</p>
</li>
<li><p>Java
public class ShuffleCard {
public static void main(String args[]) {
final int N = 52;
int[] poker = new int[N + 1];
// 初始化阵列
for(int i = 1; i &lt;= N; i++)
poker[i] = i;
// 洗牌
for(int i = 1; i &lt;= N; i++) {
int j = (int) (Math.random() /* N);
if(j == 0)
j = 1;
int tmp = poker[i];
poker[i] = poker[j];
poker[j] = tmp;
}
for(int i = 1; i &lt;= N; i++) {
// 判断花色
switch((poker[i]-1) / 13) {
case 0:
System.out.print(&quot;桃&quot;); break;
case 1:
System.out.print(&quot;心&quot;); break;
case 2:
System.out.print(&quot;砖&quot;); break;
case 3:
System.out.print(&quot;梅&quot;); break;
}
// 扑克牌数字
int remain = poker[i] % 13;
switch(remain) {
case 0:
System.out.print(&quot;K &quot;); break;
case 12:
System.out.print(&quot;Q &quot;); break;
case 11:
System.out.print(&quot;J &quot;); break;
default:
System.out.print(remain + &quot; &quot;); break;
}
if(i % 13 == 0)
System.out.println(&quot;&quot;);
}
}
}</p>
</li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/AlgorithmGossip/">AlgorithmGossip</a></li></span></span> | <span class="tags">Tagged <a href="/tags/AlgorithmGossip/" class="label label-primary">AlgorithmGossip</a></span> | <span class="time">recent updated:<time title="2014-03-07 10:35:07"datetime="2014-03-07 10:35:07"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--ShuffleCard/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-AlgorithmGossip-AlgorithmGossip--ShuffleCard" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类-easy-mock--easymock教程/">easymock教程</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类-easy-mock--easymock教程/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="easymock-">easymock教程</h1>
<p><img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <a href="http://www.javaeye.com" target="_blank">http://www.javaeye.com</a> - 做最棒的软件开发交流社区
easymock教程
作者: skydream <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
easymock教程，详细的介绍easymock的使用
第 1 / 65 页
本书由JavaEye提供的电子书DIY功能自动生成于 2010-12-06
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
目录</p>
<ol>
<li>software test
1.1 easymock教程-目录 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 1.2 easymock教程-mock和stub . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 1.3 easymock教程-单元测试中的主要测试对象和依赖 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 1.4 easymock教程-record-replay-verify模型 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 1.5 easymock教程-easymock的典型使用 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 1.6 easymock教程-class mocking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 1.7 easymock教程-mock的限制 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 1.8 easymock教程-strict和nice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 1.9 easymock教程-创建stub对象 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 1.10 easymock教程-放宽调用次数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 1.11 easymock教程-参数匹配 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 1.12 easymock教程-partial class mocking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 1.13 easymock教程-运行时返回值或者异常 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 1.14 easymock教程-改变同一个方法调用的行为 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55 1.15 easymock教程-自定义参数匹配器 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 1.16 easymock教程-命名mock对象 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 1.17 easymock教程-使用MockControl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
第 2 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.1 easymock教程-目录
1.1 easymock教程-目录
发表时间: 2010-10-14 easymock是目前比较流行的java mock 工具，这个教程将比较详细的介绍easymock的使用。
主要内容来自easymock的官网介绍和教程，我针对日常使用情况进行了一些筛选和补充，另外增加一些个 人的理解和认识，希望能对不熟悉easymock的朋友们有所帮助。
如有疏漏，错误或者疑惑，欢迎大家指正和提醒，不胜感激。
一. 基本概念
这里讲述一些测试相关的基本概念，不仅仅适用于easymock，也同样适用于其他的mock框架如jmock， jmockit等。
1) mock 和 stub
2) 单元测试中的主要测试对象和依赖
3) record-replay-verify 模型
二. 基础教程
1) 典型使用
2) Class Mocking
第 3 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.1 easymock教程-目录
3) mock的限制
4) strict和nice
5) 创建stub对象
6) 放宽调用次数
7) 参数匹配
三. 高级教程
1) Partial class mocking
2) 运行时返回值或者异常
3) 改变同一个方法调用的行为
4) 自定义参数匹配器
四. 最佳实践 1) 命名mock对象
第 4 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.1 easymock教程-目录
2) 使用 MocksControl
第 5 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.2 easymock教程-mock和stub
1.2 easymock教程-mock和stub
发表时间: 2010-08-26 作为测试的基本概念，在开发测试中经常遇到mock和stub。之前认为自己对这两个概念已经很明白了，但是 当决定要写下来并写清楚以便能让不明白的人也能弄明白，似乎就很有困难。 试着写下此文，以检验自己是不是真的明白mock和stub。 一. 相同点 先看看两者的相同点吧，非常明确的是，mock和stub都可以用来对系统(或者将粒度放小为模块，单元)进行 隔离。 在测试，尤其是单元测试中，我们通常关注的是主要测试对象的功能和行为，对于主要测试对象涉及到的次 要对象尤其是一些依赖，我们仅仅关注主要测试对象和次要测试对象的交互，比如是否调用，何时调用，调用 的参数，调用的次数和顺序等，以及返回的结果或发生的异常。但次要对象是如何执行这次调用的具体细节， 我们并不关注，因此常见的技巧就是用mock对象或者stub对象来替代真实的次要对象，模拟真实场景来进行对 主要测试对象的测试工作。 因此从实现上看，mock和stub都是通过创建自己的对象来替代次要测试对象，然后按照测试的需要控制这个 对象的行为。 二. 不同点 1. 类实现的方式 从类的实现方式上看，stub有一个显式的类实现，按照stub类的复用层次可以实现为普通类(被多个测试案 例复用)，内部类(被同一个测试案例的多个测试方法复用)乃至内部匿名类(只用于当前测试方法)。对于stub的方 法也会有具体的实现，哪怕简单到只有一个简单的return语句。 而mock则不同，mock的实现类通常是有mock的工具包如easymock, jmock来隐式实现，具体mock的 方法的行为则通过record方式来指定。 以mock一个UserService, UserDao为例，最简单的例子，只有一个查询方法：
第 6 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.2 easymock教程-mock和stub
public interface UserService { User query(String userId); }
public class UserServiceImpl implements UserService { private UserDao userDao; public User query(String userId) { return userDao.getById(userId); } //setter for userDao }
public interface UserDao { User getById(String userId); }
stub的标准实现，需要自己实现一个类并实现方法:
public class UserDaoStub implements UserDao { public User getById(String id) { User user = new User(); user.set..... return user; } }
@Test public void testGetById() { UserServiceImpl service = new UserServiceImpl(); UserDao userDao = new UserDaoStub();
service.setUserDao(userDao);
User user = service.query(&quot;1001&quot;);
第 7 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.2 easymock教程-mock和stub
... }
mock的实现，以easymock为例，只要指定mock的类并record期望的行为，并没有显式的构造新类:
@Test public void testGetById() { UserDao dao = Easymock.createMock(UserDao.class); User user = new User(); user.set..... Easymock.expect(dao.getById(&quot;1001&quot;)).andReturn(user); Easymock.reply(dao);
UserServiceImpl service = new UserServiceImpl(); service.setUserDao(userDao); User user = service.query(&quot;1001&quot;); ... Easymock.verify(dao)； }
对比可以看出，mock编写相对简单，只需要关注被使用的函数，所谓&quot;just enough&quot;。stub要复杂一些， 需要实现逻辑，即使是不需要关注的方法也至少要给出空实现。 2. 测试逻辑的可读性 从上面的代码可以看出，在形式上，mock通常是在测试代码中直接mock类和定义mock方法的行为，测 试代码和mock的代码通常是放在一起的，因此测试代码的逻辑也容易从测试案例的代码上看出来。 Easymock.expect(dao.getById(&quot;1001&quot;)).andReturn(user); 直截了当的指明了当前测试案例对UserDao这个 依赖的预期: getById需要被调用，调用的参数应该是&quot;1001&quot;，调用次数为1(不明确指定调用次数时easymock 默认为1)。 而stub的测试案例的代码中只有简单的UserDao userDao = new UserDaoStub ();构造语句和
第 8 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.2 easymock教程-mock和stub
service.setUserDao(userDao);设置语句，我们无法直接从测试案例的代码中看出对依赖的预期，只能进入具体 的UserServiceImpl类的query()方法，看到具体的实现是调用userDao.getById(userId)，这个时候才能明白完 整的测试逻辑。因此当测试逻辑复杂，stub数量多并且某些stub需要传入一些标记比如true，false之类的来制 定不同的行为时，测试逻辑的可读性就会下降。 3. 可复用性 Mock通常很少考虑复用，每个mock对象通过都是遵循&quot;just enough&quot;原则，一般只适用于当前测试方 法。因此每个测试方法都必须实现自己的mock逻辑，当然在同一个测试类中还是可以有一些简单的初始化逻辑 可以复用。 stub则通常比较方便复用，尤其是一些通用的stub，比如jdbc连接之类。spring框架就为此提供了大量的 stub来方便测试，不过很遗憾的是，它的名字用错了：spring-mock！ 4. 设计和使用 接着我们从mock和stub的设计和使用上来比较两者，这里需要引入两个概念：interaction-based和 state-based。 具体关于interaction-based和state-based，不再本文阐述，强烈推荐Martin Fowler 的一篇文 章，&quot;Mocks Aren&#39;t Stubs&quot;。地址为<a href="http://martinfowler.com/articles/mocksArentStubs.html(PS：当在" target="_blank">http://martinfowler.com/articles/mocksArentStubs.html(PS：当在</a> google中输入mock stub两个关键字做搜索时，出来结果的第一条就是此文，向Martin Fowler致敬，向 google致敬)，英文不好的同学，可以参考这里的一份中文翻译：<a href="http://www.cnblogs.com/anf/archive/" target="_blank">http://www.cnblogs.com/anf/archive/</a> 2006/03/27/360248.html。 总结来说，stub是state-based，关注的是输入和输出。mock是interaction-based，关注的是交互过 程。 5. expectiation/期望 这个才是mock和stub的最重要的区别：expectiation/期望。 对于mock来说，exception是重中之重：我们期待方法有没有被调用，期待适当的参数，期待调用的次 数，甚至期待多个mock之间的调用顺序。所有的一切期待都是事先准备好，在测试过程中和测试结束后验证是 否和预期的一致。 而对于stub，通常都不会关注exception，就像上面给出的UserDaoStub的例子，没有任何代码来帮助判 断这个stub类是否被调用。虽然理论上某些stub实现也可以通过自己编码的方式增加对expectiation的内容，
第 9 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a> 比如增加一个计数器，每次调用+1之类，但是实际上极少这样做。 6. 总结
1.2 easymock教程-mock和stub
关于mock和stub的不同，在Martin Fowler的&quot;Mocks Aren&#39;t Stubs&quot;一文中，有以下结束，我将它列出来 作为总结： (1) Dummy 对象被四处传递，但是从不被真正使用。通常他们只是用来填充参数列表。 (2) Fake 有实际可工作的实现，但是通常有一些缺点导致不适合用于产品(基于内存的数据库就是一个好 例子)。 (3) Stubs 在测试过程中产生的调用提供预备好的应答，通常不应答计划之外的任何事。stubs可能记录关 于调用的信息，比如 邮件网关的stub 会记录它发送的消息，或者可能仅仅是发送了多少信息。 (4) Mocks 如我们在这里说的那样：预先计划好的对象，带有各种期待，他们组成了一个关于他们期待接 受的调用的详细说明。 三. 退化和转化 在实际的开发测试过程中，我们会发现其实mock和stub的界限有时候很模糊，并没有严格的划分方式， 从而造成我们理解上的含糊和困惑。 主要的原因在于现实使用中，我们经常将mock做不同程度的退化，从而使得mock对象在某些程度上如 stub一样工作。以easymock为例，我们可以通过anyObject(), isA(Class)等方式放宽对参数的检测，以 atLeastOnce(),anytimes()来放松对调用次数的检测，我们可以使用Easymock.createControl()而不是 Easymock.createStrictControl()来放宽对调用顺序的检测(或者调用checkOrder(false))，我们甚至可以通过 createNiceControl(), createNiceMock()来创建完全不限制调用方式而且自动返回简单值的mock，这和stub 就几乎没有本质区别了。 目前大多数的mock工具都提供mock退化为stub的支持，比如easyock中，除了上面列出的 any/<em>/</em>/*,NiceMock之外，还提供诸如 andStubAnswer(),andStubDelegateTo(),andStubReturn(),andStubThrow()和asStub()。
第 10 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.2 easymock教程-mock和stub
前面也谈到过stub也是可以通过增加代码来实现一些expectiation的特性，stub理论上也是可以向mock 的方向做转化，而从使得两者的界限更加的模糊。
第 11 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.3 easymock教程-单元测试中的主要测试对象和依赖
1.3 easymock教程-单元测试中的主要测试对象和依赖
发表时间: 2010-10-14 在单元测试中，通常我们都会有一个明确的测试对象，我们测试的主要目的就是为了验证这个类的工作如我 们预期。
以下面的简单代码为例：
public interface UserService { User query(String userId); }
public class UserServiceImpl implements UserService { private UserDao userDao; public User query(String userId) { return userDao.getById(userId); }
public void setUserDao(UserDao userDao) { this.userDao = userDao; } }
public interface UserDao { User getById(String userId); }
public class UserDaoImpl implements UserDao {
private Datasource dataSource;
public User getById(String id) { User user = new User(); //execute database query
第 12 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
user.set.. return user; }
1.3 easymock教程-单元测试中的主要测试对象和依赖
public void setDatasource(Datasource datasource) { this.datasource = datasource; }
}
这里我们定义有两个interface: UserService 和 UserDao， 并给出了两个实现类UserServiceImpl 和 UserDaoImpl。 其中UserServiceImpl依赖到UserDao，通过setter方法可以注入一个UserDao实现。而 UserDaoImpl的实现则依赖到Datasource。
然后我们来为实现类UserServiceImpl 和 UserDaoImpl编写单元测试:</li>
<li>UserServiceImplTest
public class UserServiceImplTest {
@Test public void testQuery() { User expectedUser = new User(); expectedUser.setId(&quot;1001&quot;); expectedUser.setAge(30); expectedUser.setName(&quot;user-1001&quot;); UserDao userDao = EasyMock.createMock(UserDao.class); EasyMock.expect(userDao.getById(&quot;1001&quot;)).andReturn(expectedUser); EasyMock.replay(userDao);
UserServiceImpl service = new UserServiceImpl(); service.setUserDao(userDao); User user = service.query(&quot;1001&quot;);
第 13 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
assertNotNull(user); assertEquals(&quot;1001&quot;, user.getId()); assertEquals(30, user.getAge()); assertEquals(&quot;user-1001&quot;, user.getName());
1.3 easymock教程-单元测试中的主要测试对象和依赖
EasyMock.verify(userDao); } }
在这个测试类中，主要测试对象就是UserServiceImpl，对于UserServiceImpl的依赖UserDao，我们采取 mock这个UserDao来满足UserServiceImpl的测试需要。</li>
<li>UserDaoImplTest 代码示例就不详细写了，和上面的类似，主要测试对象就是UserDaoImpl, 我们将通过mock Datasource来 满足UserDaoImpl对datasource的测试需要。 可以从上面的例子中简单的看出，通常单元测试都遵循这样的惯例: AClass的单元测试类命名为 AclassTest，主要职责是测试AClass的行为，理所当然的主要测试对象就是AClass。而所有被AClass的依赖则 自然而然的成为次要测试对象，通常我们都不关注这些依赖的内部实现，也不会要求在AClass的单元测试案例 中对这些依赖的实现进行测试和验证。 这也符合单元测试的理念: 我们将类AClass定义为单元，测试这个单元的行为是否如预期。同时也符合 UserServiceImpl的实现逻辑：UserServiceImpl依赖到UserDao接口，并不直接依赖到UserDaoImpl，因此在 UserServiceImpl的单元测试中，也不应该引入UserDaoImpl这样的真实类，mock框架在这个时候是最适合出 场表演的了：我们可以通过mock UserDao来模拟出UserDao的各种行为以便检测UserServiceImpl在这些行为 下的处理是否正确: 不同的返回值，错误场景，异常场景。这也是mock框架在单元测试中被广泛使用的原因： 还有什么比mock 类更能方便的做到这些？
第 14 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.4 easymock教程-record-replay-verify模型
1.4 easymock教程-record-replay-verify模型
发表时间: 2010-10-15 record-replay-verify 模型容许记录mock对象上的操作然后重演并验证这些操作。这是目前mock框架领域 最常见的模型，几乎所有的mock框架都是用这个模型，有些是现实使用如easymock，有些是隐式使用如 jmockit。
以easymock为例，典型的easymock使用案例一般如下, 援引上一章中的例子：
public class UserServiceImplTest {
//<em>/</em> /<em> this is a classic test case to use EasyMock. /</em>/ @Test public void testQuery() { User expectedUser = new User(); expectedUser.setId(&quot;1001&quot;); expectedUser.setAge(30); expectedUser.setName(&quot;user-1001&quot;); UserDao userDao = EasyMock.createMock(UserDao.class); EasyMock.expect(userDao.getById(&quot;1001&quot;)).andReturn(expectedUser); EasyMock.replay(userDao);
UserServiceImpl service = new UserServiceImpl(); service.setUserDao(userDao); User user = service.query(&quot;1001&quot;); assertNotNull(user); assertEquals(&quot;1001&quot;, user.getId()); assertEquals(30, user.getAge()); assertEquals(&quot;user-1001&quot;, user.getName());
EasyMock.verify(userDao);
第 15 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
} }
1.4 easymock教程-record-replay-verify模型
在这里有两句非常明显的调用语句: Easymock.replay(...)和Easymock.verify(...)。这两个语句将上述代码分 成三个部分，分别对应record-replay-verify 3个阶段</li>
<li>record
User expectedUser = new User(); expectedUser.setId(&quot;1001&quot;); expectedUser.setAge(30); expectedUser.setName(&quot;user-1001&quot;); UserDao userDao = EasyMock.createMock(UserDao.class); EasyMock.expect(userDao.getById(&quot;1001&quot;)).andReturn(expectedUser);
这里我们开始创建mock对象，并期望这个mock对象的方法被调用，同时给出我们希望这个方法返回的结 果。
这就是所谓的&quot;记录mock对象上的操作&quot;, 同时我们也会看到&quot;expect&quot;这个关键字。
总结说，在record阶段，我们需要给出的是我们对mock对象的一系列期望：若干个mock对象被调用，依从 我们给定的参数，顺序，次数等，并返回预设好的结果(返回值或者异常).</li>
<li>replay
UserServiceImpl service = new UserServiceImpl(); service.setUserDao(userDao); User user = service.query(&quot;1001&quot;);
第 16 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.4 easymock教程-record-replay-verify模型
在replay阶段，我们关注的主要测试对象将被创建，之前在record阶段创建的相关依赖被关联到主要测试对 象，然后执行被测试的方法，以模拟真实运行环境下主要测试对象的行为。
在测试方法执行过程中，主要测试对象的内部代码被执行，同时和相关的依赖进行交互：以一定的参数调用 依赖的方法，获取并处理返回。我们期待这个过程如我们在record阶段设想的交互场景一致，即我们期望在 replay阶段所有在record阶段记录的行为都将被完整而准确的重新演绎一遍，从而到达验证主要测试对象行为 的目的。</li>
<li>verify
assertNotNull(user); assertEquals(&quot;1001&quot;, user.getId()); assertEquals(30, user.getAge()); assertEquals(&quot;user-1001&quot;, user.getName()); EasyMock.verify(userDao);
在verify阶段，我们将验证测试的结果和交互行为。
通常验证分为两部分，如上所示： 一部分是验证结果，即主要测试对象的测试方法返回的结果(对于异常测试 场景则是抛出的异常)是否如预期，通常这个验证过程需要我们自行编码实现。另一部分是验证交互行为，典型 如依赖是否被调用，调用的参数，顺序和次数，这部分的验证过程通常是由mock框架来自动完成，我们只需要 简单调用即可。
在easymock的实现中，verify的部分交互行为验证工作，会提前在replay阶段进行：比如未记录的调用，调 用的参数等。如果验证失败，则直接结束replay以致整个测试案例。
record-replay-verify 模型非常好的满足了大多数测试场景的需要：先指定测试的期望，然后执行测试，再 验证期望是否被满足。这个模型简单直接，易于实现，也容易被开发人员理解和接受，因此被各个mock框架广 泛使用。
第 17 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.5 easymock教程-easymock的典型使用
1.5 easymock教程-easymock的典型使用
发表时间: 2010-10-15
关于easymock的典型使用方式，在easymock的官网文档中，有非常详尽的讲解，文档地址为 <a href="http://easymock.org/EasyMock3_0_Documentation.html，文档的开头一部分内容都是easymock中最基本" target="_blank">http://easymock.org/EasyMock3_0_Documentation.html，文档的开头一部分内容都是easymock中最基本</a> 的使用介绍，虽然是英文，但是非常容易看懂，适用新学者入门。
这里只罗列一些简单的常用功能，依然以前面教程中使用到的测试案例为例：
public class UserServiceImplTest extends Assert {
@Test public void testQuery() {
User expectedUser = new User(); user.set.; UserDao userDao = Easymock.createMock(UserDao.class); Easymock.expect(userDao.getById(&quot;1001&quot;)).andReturn(expectedUser); Easymock.replay(userDao);
UserServiceImpl service = new UserServiceImpl(); service.setUserDao(userDao); user user = service.query(&quot;1001&quot;); assertNotNull(user); assertEquals(); //veify return user
Easymock.verify(userDao);
}
}
第 18 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.5 easymock教程-easymock的典型使用
这段简短的代码中包含以下easymock的功能：</li>
<li>创建mock对象 UserDao userDao = Easymock.createMock(UserDao.class);</li>
<li>记录mock对象期望的行为 Easymock.expect(userDao.getById(&quot;1001&quot;)).andReturn(expectedUser); 这里记录了mock对象的行为：getById()方法被调用，调用次数为1(easymock之中如果没有明确指出调 用次数，默认为1),参数为&quot;1001&quot;，expectedUser将作为返回值。</li>
<li>进入replay阶段 Easymock.replay(userDao);</li>
<li>对mock对象执行验证 Easymock.verify(userDao);
对上面上面的代码稍加改动以展示easymock的其他基本功能：</li>
<li>指定期望的调用次数 Easymock.expect(userDao.getById(&quot;1001&quot;)).andReturn(expectedUser).times(3);</li>
<li>指定抛出期望的异常 Easymock.expect(userDao.getById(&quot;1001&quot;)).andThrow(new RuntimeException(&quot;no user exist&quot;));</li>
<li>记录void 方法的行为
第 19 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.5 easymock教程-easymock的典型使用
Easymock.expect(userDao.getById(&quot;1001&quot;)) 这样的用法只能使用与mock对象的有返回值的方法，如 果mock对象的方法是void，则需要使用expectLastCall()： userDao.someVoidMethod(); Easymock.expectLastCall(); 和Easymock.expect(/<em>/</em>/*)一样，同样支持指定调用次数，抛出异常等： Easymock.expectLastCall().times(3); Easymock.expectLastCall().andThrow(new RuntimeException(&quot;some error&quot;));</li>
<li>灵活的参数匹配 Easymock.expect(userDao.getById(Easymock.isA(String.class))).andReturn(expectedUser); 类似的还有anyInt()，anyObject()， isNull() ， same(), startsWith()等诸多实现。具体细节请参考本教 程中的&quot;参数匹配&quot;一文。
第 20 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.6 easymock教程-class mocking
1.6 easymock教程-class mocking
发表时间: 2010-10-26 前面的例子中，mock的对象都是基于interface，虽然说我们总是强调要面对接口编程，而不要面对实现， 但是实际开发中不提取interface而直接使用class的场景非常之多。尤其是一些当前只有一个明确实现而看不到 未来扩展的类，是否应该提取interface或者说是否应该现在就提取interface，总是存在争论。
这种情况下，我们就会面临主要测试对象依赖到一个具体类而不是interface的情况，easymock中通过class extension 来提供对class mocking的支持。</li>
<li>class mocking的使用
easymock class extension的使用方式和普通的interface mock完全一致，基本上easymock中有的功能 easymock class extension都同样提供，而且所有的类名和方法名都保持一致。
ClassA impl = Easymock.createMock(ClassA.class); Easymock.expect(impl.getById(&quot;1001&quot;)).andReturn(...); Easymock.replay(impl); 唯一的差异在于，easymock class extension的java package和easymock不同，easymock是 org.easymock./<em>, 而 easymock class extension是org.easymock.classextension./</em>，典型如 org.easymock.classextension.Easymock 对应 org.easymock.Easymock。另外在发布时，两者是分开发布 的，easymock.jar 和 easymockclassextension.jar，需要根据需要分别导入，或者必要时同时导入。</li>
<li>3.0新版本和向后兼容
我们来回顾一下easymock的历史版本: easymock 1./<em> 非常久远了，已经没有人在用。2.0版本在 2005-12-24发布，基于jdk1.5，之后陆续发布的2.1/2.2/2.3/2.4/2.5等几个版本中，都提供了对应版本的 easymock class extension。easymock 3.0 版本是最新版本，2010-05-08 发布，主要改进就是将easymock
第 21 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.6 easymock教程-class mocking
class extension的功能合并到easymock中，以后只要使用easymock就可以提供class mocking的功能。当然 为了兼容2./</em>下的旧代码，依然提供了EasyMock 3.0 Class Extension代理到easymock 3.0。
3.0版本之后，easymock class extension的class mocking功能已经无缝集成到easymock中，因此代码的 编写简洁了很多，强烈建议新用户直接使用3.0版本。对于使用2./<em>版本的旧有代码，easymock提供了 easymock class extension的3.0版本，兼容2./</em>的代码，底层实现实际是代理给easymock3.0。因此2./*版本 easymock class extension的用户可以通过简单的升级easymock class extension到3.0即可平滑升级，之后再 逐渐替换掉easymock class extension的代码。</li>
<li>class mocking的限制
class mocking是有一些限制的， 1) 不能mock类的 final方法 如果final方法被调用，则只能执行原有的正常代码。
2) 不能mock类的static 方法。 同样如果private方法被调用，只能执行原有的正常代码。
3) 不能mock类的一些特殊方法: equals(), toString()和hashCode(). 原因是easymock在实现是为每个class mock对象提供了内建的以上三个方法。需要强调的是，对于基于 interface的mock，这个限制也是同样存在的，即使以上三个方式是interface定义的一部分。
在使用时需要避开这种场景，或者组合使用其他的mock 框架比如jmockit来mock private方法和final方法。
第 22 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.6 easymock教程-class mocking
第 23 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.7 easymock教程-mock的限制
1.7 easymock教程-mock的限制
发表时间: 2010-11-25 easymock并不是万能的，在使用easymock时有一些限制需要注意。
(1) Object方法的限制 我们都知道java是一个单根继承体系，Object是所有类的基类。在Object类上有几个基本的方法， easymock是不能改变其行为的：equals(), hashCode()和toString()。
即对于easymock创建的mock对象，其equals(), hashCode()和toString()三个方法的行为时已经固定了点， 不能通过Easymock.expect()来指定这三个方法的行为，即使这三个方法是接口定义的一部分。
我们来先看一个例子：
public class Business { private Service service;
public void execute() { System.out.println(&quot;service.toString() = &quot; + service.toString()); System.out.println(&quot;service.hashCode() = &quot; + service.hashCode()); }
public void setService(Service service) { this.service = service; } }
private interface Service {
public String toString();
public int hashCode();
第 24 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
}
1.7 easymock教程-mock的限制
execute()方法将为我们打印出toString()和hashCode()方法的结果。
public class LimitationTest {
private Business
business;
private IMocksControl mocksControl;
private Service
service;
@Before public void init() { business = new Business(); mocksControl = EasyMock.createStrictControl(); service = mocksControl.createMock(Service.class); business.setService(service); }
@Test public void testDefaultBehavior() { business.execute(); }
@Test public void testCustomizedBehavior() {
EasyMock.expect(service.toString()).andReturn(&quot;Customized toString&quot;); EasyMock.expect(service.hashCode()).andReturn(100000); mocksControl.replay();
business.execute(); mocksControl.verify(); } }
第 25 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.7 easymock教程-mock的限制
测试案例testDefaultBehavior()将为我们打印出mock对象默认的行为，输出如下： service.toString() = EasyMock for interface net.sourcesky.study.easymock.tutorial.LimitationTest$Service service.hashCode() = 26208195
可见easymock内部已经做好了toString()和hashCode()实现。
在测试案例testCustomizedBehavior()中，我们试图通过EasyMock.expect()来指定toString()和 hashCode()的行为，但是运行时遭遇错误：
java.lang.IllegalStateException: no last call on a mock available at org.easymock.EasyMock.getControlForLastCall(EasyMock.java:521) at org.easymock.EasyMock.expect(EasyMock.java:499) at net.sourcesky.study.easymock.tutorial.LimitationTest.testCustomizedBehavior(LimitationTest.java:51) ...
从&quot;no last call on a mock available&quot;的描述上看，easymock根本没有把对toString()方法的调用记录 (record)下来作为一个对mock对象的调用。
因此，在使用mock对象时，请注意equals(), hashCode()和toString()三个方法无法更改其行为。
(2) class mock的限制
相对于interface mock，class mock下easymock限制更多，除了上面谈到的equals(), hashCode()和 toString()三个方法外，还有以下限制：
第 26 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.7 easymock教程-mock的限制</li>
<li>final 方法不能被mock 2. private 方法不能对mock
(3) 静态方法 对于静态方法，easymock也无法mock其行为。
由于这个限制，当被测试类中有静态方法调用时，典型如单例方法调用，lookup方式的依赖查找， easymock就会力不从心。从这个角度上，推荐尽量使用IOC 控制反转/ DI依赖注入的方式来实现依赖的获取， 而不要使用lookup的主动查找方式。
实际开发中，当发现有因为静态方法的限制从而导致easymock无法mock我们期望的行为，造成测试案 例&quot;不好写&quot;，“写不下去”时，请换个角度思考：为什么要用静态方法？可不可以改成注入？
(4) 解决的方法
如果由于某些原因必须使用静态方法或者定制final, private方法的行为，则可以考虑搭配其他mock框架来完 成功能。
以静态方法方法为例，一个典型的使用范例是：使用jmockit来定制静态方法的行为，指定其返回easymock 创建的mock对象，然后使用easymock的标准方式定制这个mock对象的行为。
第 27 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.8 easymock教程-strict和nice
1.8 easymock教程-strict和nice
发表时间: 2010-11-19 在easymock的使用过程中，当创建mock对象时，我们会遇到 strict mock和nice mock的概念。
比如创建mock对象我们通常使用EasyMock.createMock()，但是我们会发现easymock同时提供了两个类似 的方法：
EasyMock.createNiceMock() EasyMock.createStrictMock()
类似的在创建MocksControl时，除了通常的EasyMock.createControl() 外，easymock也同时提供两个类 似的方法：
EasyMock.createNiceControl() EasyMock.createStrictControl()
我们来看看strict和nice有什么作用。参考easymock的javadoc，我们对比createMock()和 createStrictMock()：
EasyMock.createMock()： checking is disabled by default.
Creates a mock object that implements the given interface, order
EasyMock.createNiceMock() ： Creates a mock object that implements the given interface, order checking is enabled by default.
发现strict mock方式下默认是开启调用顺序检测的，而普通的mock方式则默认不开启调用顺序检测。
再看一下createNiceMock()：
第 28 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.8 easymock教程-strict和nice
Creates a mock object that implements the given interface, order checking is disabled by default, and the mock object will return 0, null or false for unexpected invocations.
和createMock()相同的是默认不开启调用顺序检测，另外有一个非常有用的功能就是对于意料之外的调用将 返回0,null 或者false.之所以说有用，是因为在我们的实际开发过程中，有时候会有这样的需求：对于某个 mock对象的调用(可以是部分，也可以是全部)，我们完全不介意调用细节，包括是否调用和调用顺序，参数， 返回值，我们只要求mock对象容许程序可以继续而不是抛出异常报告说 unexpected invocations 。nice mock在这种情况下可以为我们节省大量的工作量，非常方便。
我们来看一个简单的实际使用的例子，假设我们有一个Business类，依赖于两个service 接口：
先看只调用一个依赖的情况，注意在record阶段service1.method2()和service1.method1()的顺序和 business.executeService1()方法中的实际调用顺序是故意设置为不同的。
public class Business { private Service1 service1;
private Service2 service2;
public void executeService1() { service1.method1(); service1.method2(); }
public void executeService1And2() { service1.method1(); service1.method2();
service2.method3(); service2.method4(); }
public void setService1(Service1 service1) {
第 29 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
this.service1 = service1; }
1.8 easymock教程-strict和nice
public void setService2(Service2 service2) { this.service2 = service2; } }
private interface Service1 {
public void method1();
public void method2(); }
private interface Service2 {
public void method3();
public void method4(); }</li>
<li>普通mock
@Test public void testMock() { Business business = new Business(); Service1 service1 = EasyMock.createMock(&quot;service1&quot;, Service1.class); business.setService1(service1);
service1.method2(); EasyMock.expectLastCall(); service1.method1(); EasyMock.expectLastCall();
EasyMock.replay(service1);
第 30 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
business.executeService1(); EasyMock.verify(service1); }
1.8 easymock教程-strict和nice
测试案例可以通过，说明EasyMock.createMock()的确是不检测方法的调用顺序。 2. strict mock
@Test public void testStrictMock() { Business business = new Business(); Service1 service1 = EasyMock.createStrictMock(&quot;service1&quot;, Service1.class); ... }
案例失败，错误信息如下 java.lang.AssertionError: Unexpected method call service1.method1(): service1.method2(): expected: 1, actual: 0 at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:45) at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:73) at net.sourcesky.study.easymock.tutorial.$Proxy4.method1(Unknown Source) at net.sourcesky.study.easymock.tutorial.OrderTest$Business.executeService1(OrderTest.java:14) at net.sourcesky.study.easymock.tutorial.OrderTest.testStrictMock(OrderTest.java:79) ...... 说明strict mock下，easymock检测到了实际调用时的顺序和预期的不同。 3. nick mock
@Test public void testNiceMock() { Business business = new Business(); Service1 service1 = EasyMock.createNiceMock(&quot;service1&quot;, Service1.class);
第 31 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
... }
1.8 easymock教程-strict和nice
测试案例可以通过，而且如果是nick mock的话，record阶段可以简化：
@Test public void testNiceMockSimplify() { Business business = new Business(); Service1 service1 = EasyMock.createNiceMock(&quot;service1&quot;, Service1.class); business.setService1(service1);
EasyMock.replay(service1); business.executeService1(); EasyMock.verify(service1); }
这个简化版本的测试案例也是可以通过的。
上述的测试案例验证了strict mock和nice mock的基本使用，对于同一个mock对象，strict模式下多个方法 之间的调用顺序在record阶段和replay阶段下是需要保持一致的。但是故事并不是到此结束，更有意思的内容 在后面：如果出现多个mock对象，那么这些不同mock对象的方法之间，他们的调用顺序是否检测？普通mock 和nice mock模式下自然是不会检测顺序，但是strict模式下呢？
我们来看需要测试的方法executeService1And2()，这个方法会依次调用service1和service2的方法。使用 easymock测试这个方法，注意我们在record阶段依然故意将方法的调用顺序设置为和实际不同。</li>
<li>不使用control，直接创建两个strict mock对象
@Test public void testWithoutControlInWrongOrder() { Business business = new Business(); Service1 service1 = EasyMock.createStrictMock(&quot;service1&quot;, Service1.class);
第 32 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
Service2 service2 = EasyMock.createStrictMock(&quot;service2&quot;, Service2.class); business.setService1(service1); business.setService2(service2);
1.8 easymock教程-strict和nice
service2.method3(); EasyMock.expectLastCall(); service1.method1(); EasyMock.expectLastCall();
EasyMock.replay(service1, service2); business.executeService1And2(); EasyMock.verify(service1, service2); }
这个测试案例，出于意外的，通过了。easymock并没有检测service1.method1()和service2.method3()这 两个方法的调用顺序。</li>
<li>使用strict control创建两个strict mock对象
@Test public void testWithStrictControlInWrongOrder() { Business business = new Business(); IMocksControl mocksControl = EasyMock.createStrictControl(); ... }
案例失败，错误信息为： java.lang.AssertionError: Unexpected method call service1.method1(): service2.method3(): expected: 1, actual: 0 at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:45) at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:73) at net.sourcesky.study.easymock.tutorial.$Proxy4.method1(Unknown Source) at net.sourcesky.study.easymock.tutorial.OrderTest$Business.executeService1And2(OrderTest.java:19) at net.sourcesky.study.easymock.tutorial.OrderTest.testWithStrictControlInWrongOrder(OrderTest.java:218) ......
第 33 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.8 easymock教程-strict和nice
OK，easymock终于检测到service1.method1()和service2.method3()这两个方法的调用顺序和期望的不一 致了。
解释一下，EasyMock.createStrictMock()方法实际上内部是生成一个新的strict control，然后再创建mock 对象。 Service1 service1 = EasyMock.createStrictMock(&quot;service1&quot;, Service1.class); Service2 service2 = EasyMock.createStrictMock(&quot;service2&quot;, Service2.class);
这里实际是创建了两个strict control，而easymock是不会跨control进行顺序检测的。在实际使用过程中， 我们会有大量的场景需要检测多个mock之间的调用顺序(按说如果没有特殊要求，一般的测试场景默认都应该 如此),这种情况下就必须使用control, 而且必须是同一个strict control才能满足要求。
教程后面的最佳实践中有一条就是推荐使用mock control，可以跨mock对象检测方法调用顺序是一个重要 原因。
第 34 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.9 easymock教程-创建stub对象
1.9 easymock教程-创建stub对象
发表时间: 2010-11-23
前面教程中有个章节讨论到mock和stub的概念差别，一般来说easymock如其名所示，主要是用来做mock 用的，但是easymock中也提供有对stub的支持, 主要体现在 andStubAnswer(),andStubDelegateTo(),andStubReturn(),andStubThrow()和asStub()等方法的使用上。
我们来看一个实际使用的例子：
public class Business { private Service service;
private StubService stubService;
public void execute1() { if (service.execute()) { stubService.method1(); } }
public void execute2() { if (service.execute()) { stubService.method2(); } }
public void execute3() { if (service.execute()) { stubService.method1(); stubService.method2(); } }
第 35 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
public void setStubService(StubService stubService) { this.stubService = stubService; }
1.9 easymock教程-创建stub对象
public void setService(Service service) { this.service = service; } }
private interface Service { public boolean execute(); }
private interface StubService {
public String method1();
public String method2(); }
这里的Business类依赖到Service和StubService，execute1() / execute2() / execute3() 是我们需要测试的 三个方法，相同点都是必须调用service.execute()，不同点在于其后对stubService的调用各不相同。而我们假 设在这里我们只关心Business类对Service的调用是否如预期，不关心对于StubService的调用，只要程序可以 继续运行就可以了。
一个正统的做法是手工写一个StubService的stub 实现，例如：
private class StubServiceImpl { public String method1() { return &quot;&quot;; }
public String method2() { return &quot;&quot;; }
第 36 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
}
1.9 easymock教程-创建stub对象
但是如果这个接口复杂方法众多，则这个stub类不得不实现所有的其他方法，即使完全用不到，因为java的 语法限制。
可以这样使用easymock来实现stub：
public class BusinessTest {
private Business
business;
private IMocksControl mocksControl;
private Service
service;
@Before public void init() { business = new Business(); business.setStubService(prepareStubService()); mocksControl = EasyMock.createStrictControl(); service = mocksControl.createMock(&quot;service&quot;, Service.class); business.setService(service); }
private StubService prepareStubService() { StubService service = EasyMock.createMock(&quot;stubService&quot;, StubService.class); service.method1(); EasyMock.expectLastCall().andStubReturn(&quot;&quot;); service.method2(); EasyMock.expectLastCall().andStubReturn(&quot;&quot;);
第 37 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
EasyMock.replay(service); return service; }
1.9 easymock教程-创建stub对象
@Test public void testExecute1() { EasyMock.expect(service.execute()).andReturn(true); mocksControl.replay(); business.execute1(); mocksControl.verify(); }
@Test public void testExecute2() { EasyMock.expect(service.execute()).andReturn(false); mocksControl.replay(); business.execute2(); mocksControl.verify(); }
@Test public void testExecute3() { EasyMock.expect(service.execute()).andReturn(true); mocksControl.replay(); business.execute3(); mocksControl.verify(); } }
在方法prepareStubService()中，我们通过easymock创建了一个mock对象，然后和普通mock对象一样记 录了期望的行为。不同的是用andStubReturn()替代了andReturn().
然后我们直接调用EasyMock.replay(service)，注意在这个测试案例中，我们另外创建了一个mocksControl 并通过这个mocksControl创建了我们关注的Service接口的mock对象，它的record/replay/和verify()是和 StubService完全分离的。这样做的好处是在execute1() / execute2() / execute3()的测试案例中，我们完全不
第 38 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.9 easymock教程-创建stub对象
必额外关心这个stub，所有的事情在init()函数中就已经准备好了。这样做的好处显而易见，execute1() / execute2() / execute3()的测试案例中，代码和测试逻辑都简单了。
最后总结，在适当的时候使用easymock来创建stub对象，对于简化测试还是能有所帮助的。
第 39 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.10 easymock教程-放宽调用次数
1.10 easymock教程-放宽调用次数
发表时间: 2010-11-29 对于mock对象上的mock方法的调用,easymock支持指定次数，默认为1，例如
Easymock.expect(mock.method1()).andReturn(...);
这里没有显式的指定调用次数，因此效果等同于
Easymock.expect(mock.method1()).andReturn(...).once();
同时easymock提供了其他的方法，用于指定具体调用次数或者放宽调用次数检验。</li>
<li>once() 如果明确调用次数为1，则可以使用这个方法显式指定，也可以省略，easymock默认为1。</li>
<li>atLeastOnce() 指定调用为1次或者多次，即 count &gt;= 1.</li>
<li>anyTimes() 容许调用次数为任意次，即 count &gt;= 0.</li>
<li>times(int count) 直接指定调用次数</li>
<li>times(int min, int max) 这个方法比较灵活，可以指定最小次数和最大次数。
第 40 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.10 easymock教程-放宽调用次数
其他的方法都可以视为这个方法的变体，比如 once()等价于times(1,1) atLeastOnce()等价于times(1,Integer.MAX_VALUE) anyTimes()等价于times(0,Integer.MAX_VALUE) times(int count)等价于times(count,count)
实际使用中根据具体要求可以灵活选用上述方法来指定我们期望的调用数次。
第 41 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.11 easymock教程-参数匹配
1.11 easymock教程-参数匹配
发表时间: 2010-11-29 easymock中提供了非常多的方法来实现参数匹配，基本能满足一般参数匹配的要求。 我们来具体看一下到底有哪些方法：
(1) 基于基本类型的比较</li>
<li>eq(X value)方法, X 可以是boolean,byte,char, double,float,int,long,short,T 有多个重载方法，支持基本类型如boolean, byte,char, double,float,int, long,short，后面会介绍它也 支持Object比较。 这个eq()方法的用法直接了当，基本数值直接比较数值，对于非整型的double和float，由于存在精度 的问题，因此增加了以下两个方法来指定比较精度。
eq(double value, double delta) eq(float value, float delta)</li>
<li>aryEq(X[] values) X 可以是boolean,byte,char, double,float,int,long,short,T 这个是eq(X value)方法的数组版本，要求比较的两个数组拥有相同的长度，然后每个元素都&quot;相同&quot;，即 都可以满足eq(X value)方法。 注意到double和float并没有像eq(X value)方法那样提供可以设置精度的重载版本，不知道在数组比较 时如何去设置容许精度。</li>
<li>gt(X value), lt(X value), X 可以是byte,double,float,int,long,short 这两个方法用于参数的大小匹配，适用于数值型的基本类型如byte,double,float,int,long,short。</li>
<li>geq(X value), leq(X value)
第 42 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.11 easymock教程-参数匹配
类似gt()和lt()，无非是将&quot;&gt;&quot;改为&quot;&gt;=&quot;, &quot;&lt;&quot;改为&quot;&lt;=&quot;。</li>
<li>anyX(), X可以是Boolean, Byte, Char, Double, Float, Int, Long, Short 这是一个宽松的匹配方法，任何数值都被视为匹配OK。这个方法在我们不介意参数值时特别有用。
(2) 基于对象的比较</li>
<li>eq(T value)方法 和基本类型类似，不过对于Object，是通过调用equals()方法来进行比较。</li>
<li>same(T value) 方法 和eq()不同，same()是通过比较对象引用来进行比较的。类似java代码中, a.equals(b)和a == b的差 别。</li>
<li>anyObject() 和 anyObject(Class<T> clazz) 类似基本类型的any/<em>/</em>/*()方法，非常宽松，在我们不介意参数值时使用。 使用方式有三种: (T)EasyMock.anyObject() // 强制类型转换 EasyMock.<T> anyObject() // 固定返回的泛型 EasyMock.anyObject(T.class) // 在参数中指定返回的泛型</li>
<li>isA(Class<T> clazz) 和anyObject(Class<T> clazz) 非常，唯一一个差别在于当输入参数为null时，anyObject(Class<T> clazz)返回true而isA(Class<T> clazz) 返回false。
第 43 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.11 easymock教程-参数匹配
(3) 逻辑计算 easymock支持在参数匹配时进行一些简单的逻辑计算, 如and(), or (), not()。
not()容易理解，取反而已。or()也容易理解，两个匹配方法匹配一个即可。而and()匹配方法通常用于设置取 值区间，典型如and(gt(0), lt(5))) 的写法可以设置期望值大于0而小于5，即(0,5)区间。
此外在参数匹配中，有几个特殊角色，享受的待遇与众不同，easymock为它们提供了专有方法。</li>
<li>Comparable 对于实现了Comparable接口的对象，easymock提供了一系列的专用方法来处理，包括eq, gt, lt, geq, leq：
cmpEq(Comparable<T> value) gt(Comparable<T> value) lt(Comparable<T> value) geq(Comparable<T> value) leq(Comparable<T> value) 这个特殊处理非常合理，本来Comparable接口就提供了比较的功能，在参数匹配时应该容许直接使用。</li>
<li>string 由于字符串匹配使用的场景非常多，因此easymock为此也提供了几个常见的参数匹配方法：
contains(String substring) startsWith(String prefix) endsWith(String suffix) find(String regex) 其中contains/startsWith/endsWith是简单的字符串查找，而find()则通过支持正则表达式来提供复杂匹配。
第 44 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.11 easymock教程-参数匹配</li>
<li>null 对于Object匹配，很常见的一个场景就是输入的参数为null，easymock中提供isNull() 和 notNull() 两个 方法来完成对null值的匹配。
开发中，经常会遇到下面这种场景，期望输入的参数满足isA()或者容许为null。而直接使用isA()，是不能 支持null的，即如果参数为null时isA()会报不匹配。这个不是easymock的bug，而是刻意而为，解决的方法是 使用 or(isA(...), isNull(...))或者anyObject()。
service.execute((ClassA) EasyMock.or(EasyMock.isA(ClassA.class), EasyMock.isNull())); service.execute(EasyMock.anyObject(ClassA.class));
第 45 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.12 easymock教程-partial class mocking
1.12 easymock教程-partial class mocking
发表时间: 2010-11-30 easymock中提供对于类的mock功能，我们可以方便的mock这个类的某些方法，指定预期的行为以便测试 这个类的调用者。这种场景下被mock的类在测试案例中扮演的是次要测试对象或者说依赖的角色，主要测试对 象是这个mock类的调用者。但是有时候我们需要将这个测试类作为主要测试对象，我们希望这个类中的部分 (通常是大部分)方法保持原有的正常行为，只有个别方法被我们mock掉以便测试。</li>
<li>使用方法
我们先来看看这个partial class mocking 是如何工作的：
public class Service {
public void execute() { actualMethod(); needMockMethod(); }
void actualMethod() { System.out.println(&quot;call actualMethod()&quot;); }
public void needMockMethod() { System.out.println(&quot;call needMockMethod()&quot;); }
}
我们给出了一个非常简单的类，我们将要测试execute()方法，期望能测试到actualMethod()这个方法的正常 行为，然后需要mock掉needMockMethod().
public class PartialClassMockTest extends Assert {
第 46 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
@Test public void testPartialMock() {
1.12 easymock教程-partial class mocking
Service service = EasyMock.createMockBuilder(Service.class).addMockedMethod(&quot;needMockMethod&quot;).createMock(); service.needMockMethod(); EasyMock.expectLastCall();
EasyMock.replay(service); service.execute(); EasyMock.verify(service); } }
上面的测试案例运行通过，输出为&quot;call actualMethod()&quot;，没有&quot;call needMockMethod()&quot;，说明我们设置 的mock生效了。我们创建的mock类的确是只有部分我们制定的方法是mock的，其他都是正常行为。
再来看看为什么我们要需要partial class mocking 这个功能？为什么需要mock掉其中的一个方法？
我们来看看下面这个更加真实的例子：
public class Service {
public String execute2() { return getConfiguration(); }
public String getConfiguration() { return Configuration.getUsername(); } }
public class Configuration { public static String getUsername() { //ignore the code to get configuration from file or database return &quot;username&quot;;
第 47 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
} }
1.12 easymock教程-partial class mocking
这里例子中，需要测试的 execute2()方法需要调用getConfiguration()方法，而getConfiguration()方法则 调用了Configuration的静态方法来获取配置信息。我们假设读取配置的代码比较复杂不能直接在单元测试环境 下运行，因此通过情况下这里的execute2()方法就会因为这个getConfiguration()而造成无法测试。因此我们可 以考虑通过partial class mocking的功能来mock掉getConfiguration()方法从而使得我们的测试案例可以覆盖 到execute2()方法
@Test public void testStaticMethod() {
Service service = EasyMock.createMockBuilder(Service.class).addMockedMethod(&quot;getConfiguration&quot;).createMock(); EasyMock.expect(service.getConfiguration()).andReturn(&quot;abc&quot;);
EasyMock.replay(service); assertEquals(&quot;abc&quot;, service.execute2()); EasyMock.verify(service); }
这个测试案例可以正常通过，我们通过partial class mocking成功的避开了getConfiguration()这个绊脚 石。
当然这里的实例代码本身就有点问题，应该采用DI的方法将configuration注入进来，而不是在内部通过静态 方法来获取。因此一个建议是在使用partial class mocking功能前，先看看是不是可以通过重构来显改进测试 类。只有当我们有足够充分的不得已的理由时，才使用partial class mocking这种变通(或者说取巧)的方式来解 决问题。</li>
<li>限制
上面两个例子中，我们仔细看看会发现，被mock的方法都是public的。我们试着将方法修改为protected和 default，partial class mocking依然生效。但是修改为private之后，则抛出异常：
第 48 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.12 easymock教程-partial class mocking
java.lang.IllegalArgumentException: Method not found (or private): needMockMethod at org.easymock.internal.MockBuilder.addMockedMethod(MockBuilder.java:75) at net.sourcesky.study.easymock.tutorial.PartialClassMockTest.testPartialMock(PartialClassMockTest.java:52)
或者将mock的方法继续保持public，但是加上final，则抛出以下异常：
java.lang.IllegalStateException: no last call on a mock available at org.easymock.EasyMock.getControlForLastCall(EasyMock.java:521) at org.easymock.EasyMock.expectLastCall(EasyMock.java:512) at net.sourcesky.study.easymock.tutorial.PartialClassMockTest.testPartialMock(PartialClassMockTest.java:54)
我们回到之前的章节，class mocking里面讲述了class mocking的一些限制：private方法和final方法是不能 mock的。partial class mocking下这些限制依然存在。因此，为了开启partial class mocking，我们不得不稍 微破坏一下类的封装原则，对于原本应该是private的方法，修改为protected或者default。 不得不再次申明，partial class mocking不是一个足够好的解决方案，它只适合在不得已的情况下使用，不 要太依赖这个特性。重构代码改善代码才是王道。 3. 疑问 另外class mocking中还讲到，对于类的equals(), toString()和hashCode()这三个方法，class mocking下是 easymock为这三个方法内建了easymock的实现，因此也不能mock。而partial class mocking，这三个方法 同样不能mock，但是easymock不再为它们内建实现，而是使用它们正常的功能。
关于这点还是有一点疑问，我在easymock的官方文档中看到以下描述 Remark: EasyMock provides a default behavior for Object&#39;s methods (equals, hashCode, toString). However, for a partial mock, if these methods are not mocked explicitly, they will have their normal behavior instead of EasyMock default&#39;s one.
第 49 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.12 easymock教程-partial class mocking
言下之意，似乎equals, hashCode, toString这三个方法还是可以显式mock的。但是我测试了一下：
public class Service {
public String execute3() { actualMethod(); return toString(); }
@Override public String toString() { return &quot;defaultToString()&quot;; } }
@Test public void testToStringMethod() { Service service = EasyMock.createMockBuilder(Service.class).addMockedMethod(&quot;toString&quot;).createMock(); EasyMock.expect(service.toString()).andReturn(&quot;abc&quot;); EasyMock.replay(service); assertEquals(&quot;abc&quot;, service.execute3()); EasyMock.verify(service); }
toString()方法的mock没能生效，抛出异常:
java.lang.IllegalStateException: no last call on a mock available at org.easymock.EasyMock.getControlForLastCall(EasyMock.java:521) at org.easymock.EasyMock.expect(EasyMock.java:499) at
net.sourcesky.study.easymock.tutorial.PartialClassMockTest.testToStringMethod(PartialClassMockTest.java:
可以看到明显是EasyMock.expect(service.toString()).andReturn(&quot;abc&quot;); 这里的record没有成功。
第 50 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.13 easymock教程-运行时返回值或者异常
1.13 easymock教程-运行时返回值或者异常
发表时间: 2010-11-30 前面的教程中，我们看到easymock可以通过expect方法来设定mock方法的返回值或者异常，但是注意这 些案例中设置的返回值都是在调用被测试的类的方法前就已经确定下来的，即我们其实在测试类的代码运行前 (实际是在EasyMock.replay()方法调用前)就已经&quot;预知&quot;了返回结果。
但是在某些情况下，我们可能无法预知返回值，比如我们需要根据输入的参数值来决定返回什么，而这个参 数可能无法在record阶段获得。因此在mock方法中我们无法在record阶段就决定应该返回什么。
对于这种场景，easymock提供了IAnswer接口和andAnswer()方法来提供运行时决定返回值或者异常的机 制。
我们来看一个简单的例子：
public class Business { private Service service;
public void execute() { int count = ramdonInt(); int result = service.execute(count); }
public void setService(Service service) { this.service = service; }
private int ramdonInt() { Random random = new Random(); return random.nextInt() / 10000; } }
第 51 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
public interface Service { public int execute(int count); }
1.13 easymock教程-运行时返回值或者异常
在Business的execute()方法中，需要调用service.execute(int count)方法，而传入的参数count是需要运行 时才能确定的，这里为了简单我们random了一个int来模拟这种情况。
然后看测试案例
@Test public void testRuntimeReturn() { Business business = new Business(); Service service = EasyMock.createMock(Service.class); business.setService(service); EasyMock.expect(service.execute(EasyMock.anyInt())).andAnswer(new IAnswer<Integer>() { public Integer answer() throws Throwable { Integer count = (Integer) EasyMock.getCurrentArguments()[0]; return count /<em> 2; } });
EasyMock.replay(service); business.execute(); EasyMock.verify(service); }
这里我们通过EasyMock.expect(service.execute(EasyMock.anyInt()))来接受任意值的count参数输入， andAnswer(new IAnswer<Integer>() {}) 让我们可以指定一个IAnswer的实现类来给出返回值。在这个 IAnswer的实现类中，我们通过EasyMock.getCurrentArguments()[0]获取到service.execute()方法的第一个 参数，然后简单的运用count/</em>2规则给出返回值。这里的EasyMock.getCurrentArguments()方法可以获取到 运行时的参数列表，不过注意这个方法对重构不够友好，如果参数列表发生变化则必须手工修改对象的获取参 数的代码。
下面是一个运行时抛出异常的例子，简单起见我们通过设置exception的message来在错误信息中传递运行 时的count值。
第 52 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
@Test public void testRuntimeException() { Business business = new Business(); Service service = EasyMock.createMock(Service.class); business.setService(service);
1.13 easymock教程-运行时返回值或者异常
EasyMock.expect(service.execute(EasyMock.anyInt())).andAnswer(new IAnswer<Integer>() { public Integer answer() throws Throwable { Integer count = (Integer) EasyMock.getCurrentArguments()[0]; throw new RuntimeException(&quot;count=&quot; + count); } });
EasyMock.replay(service); try { business.execute(); fail(&quot;should throw RuntimeException&quot;); } catch (RuntimeException e) { assertTrue(e.getMessage().indexOf(&quot;count=&quot;) != -1); //get count from message EasyMock.verify(service); } }
除了IAnswer接口外，easymock中还有另外一个方式可以完成类似的功能，就是使用andDelegate()方法，
public class ServiceStub implements Service { public int execute(int count) { return count /* 2; } }
@Test public void testRuntimeReturn() { Business business = new Business(); Service service = EasyMock.createMock(Service.class); business.setService(service); EasyMock.expect(service.execute(EasyMock.anyInt())).andDelegateTo(new ServiceStub());
第 53 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
EasyMock.replay(service); business.execute(); EasyMock.verify(service); }
1.13 easymock教程-运行时返回值或者异常
这里需要先创建一个Service类的实现类和一个实例，然后通过andDelegateTo()将这个stub的实例传进去， 注意这里delegate进去的实例必须是mock对象接口相同。
delegateTo方式实际上是我们手工创建了stub(mock和stub的概念及差别请参考本教程的&quot;mock和stub&quot;一 文)，这和我们使用easymock的初衷有所违背。而且当这个接口有众多方法时，创建这样一个stub会显得很痛 苦，不如使用IAnswer方便直接。
第 54 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.14 easymock教程-改变同一个方法调用的行为
1.14 easymock教程-改变同一个方法调用的行为
发表时间: 2010-11-30 在easymock中，对于mock对象的同一个方法，可以为每一次的调用定制不同的行为。在record阶段 easymock会精确的记录我们录入的行为，基于每一次的方法调用。
这里有一个官网文档中的例子：
expect(mock.voteForRemoval(&quot;Document&quot;)) .andReturn((byte) 42).times(3) .andThrow(new RuntimeException()).times(4) .andReturn((byte) -42);
对于mock.voteForRemoval(&quot;Document&quot;)方法的调用，.andReturn((byte) 42).times(3) 表明前3次调用将 返回42，.andThrow(new RuntimeException()).times(4)表示随后的4次调用(第4,5,6,7次)都将抛出异常， andReturn((byte) -42)表示第8次调用时将返回-42。
我们来验证一下:
public class ChangeBehehaviorTest extends Assert { private static interface Service { public byte voteForRemoval(String name); }
@Test public void testExecute() { final String name = &quot;Document&quot;;
Service mock = EasyMock.createMock(&quot;service&quot;, Service.class);
EasyMock.expect(mock.voteForRemoval(&quot;Document&quot;)).andReturn((byte) 42).times(3).andThrow(new RuntimeException .times(4).andReturn((byte) -42);
第 55 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
EasyMock.replay(mock);
1.14 easymock教程-改变同一个方法调用的行为
for (int i = 0; i &lt; 3; i++) { assertEquals(42, mock.voteForRemoval(name)); } for (int i = 0; i &lt; 4; i++) { try { mock.voteForRemoval(name); fail(&quot;should throw RuntimeException&quot;); } catch (RuntimeException e) {
} } assertEquals(-42, mock.voteForRemoval(name)); EasyMock.verify(mock); } }
测试案例顺利通过。
第 56 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.15 easymock教程-自定义参数匹配器
1.15 easymock教程-自定义参数匹配器
发表时间: 2010-11-30 虽然easymock中提供了大量的方法来进行参数匹配，但是对于一些特殊场合比如参数是复杂对象而又不能 简单的通过equals()方法来比较，这些现有的参数匹配器就无能为力了。easymock为此提供了 IArgumentMatcher 接口来让我们实现自定义的参数匹配器。
我们还是用例子来说话：
public interface Service { public void execute(Request request); }
service类的execute()方法接收一个Request实例作为参数, Request是一个javabean:
public static class Request {
private boolean condition;
private String value1;
private String value2;
//ignore getter and setter method }
假设在我们的这个单独的测试案例中，我们有以下参数匹配逻辑: 如果condition为true，则只需要比较 value1；如果condition为false，则只需要比较value2. 由于这个逻辑和默认的equals方法不一致，因此我们不 能直接使用equals方法，只能实现自己的参数匹配器。
public class RequestMatcher implements IArgumentMatcher {
private boolean condition;
private String expectedValue;
第 57 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
private RequestMatcher(boolean condition, String expectedValue) { this.condition = condition; this.expectedValue = expectedValue; }
1.15 easymock教程-自定义参数匹配器
@Override public void appendTo(StringBuffer buffer) { buffer.append(&quot;RequestMatcher expect(condition=&quot;); buffer.append(condition); buffer.append(&quot; expectedValue=&quot;); buffer.append(expectedValue); buffer.append(&quot;)&quot;); }
@Override public boolean matches(Object argument) { if (!(argument instanceof Request)) { return false; }
Request request = (Request) argument; if (condition) { return expectedValue.equals(request.getValue1()); } else { return expectedValue.equals(request.getValue2()); } }
public static Request requestEquals(boolean condition, String expectedValue) { EasyMock.reportMatcher(new RequestMatcher(condition, expectedValue)); return null; } }
RequestMatcher 是我们定义的参数匹配器，matches()方法中是参数匹配逻辑的代码实现，appendTo()方 法用于在匹配失败时打印错误信息，后面我们会演示这个方法的使用。然后是最重要的方法requestEquals()， 在这里我们通过调用EasyMock.reportMatcher()告诉easymock我们要用的参数匹配器。
第 58 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.15 easymock教程-自定义参数匹配器
在测试案例中，我们和以往一样，先创建了mock对象，然后准备request对象作为测试数据。不同的是，我 们没有使用easymock提供的参数匹配方法，而是通过 service.execute(RequestMatcher.requestEquals(expectedCondition, expectedValue)); 来调用 EasyMock.reportMatcher()，以创建我们自定义的参数匹配器并为它传入了两个必备的参数 expectedCondition和expectedValue。
上面的测试案例可以顺利通过，我们的参数匹配器可以正常工作。然后我们来试试参数匹配不成功的情况
@Test public void testConditionTrueFailure() { final boolean expectedCondition = true; final String expectedValue = &quot;aaa&quot;;
Service service = EasyMock.createMock(&quot;service&quot;, Service.class); Request request = prepareRequest(expectedCondition, &quot;bbb&quot;, &quot;ccc&quot;); service.execute(RequestMatcher.requestEquals(expectedCondition, expectedValue)); EasyMock.expectLastCall();
EasyMock.replay(service); service.execute(request); EasyMock.verify(service); }
注意在Request request = prepareRequest(expectedCondition, &quot;bbb&quot;, &quot;ccc&quot;)中，我们故意设置value为 和期望的不同，当然这样测试案例就通不过了:
java.lang.AssertionError: Unexpected method call service.execute(net.sourcesky.study.easymock.tutorial.IArgumentMatcherTest$Request@10ef90c): service.execute(RequestMatcher expect(condition=true expectedValue=aaa)): expected: 1, actual: 0 at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:45) at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:73)
第 59 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.15 easymock教程-自定义参数匹配器
at $Proxy4.execute(Unknown Source) at
net.sourcesky.study.easymock.tutorial.IArgumentMatcherTest.testConditionTrueFailure(IArgumentMatcherT
注意&quot;service.execute(RequestMatcher expect(condition=true expectedValue=aaa)): expected: 1, actual: 0&quot;这行，其中的&quot;RequestMatcher expect(condition=true expectedValue=aaa)&quot;是我们在 appendTo()方法中构建出来的错误信息。appendTo()方法只在这个时候才被调用，用于生成可读性强的错误 信息以便我们在失败时检查，因此不要疏忽了这个方法的实现。
第 60 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.16 easymock教程-命名mock对象
1.16 easymock教程-命名mock对象
发表时间: 2010-11-29 在创建mock对象的时候，我们可以命名mock对象。
前面我们谈到easymock中有三种mock对象，分别用下面三个方法创建:
createMock(Class<T> toMock) createStrictMock(Class<T> toMock) createNiceMock(Class<T> toMock)
带有命名功能的方法也有对应的三种:
createMock(String name, Class<T> toMock) createStrictMock(String name, Class<T> toMock) createNiceMock(String name, Class<T> toMock)
命名mock对象有什么好处呢？其实就是一点，即在当测试案例因为某个mock对象的状态或行为不符合要求 而失败的时候，在异常信息里面可以输出这个mock对象的名称。
我们用实际的例子来看，同样是创建一个mock对象，然后调用一个没有record的方法，easymock报错退出 的测试案例。</li>
<li>不命名
Service service = EasyMock.createMock(Service.class);
异常信息如下： java.lang.AssertionError: Unexpected method call execute(): at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:45) at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:73)
第 61 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.16 easymock教程-命名mock对象
at net.sourcesky.study.easymock.tutorial.$Proxy4.execute(Unknown Source) at net.sourcesky.study.easymock.tutorial.NamingMockTest$Business.execute(NamingMockTest.java:11) at net.sourcesky.study.easymock.tutorial.NamingMockTest.testExecute(NamingMockTest.java:31) ...... 这里的错误信息&quot;Unexpected method call execute()&quot;，只指出了发生错误的是execute()方法，并未指出具 体是哪个mock对象。 当测试案例简单时，比如就一两个mock对象，我们可以直接从方法名上就看出是哪个mock对象。但是当 mock对象多了之后，尤其是方法很多的时候，就会浪费时间。</li>
<li>命名后
Service service = EasyMock.createMock(&quot;service&quot;, Service.class);
异常信息如下： java.lang.AssertionError: Unexpected method call service.execute(): at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:45) at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:73) at net.sourcesky.study.easymock.tutorial.$Proxy4.execute(Unknown Source) at net.sourcesky.study.easymock.tutorial.NamingMockTest$Business.execute(NamingMockTest.java:11) at net.sourcesky.study.easymock.tutorial.NamingMockTest.testExecute(NamingMockTest.java:30)
差别只在错误信息中&quot;Unexpected method call serviceMock.execute()&quot; 包含serviceMock的字样，因此我 们可以快递定位到具体的mock对象。
命名mock对象在初次编写测试案例时用处还不是很明显，因为编写者当时肯定对代码很熟悉。但是当另外一 个开发人员因为某此修改代码造成测试案例不能通过时，由于这个开发人员对代码的熟悉程度不够，因此命名 mock对象可以对他有所帮助，方便维护。
第 62 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.16 easymock教程-命名mock对象
命名之后的mock对象，还有一个特殊的地方就是toString()方法将返回该mock对象的名称，以代码为例:
Service service = EasyMock.createMock(&quot;service&quot;, Service.class); System.out.println(service.toString());
输出就是&quot;service&quot;，对比不命名mock对象的情况：
Service service = EasyMock.createMock(Service.class); System.out.println(service.toString());
得到的输出是&quot;EasyMock for interface net.sourcesky.study.easymock.tutorial.NamingMockTest$Service&quot;.
第 63 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.17 easymock教程-使用MockControl
1.17 easymock教程-使用MockControl
发表时间: 2010-10-26 在easymock中，通常我们使用一下的代码来创建mock对象
IMyInterface mock = createStrictMock(IMyInterface.class); replay(mock); verify(mock); reset(mock);
如果需要mock多个对象，则需要如此:
IMyInterface1 mock1 = createStrictMock(IMyInterface1.class); IMyInterface2 mock2 = createStrictMock(IMyInterface2.class); IMyInterface3 mock3 = createStrictMock(IMyInterface2.class); ... replay(mock1, mock2, mock3, ...); verify(mock1, mock2, mock3, ...); reset(mock1, mock2, mock3, ...);
不仅需要为每个mock对象增加create语句，而且需要为这个新增的mock对象更新replay()/verify()/reset() 方法，比较啰嗦，而且容易出错。
这种情况下可以考虑使用MocksControl来简化代码：
IMocksControl mocksControl = createControl(); IMyInterface1 mock1 = mocksControl.createMock(IMyInterface1.class); IMyInterface2 mock2 = mocksControl.createMock(IMyInterface2.class); IMyInterface3 mock3 = mocksControl.createMock(IMyInterface3.class); ... mocksControl.replay(); mocksControl.verify(); mocksControl.reset();
IMocksControl接口容许创建多个mock对象，这些创建的对象自动关联到这个mocksControl实例上，以后
第 64 / 65 页
<img src="" alt=""> <a href="http://skydream.javaeye.com" target="_blank">http://skydream.javaeye.com</a>
1.17 easymock教程-使用MockControl
再调用replay()/verify()/reset()时就不需要逐个列举出每个mock对象。当mock对象比较多，尤其是原有代码 上新增mock 对象时非常方便。 事实上，Easymock.createMock()方法内部实现也是使用IMocksControl的:
public static <T> T createMock(final Class<T> toMock) { return createControl().createMock(toMock); }
public static IMocksControl createControl() { return new MocksControl(MocksControl.MockType.DEFAULT); }
除了使用方便外，使用IMocksControl还有另外一个重要的好处，就是如果使用strict control，则可以跨多 个mock对象检测方法的调用顺序，具体的内容请参考本教程中的&quot;strict和nice&quot;一文。
第 65 / 65 页</li>
</ol>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_总结类/">Java_总结类</a></li><li><a href="/categories/Java&J2EE/Java_总结类/easy-mock/">easy-mock</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_总结类/" class="label label-success">Java_总结类</a><a href="/tags/easy-mock/" class="label label-info">easy-mock</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类-easy-mock--easymock教程/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_总结类-easy-mock--easymock教程" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-敏捷开发--结对编程（Pairprogramming）/">结对编程（Pair programming）</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-敏捷开发--结对编程（Pairprogramming）/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-pair-programming-">结对编程（Pair programming）</h1>
<p>在敏捷软件开发的各种实践中，结对编程（Pair Programming，下文简称Pair）是特别有争议的。Pair有一个特点，那就是还没有进行过任何Pair实践前，你很可能对它已经有了“喜欢” 或者是“讨厌”的印象。如果有人问你，你喜欢持续集成吗？你多半会回答：不是很肯定，需要试试看。但如果有人问你，你喜欢Pair吗？我猜你会马上给予明 确的肯定或否定的回答。喜欢它的人会觉得好处多多而成本低低，不喜欢它的人会觉得讨厌得难以想象。喜欢与不喜欢都可以形成强大的阵营，两边都不乏重量级的 高手。Pair的优点说起来都很明显，比如：快速反馈，更好的设计，甚至更高的效率等等。但据我了解，不喜欢Pair的人基本上都承认Pair有优点，只 是他们通常会提出反对意见，比如：Pair要求两个人协调一致，每个人的作息时间需要同步，如果一个人请假，那另一个人怎么办？等待就太浪费时间了，如果 自己一个人做那就不是Pair了；或者也有很多人感觉到Pair的时候特别累，不像一个人工作那样自主，写一小时程序，上十分钟微博，两个人同一台电脑工 作自由就小多了。</p>
<p>我所在的公司是Pair的实践者，对于喜欢Pair或者不喜欢Pair的各种原因和心态我都有切身的体 会。在实践中，我们并没有完全一成不变地照搬Kent Beck在《Extreme Programming Explained》书中所定义的Pair模式（Driver Observer模式）。因为，Pair毕竟是一种实践方法，可以供我们在软件开发中参考，而不必像对待科学理论一样教条。另外，我认为要让这种实践方法 发挥它的威力，消除人们心中的讨厌甚至是恐惧情绪是首先要解决的问题，甚至我们可以为此修改一些Pair的传统做法。下面我先来大致描述一下我们的实践模 式（<strong>Owner Supporter模式</strong>）：</p>
<p><strong>&lt;阶段1-Pair形成&gt;</strong></p>
<p>Team 在接到一个大的Story后经过讨论并分解任务形成一个个粒度适中的Task。Task的粒度一般在几小时到一两天这种级别，涉及的代码规模大约是几行到 几个类/函数。每一个Task，都有一个Owner作为责任人，这是和传统单兵开发模式相同的。不过，Owner的产生一般不是由ScrumMaster 来分配指定，而是Team成员自发地去协商选择适当的任务。Owner拿到Task以后会从Team中找一个Supporter，形成Pair。这也是一 个自发协商过程，没有强制指定，也没有固定的搭档，这样形成的Pair一般会是配合最默契也最适合相应Task的。</p>
<p><strong>&lt;阶段2-初始讨论&gt;</strong></p>
<p>Pair 形成以后， 一般是由Owner先分析需求，设计测试，并初步分析思考得出初步的设计思路。这时，Supporter可以暂时先不了解需求。然后Owner邀请 Supporter一起，向Supporter介绍需求和自己的设计思路。Supporter这时需要帮助Owner理解需求，设计测试，对设计方案提出 反馈意见，或者提出新的设计。讨论的理想结果是两人达成一致形成最终的设计方案，如果两人分歧严重不能达成一致则需要更多的人参与，比如：可以举行一个小 型的技术讨论会议把讨论扩大到整个Team。</p>
<p><strong>&lt;阶段3-具体实现&gt;</strong></p>
<p>这一阶段是根据讨论得出的设计方案开始编程实现。在经典Pair Programming中，两个人是在同一台电脑前一起工作，并不时地交换；但我们的实践发现这一点是特别容易让人疲倦，感觉不自在，从而抵触Pair的 最大因素。所以，我们在实践过程中，除了少数情况，基本上没有采用全程Pair工作，而是由Owner一个人完成。当然，如果Owner遇到了一些设计中 考虑不完善的地方，他可以随时再和Supporter讨论。</p>
<p><strong>&lt;阶段4-Review&gt;</strong></p>
<p>具 体实现完成以后，Owner又会邀请Supporter来review自己的工作。这个过程一般是借助版本控制工具对比代码改动，Supporter从实 现的角度来审查实现是否符合设计，有没有可以直接观察到的bug和潜在的问题。如果发现问题并讨论确认，Owner再做相应的改动，再Review。最终 Supporter不能review出问题了，Owner提交代码。</p>
<p><strong>&lt;阶段5-维护&gt;</strong></p>
<p>虽 然经过了讨论和review， 但在后续的测试或者上线后仍然会陆续发现问题，这时就涉及到维护工作。维护工作依然是由Owner牵头，分析log，看代码，重现，修正；但 是，Owner也可以随时邀请Supporter参与分析讨论，至少在Owner准备修改原先的代码时应该要告诉Supporter“原先我们某个地方没 有考虑周全，有什么什么问题，我打算怎么怎么改动”。这个过程好像又回到了阶段2，然后阶段3，阶段4 ... 开发中还有一种可能是，原先的Supporter或Owner已经不在Team内了，这时就需要加入一个新人形成Pair，有经验的人应该向自己的新搭档 介绍Task的相关背景。当然，还很有可能碰到根本没有熟悉该模块的人了，这时就必须形成一个新的Pair，把维护作为一项新Task。</p>
<p>上面基本上就是我们的Pair实践模式了。这种模式基本上还是保留了大部分经典Pair模式的要点，主要的区别在于：</p>
<p><strong>1. 把Pair的形成纳入Scrum框架的任务划分过程。</strong>Scrum通常会在Sprint的计划会议中将大的User Story拆分成许多小的Task，每个Task一般对应几小时到一两天的工作量。Task列表出来以后，Team自发协商每个Task形成一个 Pair，整个过程一般没有管理者的直接干预。Story的背景需要Team中的每个人都了解，Task的细节由Pair负责。Pair的效果通常也依赖 于Task的合理划分。</p>
<p><strong>2. 避免全程Pair。</strong>因为，全程Pair在实践和心理上会遇到很多问题，比如：时间同步问题，并行工作问题，不自在感问题。避免全程Pair可以使得 Owner和Supporter的时间安排更加灵活，增加并行性，减少不自在感。大部分不喜欢Pair的人基本上都是尤其不喜欢全程Pair，所以这项改 动对于吸引更多的人采用Pair具有重要的意义。</p>
<p><strong>3. 区分Owner和Supporter的职责。</strong>经典Pair模式中Driver和Observer角色是随时交换的，也就是说对于一个Task来讲两个人的 职责是相同的，这样可以减小每一个人的压力，但又容易造成缺乏责任感。Owner Supporter模式是单兵模式和经典Pair模式之间的一种妥协，试图在责任和压力之间找到一种平衡。Owner是驱动整个过程的主导，并且是主要的 具体实现者；Supporter以辅助为主，在讨论和review的时候可以站在不同的角度帮助Owner。<strong>Supporter并非没有责任，熟悉Task的所有细节是Supporter的责任。</strong>当Owner由于请假或忙于其他事物时，Supporter应该立即可以代替Owner处理Task的实现或维护。如果Supporter做不到完全的backup，这就是Supporter的失职，在整个Team和领导的心中应该有这样的认识。</p>
<p>最后，除了显而易见的“引入反馈，提高质量”等很“官方”的优点外，我从管理者和开发人员的角度分别总结一下Owner Supporter模式的“不为人知”却真正很有价值的优点。</p>
<p><strong>管理者角度：</strong></p>
<p><strong>1. 应对人员变动：</strong>每个模块至少两个人熟悉，这样在有人请假的时候都有backup，不会造成严重的耽误工作进度。如果有人要离职，交接工作通常也会非常轻 松，几乎没有什么需要特别交接的。很多项目都缺乏文档，只有实现的人知道怎么回事，而即使有文档也总有不清楚的地方，所以留住熟悉的人就是留下了活文档。</p>
<p><strong>2. 增加对质量的信心：</strong>相比单兵作战模式，即使是不懂技术的管理者，Pair也可以自然地增加他们对于软件质量的信心，毕竟“三个臭皮匠顶个诸葛亮”。另外， 需要特别提到的是安全性问题。我曾经听说过一个电信计费项目，一个开发人员故意留了一个漏洞，把钱自动打入自己的银行卡，最终为公司带来了麻烦。如果采用 Pair方式，这种情况就不那么容易发生。</p>
<p><strong>3. 增加反馈：</strong>对于同一个事物，不同的人也会有不同的看法，这是很正常的现象。比如，在对问题进行估计时一个人乐观，一个人悲观，这时管理层可以同时参考他们的意见，对问题掌握得更加全面。</p>
<p><strong>4. 代替培训：</strong>相比传统课程或讲座式培训，Pair能让新员工更快地适应项目。Pair方法也和一些公司采用的导师制有明显的区别。导师制更强调师傅带徒弟， 而Pair则不然。在实践中，我们更鼓励基础比较好的新员工多做Owner，老员工作为Supporter支持；只对基础比较差的新员工先从 Supporter做起，然后逐步过渡到Owner。这样做是因为新员工一般积极性比较高，适合承担更多的具体工作，而老员工则应该避免重复劳动，而是以 辅助和指导为主。另外，新员工也可能带来一些新的思想、方法和技能，这些反而是老员工应该学习的。<em>**</em></p>
<p><strong>开发人员角度：</strong></p>
<p><strong>1. 分担压力，增加默契：</strong>Task依然具有明确的责任人，但Supporter可以分担Owner的压力，即使是Team内的技术高手有一个人做backup也是有益的。有人讨论有人支持更容易达到良好的工作效果，而大家相互Support也可以让团队更加默契。</p>
<p><strong>2. 消除经典Pair的不自在感：</strong> Owner Supporter模式与经典Pair的Driver Observer模式相比更少存在不自在感，因为整个过程是Owner主导的，他有更多的自由安排什么时候讨论，什么时候独立工作。</p>
<p><strong>3. 分享知识和技能：</strong>在Pair的过程中Owner和Supporter会自然地相互传播和分享知识和技能，有助于学习提高。</p>
<p><strong>4. 培养组织能力和表达能力：</strong> Owner相当于一个微型团队的leader，在Pair过程中可以锻炼组织能力和表达能力。这个过程可以让一些不善于交流和组织的技术人员逐渐改善交流和组织能力。</p>
<p>Owner Supporter模式在我们的实践中收到了良好的效果，而且成本很低，值得推荐！
来源： <a href="[http://blog.csdn.net/chjttony/article/details/6203522](http://blog.csdn.net/chjttony/article/details/6203522)">[http://blog.csdn.net/chjttony/article/details/6203522](http://blog.csdn.net/chjttony/article/details/6203522)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/敏捷开发/">敏捷开发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/敏捷开发/" class="label label-primary">敏捷开发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-敏捷开发--结对编程（Pairprogramming）/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-敏捷开发--结对编程（Pairprogramming）" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/30/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/28/">28</a></li><li><a class="page-number" href="/page/29/">29</a></li><li><a class="page-number" href="/page/30/">30</a></li><li class="active"><li><span class="page-number current">31</span></li><li><a class="page-number" href="/page/32/">32</a></li><li><a class="page-number" href="/page/33/">33</a></li><li><a class="page-number" href="/page/34/">34</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/32/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 16:47:45</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
