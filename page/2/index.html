
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 2 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--知其所以然（以算法学习为例）/">知其所以然（以算法学习为例）</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:30.000Z"> <a href="/2014/02/03/2014-02-03--知其所以然（以算法学习为例）/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">知其所以然（以算法学习为例）</h1>
<p>其实下文的绝大部分内容对所有学习都是同理的。只不过最近在<a href="http://blog.csdn.net/pongba/archive/2008/06/05/2513263.aspx" target="_blank">正儿巴经地</a>学算法，而后者又不是好啃的骨头，所以平时思考总结得就自然要比学其它东西要多一些。</p>
<p>问题：目前几乎所有的算法书的讲解方式都是欧几里德式的、瀑布式的、自上而下的、每一个推导步骤都是精准制导直接面向目标的。由因到果，定义、引理、定理、证明一样不少，井井有条一丝不乱毫无赘肉。而实际上，这完全把人类大脑创造发明的步骤给反过来了。看起来是阳关大道，实际上车马不通。</p>
<p><img src="http://mindhacks.cn/wp-content/uploads/2009/02/clip-image001.jpg" alt=""></p>
<p>而对读者来说，这就<strong>等于直接告诉你答案&amp;做法了</strong>，然后<strong>让你去验证</strong>这个答案&amp;做法是可行&amp;成立的。而关于答案&amp;做法到底是怎么来的，从问题到答案之间经历了怎样的思维过程。却鲜有书能够很好的阐释。就我有限的阅（算法）书经验，除了波利亚的《怎样解题》还算合格之外（也并非最理想），其它的（包括有名的《算法导论》、《如何解题：现代启发式方法》、《Algorithms》、《编程珠玑》，甚至TAOCP——公平地说由于高老大对算法领域历史了解得非常通透，所以许多地方能够从原始脉络来讲述一个问题，譬如令人印象深刻的从竞赛树到堆的讲解就寥寥一页纸道出了堆这个数据结构的本质来，而像刚才列的几本有名的书却都没有做到），在思维的讲述上都算不上合格<strong>（当然不是说这些书没有价值，作为知识性的参考书籍，它们将知识整理出系统结构，极大的便利了知识的掌握，就像《什么是数学》所做的工作一样）</strong>，为什么我这么说呢，因为我发现每每需要寻找对一个算法的解释的时候，翻开这些书，总是直接就看到关于算法逻辑的描述，却看不到整个算法的诞生过程背后的思想。</p>
<p><strong>我们要的不是相对论，而是诞生相对论的那个大脑。我们要的不是金蛋，而是下金蛋的那只鸡。</strong></p>
<p><strong>Update(2008-7-24):*</strong> <strong>收到不少同学的批评，想来这个开头对一些著作的语气过重了，实际上，注意，*</strong>我完全不否认这些著作的价值，我自己也在通过阅读它们来学习算法，并且有很多收获<strong><em>。这篇文章更多的只是建议</em></strong>除了阅读这些著作之外还需要做的功课<strong><em>。此外，对于这类知识讲述（欧几里德）方式的批判西方（尤其是在数学领域）早就有了，早在欧拉和庞加莱的时候，他们俩就极其强调思维的传授，欧拉认为如果不能传授思维，那数学教学是没意义的。而庞加莱本人则更是对数学思维有极大的兴趣和研究（</em></strong>我前阵子在讨论组上还转载了一篇庞加莱的著名演讲，就是说这个的，参见<strong>[</strong>这里<em>*](<a href="http://groups.google.com/group/pongba/browse_frm/thread/3dfc84e0506486cc" target="_blank">http://groups.google.com/group/pongba/browse_frm/thread/3dfc84e0506486cc</a>)</em>）。我只是在说目前的算法书没有做到思维讲述的层面，因此建议阅读这些书之余应该寻找算法的原始出处，应该寻根究底，多做一些功课，知道算法到底是怎么诞生的，并且我说明了为什么应该知其所以然，有哪些好处（见下文），我还给了几个例子譬如红黑树作者讲红黑树的，g9讲后缀树的，以及Knuth讲heap的。唉，其实挺正统的观点，授人以渔，不管是东方西方都有类似的古老谚语。而我只是从认知科学的角度加了点解释，windstorm称之为“解释文”。而已。可惜被开头的语气搞砸了，算了，既发了也就不改了。*</p>
<p><img src="http://mindhacks.cn/wp-content/uploads/2009/02/clip-image002.gif" alt=""></p>
<p>为什么会这样，其实是有原因的。</p>
<p>我们在思考一个问题的过程中有两种思维形式：</p>
<ul>
<li><strong>联想</strong>：这种思维某种程度上可以说是“混乱”的（虽然从一个更根本的层面上说是有规则的），所谓混乱是指很多时候并不确定联想到的做法最终是否可行，这些联想也许只是基于题目中的某个词语、语法结构、问题的某个切片、一些零星局部的信息。这个过程是试探性的。最后也许有很大一部分被证明是不可行的。很多时候我们解决问题用的都是这种思维，简言之就是首先枚举你关于这个问题能够想到的所有你学过的知识，然后一一往上套看看能否解决手头的问题。这种思维方式受限于人脑联想能力本身的局限性。我在<a href="http://blog.csdn.net/pongba/archive/2008/04/18/2302905.aspx" target="_blank">《跟波利亚学解题》</a>中就提到了几个例子。联想本身需要记忆提取的线索，所以受到记忆提取线索的制约，如果线索不足，那怎么也联想不起来。而提取线索的建立又取决于当初保存记忆的时候的加工方法（<a href="http://www.douban.com/subject/1315575/" target="_blank">《找寻逝去的自我》</a>里面有阐述），同时，面对一个问题，你能够从中抽取出来的联想线索又取决于你对问题的认识层度/抽象深度，表浅的线索很可能是无关的，导致无效的联想&amp;试错（<a href="http://www.douban.com/subject/2845839/" target="_blank">《Psychology of Problem Solving》</a>里面有阐述）。总之，联想这个过程充满了错误的可能。</li>
<li><strong>演绎**</strong>&amp;<strong>**归纳</strong>：演绎&amp;归纳是另一种思维形式。它们远比联想有根据。其中演绎是严格的，必然的。归纳也是有一定根据的。在面对一个问题的时候，我们有意无意的对问题中的各个条件进行着演绎；譬如福尔摩斯著名的“狗叫”推理——狗+生人=&gt;吠叫 &amp; 昨晚狗没有叫 =&gt; 那个人是熟人。就是一个典型的对问题的各个条件进行演绎的推理过程。还有就是通过对一些特殊形式的观察来进行归纳，试图总结问题中的规律。然而，不幸的是，面对复杂的问题，演绎&amp;归纳也并不总是“直奔”问题的解决方案的。人的思维毕竟只能一下子看到有限的几步逻辑结论，一条逻辑演绎路径是否直奔答案，不走到最后往往是不知道的，只要答案还未出现，我们大脑中的逻辑演绎之树的末端就始终隐藏在黑暗之中。而当最终答案出现了之后，我们会发现，这棵演绎之树的很多分支实际上都并不通往答案。所以，虽然演绎&amp;归纳是一种“必然”的推理，然而却并不“必然”引向问题的结论，它也是试错的，只不过比联想要更为靠谱一些。</li>
</ul>
<p>既然认识到，<strong>人类解决问题的两大思维方式实际上都是有很大的试错成分的</strong>（好听一点叫“探索”），那么就不难意识到，对一个问题的思考过程实际上是相当错综复杂的，而且<strong>充满了无效分支</strong>——在思考的过程中我们也会不断的对分支进行评估，做适当的剪枝——因此当我们找到问题的解之后，<strong>一来思维的漫长繁杂的过程已经在大脑里面淡化得差不多了</strong>，只有那些引向最终结论的过程会被加“高亮”——我们在思考的过程中本就会不断的抛弃无效的思路，只留下最有希望的思路。简而言之就是最后证明没用或者早先我们就不抱希望的一些想法就被从工作记忆中扔掉了。<strong>二来，思考过程是我们的空气和水，而“<a href="http://blog.csdn.net/pongba/archive/2008/01/04/2025830.aspx" target="_blank">鱼是最后一个感觉到水的</a>”</strong>，我们感觉不到思维法则本身的存在，我们只是不知不觉运用它。<strong>三来，由于我们的目标是问题的解</strong>，解才是我们为之兴奋和狂喜的东西，而不是求解的过程，<strong>过程只是过程，目的才是目的</strong>。这就像一个寻宝者，在漫长曲折的寻宝历程之后，在找到宝藏的时候，他会对宝藏感到狂喜（记得阿基米德的“找到了！”吗？）而迫不及待地要展示出来，而漫长的思考本身却成了注脚。我们是有目的的动物，目的达到了，其它的就相对不那么重要了。最后，对于传授知识的人，也许还有<strong>其四：感到介绍思维过程是不相干的</strong>，毕竟思维过程并不是算法问题的解，算法问题的解才是算法问题的解。然而不幸的是，忽视到达解的那个过程实际上却变成了舍本逐末。我们看到的是寥寥数行精妙绝伦的算法，然后仰天长叹自己想不出来啊想不出来。为什么想不出来，因为你不知道那短短数行算法背后经历的事怎样漫长的思考过程，如果问题求解是一部侦探小说，<strong>那么算法只是结局而已，而<a href="http://blog.csdn.net/pongba/archive/2008/05/07/2412144.aspx" target="_blank">思考过程</a>才是情节</strong>。</p>
<p><img src="http://mindhacks.cn/wp-content/uploads/2009/02/clip-image003.gif" alt=""></p>
<p>既然如此，也就难怪古往今来算法牛人们算法牛，但却没有几个能真正在讲述的时候还原自己的思维过程的（那个“ 渔”字），手把手的教学生走一遍推理的思路，就可以让学生获得思维过程的训练。金出武雄在<a href="http://www.douban.com/subject/1867455/" target="_blank">《像外行一样思考，像专家一样实践》</a>中说<strong>写论文应该写得像侦探小说一样</strong>，我很赞同。欧几里德式的介绍，除了提供枯燥的知识之外，并没有提供帮助人获得知识的东西——思维（关于对数学书籍的欧几里德式写法的批评其实也是由来已久了，并且有人呼吁了好几种其它的<a href="http://en.wikipedia.org/wiki/Mathematics_education#Methods" target="_blank">教学方法</a>）。<strong>从这方面，我们所尊敬的一些“圣经”级书籍在传道授业上还不如侦探小说</strong>，前者是罗列一大堆知识，后者则是阐述获得知识的过程——推理&amp;联想。</p>
<p>然而，我们都是人，人类该有的思维形式，我们难道不是都有吗。既然如此，思维本身又有什么需要一遍遍教的呢？</p>
<p>并非如此。</p>
<p>讲述思维过程而非结果有几个极其重要的价值：</p>
<ul>
<li><strong>内隐化</strong>：思维法则其实也是知识（只不过它是元知识——是帮助我们获得新知识的知识）；是<a href="http://en.wikipedia.org/wiki/Implicit_memory" target="_blank">内隐的记忆</a>。我们在思考的过程中觉察不到思维法则的作用，它们却在幕后实实在在的左右着我们的思维轨迹。要将思维方法内隐化，<a href="http://blog.csdn.net/pongba/archive/2008/06/05/2513263.aspx" target="_blank">需要不断练习</a>，就像需要不断练习才能无意识状态下就能骑自行车一样。</li>
<li><strong>跨情境运用</strong>：思维法则也是知识记忆，是问题解决策略。既然是记忆，就受到提取线索的制约，这就是为什么当波利亚<a href="http://www.douban.com/subject/1456890/" target="_blank">告诉你</a>要“注意未知数”之后你还是不能真正在所有需要你“注意未知数”的地方都能提醒自己“注意未知数”。很多时候未知数是很隐蔽的，未知数并不会总是头顶一个大帽子上面写着“我是未知数”。所以很多时候缺乏对这个策略的“提醒”线索，这也是为什么<strong>你学会了在解决数学问题的时候“**</strong>注意未知数”<strong><strong>却不一定能在解决现实生活中的问题中时刻都能“</strong></strong>注意你的未知数”<strong>（<a href="http://www.douban.com/subject/1135754/" target="_blank">《你的灯亮着吗？》</a>整本书的价值便在于此），因为解数学题和解决生活中问题的场景不一样，不同的环境线索，在你大脑中激发的记忆也不一样。就连问题求解中，不同的问题之间的细小差别也可能导致思维轨迹很大的不同，有时你的注意力会被一个无关线索激发的联想吸引开去，忘记如“注意你的未知数”这样的重要法则。而一本从思维角度来讲问题求解的书则可以一遍遍将你置于不同的问题场景下然后在该提醒你的时候提醒你，让你醒悟到“</strong>哦，原来<strong>*</strong>这个<strong>*</strong>时候也应该想到<strong>*</strong>这个<strong>*</strong>啊。**”，做多了这样的思维演习你就会逐渐从中领悟到某种共性，并将一些思维习惯得到强化，于是终于能够在需要运用某策略的时候能适时的想起来了。</li>
<li><strong>对问题解的更多**</strong><a href="http://blog.csdn.net/pongba/archive/2008/06/05/2513263.aspx" target="_blank">记忆提取线索</a><strong>：我们平时学习算法时几乎仅止于“理解”，别人把一个方案放在你面前，你去验证一下，心说“哦，不错，这个的确可以工作”。然后就没了。稍微简单一点的算法还好，复杂一点的对于记忆的负担是很大的，这就是为什么有时候我们看到一个绝妙的解法，这个解法看上去不知道从哪里来的，但经过我们的理解，却发现是对的，我们感叹，真巧妙，结果一些天之后，别人问起这个问题，我们说：“</strong>唉，那是个多么巧妙的算法啊，但是我只记得它巧妙，却不记得它到底是怎样的了。<strong>” 为什么？因为在不知其所以然的情况下，算法只是一堆离散的机械步骤，缺少背后的思想的支撑，这些步骤之间就没有一个</strong>本质层面上的关联<strong>（先知亚里士多德早就指出：学习即联接）。所以就跟背历史书也没多大区别。然而，</strong>知道了算法是怎样一步步被推导出来的，我们就一下拥有了大量的记忆提取线索：对算法发现过程中的任何一个关键步骤（尤其是本质）的回忆都可能使我们能够自己动手推导出剩余的内容<strong>。</strong>譬如<strong>你知道堆(heap)是怎样由朴素的决策树演化而来的，它又是为了解决什么问题的，你即便忘记了具体的细节，也可以自己推导出来。</strong>譬如<strong>你知道KMP算法的本质在于消除回溯，至于如何消除回溯却并不是那么难以推导的，所以即便忘了也可以借助于大脑的逻辑演绎能力再现出来。</strong>譬如<strong>你知道Tarjan算法其实只是从后序遍历经过两个优化调整而来的（其中并査集的使用其实只是优化手段——为了能够迅速判断祖先节点是谁——而非算法本质——当然，算法设计的主要任务本来就是通过问题条件中蕴含的知识来“消除冗余计算”和“避免不必要计算”，所以你也可以说并査集的使用是关乎本质的，只不过，知道了为什么需要引入并査集，就会强烈地感觉到一切是顺理成章的了），那这个出了名的绕人的算法也就不那么难以理解和记忆了。</strong>譬如**你知道<a href="http://blog.csdn.net/pongba/archive/2008/06/13/2544933.aspx" target="_blank">排序的本质</a>，就能够对什么是最优排序，为什么它是最优排序有深刻的认识。四两拨千斤。</li>
</ul>
<p><img src="http://mindhacks.cn/wp-content/uploads/2009/02/clip-image004.jpg" alt=""></p>
<ul>
<li><strong>包含了多得多的知识</strong>：<strong>记一个算法，就只有一个算法</strong>。一个萝卜一个坑。<strong>就好比背99**</strong>乘法表只能解决乘法问题一样<strong>。而记</strong>背后的思想，却有助于解决一类问题<strong>。思想所处的抽象层面往往比到处都是实现细节的算法本身要低，越是低的抽象层次，越是本质，涵盖范围越是广泛。数学的发展本身就体现了这个过程，抽象代数就是非常好的例子。</strong>算法诞生过程中的思路往往包含了比实际算法更本质得多的知识**，实际算法乃至算法的某个特定语言的实现包含了太多表面的不相干知识，它们会阻碍对本质的理解。</li>
<li><strong>重在分析推理，而不是联想</strong>：学了一大通算法和数据结构之后的一个<strong>副作用</strong>就是，看到一个问题之后，脑袋里立即不管三七二十一冒出一堆可能相干的数据结构和算法来。联想是强大的<a href="http://www.douban.com/doulist/127649/" target="_blank">思维捷径</a>，在任何时候都会<a href="http://en.wikipedia.org/wiki/Attention#Neural_correlates_of_attention" target="_blank">抢占</a>大脑的<a href="http://en.wikipedia.org/wiki/Working_memory" target="_blank">工作记忆</a>，由不得你控制——比如我问你“如何寻找区间的最大值”，首先进入你的意识的肯定就是学过的那个算法，甚至算法的实现细节都一一跳了出来，也许最先跳出来的还是算法实现中某个最容易弄错的边界细节，或是某个比较tricky的实现技巧！然而这些其实根本不反映一个算法的本质，结果想来想去总是停留在问题的表层。而另一方面，重在思维的传授则可以让人养成从问题本质入手，逐步分析推理的习惯，而不是直接生搬硬套。<strong>当然，完全不可否认，联想本身也是极其重要的思维方法，甚至可以说是人类思维<a href="http://en.wikipedia.org/wiki/Hebbian_learning" target="_blank">最重要的</a>**</strong>特征**。很多时候我们并不知道问题的本质是什么，就需要靠联想、类比来领路探索。只不过，养成优先从问题的本质入手进行考察的好习惯绝对是有更大的好处的。</li>
</ul>
<p>那到底什么样的才算是授人以渔的呢？波利亚的《如何解题》绝对算是一本，他的《数学的发现》也值得一看。具体到算法书，那就不是光看text book就足够的了，为了深入理解一个算法的来龙去脉前因后果，从一个算法中领悟尽量深刻的东西，则需要做到三件事情：</p>
<ul>
<li><strong>寻找该算法的原始出处</strong>：TAOCP作为一个资料库是绝对优秀的，基础的算法只要你能想到的，几乎都可以在上面找到原始出处。查到原始出处之后（譬如一篇paper），就可以去网上搜来看了。因为最初的作者往往对一个方案的诞生过程最为了解。比如经典数据结构中的红黑树是出了名的令人费解的结构之一，但它的作者Sedgewick<a href="http://groups.google.com/group/pongba/browse_thread/thread/3513a21065faba68" target="_blank">一张PPT，给你讲得通通透透</a>，比算法导论上的讲法强上数倍。</li>
<li><strong>原始的出处其实也未必就都推心置腹地和你讲得那么到位</strong>：前面说过，算法设计出来了之后人们几乎是不会去回顾整个的思维过程细节的，只把直指目标的那些东西写出来。结果就又是一篇欧几里德式的文章了。于是你就迷失在一大堆“定义”、“引理”、“定理”之中了。这种文章看上去整个写得井井有条，其实是把发明的过程整个给颠倒过来了，我一直就想，如果作者们能够将整个的思路过程写出来，哪怕文字多上十倍，我也绝对会比看那一堆定义定理要容易理解得多。话说回来，怎么办？可以再去网上找找，牛人讲得<a href="http://blog.csdn.net/g9yuayon/archive/2008/06/21/2574781.aspx" target="_blank">未必比经典教材上的差</a>。那倘若实在找不出好的介绍呢，就只能自己<strong>揣摩</strong>了。<strong>揣摩的重要性，是怎么说都不为过的</strong>。揣摩的<strong>一些指导性的问题有</strong>：为什么要这样（为什么这是好的）？为什么不是那样（有其它做法吗？有更好的做法吗？）？这样做是最好的吗？（为什么？能证明吗？）这个做法跟其它的什么做法有本质联系吗？<em>这个</em>跟<em>这个</em>的区别是什么？<strong>问题的本质是什么</strong>？<strong>这个做法的本质又是什么</strong>？到底本质上是什么东西导致了这个做法如此..？与这个问题类似的还有其它问题吗？（同样或类似的做法也适用吗？）等等。</li>
<li><strong>不仅学习别人的思路，整理自己的思路也是极其重要的</strong>：详见<a href="http://blog.csdn.net/pongba/archive/2008/04/18/2302905.aspx" target="_blank">《跟波利亚学解题》</a>的“4. 一个好习惯”和“7. 总结的意义”。</li>
</ul>
<p>前一段时间我们讨论组上有不少例子，见<a href="http://groups.google.com/group/pongba/web/toplang-problemsolvingseries" target="_blank">这里</a>，或<a href="http://del.icio.us/pongbablog/%E8%A7%A3%E9%A2%98" target="_blank">这里</a>。
来源： <a href="[http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/](http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/)">[http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/](http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/)</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:28:06"datetime="2014-03-07 11:28:06"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--知其所以然（以算法学习为例）/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--知其所以然（以算法学习为例）" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--专访张龙：我的漫漫程序人生路部分摘录/">专访张龙：我的漫漫程序人生路(部分摘录)</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--专访张龙：我的漫漫程序人生路部分摘录/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">专访张龙：我的漫漫程序人生路(部分摘录)</h1>
<h1 id="-">专访张龙：我的漫漫程序人生路</h1>
<p>一、关于基础</p>
<p><strong>CSDN：你在系列文章最后分享了9点心得体会，总结当时到现在的这段时光，是否有新的感悟分享？</strong></p>
<p><strong>张龙：</strong>我现在依然在坚守着这些体会：</p>
<ol>
<li><p>基础的重要性。我总是不断强调基础的重要性，因为我是有切身体会的。基础的东西可以让你受用一生。struts出来了，webwork出来，tapestry出来了，jsf出来了，struts2也出来了，等等等等。但是这些框架或者标准都是新东西吗？其实每个人都知道并不是的，他们都是基于HTTP协议的，换句话说都是构建在jsp与servlet基础之上的，有很多人连这两个基础都没掌握好，就去学这些框架，这真是难以想象的。有了好的基础会让你学习新东西更快，也更扎实，走的也更远，否则你永远都是在跟着别人的脚步。</p>
</li>
<li><p>还是基础。我们都知道Spring是非常优秀的框架，也是很多公司采用的技术选型。但是你是否真的了解Spring的核心IOC与AOP了吗？适当看些设计模式的书会让你受益匪浅。其实你只要掌握了java的动态代理对于AOP的理解就是自然而然的事情了。</p>
</li>
<li><p>舍得投入。 有时间的话买些书看看，好书可以让你系统的学习一些技术，而不是一些支离破碎的技术点。</p>
</li>
<li><p>抓紧时间。 将游戏的时间控制的少一些，把精力放在学习上吧，如果你想投身IT行业，做好不断学习的准备</p>
</li>
<li><p>要有激情。 没有激情的人生是惨淡的人生。生活和学习要有激情，否则你体会不到淋漓尽致的快乐与苦痛。</p>
</li>
<li><p>要有耐心。 没有耐心是无法成为一个优秀的程序员的。其实写程序的时候大部分时间是与错误、异常相伴的，不要幻想一下就能将程序写对，优秀的程序实际上是不断重构的过程。</p>
</li>
<li><p>要能耐得住寂寞。 很多时候我们都是与计算机为伴的，如果你没有对程序的兴趣与热情，时间长了你会坐不住的。</p>
</li>
</ol>
<p>8.英语的重要性，如果你想进外企的话，那么英语是必须要过的一关（主要体现在听说上）。</p>
<ol>
<li>最后一点，坚持学习。活到老学到老是对程序开发人员最好的描述。</li>
</ol>
<p><strong>基础的东西总是最重要的。</strong></p>
<hr>
<hr>
<p>二、关于自学（经验）</p>
<p><strong>CSDN：在（中）篇里，你提及上大学最大的两个收获就是：决定了自己的人生方向和掌握了自学的方法。你对现在正处在大学里的准程序员们有何建议？</strong></p>
<p><strong>张龙：</strong>我始终认为这是我大学期间最大的两个收获。因为进入大学后就意味着要独立承担自己的一切，别人可以给你建议，但最后拿主意的一定是自己。<strong>特别是对于计算机专业来说，自学意味着一切。</strong>毕竟计算机领域涉及众多，学校上课讲的只是最基本和基础的，在掌握了这些内容之后剩下的就要靠自己了。</p>
<p>现如今，互联网上的资源一应俱全，你要的东西网上基本都能找到，比我那个时代好太多了。不过，这是一个最好的时代，也是一个最坏的时代。可能你需要的很多资源都需要翻墙才能获取，这应该是每个程序员的必备技能了。另外，对于在校学生来说，有机会可以兼职或是去公司实习，这样可以尽早步入社会，了解公司都需要什么，为今后的工作提前做好铺垫。</p>
<pre><code>关于压力
</code></pre><p><strong>CSDN：你在研究生的时候做过柯尼卡—美能达公司的经销商管理系统、一个游戏点卡的销售网站，都给了你不小的压力，你是如何对待压力的？</strong></p>
<p><strong>张龙：</strong>压力每个人都有，做事情如果没有压力其实很容易造成拖延。这种压力一方面来自于自身，另一方面则是外界施加的。适度的压力会激发人的潜能，<strong>我现在在做事情的时候就喜欢给自己设定一个截止日期，算是自己给自己的压力吧。</strong>没有压力可能一件事，特别是需要长时间付出的事情永远也做不完。</p>
<p>三、关于沟通（经验）
<strong>CSDN：你在研究生期间就给人讲授课程，锻炼自己的口语表达能力，不少程序员相对比较内敛，这方面你有什么经验可分享？</strong></p>
<p><strong>张龙：</strong>我觉得这是个循环问题。你越闭塞，越不想与人交流，那你就越陷在自己的圈子当中，不愿走出来。反过来说，当你<strong>走出去，多多参与讨论，多多与人沟通，这对你的思维也是很好的锻炼，你就知道该如何与人打交道。</strong>你永远不是一个人在战斗，走出去才能实现更好的腾飞。</p>
<p>四、关于学习（建议）
<strong>CSDN：在你一路走来，遇到一些浮躁的心境时是怎么处理的？对刚进入这个领域的人有何建议？</strong></p>
<p><strong>张龙：</strong>浮躁、烦恼每个人都有，也不光是程序员才会这样，各行各业的人都会遇到各种各样的问题。适当排解很重要，憋在心里只会把人憋疯，出去找朋友喝喝酒、唱唱歌，一切都会过去的。我不是专家，不敢给人提建议，只是觉得<strong>学习是保证你今后的路越走越宽的最佳手段</strong>。</p>
<p><strong>来源： &lt;</strong><a href="http://www.csdn.net/article/2013-08-21/2816646" target="_blank"><strong><a href="http://www.csdn.net/article/2013-08-21/2816646">http://www.csdn.net/article/2013-08-21/2816646</a></strong></a><strong>&gt;</strong></p>
<hr>
<p>另：一个文章摘录</p>
<p>程序员最重要的技能         火龙果软件 发布于 2013-8-22    <img src="" alt="">
什么才是程序员最有价值的技能？怎样才能成为一名成功的开发者呢？我敢打赌，在你的职业生涯中你至少问过自己一次这样的问题。你找到答案了吗？你认为自己搞清楚了没有？
许多年轻的程序员会告诉你，伟大的开发者最重要的技能是<strong>对自己所用语言的掌握</strong>。当然，你得对 C/#、 F/#、C++、Java、Ruby、Haskell 或什么别的语言娴熟于心。然而，语言本身并不能提供足够的技能让你完成桌面或 web 应用。
“那要不就是对平台的知识了，”你又问自己。也许甚至是整个平台体系，如果你仔细思考一下的话。比方说，这有可能意味着要知道 Windows API 或 iOS 开发的工具或库。可是，你再想一下。如果趋势变了的话又会怎样？如果项目转向另一个平台的话又会怎样？如果你只具备前一个平台的知识的话，你还会是一名伟大的程序员吗？我不这么认为。
“对！我知道了。肯定是<strong>解决问题和分析性思维的能力</strong>”，你几乎对着我吼起来了。事实上你是对的。没有一个好的开发者是不具备分析性思维的。但是，问题解决仍然不是你应该具备的最重要技能。
“如果不是编程知识的话，那一定就是<strong>编程激情</strong>。你每天都得学点新东西。不能停止，你得热爱它。”的确，你是对的，尽管这并非最重要的能力，但已经接近了。让你从好的开发者变成伟大的开发者的，是编程的激情，尤其是学习的激情。
然而，还有一个技能更有价值，那就是<strong>沟通</strong>。
许多时候这一点被低估了，可如果不使用沟通技能的话你一天都过不了。而且，你要沟通的还不仅仅是客户。还包括你的同事，分享你的想法，用不侮辱人的方式辩论，说服你的老板应该采取你的方式。此外，还有还要汇报状态更新，解释发生的事情。你每天都要沟通，而且要沟通得当，如果你要成为伟大的开发者的话。
这就是我要发文章谈演讲这个似乎不相干话题的原因。我认为从中你可以学到很多东西，如果你对此感兴趣的话你可以继续学习 coursera 的课程（英文）。</p>
<p>来源： <a href="[http://www.uml.org.cn/itnews/2013082209.asp](http://www.uml.org.cn/itnews/2013082209.asp)">[http://www.uml.org.cn/itnews/2013082209.asp](http://www.uml.org.cn/itnews/2013082209.asp)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:29"datetime="2014-03-07 11:24:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--专访张龙：我的漫漫程序人生路部分摘录/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--专访张龙：我的漫漫程序人生路部分摘录" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--BruceEckel：编程生涯/">Bruce Eckel：编程生涯</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--BruceEckel：编程生涯/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="bruce-eckel-">Bruce Eckel：编程生涯</h1>
<p><strong>EN文：</strong></p>
<p>Computing Thoughts
A Career in Computing
by Bruce Eckel
June 2, 2009
 <strong>Summary</strong>
I regularly receive requests for career advice, and I&#39;ve tried to capture the answers in this blog, and in a follow-on. For those of you who asked but never got an answer, I apologize. Your questions stimulated me to work on this, and it&#39;s taken awhile.</p>
<p>The question that people ask is usually the wrong one: &quot;should I learn C++ or Java?&quot; In this essay, I shall try to lay out my view of the true issues involved in choosing a career in computing.</p>
<p>Note that I am not talking here to the people who already know it is their calling. You&#39;re going to do it regardless of what anyone says, because it&#39;s in your blood and you can&#39;t get away from it. You know the answer already: C++ AND Java AND shell scripting AND Python AND a host of other languages and technologies that you&#39;ll learn as a matter of course. You already know several of these languages, even if you&#39;re only 14.</p>
<p>The person who asks me this question may be coming from another career. Or perhaps they are coming from a field like web development and they&#39;ve figured out that HTML is only kind of like programming, and they&#39;d like to try building something more substantial. But I especially hope that, if you are asking this question, you&#39;ve realized that to be successful in computing, you need to teach yourself how to learn, and never stop learning.</p>
<p>The more I do this, the more it seems to me that software is <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=255898" target="_blank">more akin to writing</a> than anything else. And we haven&#39;t figured out what makes a good writer, we only know when we like what someone writes. This is not some kind of engineering where all we have to do is put something in one end and turn the crank. It is tempting to think of software as deterministic -- that&#39;s what we want it to be, and that&#39;s the reason that we keep coming up with tools to help us produce the behavior we desire. But my experience keeps indicating the opposite, that it is more about people than processes, and the fact that it runs on a deterministic machine becomes less and less of an influence, just like the Heisenberg principle doesn&#39;t affect things on a human scale.</p>
<p>My father built custom homes, and in my youth I would occasionally work for him, mostly doing grunt labor and sometimes hanging sheet rock. He and his lead carpenter would tell me that they gave me these jobs for my own good -- so that I wouldn&#39;t go into the business. It worked.</p>
<p>So I can also use the analogy that building software is like building a house. We don&#39;t refer to everyone who works on a house as if they were exactly the same. There are concrete masons, roofers, plumbers, electricians, sheet rockers, plasterers, tile setters, laborers, rough carpenters, finish carpenters, and of course, general contractors. Each of these requires a different set of skills, which requires a different amount of time and effort to acquire. House-building is also subject to boom and bust cycles, like programming. If you want to get in quick, you might take a job as a laborer or a sheet rocker, where you can start getting paid without much of a learning curve. As long as demmand is strong, you have steady work, and your pay might even go up if there aren&#39;t enough people to do the work. But as soon as there&#39;s a downturn, carpenters and even the general contractor can hang the sheet rock themselves.</p>
<p>When the Internet was first booming, all you had to do was spend some time learning HTML and you could get a job and earn some pretty good money. When things turned down, however, it rapidly becomes clear that there is a hierarchy of desirable skills, and the HTML programmers (like the laborers and sheet rockers) go first, while the highly-skilled code smiths and carpenters are retained.</p>
<p>What I&#39;m trying to say here is that you don&#39;t want to go into this business unless you are ready to commit to lifelong learning. Sometimes it seems like programming is a well-paying, reliable job -- but the only way you can make sure of this is if you are always making yourself more valuable.</p>
<p>Of course you can find exceptions. There are always those people who learn one language and are just competent enough and perhaps savvy enough to stay employed without doing much to expand their abilities. But they are surviving by luck, and they are ultimately vulnerable. To make yourself less vulnerable, you need to continuously improve your abilities, by reading, going to user groups, conferences, and seminars. The more depth you have in this field, the more valuable you will be, which means you have more stable job prospects and can command higher salaries.</p>
<p>Another approach is to look at the field in general, and find a place where you already have talents. For example, my brother is interested in software, and dabbles with it, but his business is in installing computers, fixing them and upgrading them. He&#39;s always been meticulous, so when he installs or fixes your computer you know that it will be in excellent shape when he&#39;s done; not just the software, but all the way down to the cables, which will be bundled neat and out of the way. He&#39;s always had more work than he could do, and he never noticed the dot-com bust. And needless to say, his work cannot be offshored.</p>
<p>I stayed in college a long time, and managed to get by in various ways. I even began a Ph.D. program at UCLA, which was mercifully cut short -- I say mercifully because I no longer loved being in college, and the reason I stayed in college for so long was because I enjoyed it so much. But what I enjoyed was typically the off-track stuff. Art and dance classes, working on the college newspaper, and even the handful of computer programming classes that I took (which were off-track because I was a physics undergrad and a computer <em>engineering</em> graduate student). Although I was far from exceptional academically (a delightful irony is that many colleges that would not have accepted me as a student now use my books in their courses!), I really enjoyed the life of the college student, and had I finished a Ph.D. I probably would have taken the easy path and ended up a professor.</p>
<p>But as it turns out, some of the greatest value that I got from college was from those same off-track courses, the ones that expanded my mind beyond &quot;stuff we already know.&quot; I think this is especially true in computing because you are always programming to support some other goal, and the more you know about that goal the better you&#39;ll perform (I&#39;ve encountered some European graduate programs that require the study of computing in combination with some other specialty, and you build your thesis by solving a domain-specific problem in that other specialty).</p>
<p>I also think that knowing more than just programming vastly improves your problem-solving skills (just as knowing more than one programming language vastly improves your programming skills). On multiple occasions I have encountered people, trained only in computer science, who seem to have more limits in their thinking than those who come from some other background, like math or physics, which requires more rigorous thinking and is less prone to &quot;it works for me&quot; solutions.</p>
<p>In one session a conference that I organized, one of the topics was to come up with a list of features for the ideal job candidate:</p>
<ul>
<li>Learning as a lifestyle. For example, you should know more than one language; nothing opens your eyes more to the strengths and limitations of a language than learning another one.</li>
<li>Know where and how to get new knowledge.</li>
<li>Study prior art.</li>
<li>We are tool users.</li>
<li>Learn to do the simplest thing.</li>
<li>Understand the business (Read magazines. Start with Fast Company, which has very short and interesting articles. Then you can see if you want to read others)</li>
<li>You are personally responsible for errors. &quot;It works for me&quot; is not an acceptable strategy. Find your own bugs.</li>
<li>Become a leader: someone who communicates and inspires.</li>
<li>Who are you serving?</li>
<li>There is no right answer ... and always a better way. Show and discuss your code, without emotional attachment. You are not your code.</li>
<li>It&#39;s an asymptotic journey towards perfection.</li>
</ul>
<p>Take whatever risks you can -- the best risks are the scary ones, but in trying you will feel more alive than you can imagine. It&#39;s best if you don&#39;t plan for a particular outcome, because you will often miss the true possibilities if you&#39;re too attached to a result. My best adventures have been ones that have started with &quot;lets do a little experiment and see where it takes us.</p>
<p>Some people will be disappointed by this answer, and reply &quot;yes, that&#39;s all very interesting and useful. But really, what should I learn? C++ or Java?&quot; I&#39;ll fend these off by repeating here: I know it seems like all the ones and zeroes should make everything deterministic, so that such questions should have a simple answer, but they don&#39;t. It&#39;s not about making one choice and being done with it. It&#39;s about continuous learning and sometimes, bold choices. Trust me, your life will be more exciting this way.</p>
<h1 id="-further-reading-"><a href="">Further Reading</a></h1>
<p>Here&#39;s an earlier piece I wrote on <a href="http://mindview.net/WebLog/log-0030" target="_blank">how I got started in programming</a>.
I found all these to be interesting and stimulating takes on the same subject: </p>
<ul>
<li>Teach yourself programming in ten years, by Peter Norvig: <a href="http://norvig.com/21-days.html" target="_blank"><a href="http://norvig.com/21-days.html">http://norvig.com/21-days.html</a></a></li>
<li>How to be a Programmer, by Robert Read: <a href="http://samizdat.mines.edu/howto/HowToBeAProgrammer.html" target="_blank"><a href="http://samizdat.mines.edu/howto/HowToBeAProgrammer.html">http://samizdat.mines.edu/howto/HowToBeAProgrammer.html</a></a></li>
<li>Here&#39;s a <a href="http://news-service.stanford.edu/news/2005/june15/jobs-061505.html" target="_blank">speech by Steve Jobs</a>, trying to inspire a group of graduating college students.</li>
<li>Kathy Sierra: Does College Matter? <a href="http://headrush.typepad.com/creating_passionate_users/2005/07/does_college_ma.html" target="_blank"><a href="http://headrush.typepad.com/creating_passionate_users/2005/07/does_college_ma.html">http://headrush.typepad.com/creating_passionate_users/2005/07/does_college_ma.html</a></a></li>
<li><a href="http://www.paulgraham.com/college.html" target="_blank"><a href="http://www.paulgraham.com/college.html">http://www.paulgraham.com/college.html</a></a></li>
<li><a href="http://www.joelonsoftware.com/articles/CollegeAdvice.html" target="_blank"><a href="http://www.joelonsoftware.com/articles/CollegeAdvice.html">http://www.joelonsoftware.com/articles/CollegeAdvice.html</a></a></li>
<li><a href="http://www.jamesshore.com/Blog/Five-Design-Skills.html" target="_blank"><a href="http://www.jamesshore.com/Blog/Five-Design-Skills.html">http://www.jamesshore.com/Blog/Five-Design-Skills.html</a></a></li>
<li><a href="http://steve-yegge.blogspot.com/2006/03/truth-about-interviewing.html" target="_blank"><a href="http://steve-yegge.blogspot.com/2006/03/truth-about-interviewing.html">http://steve-yegge.blogspot.com/2006/03/truth-about-interviewing.html</a></a></li>
</ul>
<p>In a future article (I&#39;ll post the link here when it&#39;s done), I will talk about the importance of understanding management and business issues, whether or not you ever plan to be a manager, and in that article I&#39;ll include a list of books that (even though they&#39;re about management) you should read to prepare yourself for your career.</p>
<h1 id="talk-back-">Talk Back!</h1>
<p>Have an opinion? Readers have already posted <a href="http://www.artima.com/forums/flat.jsp?forum=106&amp;thread=259358" target="_blank">24 comments</a> about this weblog entry. Why not <a href="http://www.artima.com/forums/post.jsp?forum=106&amp;thread=259358&amp;reply=true" target="_blank">add yours</a>?</p>
<h1 id="rss-feed">RSS Feed</h1>
<p>If you&#39;d like to be notified whenever Bruce Eckel adds a new entry to <a href="http://www.artima.com/weblogs/index.jsp?blogger=beckel" target="_blank">his weblog</a>, subscribe to his <a href="http://www.artima.com/weblogs/feeds/bloggers/beckel.rss" target="_blank">RSS feed</a>.  </p>
<hr>
<p><strong>中文：</strong></p>
<p><strong>Bruce Eckel：编程生涯</strong></p>
<p>作者 <strong>Bruce Eckel</strong> 是编程界的大牛，著有大名鼎鼎的《Thinking in C++》和《Thinking in Java》。
本文是他对程序员（尤其是新手）的忠告。</p>
<p>================华丽的分割线================</p>
<p>大家总是问一个错误的问题：“我应该学习C++还是Java？”在本文中，我将告诉大伙儿：对于选择编程生涯真正需要关注的是哪些问题。</p>
<p>请 注意，这篇文章的目标读者并不是那些已经做出自己选择的人。（对于这些人而言）你会继续自己的编程生涯，而不管别人会怎么说。因为它已经渗透到你的血液 中，你已经无法摆脱。你已经知道答案：C++、Java、Shell脚本、Python、还有其它一大堆的语言和技术，你都理所当然地会去学习。甚至有可 能你才仅仅14岁，就已经知道好几种不同的语言。</p>
<p>问我这样的问题的人可能来自其他行业，或者来自诸如Web开发之类的领域。他们知道HTML是一种类编程语言，而且想尝试构建某些更大型的应用。但我特别希望，当你在问这个问题时，你已经意识到了想要在计算机领域取得成功，你需要掌握自学能力，而且永不停息。</p>
<p><strong>在这个领域做得越多，我越觉得软件开发比任何行业都更接近于写作。</strong> 我们从来不知道是什么造就了优秀的作者，我们只知道什么时候我们会喜欢某个人的文字。编程不是一种工程，仅需要把东西从入口倒进去，然后再转动手柄。把软 件开发看成确定性的，是一个诱人的想法。因为这个想法，人们总想搞出一些工具来帮我们开发出想要的软件。但是我的经验告诉我，事实并非如此——人的重要性 远高于流程。而软件是否运行在一部精确的机器上已经越来越不重要了——这犹如测不准原理对人类的影响。</p>
<p>我的父亲是造房子的，小时候我偶尔会帮忙打下手，放放砖块之类。他和他的木工告诉我，他们是为我好才让我干这些活——这样我就不至于走入这个行业。事实确实是这样。</p>
<p>我 们不妨把软件开发比作盖房子。造房子的人当然不可能完全一样。这些人里面有：混凝土工、屋顶工、管道工、电工、砖瓦工、水泥工、瓦片工、搬运工、粗木工、 细木工。当然，还有工头。每个工种都需要相应的技能，这些技能都需要花时间和精力去掌握。跟软件开发一样，造房子也是一个“建立/推翻”的过程。如果你想 很快地获得回报，你可能从搬运工和砖瓦工开始做，这样的话，你无需太多的学习曲线就可以获得回报。当需求很多时，你的工作会很稳固，甚至收入也可能提升 ——如果没有足够的人手的话。但是，一旦行情不妙，木匠甚至工头就可能把砖瓦工一脚踢开。</p>
<p>当互联网刚刚兴起时，仅仅是花一点时间学习HTML，你就可以得到一份薪水丰厚的工作。但是当形势惨淡时，对于技能的要求更高了——HTML程序员（就像搬运工和砖瓦工一样）第一个被抛弃了，而拥有更高技能的程序员则留了下来。</p>
<p>我想说的是： <strong>除非你准备活到老学到老，不然的话，不要进入这个行业！编程看起来似乎是一个高收入而又稳定的工作。但要做到这一点，唯一的途径是：始终让自己更有价值。</strong></p>
<p>当然，你总能找到例外。总有那么一些人，仅仅学了一门编程语言，就可以胜任留在一个岗位上，而不需要增长他的技能。但他们只是幸免于难而已，他们最终无疑是很脆弱的。为了不让自己变得脆弱，你需要持续的提高自己，通过阅读、加入用户组、参加研讨会…… <strong>你学得越深入，你就越有价值，也就意味着你有更好的职业前景，可以配得上更高的薪水。</strong></p>
<p>另 一个方法是：先大致地了解这个领域，找到最适合你的地方。打个比方：我的兄弟对软件很感兴趣，也进入了这个行业，但他的工作是安装、维修、升级电脑。他总 是一丝不苟，所以当他把电脑搞好，一定会很完美——不只只是软件，连电线都会被仔细地捆好。他总是生意兴隆，远远超出他的精力所能及。他甚至都不用担心 .com 泡沫的崩溃。显然他的饭碗不容易被抢走。</p>
<p>我在高校里待了很久，甚至还在UCLA（加州大学洛杉矶分校）开始进修博士学位，后来 又幸运地终止了。我说“幸运”是因为我不再喜欢呆在学校，而我之前在高校待了那么久，只是因为我很享受它。但我所享受的，基本上是不务正业的东西——艺术 和舞蹈课，在校报工作，还有一小撮计算机课程（之所以说计算机课程“不务正业”，是因为我本科是物理专业，研究生才是计算机专业）。虽然我在学术上远谈不 上卓越（有意思的是很多当时也许不会接受我这个学生的学校现在却用我的书做教材）。我真的很享受作为学生的日子，当我完成博士课程，也许会以一个教授的身 份终老一生。</p>
<p>但就如现在看到的，我在学校里最大的收获恰恰来自我那些“不务正业”的课程，它们拓展了我的思维，使之超越了“我们已经知道 的东西”。在计算机领域中，你总是为某种目标而编程。你对目标了解得越多，你就做得越好。我遇到过一些欧洲的研究生，他们需要结合其它专业领域来搞编程， 他们的论文需要解决这个专业领域的特定的问题。</p>
<p><strong>了解编程之外的领域，将会极大得提高你解决问题的能力</strong> （就如同多学几种编程语言将极大地提高你的编程技能）。很多时候，我发现仅仅学习计算机专业的学生，比那些（除了计算机之外）拥有其它背景的学生，在思维上有更多的局限性。因为后者有着更严谨的思维，也不那么容易想当然。</p>
<p>有一次我组织了一次会议，其中一个议题是：理想的应聘者有哪些特征：
◇把学习当成生活方式。比如：你应该知道不止一种语言，没有什么比学习一门新语言更能让你开阔眼界了。
◇知道如何获取知识
◇Study prior art
◇善用工具
◇学会把事情简化
◇理解业务
◇为自己的错误负责。“我就是这样的”是不能接受的托词。能找到自己的失误。
◇成为一个领导者，善于沟通和激励。
◇搞清楚你在为谁服务
◇没有绝对正确的答案（更好的方法总是存在的）。展示并讨论你的代码，不要带着感情因素——你的代码并不等于你本人。
◇明白完美是渐进的</p>
<p>要 尝试一些冒险的事情——尤其是那些令人害怕的冒险。当你尝试之后，将体会到出乎意料的兴奋。（在冒险的过程中）最好不要刻意去计划某个特定的结果。当你过 于注重结果，你往往会错过那些真正有价值的问题。我的冒险往往是这样开始的——“我们先做些试验，看看它会把我们带到什么地方”。</p>
<p>或许某 些人会对我的回答感到失望，并回复我说：“是的，这很有趣也很有用。但我到底应该学什么？C++还是Java？” 我再重复一次：并不是所有的问题都有一个唯一的简单的答案。问题的关键不在于选择某个编程语言，然后掌握之。问题的关键在于：持续学习，并且很多时候，有 不止一个选择。相信我所说的，你的生活会更精彩！</p>
<p>洋文原始出处：
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=259358" target="_blank"><a href="http://www.artima.com/weblogs/viewpost.jsp?thread=259358">http://www.artima.com/weblogs/viewpost.jsp?thread=259358</a></a>
来源： <a href="[http://www.rootsir.com/transshipment/2012/709.html](http://www.rootsir.com/transshipment/2012/709.html)">[http://www.rootsir.com/transshipment/2012/709.html](http://www.rootsir.com/transshipment/2012/709.html)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:29"datetime="2014-03-07 11:24:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--BruceEckel：编程生涯/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--BruceEckel：编程生涯" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--分享警惕偷走时间的5大窃贼/">【分享】警惕偷走时间的5大窃贼</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--分享警惕偷走时间的5大窃贼/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-5-">【分享】警惕偷走时间的5大窃贼</h1>
<p><a href=""></a></p>
<p><a href="http://www.cnblogs.com/cancanwyq/" target="_blank">E8软件 中国式流程管控解决方案领导者 400-006-2800 公众微信号：e8flow</a></p>
<p>致力于中国管理软件设计
E8软件||ITSM解决方案||IT服务管理系统||ITIL管理思想执行工具||E8.NET工作流架构||企业流程管理解决方案</p>
<ul>
<li><a href="http://www.cnblogs.com/" target="_blank">博客园</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/" target="_blank">首页</a></li>
<li><a href="http://q.cnblogs.com/" target="_blank">博问</a></li>
<li><a href="http://home.cnblogs.com/ing/" target="_blank">闪存</a>
<em>
</em></li>
<li><a href="http://www.cnblogs.com/cancanwyq/rss" target="_blank">订阅</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/admin/EditPosts.aspx" target="_blank">管理</a>
随笔-133  文章-34  评论-370 </li>
</ul>
<h1 id="-5-http-www-cnblogs-com-cancanwyq-p-3281827-html-"><a href="http://www.cnblogs.com/cancanwyq/p/3281827.html" target="_blank">【分享】警惕偷走时间的5大窃贼</a></h1>
<p> <a href="http://www.chinae8.net/" target="_blank"><img src="" alt=""></a></p>
<p>好的管理者都是好的时间管理者。而管理者时间管理的根本是抓大放小、果断决策、大胆授权、梳理系统、做好计划。只有这样，管理者才能防范偷走你宝贵时间的5大窃贼，才能让自己免于焦头烂额。</p>
<p>管理者管理什么？一是管事，二是管人，三是管时间。在这三个维度上，管事最容易，管人最困难，管时间不难却最容易被忽略。</p>
<p>很多管理者天天忙得团团转，却得不到上司的好评，主要的原因就是不会做时间管理，让自己和下属宝贵的时间被浪费掉。</p>
<p>什么会偷走管理者的时间，让管理者焦头烂额却得不到应得的结果？以我的经验，管理者有5大时间窃贼需要提防。</p>
<ol>
<li><p>抓小放大。很多管理者忙于无数的小细节，不跳出细节思考什么才是自己真正应该做的事情。结果是不重要的事情做了一大堆，重要的事情一个没有做，上司不关心的事情做了一大堆，上司关心的事情一个没有做。其实事情都有逻辑关系和层次：解决一个上一级的问题，通常能让你一下子解决3〜5个次一级的问题。如果我们能抓住最上级的问题用心解决，解决一个最上级问题的效果会相当于解决几十个最底层级的问题。但解决一个大问题和解决一个小问题花的时间差别并不大，至少不是几十倍的差别。</p>
</li>
<li><p>议而不决。很多管理者忙于开会，忙于和很多相关和不相关的同事讨论如何解决一个问题，却迟迟不愿自己负起责任做出决定。这类管理者把本来可以半个小时开完的会议拖延到3个小时，把本来可以在一次会议上做的决定延迟到下一次会议。议而不决的后果是让管理者要处理的事情大量积压，让管理者的时间越来越少。这样的管理者没有认识到，没有事情可以通过拖延得到解决，决策的质量也不能通过拖延得到提高。</p>
</li>
<li><p>不能授权。很多管理者习惯于自己做事情，不习惯授权给别人做，总担心别人做不好，总觉得教会别人做不如自己做快。久而久之，自己做的小事越来越多，自己的时间越来越不够用，身边的人越来越闲，自己的委屈越来越多。</p>
</li>
<li><p>管而不理。很多管理者习惯于管事，不习惯于理事。例如，发现有人迟到，会狠狠地批评当事人，却不会思考是否是公司的考勤制度或考勤技术有问题。管而不理的后果是，一件事情发生一次，管理者要管一次，次次发生，次次要管。随着企业规模的扩大，次次管的事情会大幅增加，管理者的时间越来越少。其实只要系统梳理一次，一类问题就能解决了。从这个角度看，管是小，理是大，管理者要抓大放小，就要更多地梳理，而不是被动地管理。</p>
</li>
<li><p>不做计划。计划是什么？就是把你要做的事情和你可以用的资源合理地匹配起来，简而言之就是事先想清楚在什么时间用什么资源完成你要做的事情。在可以用的资源里，最重要的和最稀少的资源就是时间了。不做计划意味着资源和事情不匹配，意味着资源尤其是时间资源的浪费。一个人一天就24小时，浪费了就没有了。很多人忙，其实不是没有时间，而是没有合理地安排时间。</p>
</li>
</ol>
<p>好的管理者都是好的时间管理者。而管理者时间管理的根本是抓大放小、果断决策、大胆授权、梳理系统、做好计划。只有这样，管理者才能防范偷走你宝贵时间的5大窃贼，才能让自己免于焦头烂额。</p>
<p><strong>分享是一种美德，请随手转播  </strong></p>
<p>敬请关注【流程管理】公众微信平台，微信号：<strong>e8flow</strong>,宣传流程管理理念，每日会与您分享管理技巧，管理经验、哲理小故事和财经评论、财经观点。 您可以通过 “添加朋友”--&gt; &quot;搜索号码&quot; 或 “查找公众微信账号”,输入 e8flow ,搜索添加此关注</p>
<p>E8软件 提升企业战略执行力
<a href="http://www.chinae8.net/" target="_blank"><a href="http://www.chinae8.net">http://www.chinae8.net</a>
</a> 流程银行QQ群 :74080032
【流程管理】微信公众号：e8flow
绿色通道： <a href="">好文要顶</a> <a href="">关注我</a> <a href="">收藏该文</a><a href="http://space.cnblogs.com/msg/send/%e8%8b%8f%e5%ba%b7%e8%83%9c" target="_blank">与我联系</a> <a href="&quot;分享至新浪微博&quot;"><img src="" alt=""></a></p>
<p><a href="http://home.cnblogs.com/u/cancanwyq/" target="_blank"><img src="" alt=""></a></p>
<p><a href="http://home.cnblogs.com/u/cancanwyq/" target="_blank">苏康胜</a>
<a href="http://home.cnblogs.com/u/cancanwyq/followees" target="_blank">关注 - 0</a>
<a href="http://home.cnblogs.com/u/cancanwyq/followers" target="_blank">粉丝 - 24</a></p>
<p><a href="">+加关注</a></p>
<p>0</p>
<p>0
(请您对文章做出评价)</p>
<p><a href="http://www.cnblogs.com/cancanwyq/archive/2013/08/21/3271848.html" target="_blank">«</a> 上一篇：<a href="http://www.cnblogs.com/cancanwyq/archive/2013/08/21/3271848.html" title="发布于2013-08-21 09:04" target="_blank">2013年江苏省钢贸市场融资黑洞引发传统信用分析技术的思考</a></p>
<p>posted @ 2013-08-26 08:24 <a href="http://www.cnblogs.com/cancanwyq/" target="_blank">苏康胜</a> 阅读(162) 评论(0) <a href="http://www.cnblogs.com/cancanwyq/admin/EditPosts.aspx?postid=3281827" target="_blank">编辑</a> <a href="">收藏</a></p>
<p><a href="">刷新评论</a><a href="">刷新页面</a><a href="">返回顶部</a></p>
<p>注册用户登录后才能发表评论，请 <a href="">登录</a> 或 <a href="">注册</a>，<a href="http://www.cnblogs.com/" target="_blank">访问</a>网站首页。
<a href="http://www.cnblogs.com/" title="程序员的网上家园" target="_blank">博客园首页</a><a href="http://q.cnblogs.com/" title="程序员问答社区" target="_blank">博问</a><a href="http://news.cnblogs.com/" title="IT新闻" target="_blank">新闻</a><a href="http://home.cnblogs.com/ing/" target="_blank">闪存</a><a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a><a href="http://kb.cnblogs.com/" target="_blank">知识库</a></p>
<p><strong>最新IT新闻</strong>:
· <a href="http://news.cnblogs.com/n/186400/" target="_blank">淘宝保险潜行三年保单超10亿笔 运费险占比过半</a>
· <a href="http://news.cnblogs.com/n/186399/" target="_blank">科学家发现古埃及人陨石项链：距今5000年</a>
· <a href="http://news.cnblogs.com/n/186398/" target="_blank">键盘藏真菌比臭鞋高65倍</a>
· <a href="http://news.cnblogs.com/n/186396/" target="_blank">乔布斯和马斯克两巨人之间的“神同步”</a>
· <a href="http://news.cnblogs.com/n/186395/" target="_blank">苹果7月修改应用排行算法：首次参考用户评级</a>
» <a href="http://news.cnblogs.com/" title="IT新闻" target="_blank">更多新闻...</a></p>
<p><strong>最新知识库文章</strong>:
· <a href="http://kb.cnblogs.com/page/186346/" target="_blank">计算机专业学习浅谈</a>
· <a href="http://kb.cnblogs.com/page/186221/" target="_blank">遗失的乔布斯访谈</a>
· <a href="http://kb.cnblogs.com/page/179631/" target="_blank">从登录开始</a>
· <a href="http://kb.cnblogs.com/page/179146/" target="_blank">聊聊内存泄露</a>
· <a href="http://kb.cnblogs.com/page/185599/" target="_blank">与Google轻轻地擦肩而过</a>
» <a href="http://kb.cnblogs.com/" target="_blank">更多知识库文章...</a></p>
<h3 id="-">公告</h3>
<p>自2007年10月20日
<a href="http://www.newzgc.com/" target="_blank"><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""></a>
<a href="http://www.feifanit.com.cn/productITSM.htm?default=solutions" target="_blank">E8.ITSM HelpDesk 您身边的IT服务管理专家</a>
<a href="http://www.feifanit.com.cn/productITSM.htm" target="_blank"><img src="" alt=""></a>
<a href="http://www.feifanit.com.cn/productFlow.htm" target="_blank">E8.Net工作流提升企业管理执行力</a>
<a href="http://www.feifanit.com.cn/productFlow.htm" target="_blank"><img src="" alt=""></a>
<a href="http://t.qq.com/E8FLOW" target="_blank"><img src="" alt=""></a> 敬请关注【流程管理专家】公众微信号：e8flow,分享流程管理经验，传播管理理念，提升管理执行力！</p>
<p>昵称：<a href="http://home.cnblogs.com/u/cancanwyq/" target="_blank">苏康胜</a>
园龄：<a href="http://home.cnblogs.com/u/cancanwyq/" title="入园时间：2006-02-15" target="_blank">7年6个月</a>
粉丝：<a href="http://home.cnblogs.com/u/cancanwyq/followers/" target="_blank">24</a>
关注：<a href="http://home.cnblogs.com/u/cancanwyq/followees/" target="_blank">0</a></p>
<p><a href="">+加关注</a></p>
<h3 id="-">搜索</h3>
<h3 id="-">我的标签</h3>
<ul>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/%E5%B7%A5%E4%BD%9C%E6%B5%81/" target="_blank">工作流</a>(15)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/.net/" target="_blank">.net</a>(11)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" target="_blank">项目管理</a>(8)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F/" target="_blank">开发团队</a>(6)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/E8.net/" target="_blank">E8.net</a>(6)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/ITIL/" target="_blank">ITIL</a>(5)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/IT%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/" target="_blank">IT服务管理</a>(4)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/.Net%E5%B7%A5%E4%BD%9C%E6%B5%81/" target="_blank">.Net工作流</a>(4)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/CIO/" target="_blank">CIO</a>(4)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/E8.Net%E6%9E%B6%E6%9E%84/" target="_blank">E8.Net架构</a>(3)</li>
<li><p><a href="http://www.cnblogs.com/cancanwyq/tag/" target="_blank">更多</a></p>
<h3 id="-">经典收藏</h3>
</li>
<li><p><a href="http://blog.vsharing.com/cancanwyq" target="_blank">ITIL标准面向中国企业的实践之路</a></p>
</li>
<li><a href="http://blog.vsharing.com/cancanwyq" target="_blank">ITIL与ITSM管理软件</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/articles/343325.html" target="_blank">工作流技术杂谈</a></li>
<li><a href="http://www.feifanit.com.cn/" target="_blank">工作流应用网站</a></li>
</ul>
<h3 id="-">团队博客</h3>
<ul>
<li><a href="http://dotnetenterprise.cnblogs.com/" target="_blank">.Net企业应用开发</a></li>
<li><a href="http://shanghai.cnblogs.com/" target="_blank">上海.net俱乐部</a></li>
<li><p><a href="http://shenzhen.cnblogs.com/" target="_blank">深圳.Net俱乐部</a></p>
<h3 id="-">阅读排行榜</h3>
</li>
<li><p><a href="http://www.cnblogs.com/cancanwyq/archive/2009/09/22/1571707.html" target="_blank">1. 从网友发的一个关于程序员人生的流程图想到的(4923)</a></p>
</li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2009/03/18/1415070.html" target="_blank">2. 技术高速发展，IT人员路在何方？(3554)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2007/10/27/939392.html" target="_blank">3. 模式窗口window.open造成Session丢失的解决方法(2984)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2009/05/12/1454574.html" target="_blank">4. 机会来了，创业你准备好了吗？(2668)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/06/10/1755244.html" target="_blank">5. 软件公司有一种幸福叫好好活着(2566)</a></li>
</ul>
<h3 id="-">推荐排行榜</h3>
<ul>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/06/10/1755244.html" target="_blank">1. 软件公司有一种幸福叫好好活着(6)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/06/09/1754443.html" target="_blank">2. 软件企业三个“留住”，创建品质团队(4)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/08/23/1806258.html" target="_blank">3. 项目经理进阶修炼2--处理需求变更策略(4)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/07/19/1780453.html" target="_blank">4. 中国程序员有望挑战“比尔.盖茨”的三大管理类需求(3)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/08/16/1800428.html" target="_blank">5. 软件开发技术高手转向项目管理者要突破的误区-- 跟博客园的朋友探讨的思路(3)</a>
Copyright ©2013 苏康胜</li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:29"datetime="2014-03-07 11:24:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--分享警惕偷走时间的5大窃贼/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--分享警惕偷走时间的5大窃贼" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--知其所以然（三）：为什么算法这么难？/">知其所以然（三）：为什么算法这么难？</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--知其所以然（三）：为什么算法这么难？/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">知其所以然（三）：为什么算法这么难？</h1>
<h1 id="-http-mindhacks-cn-2011-07-10-the-importance-of-knowing-why-part3-"><a href="http://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/" target="_blank">知其所以然（三）：为什么算法这么难？</a></h1>
<p>不知不觉《知其所以然》系列竟然也写到第三篇了，虽然前面两篇也说了不少，但是总觉得还有东西没有说“透”，或者说没有说“好”。所以这篇试图从不同的角度用更好的例子来继续深入阐述。（感谢<a href="http://www.douban.com/people/silwile/" target="_blank">silwile</a>对本文的review和意见）</p>
<p>广大码农同学们大多都有个共识，认为算法是个硬骨头，很难啃，悲剧的是啃完了还未必有用——除了面试的时候。实际工程中一般都是用现成的模块，一般只需了解算法的目的和时空复杂度即可。</p>
<p>不过话说回来，面试的时候面算法，包括面项目中几乎不大可能用到的算法，其实并不能说是毫无道理的。<strong>算法往往是对学习和理解能力的一块试金石</strong>，难的都能掌握，往往容易的事情不在话下。志于高者得于中。反之则不成立。另一方面，虽说教科书算法大多数都是那些即便用到也是直接拿模块用的，但不幸的是，我们这群搬砖头的有时候还非得做些发明家的事情：要么是得把算法当白盒加以改进以满足手头的特定需求；要么干脆就是要发明轮子。所以，虽说面试的算法本身未必用得到，但熟悉各种算法的人通常更可能熟悉算法的思想，从而更可能具备这里说的两种能力。</p>
<p>那么，为什么说算法很难呢？这个问题只有两种可能的原因：</p>
<ol>
<li>算法本身就很难。也就是说，算法这个东西对于人类的大脑来说本身就是个困难的事儿。</li>
<li>讲得太烂。</li>
</ol>
<p>下面会说明，算法之所以被绝大多数人认为很难，以上两个原因兼具。</p>
<p>我们说算法难的时候，有两种情况：<strong>一种是学算法难。第二种是设计算法难</strong>。对于前者，大多数人（至少我当年如此）学习算法几乎是在背算法，就跟背菜谱似的（“Cookbook”是深受广大码农喜爱的一类书），然而算法和菜谱的区别在于，算法包含的细节复杂度是菜谱的无数倍，算法的问题描述千变万化，逻辑过程百转千回，往往看得人愁肠百结，而相较之下任何菜谱涉及到的基本元素也就那么些（所以程序员肯定都具有成为好厨师的潜力:D）注意，即便你看了算法的证明，某种程度上还是“背”（为什么这么说，后面会详述）。我自己遇到新算法基本是会看证明的，但是发现没多久还是会忘掉，这是死记硬背的标准症状。如果你也啃过算法书，我相信很大可能性你会有同感：<em>为什么当时明明懂了，但没多久就忘掉了呢？为什么当时明明非常理解其证明，但没过多久想要自己去证明时却发现怎么都没法补上证明中缺失的一环呢？</em></p>
<p>初中学习几何证明的时候，你会不会傻到去背一个定理的证明？不会。你只会背结论。为什么？一方面，因为证明过程包含大量的细节。另一方面，证明的过程环环相扣，往往只需要注意其中关键的一两步，便能够自行推导出来。算法逻辑描述就好比定理，算法的证明的过程就好比定理的证明过程。但不幸的是，与数学里面大量简洁的基本结论不同，算法这个“结论”可不是那么好背的，许多时候，<strong>算法本身的逻辑就几乎包含了与其证明过程等同的信息量</strong>，甚至算法逻辑本身就是证明过程（随便翻开一本经典的算法书，看几个经典的教科书算法，你会发现算法逻辑和算法证明的联系有多紧密）。于是我们又回到刚才那个问题：你会去背数学证明么？<strong>既然没人会傻到去背整个证明，又为什么要生硬地去背算法呢</strong>？</p>
<p>那么，不背就不背，去理解算法的证明如何？理解了算法的证明过程，便更有可能记住算法的逻辑细节，理解记忆嘛。然而，仍然不幸的是，绝大多数算法书在这方面做的实在糟糕，证明倒是给全了，逻辑也倒是挺严谨的，可是似乎没有作者能真正还原算法发明者本身如何得到算法以及算法证明的思维过程，按理说，证明的过程应该反映了这个思维过程，但是在下文关于霍夫曼编码的例子中你会看到，其实饱受赞誉的<a href="http://www.amazon.com/Introduction-Algorithms-International-Thomas-Cormen/dp/0262533057" target="_blank">CLRS</a>和<a href="http://www.amazon.com/Algorithms-Sanjoy-Dasgupta/dp/0073523402" target="_blank">《Algorithms》</a><em>不仅没能还原这个过程，反而掩盖了这个过程</em>。</p>
<p>必须说明的是，没有哪位作者是故意这样做的，但任何人在讲解一个自己已经理解了的东西的时候，往往会无意识地对自己的讲解进行“线性化”，例如证明题，如果你回忆一下高中做平面几何证明题的经历，就会意识到，其实证明的过程是一个充满了试错，联想，反推，特例，修改问题条件，穷举等等一干“非线性”思维的，混乱不堪的过程，而并不像写在课本上那样——引理1，引理2，定理1，定理2，一口气直到最终结论。这样的证明过程也许容易理解，但绝对不容易记忆。过几天你就会忘记其中一个或几个引理，其中的一步或几步关键的手法，然后当你想要回过头来自己试着去证明的时候，就会发现卡在某个关键的地方，为什么会这样？因为证明当中并没有告诉你为什么作者当时会想到证明算法需要那么一个引理或手法，所以，<strong>虽说看完证明之后，对算法这个结论而言你是知其所以然了，但对于算法的证明过程你却还没知其所以然</strong>。在我们大脑的记忆系统当中，<strong>新的知识必须要和既有的知识建立联系，才容易被回忆起来</strong>（<a href="http://mindhacks.cn/2009/03/28/effective-learning-and-memorization/" target="_blank">《如何有效地学习与记忆》</a>）<strong>，联系越多，越容易回忆，而一个天外飞仙似地引理，和我们既有的知识没有半毛钱联系，没娘的孩子没人疼，自然容易被遗忘。</strong>（为什么还原思维过程如此困难呢？我曾经在<a href="http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/" target="_blank">知其所以然（一）</a>里详述）</p>
<p>正因为绝大多数算法书上悲剧的算法证明过程，很多人发现证明本身也不好记，于是宁可选择直接记结论。当年我在数学系，考试会考证明过程，但似乎计算机系的考试考算法证明过程就是荒谬的？作为“工程”性质的程序设计，似乎更注重使用和结果。但是如果是你需要在项目中自己设计一个算法呢？这种时候最起码需要做的就是证明算法的正确性吧。我们面试的时候往往都会遇到一些算法设计问题，我总是会让应聘者去证明算法的正确性，因为即便是<strong>一个“看上去”正确的算法，真正需要证明起来往往发现并不是那么容易</strong>。</p>
<p>所以说，绝大多数算法书在作为培养算法设计者的角度来说是失败的，比数学教育更失败。大多数人学完了初中平面几何都会做证明题（数学书不会要求你记住几何所有的定理），但很多人看完了一本算法书还是一团浆糊，不会证明一些起码的算法，我们背了一坨又一坨结论，非但这些结论许多根本用不上，就连用上的那些也不会证明。为什么会出现这样的差异？因为数学教育的理想目的是为了让你成为能够发现新定理的科学家，而码农系的算法教育的目的却更现实，是为了让你成为能够使用算法做事情的工程师。然而，事情真的如此简单么？如果真是这样的话干脆连算法结论都不要背了，只要知道算法做的是什么事情，时空复杂度各是多少即可。</p>
<p>如果说以上提到的算法难度（讲解和记忆的难度）属于<a href="http://en.wikipedia.org/wiki/Accidental_complexity" target="_blank">Accidental Complexity</a>的话，算法的另一个难处便是Essential Complexity了：算法设计。还是拿数学证明来类比（如果你看过《Introduction to Algorithms：A Creative Approach》就知道算法和数学证明是多么类似。），与单单只需证明相比，<strong>设计算法的难处在于，定理和证明都需要你去探索，尤其是前者</strong>——你需要去自行发现关键的那（几）个定理，跟证明已知结论相比（已经确定知道结论是正确的了，你只需要用逻辑来连接结论和条件），<strong>这件事情的复杂度往往又难上一个数量级。</strong></p>
<p>一个有趣的事实是，<strong>算法的探索过程往往蕴含算法的证明过程</strong>，理想的算法书应该通过还原算法的探索过程，从而让读者不仅能够自行推导出证明过程，同时还能够具备探索新算法的能力。之所以这么说，皆因为我是个懒人，懒人总梦想学点东西能够实现以下两个目的：</p>
<ol>
<li><strong>一劳永逸</strong>：程序员都知道“<a href="http://en.wikipedia.org/wiki/Write_once,_run_anywhere" target="_blank">一次编写到处运行</a>”的好处，多省事啊。学了就忘，忘了又得学，翻来覆去浪费生命。为什么不能看了一遍就再也不会忘掉呢？到底是教的不好，还是学得不好？</li>
<li><strong>事半功倍</strong>：事实上，程序员不仅讲究一次编写到处运行，更讲究“一次编写到处使用”（也就是俗称的“复用”）。如果学一个算法所得到的经验可以到处使用，学一当十，推而广之，时间的利用效率便会大大提高。究竟怎样学习，才能够使得经验的外推（extrapolate）效率达到最大呢？</li>
</ol>
<p>想要做到这两点就必须<strong>尽量从知识树的“根节点”入手</strong>，虽然这是一个美梦，例如数学界寻找“根节点”的<a href="http://mindhacks.cn/2008/04/18/learning-from-polya/" target="_blank">美梦由来已久</a>（《跟波利亚学解题》的“一点历史”小节），但哥德尔一个证明就<a href="http://mindhacks.cn/2006/10/15/cantor-godel-turing-an-eternal-golden-diagonal/" target="_blank">让美梦成了泡影</a>（《永恒的金色对角线》））；但是，这并不阻止我们去寻找更高层的节点——<a href="http://mindhacks.cn/2008/04/18/learning-from-polya/" target="_blank">更具普适性的解题原则和方法</a>。所以，理想的算法书或者算法讲解应该是从最具一般性的思维法则开始，顺理成章地推导出算法，这个过程应该尽量还原一个”普通人“思考的过程，而不是让人看了之后觉得”这怎么可能想到呢？</p>
<p>以本文上篇提到的霍夫曼编码为例，第一遍看霍夫曼编码的时候是在本科，只看了算法描述，觉得挺直观的，过了两年，忘了，因为不知道为什么要把两个节点的频率加在一起看做单个节点——一件事情不知道“为什么”就会记不牢，知道了“为什么”的话便给这件事情提供了必然性。不知道“为什么”这件事情便可此可彼，<strong>我们的大脑对于可此可彼的事情经常会弄混，它更容易记住有理有据的事情</strong>（<em>从信息论的角度来说，一件必然的事情概率为1，信息量为0，而一件可此可彼的事情信息量则是大于0的</em>）。第二遍看是在工作之后，终于知道要看证明了，拿出著名的《Algorithms》来看，边看边点头，觉得讲得真好，一看就理解了为什么要那样来构造最优编码树。可是没多久，又给忘了！这次忘了倒不是忘了要把两个节点的频率加起来算一个，而是忘了为什么要这么做，因为当时没有弄清霍夫曼为什么能够想到为什么应该那样来构造最优编码树。结果<em>只知其一不知其二</em>。</p>
<p>必须说明的是，如果只关心算法的结论（即算法逻辑），那么理解算法的证明就够了，光背算法逻辑难记住，理解了证明会容易记忆得多。但如果也想不忘算法的证明，那么不仅要理解证明，还要理解证明背后的思维，也就是<em>为什么背后的为什么</em>。后者一般很难在书和资料上找到，唯有自己多加揣摩。为什么要费这个神？只要不会忘记结论不就结了吗？取决于你想做什么，如果你想真正弄清算法设计背后的思想，不去揣摩算法原作者是怎么想出来的是不行的。</p>
<p>回到霍夫曼编码问题，我们首先看一看《Algorithms》上是怎么讲的：</p>
<p>首先它给出了一棵编码树的cost function：</p>
<p>cost of tree = Σ freq(i) /* depth(i)</p>
<p>这个cost function很直白，就是把编码的定义复述了一遍。但是接下来就说了：</p>
<p><em>There is another way to write this cost function that is very helpful.</em> Although we are only given frequencies for the leaves, we can define the frequency of any internal node to be the sum of the frequencies of its descendant leaves; this is, after all, the number of times the internal node is visited during encoding or decoding…</p>
<p>接着就按照这个思路把cost function转换了一下：</p>
<p>The cost of a tree is the sum of the frequencies of all leaves and internal nodes, except the root.</p>
<p>然后就开始得出算法逻辑了：</p>
<p>The <em>first formulation</em> of the cost function tells us that the <em>two symbols with the smallest frequencies must be at the bottom of the optimal tree</em>, as children of the lowest internal node (this internal node has two children since the tree is full). Otherwise, swapping these two symbols with whatever is lowest in the tree would improve the encoding.</p>
<p>This suggests that we start constructing the tree greedily: find the two symbols with the smallest frequencies, say i and j, and make them children of a new node, which then has frequency fi + fj. To keep the notation simple, let’s just assume these are f1 and f2. By the <em>second formulation</em> of the cost function, any tree in which f1 and f2 are sibling-leaves has cost f1 + f2 plus the cost for a tree with n – 1 leaves of frequencies (f1 + f2), f3, f4, .., fn. <em>The latter problem is just a smaller version of the one we started with</em>.</p>
<p>读到这里我想大多数人有两种反应：</p>
<ol>
<li>觉得理所当然。</li>
<li>觉得恍然大悟。</li>
</ol>
<p>因为我当时也是这么觉得的。可是后来当我发现自己无法从头证明一遍的时候，我知道肯定是理解的不够深刻。如果理解的够深刻，那么基本上是不会忘掉的。</p>
<p>如果看完霍夫曼编码这样一个简短证明你觉得顺理成章，一切都挺显然，<em>那就坏了</em>，即便是看上去最基本的性质也往往实际上没那么显然。“逢山开路，遇水架桥”在我们今天看来是无比显然的事实，但是试想在没有桥的远古时代，一个原始人走到一条湍急的河流前，他会怎么想，他又能有什么法子呢？这是个他从来没有遇见过的问题。如果后来有一天，他路过另外一条小溪，看到小溪上有一截被闪电劈断的枯树，于是他踏着树干走过了小溪，并意识到“树横过河面”可以达到“过河”这个目的，这就将条件和目的建立了直接的联系（事实上，是自然界展示了这个联系，我们的原始人只是记住了这个联系）。后来他又路过那条河流，他寻思如何达到“过河”这个目的的时候，忽然意识到在他的记忆中已经遇到过需要达成同样目的的时候了，那个时候的条件是“树横过河面”，于是问题便归结为如何满足这个“树横过河面”的条件，而后一个问题就简单多了。（事实上波利亚在他的著作《How to Solve it》中举的正是这么个例子）</p>
<p>为什么那么多的算法书，就看不到有一本讲得好的？因为我们求解问题过程中的思维步骤太容易被自己当作“显然”的了，但除了我们天生就会的认知模式（联系，类比），没有什么是应该觉得显然的，试错是我们天生就会的思维法则么？是的，但是可供尝试的方案究竟又是怎么来的呢？就拿上面的例子来说，一个从没有见过枯树干架在小溪上的原始人，怎么知道用树架桥是一种可选的方案呢？俗话说巧妇难为无米之炊啊。我们大脑的神经系统会的是将目的和条件联系起来，第一次原始人遇到小溪过不去，大脑中留下了一个未实现的目的，后来见到小溪上的树干，忽然意识到树干是实现这个目的的条件，两者便联系起来了，因此问题就规约为如何架树干了。</p>
<p>回到《Algorithms》中的证明上，这个看似简洁明了的证明其实有几处非常不显然的地方，甚至不严谨的地方，这些地方也正是你过段时间之后试图自己证明的话会发现卡住的地方：</p>
<ol>
<li>作者轻飘飘地就给出了cost function的另外一种关键的描述，而对于如何发现这种描述却只是一语带过：&quot;<em>There is another way to write this cost function that is very helpful.. </em>we can define the frequency of any internal node to be the sum of the frequencies of its descendant leaves“这其实就是我常常痛恨的“<em>我们考虑</em>…”，这里作者其实就是在说”让<em>我们考虑</em>下面这样一种<em>奇妙</em>的转换“，可是怎么来的却不说。但必须承认，《Algorithms》的作者还是算厚道的，因为后面他又稍微解释了一下：“this is, after all, the number of times the internal node is visited during encoding or decoding…”这个解释就有点让人恍然大悟了，但是千万别忘了，这种恍然大悟是一种错觉，你还是没明白为什么他会想到这一点。这就像是作者对你说“<em>仔细观察</em>问题条件，我们<em>容易发现</em>这样一种奇妙的性质..”，怎么个“仔细”法？凭什么我自己“观察”半天就是发现不了呢？霍夫曼本人难道也是死死盯着问题<a href="http://en.wikipedia.org/wiki/Huffman_tree#History" target="_blank">“观察”了一学期</a>然后就“发现”了么？我们有理由相信霍夫曼肯定尝试了各种各样的方法，作出了各种各样的努力，否则当年Shannon都没搞定的这个问题花了他一学期，难道他在这个学期里面大脑就一片空白（或者所有的尝试全都是完全不相干的徒劳），然后到学期末尾忽然“灵光一现”吗？</li>
<li>如果“仔细观察”:)，我们会发现两个cost function表达中frequency的概念有微妙的差异，在第一个cost function中，只有叶子节点有frequency，而这个frequency必须和叶子节点的深度相乘。而在第二个cost function中，内部节点也具有了frequency，可是所有节点的“frequency”忽然全都不跟深度相乘了。frequency的不同含义令人困惑。</li>
<li>作者提到：第一个cost function告诉我们频率最低的两个节点必然处于最优编码树的底端，作为最低内部节点的两个子节点。这是一个不严谨的说法，从前文给出的条件和性质，只能推导出编码树的最底层必然能找到频率最低的两个节点，但<em>它们未必一定要是兄弟节点</em>，如果树的最底层不止能容纳两个节点的话它们就可以有不同的父节点。“我们不妨考虑”这样一个例子：对A,B,C,D四个字母进行编码，假设它们的频率分别是1， 1， 2， 2。这个时候我们可以构造如下图所示的两棵树，两棵树的cost都是12，都是最优的。但其中一棵树中，两个频率最低的节点并非兄弟。 
<a href="http://mindhacks.cn/wp-content/uploads/2011/07/tree2.jpg" target="_blank"><img src="&quot;tree2&quot;" alt="tree2"></a></li>
</ol>
<p>为什么要提到上面这几点不显然和不严谨的地方，因为只要当你看到算法书上出现不显然和不严谨的地方，基本上就意味着作者其实跳过了关键的思维步骤。</p>
<p>不幸的是《Algorithms》这本书里面讲霍夫曼编码已经算是讲的好的了，如果你翻开著名的CLRS，看一看当中是怎么证明的，你就知道我说的什么意思了。有时候这些证明是如此的企图追求formal和严谨，一上来就定义符号一大摞，让人看了就想吐。</p>
<p>说了这么多，<em>有没有可能把霍夫曼编码讲的更好呢</em>？前面说过，霍夫曼编码我记了又忘，忘了又记，好几次了，有一次终于烦了，心想如果要自己去证明，会怎么去证，那个时候我已经忘了《Algorithms》里面怎么讲的了。所以我得从头来起，首先，对于算法问题，有一个一般性原则是，<strong>先看一看解空间的构成</strong>。尤其是对于搜索问题（最优化问题可以看做搜索问题的一个特例），这一点尤其重要。霍夫曼编码的可能的编码树是有穷的，如果穷举所有的编码树，然后找到那棵代价最小的，这种方法至少是可行的，有了可行的方法（即便是穷举）至少让我们内心感到踏实。</p>
<p>接下来便是提高搜寻效率的问题。而提高搜寻效率的关键（同样也是一个一般性原则），便是<strong>尽量去寻找问题条件能够推导出来的性质，**</strong>然后利用这些性质去避免不必要的搜寻**，只要你学过二分搜索就应该理解这个一般性原则：二分搜索的效率之所以高于“穷搜”（O(n)），便是因为它利用了问题中的性质（有序）来避免了不必要的搜寻。有时候这个性质甚至可以直接将时间降为O(1)，例如在一个有序数组中寻找出现次数大于n/2的数（假设该数存在），利用“该数一定出现在数组正中间”这个性质，我们直接就避免了所有的计算。</p>
<p>不过，话虽如此，有时候这些性质并不是那么“显然”的，需要对问题进行深入的折腾才能有可能发现。第三个一般原则：如果你要搜寻的元素是某个满足特定条件的元素（例如寻找最优解的时候，“最优”的定义就是这个“特定条件”），那么可以“<strong>倒过来推</strong>”（数学证明常用手法，结论当条件使），即假设你已经找到了你要找的元素，那么能得出哪些结论，每一个结论都是最优解的一个必要条件，而<em>每一个必要条件都能够帮助你避免不必要的搜寻</em>，因为你<em>只要发现某个候选解不满足某个必要条件，就可以立即将其丢弃</em>，前面提到的寻找出现次数大于n/2的例子是一个极端情况，我们得出的必要条件导致我们可以直接丢弃除中点元素之外的一切其他元素，再例如如果有人叫你寻找有序数组中最小元素，你会毫不犹豫地把该数组头尾元素中较小的那个给他，因为你知道“如果那个最小元素存在，那么它<em>必然</em>位于头尾”——这个必要条件直接允许你丢弃掉n-2个候选解。</p>
<p>回到霍夫曼编码问题，按照这个原则，我们会去<em>假设已经得到了最优编码树</em>，那么我们能够发现关于它的什么性质呢？这里又要提到另一个适用于很多最优化问题的原则（前面提到的原则适用于一般性搜索问题），<strong>所谓最优解，就是说比其他所有解都要更好</strong>，虽然这句话听上去像是废话，但是它的一个直接推论——<strong>比与它邻近的所有候选解都要好</strong>——就是一个非常有用的，不是废话的性质了。学过微积分的都知道，光滑函数的最值点必然是大（小）于其邻域内的所有点的，然后再根据这个就自然推出该点的一阶导数（切线斜率）必然为0的性质，这个性质（必要条件）让我们直接省掉了去整个区间内搜索的麻烦，从而可以直接锁定有限几个候选解。那么，既然我们说最优霍夫曼树一定比它“附近”的树更好，我们就想看看，怎么来找到它附近的树。我们知道要从一个点到它附近，往往是对这个点进行一些调整，例如N+1是到达附近的另一个整数。霍夫曼树是一棵树，所以对这棵树的所有的一次“改动”（或“折腾”）都能够到达与它的“改动”距离为1的点（是不是想起“编辑距离”这个概念），怎么改动呢？最符合直觉的（虽然并不是唯一的）改动便是把叶子节点进行互换。</p>
<p>于是我们得到一个重要的推论：</p>
<ul>
<li><em>在最优霍夫曼树中，无论互换哪两个叶子节点，得到的树都变得更“差”。（严格来说是不会变得更“好”，因为最优树未必唯一）</em></li>
</ul>
<p>这个性质看上去有点像废话，值得费这么多事么？值得。因为虽然前文说了很多，但都是大多数人大脑里面既有的，一般性的法则，前面说过，如果我们能够从我们已经掌握的一般法则出发来推导出问题的解，那么记忆负担是最小的，因为这里面用到的所有法则我们都很清楚，也知道怎么一步步往下走。</p>
<p>上面这个性质究竟意味着什么呢？如果你假设这两个叶子节点的频率为f1和f2，深度为d1和d2，互换它们的时候，其他叶子节点的cost保持不变，令为常量C，那么互换前总cost为C+f1d1+f2d2，互换后为C+f1d2+f2d1，既然互换之后的树一定更”差“那么就是说f1d1+f2d2 &lt; f1d2 + f2d1，简单变换一下就得到结论：f1(d1-d2)<f2(d1-d2)，也就是说如果d1<d2，那么f1必然>f2，如果d1&gt;d2，那么f1必然&lt;f2。换言之就是<em>叶子节点的深度越高，频率必须越低</em>，否则就不可能是最优霍夫曼树。那么，之前我们觉得不那么显然的结论便呼之欲出了：频率最低的叶子节点必然位于树的最底层，频率最高的叶子节点必然位于树的最高层。</p>
<p>有了这个结论之后，我们便能够对最优霍夫曼树的构建走出确定性的一步，即，将频率最低的两个叶子节点放在最底层。别小看这一步，这一步已经排除了大量的可能性。这里，我们容易一开始天真地觉得最底层只有这两个叶子节点，于是它们拥有共同父节点，<em>这样一来霍夫曼树的整个拼图便已经拼好了一个小小的角落</em>。</p>
<p>然后我们会发现，要是它们不是兄弟怎么办呢？这里提到另一个一般原则——<strong>归约</strong>。不是兄弟的情况能否归约为是兄弟的情况？反正我们要求的是<em>一个</em>最优解，而不是<em>所有的</em>最优解，我们只需证明，如果当这两个最低频率的叶子不是兄弟的时候的确存在着某棵最优霍夫曼树，那么通过交换它们各自的兄弟，从而让这两个叶子团聚之后，修改后的树仍然是最优的就可以了。事实情况也的确如此，证明非常直接——既然这里涉及到的所有4个节点都在最底层同一个高度上，那么互相交换的时候不会改变他们任何一个人的深度值，所以总cost不会改变。</p>
<p>但是接下来我们犯了难，整个树的一个小小的樱桃状的局部是确定下来了，接下来怎么办呢？一个最自然的思路就是考虑第三小的叶子，因为前面说了，元素频率越低就越位于树的底部嘛。第三小的叶子有两种可能的归属，一是跟最小的两个叶子同样位于最底层（这不会违反我们前面得到的推论），这个时候第三小的叶子的兄弟叶子肯定是第四小的叶子，如下图：</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2011/07/tree3.jpg" target="_blank"><img src="&quot;tree3&quot;" alt="tree3"></a></p>
<p>另一种归属就是往上一层去（注意，一旦第三小的叶子往上去了一层，那么剩下的所有叶子都必须至少在这个层以上），往上一层去了之后，它的兄弟是谁呢？不妨将它和刚才第一第二叶子的父节点结为兄弟（前面证明过，同层之前节点互换不会改变编码的cost），如下图：</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2011/07/tree5.jpg" target="_blank"><img src="&quot;tree5&quot;" alt="tree5"></a></p>
<p>可是现在问题出现了：虽然第一步构建（最小的两个叶子）是确定的，但是到了第二步摆在我们面前的就有两个选择了，到底选择哪个呢？一个办法就是把两种选择都记下来，然后继续往下走。可是别小看两种选择，接下去每一步都有两种选择的话就变成指数复杂度了。所以现在我们便有了动机<em>回头看一看</em>，<em>看问题中是否有什么没有发现的性质能够帮助我们再排除掉其中一个选择</em>。理想情况下如果每一步都是必然的，确定的，那么N步我们就可以构建出整棵树，这是我们希望看到的，抱着这个良好的愿望，我们仔细观察上面两种构型，一个自然而然的问题是：这两种构型都有潜质成为最优解吗？如果我们能够证明其中一种构型不能成为最优解那该多好？就省事多了嘛。这里引入另一个一般性的解题法则：<strong>特例</strong>。我们的<strong>大脑喜欢具体的东西，在特例中折腾和观察会方便的多</strong>。</p>
<p>上面这个{1, 2, 3, 4}的例子就是个很好的特例，如图（注：图中节点旁的数字一概为<em>频率值，</em>而非编号）：</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2011/07/tree31.jpg" target="_blank"><img src="&quot;tree3&quot;" alt="tree3"></a></p>
<p>多加折腾一番<em>也许</em>我们不难发现，如果将1，2及其父节点跟叶子4进行交换（注意：<em>交换的时候1，2也被一同带走了</em>，因为反正1，2两个节点已确定是好兄弟永远不会分家了，折腾的时候只能作为一个整体移动，所以这里也可以说是<strong>交换子树</strong>），那么树的编码将会变得更优，因为这样一次交换会将1和2的深度+1，意味着整棵树的代价+3，而同时会将叶子4的深度-1，也就是说整棵树的代价-4，总体上整棵树的代价就是+3-4=-1（注意，在计算的时候我们只需考虑被交换的局部，因为树的其他部分的代价保持不变）。如下图：</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2011/07/tree4.jpg" target="_blank"><img src="&quot;tree4&quot;" alt="tree4"></a></p>
<p>这个交换启发了我们，其实前面一开始说的交换两个叶子节点<em>可以推广为交换内部节点和叶子节点</em>，然后很快我们就会意识到其实可以推广到交换任意两个节点。（注意，<em>当我们说交换内部节点的时候，其实是连同该内部节点作为局部根节点的整个子树都交换过去</em>）于是前面我们的推论就可以推广为：</p>
<ul>
<li><em>在最优霍夫曼树中，无论互换哪两个节点，得到的树都变得更“差”（交换内部节点则是连同该内部节点作为局部根的子树一同带走）</em></li>
</ul>
<p>这个推论很容易理解，只不过是多增加了一种“编辑”最优霍夫曼树的方法罢了（记住<em>最优霍夫曼树无论怎么“编辑”都不会变得更“好”，包括“交换子树”这种“编辑”</em>），我们前面没有想到这种“编辑”方法是因为它不那么显然，而且当时我们已经想到一种最直接的“编辑”方法了，即交换叶子，就容易顺着那个思路一直走下去，直到我们发现必须寻找新的性质，才回过头来看看有没有其他法子。</p>
<p>当然，并不排除一开始就想到这种推广的可能性，问题求解的过程并不是这么线性的，如果我们习惯了推而广之的思维，也许一下就能想到这个推广来。类似的，也不排除从另一种思路出发想到这种推广的可能性。所以这里只是可能的思维轨迹中的一种，重点在于其中并没有某处忽然出现一个不知从哪里冒出来的，神启一般的结论。</p>
<p>刚才提到，构造最优树的第二步是考虑第三小的叶子，但也有另一种常见的思维：考虑到第一步（即选取频率最小的两个叶子）所做的事情是从N个叶子中选择两个黏在一起作为兄弟，那么也许对于一些人来说自然而然的第二步就是试图继续选取两个节点黏在一起作为兄弟（注意这里不仅可以选择叶子，也可以选择已经生成的内部节点），然后依次类推来拼完整棵树。按照这一思路，第二步的选项仍然还是集中在第三小的叶子上，因为这个选择要么是让第三第四小的叶子结拜为兄弟，要么是让最小两个叶子的父节点和第三小的叶子结拜。</p>
<p>回到刚才我们的推论：在最优霍夫曼树中，无论互换哪两个节点，得到的树都变得更“差”（交换内部节点则是连同该内部节点作为局部根的子树一同带走） 。根据这个推论我们容易计算出，<em>在最优霍夫曼树当中，两个内部节点n1和n2，如果n1比n2更深，那么n1下面的所有叶子的频率之和必然要小于n2下面所有叶子的频率之和</em>。如果交换的是一个内部节点和一个叶子节点，则道理是类似的。这个性质的证明和上面的类似，就不赘述了。</p>
<p>这个性质暗示了一个重要的推广结论：<em>如果我们把每个内部节点的所有叶子的频率之和标在它旁边，那么整棵树的每个节点便都有了一个数值，这个数值遵循统一的规律：即越往深层越小</em>。这就意味着，我们刚才的二选一困境有办法了！当我们将最小的两个叶子f1和f2合并的时候，生成了一个新的节点M，这个节点有一个数字（为两个叶子的频率之和f1+f2），根据上面的推论，<em>这个数字f1+f2跟所有频率一同，遵循最小的在最底层的原则</em>，所以我们下一步必须在剩下的那些互相之间关系待确定的节点（叶子节点和内部节点）之中，即{(f1 + f2), f3, f4}里面选择最小的两个数字结合成兄弟（由于f1和f2这两个节点已经铁板钉钉结为整体了，所以从集合里面可以看做移除）。到这里，我们就发现递归已经出现了，接下去的过程对于绝大多数人应该就真的很显然了。</p>
<p>以上的解释，比《Algorithms》更简短吗？显然不是。反而要长得多（其实真正的思维过程比这要更长，因为中间还会涉及各种不成功的尝试）。但是它比《Algorithms》当中的版本更不容易被忘记，因为其中关键的思维拐点并不是毫无来由的，而是从你已经熟知的，或者说虽然不知道，但容易理解的一般性解题法则出发自然推导出来的，所以你基本上不需要记忆什么东西，因为你需要记的已经在你脑海中了。</p>
<p>在上面的证明过程中，还有一个不像看上去那么显然的事情：在我们寻找最优霍夫曼树的时候，我们曾经试图去比较假想的最优树和它的“临近”的树，从而去探索最优树的性质。但是，究竟什么是临近的树？在前面的讲解中，我们说如果交换A和B这两个叶子节点，便得到一颗不同的树，可以看做和原树的“编辑距离”为1的树。但是，真的这么显然么？难道除了交换叶子的位置，就没有其他办法去“折腾”这棵树了？后来我们看到，可以<em>交换子树</em>而不仅仅是叶子，而交换子树让我们得到了至关重要的推论。此外，如果不是交换，而是像AVL树那样“旋转”呢？说到底，二叉树是一个离散的东西，并不像连续值那样，天生就有“距离”这个概念，如果我们离散而孤立地去看待所有的树，那么没有什么临近不临近的，临近本是一个距离的概念，除非我们定义树和树之间的距离函数，才能说临近与否，而距离函数怎么定义才是“显然”的呢？</p>
<p>还有，其实以上只是试图给出最优霍夫曼树的<em>证明</em>的一个更自然的过程，而<em>当年霍夫曼面临这个问题的时候根本还没有人想到要用二叉树呢！更不要说在二叉树的前提之下进行证明了</em>。根据wikipedia的介绍，霍夫曼同学（当年还在读Ph.D，所以的确是“同学”，而这个问题是坑爹的导师Robert M. Fano<a href="http://www.huffmancoding.com/my-family/my-uncle" target="_blank">给他们作为大作业的</a>，Fano自己和Shannon合作给出了一个suboptimal的编码方案，为得不到optimal的方案而寝食难安，情急之下便死马当活马医扔给他的学生们了）当年为这个问题憔悴了一个学期，最后就快到deadline的时候“忽然”想到二叉树这个等价模型，然后在这个模型下三下五除二就搞定了一篇流芳千古的论文，超越了其导师。</p>
<p>最后说两个有趣的现象：也许很多人会觉得，越是大师来写入门教科书越是好，其实很多时候并非如此，尤其是在算法设计和数学领域，往往越是在其中浸淫久了越是难写出贴近初学者的书，因为大量对初学者来说一点都不显然的事情在他看来已经是“不假思索”了，成了他的内隐记忆，尤其是当他想要和你解释一个复杂的东西的时候你就会发现他会常常逻辑跳跃，满嘴跑术语，根本没有意识到别人对有些术语和隐含的逻辑根本没有像他那样的理解。</p>
<p><strong>最适合将一个东西讲给别人听的时候并不是等懂了很多年以后，而是刚刚弄懂的时候</strong>，这个时候从不懂到懂的差别记忆还非常鲜明，能够清清楚楚地记得到底是哪些关键的地方是最折磨人的，也最能够站在不懂者的角度来思考问题。像波利亚这样，成了大师还能够站在不懂者角度去换位思考的，可以说是凤毛麟角。所以说前Amazon CAO（首席算法官）的<a href="http://www.amazon.com/Introduction-Algorithms-Creative-Udi-Manber/dp/0201120372/" target="_blank">《Introduction to Algorithms: a Creative Approach》</a>绝对是本罕见的好算法书）</p>
<p><a href="http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/" target="_blank">知其所以然（一）</a>里面曾经提到，要弄清来龙去脉，最好去看看原始作者是怎么想的，可是正如上文所说，即便是最初的发明者，在讲述的时候也会有意无意地“线性化”，我就去查看了霍夫曼最初的论文，那叫一个费解，不信你可以自己看看(<a href="http://compression.ru/download/articles/huff/huffman_1952_minimum-redundancy-codes.pdf" target="_blank">PDF</a>)。</p>
<p>可以归约为搜索算法的问题（非常多）一般来说相对还是有一些头绪的，因为搜索空间一般还比较容易界定，难点在于要从问题的条件中推导出用于节省搜索的性质。而策略设计问题则完全是另一个世界，因为策略的设计空间貌似是可列无穷的，常常让人感觉无从下手，摸不着头绪，许多让人挠头的智力问题就有这个特点（例如著名的100个囚徒和1个灯泡的房间就让很多人有这种感觉），策略设计问题也有一些较通用的法则，以后再说。</p>
<p>怎么才能在学算法的时候学到背后的东西呢？有以下几点很重要：</p>
<ol>
<li><strong>不要觉得每个步骤都很显然</strong>，每个nontrivial的算法背后都有一段艰辛的探索经历，觉得显然的话必然是一种幻觉。<strong>Stay foolish</strong>，才能发现某些环节其实并不是那么显然的。</li>
<li>检验是否真正理解的最佳方法就是<strong>过一段时间之后，自己试着证明一次</strong>。如果真正理解了的话，你的证明便会比较顺畅。如果当时没有真正理解，那么凡是那些你当时觉得显然但其实不显然的地方，都会成为你证明里面缺失的环节。</li>
<li>对于一个算法，<strong>多寻找各种来源的资料</strong>，也许能够找到一个讲的比较深刻的。我在<a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/" target="_blank">《数学之美番外篇：快排为什么那么快》</a>和<a href="http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/" target="_blank">《知其所以然（一）》</a>里面都举到了这样的例子。</li>
<li><strong>多试着去抽象背后的一般性法则</strong>，即便后来发现抽象得是错的，也比不去抽象要好。<a href="http://mindhacks.cn/2009/03/28/effective-learning-and-memorization/" target="_blank">抽象是推广的基础</a>。只有抽象出更深层的法则，才能让你事半功倍，触类旁通，否则一个萝卜永远是一个坑。（注意，其实我们的下意识是会进行一定程度的抽象的，例如前面提到的原始人的例子，小溪和小河（或者小沟）细节上是不同的，但本质上是一样的，我们的大脑会自动进行这种简单抽象，提出事物的共性。正因此，即便你不去有意识地总结一般规律，只要你看的足够多，练的足够多，必然就会越来越谙熟。）</li>
</ol>
<p>最后留个问题：虽然按照上文的方式来构造霍夫曼树一定能够得到<em>一个</em>最优树，但是怎么证明一定能得到呢？乍一看这个问题似乎很多余，因为证明很简单：我们拼装整棵树的每一步都没得选，而且每一步都必然拼凑出最优树的一个小小局部，如果最终还没有得到最优树的话，只能说最优树是不存在的了，然而最优树是一定存在的，因为所有树的集合是有穷的，有穷集必有最值，因此证毕。这个证明固然是没问题的，但它其实是一个间接证明，换句话说，我们在构建树的过程中的逻辑是这样的：“之所以我们选择粘结n1和n2，是因为其他粘法必然违反最优树的两个性质。所以我们别无选择。”但是，这并没有说，我们选择了粘结n1和n2，一定就<em>符合</em>了最优树的性质。（也就是说“其他做法都是错”并不能推出“这种做法必然对”，这就像是你在一大堆豆子当中寻找一个特殊的豆子，你拿起一个，看看不是，扔掉，又拿起一个，还不是，扔掉，排除到最后只剩一个豆子了，假设你又知道这个特殊的豆子必然存在，那么这个时候你根本不用看就知道这个豆子一定就是你要找的）那么，你能否直接证明，拼装最优树的过程每一步都<em>符合</em>最优树的性质呢？</p>
<p>P.S.</p>
<p>[1] 《逃出你的肖申克》和《BetterExplained》是我喜欢的两个系列，还会继续写，我有很多问题，也在Evernote里面记了不少零碎的思考和资料，但只有当我觉得理解的足够深入，系统，以及手头有足够的有意思和有说服力的例子的时候，我才会把整条线串起来成文，所以这事慢慢来不着急，反正这个博客也不会关掉。</p>
<p>[2] 工作之后可用业余时间急剧减少，已经陆续基本把GReader砍掉了，时间再往前推，砍掉邮件列表，再往前是Twitter，再往前是BBS。现在基本就只剩邮件了。越来越发现当时间有限的时候，看书比看网要有效得多，也不会那么信息焦虑，网络上的那些消息当中真正重要的会自己来找你，不用每天去刷屏。不过有个例外，我过一阵子就会去逛一下Amazon的个性化推荐项目。如果你已经工作，苦于时间有限，我建议你这么做。最近看过的几本值得好好推荐的书有：《Number Sense》，《Reading in the Brain》，《The Vision Revolution》，《The Tell-Tale Brain》，《Kluge》。</p>
<p>[3] 顺便吐槽国内出版社引进Pop Science类书籍的效率和质量，就我观察，台湾引进Pop Science类书籍需要延迟两年左右，大陆则从三四年到无限期不等（某种程度上，一个国家的出版方的认识水平，决定了这个国家大众的认识水平。你去看下我在豆瓣的书单就知道有多少好书与国内读者失之交臂了），例如《Number Sense》这本好书，到现在还没有引进，99年出版的书啊。《Kluge》更是译为《乱乱脑》这种坑爹的书名，封面搞得跟少儿读物一样。《Reading in the Brain》引入的算较快的，但也延迟了一年半了，而且翻译质量也不是很上乘（算是不功不过吧），说到这里要赞中信出版社，最近一年引入了很多给力的Pop Science畅销书，眼光还算不错。最近在Amazon上搜一些好的发展心理学的书，通过Amazon的推荐引擎看到了<a href="http://www.amazon.com/Pink-Brain-Blue-Differences-Troublesome/dp/0618393110" target="_blank">《Pink Brain，Blue Brain》</a>，这本受到因研究大脑记忆的分子机制而获诺奖的Eric Kandel盛赞的科普09年就出了，到现在国内影子都见不着，还好在卓越上买到了原版。虽然基本还没开始看，但可以郑重推荐给初为父母的同学们:)
来源： <a href="[http://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/](http://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/)">[http://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/](http://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/)</a> </p>
<ul>
<li>kw</li>
</ul>
<p>哇塞，又是不鸣则已，一鸣惊人！</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="dribble"></li>
</ul>
<p>dribble</p>
<p>其实我倒真是觉得在算法证明的时候用一堆符号有什么不好，因为算法本身就是应用数学，数学需要符号化。算法的牛人们很多都有数学、物理的背景，我觉得就算是理解了某一个算法设计最像idea的地方，对自己设计算法并没有本质的帮助，只能帮助记住这个算法而已。</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="felven"></li>
</ul>
<p>felven</p>
<p>沙发，正如老师所说的，把算法学好了去哪里都不成问题</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="cacard"></li>
</ul>
<p>cacard</p>
<p>moring...</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="sk.c"></li>
</ul>
<p>sk.c</p>
<p>沙发？？？好久没见更新了。。。^_^</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="limitlimiter"></li>
</ul>
<p>limitlimiter</p>
<p>让我重新捡起算法，谢谢未鹏大牛</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="佘明磊"></li>
</ul>
<p>佘明磊</p>
<p>谢谢你，虽然有技术壁垒我不大看懂！</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.helishi.net/" title="ikbear" target="_blank"><img src="" alt="ikbear"></a></li>
</ul>
<p><a href="http://www.helishi.net/" target="_blank">ikbear</a></p>
<p>很多思维结论的背后，并不是有确定的东西。发明者之所以连自己都没法将其讲清楚，很可能是这确实无从谈起，因为它确实是一丝灵光的结果；也可能是他的思维确实无法轻易让普通人理解；或者他根本就表达不好。
虽然说，写书的人把那些探索算法的思维过程写出来能够很好的帮助读者理解，让读者跟深更快的掌握算法。但是这也仅限于让读者掌握，让读者接受。这样，读者不光要接受其结论，连其思考过程也要接受。这本身就扼杀了想象力，还是停留在“背”的阶段。拿毕达哥拉斯定理来说，几百种的证明，每一种证明都有不同的思维过程。如果你认为探索每一种证明的思维过程就认为掌握了它，那么它的第二种第三种第N种证明又是从何而来的？
真正要去探索算法，应该是在基本理解算法之后，再去自己思考。参考别人的思考过程可能可以帮助自己思考，但参考别人的思考过程并不代表自己思考，两者并不等同。不过，这正是常人无法得到的。</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="dsigma"></li>
</ul>
<p>dsigma</p>
<p>我是菜鸟，我倒非常认同刘老师的观点，必须有所思考！
理解是一个思考的过程，而回味这个理解的过程才是我成长的过程。</p>
<p>2011年7月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://aboutminds.net/" title="kevinyzd" target="_blank"><img src="" alt="kevinyzd"></a></li>
</ul>
<p><a href="http://aboutminds.net/" target="_blank">kevinyzd</a></p>
<p>订阅你的blog很长时间。我喜欢这种典型的逻辑教程，我虽然数学不是非常好，但希望可以从中得到更多的了解，因为这确实是一个非常有意思的东西。另外你写文章的方式或多或少对我有所影响。</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://workzen.net/" title="Fey" target="_blank"><img src="" alt="Fey"></a></li>
</ul>
<p><a href="http://workzen.net/" target="_blank">Fey</a></p>
<p>期待刘未鹏的书《暗时间》出版...</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="feirainy"></li>
</ul>
<p>feirainy</p>
<p>&quot;大脑喜欢具体的东西，在特例中折腾和观察会方便的多，也许我们不难发现，如果交换1，2的父节点（因为反正1，2两个节点已确定是好兄弟永远不会分家了，折腾的时候只能作为一个整体移动）和叶子4，那么树的编码将会变得更优.&quot;－－在这里纠结了好一阵。。。</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>谢谢提醒，我已经根据你和楼下abellong的意见修改了那部分。我自己写到那里的时候也觉得似乎有点拗口，当时偷懒没改:D</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="feirainy"></li>
</ul>
<p>feirainy</p>
<p>谢谢回复，关于特例的那一段，因为当时折腾了一阵，后面见到未鹏修改了却与我当时的理解不太一样，我表示提出一点点意见，本人只是菜鸟，如有错，请见谅。</p>
<ol>
<li>对特例的折腾，最后得出的启发是：“在最优霍夫曼树中，无论互换哪两个节点，得到的树都变得更“差””。
可是特例呈现出来的是，通过交换1、2的父结点与结点4（编号是频率），可以得到更“优”的树，这对交换后得出更“差”的启发刚好相反。
（不过因为情况只有两种，即结点3与结点12在同一层，以及结点3在上一层，所以拐个弯能够想到从情况1到情况2更优，即相当于从情况2到情况1更差）。</li>
<li>特例提出的是，在最小的4个频率值为1，2，3，4时，交换1，2的父结点与结点4可以减少树的总代价，得到更优的树。
然后我当时就觉得，如果最小的4个频率值为3，4，5，6时，以同样方式交换结点树的总代价却会增大。于是觉得这样交换代价可能增大，可能减少，不能确定什么呀。。。
后面终于注意到，因为第3个最小频率值的结点的情况只有两种，就是说两种情况有一种比另一种更优（至少不会更差？），于是第3个最小频率值的结点的位置就确定下来了，在此位置确定的基础上，交换确实会令树的代价增加（至少不减少），于是也可以推广交换的方式了。</li>
</ol>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>@feirainy，谢谢你提的疑惑。说明我还是没有讲好:)
是这样的，特例中得出的启发仅仅是“可以交换子树，而不仅仅是交换叶子”，仅此而已。至于“最优霍夫曼树中无论交换哪两个子树都使cost增加”并不是特例中得出的推论，而是最优霍夫曼树的“最优”性质得出的直接推论。</p>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="abellong"></li>
</ul>
<p>abellong</p>
<p>&quot;频率最低的两个节点必然处于编码树的最底层，但未必一定要是兄弟节点&quot; 这个说法也不严谨，反例：1,1,1,3总有一个频率为1（最低）的在倒数第二层，不是最底层。
“在上面的例子中，我们已经有了特例”，表示不知道特例在哪里？因此，“如果交换1，2的父节点和叶子4，那么树的编码将会变得更优”这个结论也不是“不难发现”，甚至错误。
那个推广，似乎就是从“特例”里得到启发，并没有证明（至少是严格证明），让人不放心
总的感觉，此篇文章仍然让人费解……
我觉得一般书上让人难以理解的其中一点是略去了一些特例（比如频率相等的情况），这些可以通过“归约”解释，可以多花心思在这里：为什么可以只处理某一种情况，其他都可以归约为这种情况？</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<ol>
<li>“频率最低的两个节点必然处于编码树的最底层，但未必一定要是兄弟节点” 的确不严谨。谢谢指出。准备添加说明：“当频率最低的两个节点处于不同层的时候，必然可以归约为同层”</li>
<li>特例就是1,2,3,4那个例子。“交换1,2的父节点和叶子4”是指交换1,2那个子树（1,2和他们的父亲）和叶子4。交换后的情况我画了图。</li>
<li>那个推广的确是特例中的启发，然后后面是有证明的。如果你说的是“在最优霍夫曼树中，无论互换哪两个节点，得到的树都变得更“差”（交换内部节点则是连同该内部节点作为局部根的子树一同带走）”这个推广没有证明的话，我想说的是这个是“最优树”的定义的直接蕴含啊，不需要证明。如果你说的是“在最优霍夫曼树当中，两个内部节点n1和n2，如果n1比n2更深，那么n1下面的所有叶子的频率之和必然要小于n2下面所有叶子的频率之和。”这个推广没有证明的话，是因为证明和置换叶子节点的情况类似，文中提了“不加赘述”。
谢谢指正。</li>
</ol>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="abellong"></li>
</ul>
<p>abellong</p>
<p>谢谢回复:)
第二个问题，回想我当时的理解：我把那俩幅图里的1、2、3、4默认成编号，即第1小、第2小（而不是理解成频率）…导致我错了。当时脑子短路，没转过来。 不过还是建议换个数字更好些
提的第三个问题 真完全是我的问题了，没有仔细考虑，胡乱就问了，惭愧
谢谢您的分享，从您博客我学到了很多:)</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="abellong"></li>
</ul>
<p>abellong</p>
<p>回头再看，发现您修改后意思已非常明确了，忽略那个建议吧</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>@abellong
根据你的建议我仔细修改了那一段的细节，其实我当时写的时候也是觉得那段有点拗口。楼上的feirainy也提了类似的疑惑。
“1、2、3、4默认成编号，即第1小、第2小（而不是理解成频率）”，恩，这个我再想想，也许回头加个注。
再次感谢。</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p><a href="">回复 abellong: </a>我回头看了一下，的确{1,2,3,4}有编号之嫌，因为前文提到第一第二小，和第三第四小，恰巧用的频率也是1，2，3，4，所以的确有点容易混淆。所以我在“特例”那个地方加了括号说明是频率。当然具体频率数字最好是改掉，不过还要重新作图，就懒了:)</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://mindlee.net/" title="酷~行天下" target="_blank"><img src="" alt="酷~行天下"></a></li>
</ul>
<p><a href="http://mindlee.net/" target="_blank">酷~行天下</a></p>
<p>未鹏大牛终于更新了，学算法学的头大………</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Kejia"></li>
</ul>
<p>Kejia</p>
<p>你写的真好。</p>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://moodylee.me/" title="moody" target="_blank"><img src="" alt="moody"></a></li>
</ul>
<p><a href="http://moodylee.me/" target="_blank">moody</a></p>
<p>时隔半年，ponba终于又出手了。</p>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.bengogo.com/" title="好看的电影" target="_blank"><img src="" alt="好看的电影"></a></li>
</ul>
<p><a href="http://www.bengogo.com/" target="_blank">好看的电影</a></p>
<p>哈哈还好我以前的数学还算不错！算术这东西就要思考</p>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="hlily"></li>
</ul>
<p>hlily</p>
<p>好吧。。我承认太长的博客。我总是看不下去~</p>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="custqi"></li>
</ul>
<p>custqi</p>
<p>几乎所有的算法都来源于其背后的数学知识， 像图论， 贪心有拟阵， 动态规划出自运筹学，搜索其实也能从图论延伸出来，当然还有更难一些的搜索，数论也有专门的数学教材等等， 个人认为用一个学习算法 应该用一个 数学的头脑去学习，一些推导证明更应该用 数学的思维去验证，当然也可以用实例数据去手工执行代码，这样会好理解一些，仅一家之言，口水就不必了。</p>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gordon"></li>
</ul>
<p>gordon</p>
<p>何为“数学的头脑”？帅哥，你还没有说出来啊。呵呵
其实这篇文章已经讲的很清楚了，基本思想就是“读完以后，合上书，你把它复述出来。 ”
这个可是不容易啊，pongba做这个都很吃力的。
要什么自行车，搞的强盗不像强盗，猴子不像猴子的，还是干强盗这份比较有前途的职业吧。
------- 摘自《大话西游》和《卖拐》
当然个人爱好除外。</p>
<p>2011年7月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gordon"></li>
</ul>
<p>gordon</p>
<p>算法在狭义上压根就不是计算机专业的内容，那是计算数学专业的内容。当然非要抬杠说，只要是涉及到计算的都属于计算科学，也属于计算机科学，我也无语。
但那真不是计算机科学的内容，计算科学不等于计算机科学，OK。</p>
<p>2011年9月16日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gordon"></li>
</ul>
<p>gordon</p>
<p>计算机这个专业是讲什么的，就是讲什么是计算机，从底层硬件、接口技术到用晶体管做一个4位计算机的实现，再到内外存，硬件结束上升到系统软件；
操作系统如何管理硬件，内存管理、磁盘管理等东东，编译器，数据库；系统软件结束了就是应用软件。然后计算机和计算机之间有通讯，就是计算机网络。
完了，真的完了。
计算机专业的数学和其他专业需要计算机处理的数学要分清楚，要清楚的分开。
要搞清楚计算机专业的研究对象是什么，狭义的计算机专业压根就不研究算法，研究的是数据结构。
但是如何选择数据结构？却要把算法提出来，选择不同的数据结构，算法复杂度是不一样的，
也就是说数据结构定了，就会降低算法实现的复杂度。
就是为了讲清楚数据结构怎么选择的问题，所以稍带把算法也讲了，就是这样。</p>
<p>2011年9月16日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="黄铂钧"></li>
</ul>
<p>黄铂钧</p>
<p>计算机学科的“教学”和“研究”要分清楚，要清楚的分开。
要搞清楚计算机专业的教学对象是什么，狭义的计算专业压根就不教“计算机相关研究所需的知识”，教的是“如何把已有的计算机知识应用到实际中”
不过话说回来，现在计算机专业的教学确实很差，只是谁也没有能力去改进而已。</p>
<p>2011年11月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gordon"></li>
</ul>
<p>gordon</p>
<p>码农要研究算法的原因是因为有其他行业的问题需要计算机来处理，这个在公司中一般应该专门设置这样的算法岗位，招聘“ 计算数学 “专业的人才。
小公司一般没有这个岗位，大多是拿开源的工具包在用，只要能看懂文档，会用就行了。</p>
<p>2011年9月16日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.iphonephysics.com/" title="iphysics" target="_blank"><img src="" alt="iphysics"></a></li>
</ul>
<p><a href="http://www.iphonephysics.com/" target="_blank">iphysics</a></p>
<p>大刘的想法和我非常相似，多年以来我在数学的学习过程中深有体会，
定理的探索 有很多失败，试错，摸索的过程， 《费马大定理》这本书就是一个揭示类似过程的好例子，可是在教科书和课堂上出现的都是千锤百炼的最精炼的结果，学生学不到如何去摸索，可是要完全再现摸索的过程，确实需要非常精深的学识与阅历。不是一般老师可以达到的</p>
<p>2011年7月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Greg"></li>
</ul>
<p>Greg</p>
<p>您的文章阐述的观点很正确，给人很大启发。
但关于您的文章的表达方面，我从一个读者角度提出一个建议：
我希望您写文章能够更加深入浅出，就是能一目了然的明白文章的主旨。
拿这篇文章作例，我理解的主旨就是：学习算法的好途径是透彻地理解算法。也就是“知其所以然”的学习。（我十分赞同这个观点，自己也是努力这么做的。）
我希望您的表达能更直观，要做到这样本身就需要首先对自己的观点有透彻的理解，不然就容易东一句西一句，抓不住要领。
谢谢。</p>
<p>2011年7月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="jkryanchou"></li>
</ul>
<p>jkryanchou</p>
<p>终于更新了。。等过一个又一个季节。又是一篇佳作。。未鹏，一直期待你文章。。。持续关注中。</p>
<p>2011年7月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="4D"></li>
</ul>
<p>4D</p>
<p>光滑函数的最值点必然是大（小）于其邻域内的所有点的
这个好像不是最值点的定义吧，这个是极大值点的定义吧</p>
<p>2011年7月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>不是定义，是必要条件。</p>
<p>2011年7月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="JOB"></li>
</ul>
<p>JOB</p>
<p>我是个大三的学生，您在例证中对哈夫树的讲解跟我们当年离散数学的老师讲的有异曲同工之妙，我现在倒是很感激那个老师了。</p>
<p>2011年7月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="JOB"></li>
</ul>
<p>JOB</p>
<p>对于在结尾处您埋下的问题，可否指点一二？</p>
<p>2011年7月14日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/sun0721?inviteCode=1715455645" title="miracle-light" target="_blank"><img src="" alt="miracle-light"></a></li>
</ul>
<p><a href="http://weibo.com/sun0721?inviteCode=1715455645" target="_blank">miracle-light</a></p>
<p>真是太感谢啦，这么好的内容怎么能错过呀，老天有眼！</p>
<p>2011年7月14日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://hi.baidu.com/gevolution90/" title="朱健强" target="_blank"><img src="" alt="朱健强"></a></li>
</ul>
<p><a href="http://hi.baidu.com/gevolution90/" target="_blank">朱健强</a></p>
<p>若是博主把使用 evernote 的方法，技巧，收获等写成一文，想必定是一篇佳作。</p>
<p>2011年7月15日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.nb-lz.com/" title="宁波餐饮管理" target="_blank"><img src="" alt="宁波餐饮管理"></a></li>
</ul>
<p><a href="http://www.nb-lz.com/" target="_blank">宁波餐饮管理</a></p>
<p>学习下，谢谢博主分享</p>
<p>2011年7月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="黄铂钧"></li>
</ul>
<p>黄铂钧</p>
<p>&quot;设计算法的难处在于，定理和证明都需要你去探索，尤其是前者&quot;
设计算法可以看成是在做解答题,而解答题比证明题难是共识吧.其实数学也一样,主要成果体现在定理的提出,而不在于证明
&quot;理想的算法书应该通过还原算法的探索过程&quot;
没有textbook会这么写的，因为那样写出来的书会奇厚无比，知识的传达应以简洁为好。只有&quot;how to solve it&quot;这种科普读物才有篇幅会讨论思考方法
“当年Shannon都没搞定的这个问题花了他一学期”
我听说的版本是Huffman只用了一个下午就证明了这个贪心算法的最优。就像你说的，huffman面对的问题，难点不在于证明最优性（他只用了半天），而在于提出这个greedy algorithm本身（他用了一个学期）。而通常算法书上只涉及最优树构建这个相对简单的子问题。
“有没有可能把霍夫曼编码讲的更好呢”
taocp里讲的很清楚（可能因为knuth当年专门研究过haffman algebra）</p>
<p>2011年7月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="黄铂钧"></li>
</ul>
<p>黄铂钧</p>
<p>解决huffman的最优编码问题，关键在于把它转化成tree construction问题；但有意思的是，想说清楚huffman算法却恰恰要避开tree construction这个视角。只要纠缠在“树”，“节点”，“叶子”这些概念上，无论你怎么解释都会显得cumbersome。
至于思考方法，对于huffman tree这个具体问题，我个人的经验是关键在于要意识到，所谓的&quot;optimal tree&quot;其实往往不止一个，也就是说，同时存在相当数量的彼此不同的树它们都是最优的。一旦意识到这一点证明思路就走上正轨了，后面那些“交换”什么的都是技术问题，仔细思考加上一些耐心就会自然得到。</p>
<p>2011年7月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.mllovw.info/" title="babyface" target="_blank"><img src="" alt="babyface"></a></li>
</ul>
<p><a href="http://www.mllovw.info/" target="_blank">babyface</a></p>
<p>不错，过来支持下~~</p>
<p>2011年8月2日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.hx569.com/" title="丰禾棋牌" target="_blank"><img src="" alt="丰禾棋牌"></a></li>
</ul>
<p><a href="http://www.hx569.com/" target="_blank">丰禾棋牌</a></p>
<p>你成功的让我把头都看大了。</p>
<p>2011年8月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://king.violinmm.com/" title="violin" target="_blank"><img src="" alt="violin"></a></li>
</ul>
<p><a href="http://king.violinmm.com/" target="_blank">violin</a></p>
<p>很是佩服楼主如此博学，真是值得学习的好地方！</p>
<p>2011年8月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.tong12.com/" title="北京时尚摄影" target="_blank"><img src="" alt="北京时尚摄影"></a></li>
</ul>
<p><a href="http://www.tong12.com/" target="_blank">北京时尚摄影</a></p>
<p>博主真是个用脑之人啊，这分析的，佩服佩服</p>
<p>2011年8月16日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.9sh.net/" title="仁心博客" target="_blank"><img src="" alt="仁心博客"></a></li>
</ul>
<p><a href="http://www.9sh.net/" target="_blank">仁心博客</a></p>
<p>文字好多 啊</p>
<p>2011年8月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://yaojingguo.iteye.com/" title="小雨" target="_blank"><img src="" alt="小雨"></a></li>
</ul>
<p><a href="http://yaojingguo.iteye.com/" target="_blank">小雨</a></p>
<p>有道理。</p>
<p>2011年9月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://zwl.me/" title="守候幸福" target="_blank"><img src="" alt="守候幸福"></a></li>
</ul>
<p><a href="http://zwl.me/" target="_blank">守候幸福</a></p>
<p>和高中学习一样，有些人一下子就会了 而且融汇贯通</p>
<p>2011年9月21日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.stonecrushermobile.org/" title="stone crusher" target="_blank"><img src="" alt="stone crusher"></a></li>
</ul>
<p><a href="http://www.stonecrushermobile.org/" target="_blank">stone crusher</a></p>
<p>不错。支持</p>
<p>2011年10月9日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.popbedding.com/" title="train quilt" target="_blank"><img src="" alt="train quilt"></a></li>
</ul>
<p><a href="http://www.popbedding.com/" target="_blank">train quilt</a></p>
<p>文章很好。另外，验证码也太长了···</p>
<p>2011年10月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://stackpop.org/blog/" title="stackpop" target="_blank"><img src="" alt="stackpop"></a></li>
</ul>
<p><a href="http://stackpop.org/blog/" target="_blank">stackpop</a></p>
<p>呵呵~算法到底是像奥数一样的东西还是什么？</p>
<p>2011年10月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.a891.com/" title="芳草集" target="_blank"><img src="" alt="芳草集"></a></li>
</ul>
<p><a href="http://www.a891.com/" target="_blank">芳草集</a></p>
<p>文字好多 啊</p>
<p>2011年10月27日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://blog.csdn.net/ty1921" title="Ty1921" target="_blank"><img src="" alt="Ty1921"></a></li>
</ul>
<p><a href="http://blog.csdn.net/ty1921" target="_blank">Ty1921</a></p>
<p>上班偷空来瞅着终于更新了，只是比以前长的多，晚上回去细看。
想起前两天的小事：看京东有卖大大的书，买回来一看，后面有一部分算法方面的，给读中学的小弟是不成了，又舍不得，最后让他撕了前一半（暗时间...），我撕了后一半 - -/#</p>
<p>2011年11月3日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="zy498420"></li>
</ul>
<p>zy498420</p>
<p>寻找特定解的过程是个构建无噪声有损信道的信息传递过程，前提条件是信源，信息量损失越小，所得结果更general的概率越高。对于有限字符集和离散无记忆信源寻找前缀码编码表的过程，显然码率越好结果算是更general。该问题信源中有效信息是（前提条件）：字符集对应分布值的比例（绝对值无意义，属于无效信息，信道可以丢失这个信息），互斥事件加法法则（不同字符独立且互斥，“或”的概率可以直接相加），对结果的最优化要求是一个约束，也就是对信道本身做了一些限制，要求某些结果集的概率为0。太困了，改日再说。</p>
<p>2011年12月6日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="haozijun"></li>
</ul>
<p>haozijun</p>
<p>第一次来到这里，作者写的真是深奥，5年没有碰数学了，关于信道什么的都忘光了，现在想要捡起来。向楼主学习。也希望能和楼主交流，我的QQ229742946，希望加我</p>
<p>2012年5月23日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Zhen"></li>
</ul>
<p>Zhen</p>
<p>Hi, your word 事半功倍 is misused. It is 事倍功半 if I am right.
Thanks</p>
<p>2012年3月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="伊生臻爱"></li>
</ul>
<p>伊生臻爱</p>
<p>未鹏大哥，你应该是计算数学专业吧，现在改名叫信息与计算科学，我也是这个专业，但是觉悟远远不如你，像你看齐，还好现在才大二，大一基本玩过去的，专业课都没学，要补啦，像数分、高代的，全要补。。。</p>
<p>2012年3月28日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="raof01"></li>
</ul>
<p>raof01</p>
<p>且不说算法如何难，就尾递归而论，虽然不太复杂，也需要经过“试错、联想……”等一系列探索，才能真正掌握，才能应用到实际问题中去</p>
<p>2012年5月24日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="story"></li>
</ul>
<p>story</p>
<p>刘老师，不知道能否写写有关编程语言的学法，您的博客正是有种相见恨晚的感觉</p>
<p>2012年8月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://xq.com.nu/" title="haitao" target="_blank"><img src="" alt="haitao"></a></li>
</ul>
<p><a href="http://xq.com.nu/" target="_blank">haitao</a></p>
<p>构造算法不难，论证才难！
比如，我设计了一个加密算法、伪随机生成算法，怎么验证加密强度、随机程度，真的难！</p>
<p>2012年8月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="路人"></li>
</ul>
<p>路人</p>
<p>个人猜测整楼的评论没有一个学历超过研究生的</p>
<p>2012年8月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://blog.yejintao.cn/" title="叶金涛" target="_blank"><img src="" alt="叶金涛"></a></li>
</ul>
<p><a href="http://blog.yejintao.cn/" target="_blank">叶金涛</a></p>
<p>数学是计算机的根基，算法是编程的根本，知其所以然，才能用科学的眼光探讨问题。这也是专业培养所在——计算机科学与技术。</p>
<p>2012年8月21日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.zwjdjx.com/" title="折弯机模具" target="_blank"><img src="" alt="折弯机模具"></a></li>
</ul>
<p><a href="http://www.zwjdjx.com/" target="_blank">折弯机模具</a></p>
<p>算法总是在变啊，哎，计划永远赶不上变化啊</p>
<p>2012年10月26日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><a href="http://weibo.com/feiyuliu" title="Feythin Lau" target="_blank"><img src="" alt="Feythin Lau"></a></li>
</ul>
<p><a href="http://weibo.com/feiyuliu" target="_blank">Feythin Lau</a></p>
<p>数学是算法的基础，算法是程序的灵魂。。。</p>
<p>2012年11月3日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.renren.com/profile.do?id=282621198" title="杨翼" target="_blank"><img src="" alt="杨翼"></a></li>
</ul>
<p><a href="http://www.renren.com/profile.do?id=282621198" target="_blank">杨翼</a></p>
<p>总是知其然不知其所以然</p>
<p>1月3日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://ifeve.com/" title="并发编程" target="_blank"><img src="" alt="并发编程"></a></li>
</ul>
<p><a href="http://ifeve.com/" target="_blank">并发编程</a></p>
<p>知其然容易，知其所以然难。而对于算法必须要知其所以然。</p>
<p>1月21日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:29"datetime="2014-03-07 11:24:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--知其所以然（三）：为什么算法这么难？/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--知其所以然（三）：为什么算法这么难？" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li class="active"><li><span class="page-number current">2</span></li><li><a class="page-number" href="/page/3/">3</a></li><li><a class="page-number" href="/page/4/">4</a></li><li><a class="page-number" href="/page/5/">5</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/3/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 13:06:28</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
