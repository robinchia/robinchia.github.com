
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>AlgorithmGossip | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><h2 class="archive-title tag">AlgorithmGossip</h2>


<div class="archive">

  <ul class="list-group"><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--ArmstrongNumber/">ArmstrongNumber</a></h3><p class="list-group-item-text">ArmstrongNumberAlgorithm Gossip: 阿姆斯壮数
说明
在三位的整数中，例如153可以满足13 + 53 + 33 = 153，这样的数称之为Armstrong数，试写出一程式找出所有的三位数Armstrong数。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--OddArray/">OddArray</a></h3><p class="list-group-item-text">OddArrayAlgorithm Gossip: 奇数魔方阵
说明
将1到n(为奇数)的数字排列在nxn的方阵上，且各行、各列与各对角线的和必须相同，如下所示：


解法
填魔术方阵的方法以奇数最为简单，第一个数字放在第一行第一列的正中央，然后向右(左)上填，如果右(左)上已有数字，则向下填，如下图所示：</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--BinarySearch/">BinarySearch</a></h3><p class="list-group-item-text">BinarySearchAlgorithm Gossip: 二分搜寻法（搜寻原则的代表）
说明
如果搜寻的数列已经有排序，应该尽量利用它们已排序的特性，以减少搜寻比对的次数，这是搜寻的基本原则，二分搜寻法是这个基本原则的代表。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--CrapsGame/">CrapsGame</a></h3><p class="list-group-item-text">CrapsGameAlgorithm Gossip: Craps赌博游戏
说明
一个简单的赌博游戏，游戏规则如下：玩家掷两个骰子，点数为1到6，如果第一次点数和为7或11，则玩家胜，如果点数和为2、3或12，则玩家输，如果和 为其它点数，则记录第一次的点数和，然后继续掷骰，直至点数和等于第一次掷出的点数和，则玩家胜，如果在这之前掷出了点数和为7，则玩家输。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--EightCoins/">EightCoins</a></h3><p class="list-group-item-text">EightCoinsAlgorithm Gossip: 八枚银币
说明
现有八枚银币a b c d e f g h，已知其中一枚是假币，其重量不同于真币，但不知是较轻或较重，如何使用天平以最少的比较次数，决定出哪枚是假币，并得知假币比真币较轻或较重。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--EightQueen/">EightQueen</a></h3><p class="list-group-item-text">EightQueenAlgorithm Gossip: 八个皇后
说明
西洋棋中的皇后可以直线前进，吃掉遇到的所有棋子，如果棋盘上有八个皇后，则这八个皇后如何相安无事的放置在棋盘上，1970年与1971年， E.W.Dijkstra与N.Wirth曾经用这个问题来讲解程式设计之技巧。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--EratosthenesPrime/">EratosthenesPrime</a></h3><p class="list-group-item-text">EratosthenesPrimeAlgorithm Gossip: Eratosthenes筛选求质数
说明
除了自身之外，无法被其它整数整除的数称之为质数，要求质数很简单，但如何快速的求出质数则一直是程式设计人员与数学家努力的课题，在这边介绍一个著名的 Eratosthenes求质数方法。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--FibonacciSearch/">FibonacciSearch</a></h3><p class="list-group-item-text">FibonacciSearchAlgorithm Gossip: 费氏搜寻法
说明
二分搜寻法每次搜寻时，都会将搜寻区间分为一半，所以其搜寻时间为O(log(2)n)，log(2)表示以2为底的log值，这边要介绍的费氏搜寻，其利用费氏数列作为间隔来搜寻下一个数，所以区间收敛的速度更快，搜寻时间为O(logn)。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--FourNArray/">FourNArray</a></h3><p class="list-group-item-text">FourNArrayAlgorithm Gossip: 4N 魔方阵
说明
与 奇数魔术方阵 相同，在于求各行、各列与各对角线的和相等，而这次方阵的维度是4的倍数。

解法
先来看看4X4方阵的解法：</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--GCDPNumber/">GCDPNumber</a></h3><p class="list-group-item-text">GCDPNumberAlgorithm Gossip: 最大公因数、最小公倍数、因式分解
说明
最大公因数使用辗转相除法来求，最小公倍数则由这个公式来求：
GCD /* LCM = 两数乘积

解法
最大公因数可以使用递回与非递回求解，因式分解基本上就是使用小于输入数的数值当作除数，去除以输入数值，如果可以整除就视为因数，要比较快的解法就是求出小于该数的所有质数，并试试看是不是可以整除，求质数的问题是另一个课题，请参考 Eratosthenes 筛选求质数。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--GrayCode/">GrayCode</a></h3><p class="list-group-item-text">GrayCodeAlgorithm Gossip: 格雷码（Gray Code）
说明
Gray Code是一个数列集合，每个数使用二进位来表示，假设使用n位元来表示每个数好了，任两个数之间只有一个位元值不同，例如以下为3位元的Gray Code：</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--HeapSort/">HeapSort</a></h3><p class="list-group-item-text">HeapSortAlgorithm Gossip: Heap 排序法 - 改良的选择排序
说明
选择排序法的概念简单，每次从未排序部份选一最小值，插入已排序部份的后端，其时间主要花费于在整个未排序部份寻找最小值，如果能让搜寻最小值的方式加 快，选择排序法的速率也就可以加快，Heap排序法让搜寻的路径由树根至最后一个树叶，而不是整个未排序部份，因而称之为改良的选择排序法。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--InFixPostfix/">InFixPostfix</a></h3><p class="list-group-item-text">InFixPostfixAlgorithm Gossip: 中序式转后序式（前序式）
说明
平常所使用的运算式，主要是将运算元放在运算子的两旁，例如a+b/d这样的式子，这称之为中序（Infix）表示式，对于人类来说，这样的式子很容易理 解，但由于电脑执行指令时是有顺序的，遇到中序表示式时，无法直接进行运算，而必须进一步判断运算的先后顺序，所以必须将中序表示式转换为另一种表示方 法。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--InterpolationSearch/">InterpolationSearch</a></h3><p class="list-group-item-text">InterpolationSearchAlgorithm Gossip: 插补搜寻法
说明
如果却搜寻的资料分布平均的话，可以使用插补（Interpolation）搜寻法来进行搜寻，在搜寻的对象大于500时，插补搜寻法会比 二分搜寻法 来的快速。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--JosephusProblem/">JosephusProblem</a></h3><p class="list-group-item-text">JosephusProblemAlgorithm Gossip: 约瑟夫问题（Josephus Problem）
说明
据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人 开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--KnapsackProblem/">KnapsackProblem</a></h3><p class="list-group-item-text">KnapsackProblem[Algorithm Gossip: 背包问题（Knapsack Problem）]
说明
假设有一个背包的负重最多可达8公斤，而希望在背包中装入负重范围内可得之总价物品，假设是水果好了，水果的编号、单价与重量如下所示：</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--KnightTour/">KnightTour</a></h3><p class="list-group-item-text">KnightTourAlgorithm Gossip: 骑士走棋盘
说明
骑士旅游（Knight tour）在十八世纪初倍受数学家与拼图迷的注意，它什么时候被提出已不可考，骑士的走法为西洋棋的走法，骑士可以由任一个位置出发，它要如何走完[所有的位置？</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--LifeGame/">LifeGame</a></h3><p class="list-group-item-text">LifeGameAlgorithm Gossip: 生命游戏
说明
生命游戏（game of life）为1970年由英国数学家J. H. Conway所提出，某一细胞的邻居包括上、下、左、右、左上、左下、右上与右下相邻之细胞，游戏规则如下：</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--LinearSearch/">LinearSearch</a></h3><p class="list-group-item-text">LinearSearchAlgorithm Gossip: 循序搜寻法（使用卫兵）
说明
搜寻的目的，是在“已排序的资料”中寻找指定的资料，而当中循序搜寻是最基本的搜寻法，只要从资料开头寻找到最后，看看是否找到资料即可。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--LongPI/">LongPI</a></h3><p class="list-group-item-text">LongPIAlgorithm Gossip: 长 PI
说明
圆周率后的小数位数是无止境的，如何使用电脑来计算这无止境的小数是一些数学家与程式设计师所感兴趣的，在这边介绍一个公式配合 大数运算，可以计算指定位数的圆周率。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--MatchString/">MatchString</a></h3><p class="list-group-item-text">MatchStringAlgorithm Gossip: 字串核对
说明
今日的一些高阶程式语言对于字串的处理支援越来越强大（例如Java、Perl等），不过字串搜寻本身仍是个值得探讨的课题，在这边以Boyer- Moore法来说明如何进行字串说明，这个方法快且原理简洁易懂。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--MathPI/">MathPI</a></h3><p class="list-group-item-text">MathPI[Algorithm Gossip: 蒙地卡罗法求 PI]
说明
蒙地卡罗为摩洛哥王国之首都，该国位于法国与义大利国境，以赌博闻名。蒙地卡罗的基本原理为以乱数配合面积公式来进行解题，这种以机率来解题的方式带有赌博的意味，虽然在精确度上有所疑虑，但其解题的思考方向却是个值得学习的方式。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--MaxGuest/">MaxGuest</a></h3><p class="list-group-item-text">MaxGuestAlgorithm Gossip: 最大访客数
说明
现将举行一个餐会，让访客事先填写到达时间与离开时间，为了掌握座位的数目，必须先估计不同时间的最大访客数。

解法
这个题目看似有些复杂，其实相当简单，单就计算访客数这个目的，同时考虑同一访客的来访时间与离开时间，反而会使程式变得复杂；只要将来访时间与离开时间分开处理就可以了，假设访客 i 的来访时间为x[i]，而离开时间为y[i]。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--MergeSort/">MergeSort</a></h3><p class="list-group-item-text">MergeSortAlgorithm Gossip: 合并排序法
说明
之前所介绍的排序法都是在同一个阵列中的排序，考虑今日有两笔或两笔以上的资料，它可能是不同阵列中的资料，或是不同档案中的资料，如何为它们进行排序？</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--MultiColorHanoiTower/">MultiColorHanoiTower</a></h3><p class="list-group-item-text">MultiColorHanoiTowerAlgorithm Gossip: 双色、三色河内塔
说明
双色河内塔与三色河内塔是由之前所介绍过的河内塔规则衍生而来，双色河内塔的目的是将下图左上的圆环位置经移动成为右下的圆环位置：</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--TriangleArray/">TriangleArray</a></h3><p class="list-group-item-text">TriangleArrayAlgorithm Gossip: 上三角、下三角、对称矩阵
说明
上三角矩阵是矩阵在对角线以下的元素均为0，即Aij = 0，i &gt; j，例如：
1   2   3     4    5</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--BigNumber/">BigNumber</a></h3><p class="list-group-item-text">BigNumber[Algorithm Gossip: 超长整数运算（大数运算）]
说明
基于记忆体的有效运用，程式语言中规定了各种不同的资料型态，也因此变数所可以表达的最大整数受到限制，例如123456789123456789这样的 整数就不可能储存在long变数中（例如C/C++等），我们称这为long数，这边翻为超长整数（避免与资料型态的长整数翻译混淆），或俗称大数运算。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--PascalTriangle/">PascalTriangle</a></h3><p class="list-group-item-text">PascalTriangleAlgorithm Gossip: 巴斯卡三角形
巴斯卡（Pascal）三角形基本上就是在解 nCr ，因为三角形上的每一个数字各对应一个nCr，其中 n 为 row，而 r 为 column，如下：</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--PerfectNumber/">PerfectNumber</a></h3><p class="list-group-item-text">PerfectNumberAlgorithm Gossip: 完美数
说明
如果有一数n，其真因数（Proper factor）的总和等于n，则称之为完美数（Perfect Number），例如以下几个数都是完美数：</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--Permutation/">Permutation</a></h3><p class="list-group-item-text">PermutationAlgorithm Gossip: 排列组合
说明
将一组数字、字母或符号进行排列，以得到不同的组合顺序，例如1 2 3这三个数的排列组合有：1 2 3、1 3 2、2 1 3、2 3 1、3 1 2、3 2 1。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--PossibleSet/">PossibleSet</a></h3><p class="list-group-item-text">PossibleSetAlgorithm Gossip: 产生可能的集合
说明
给定一组数字或符号，产生所有可能的集合（包括空集合），例如给定1 2 3，则可能的集合为：{}、{1}、{1,2}、{1,2,3}、{1,3}、{2}、{2,3}、{3}。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--PostfixCal/">PostfixCal</a></h3><p class="list-group-item-text">PostfixCalAlgorithm Gossip: 后序式的运算
说明 将 中序式转换为后序式 的好处是，不用处理运算子先后顺序问题，只要依序由运算式由前往后读取即可。

解法
运算时由后序式的前方开始读取，遇到运算元先存入堆叠，如果遇到运算子，则由堆叠中取出两个运算元进行对应的运算，然后将结果存回堆叠，如果运算式读取完 毕，那么堆叠顶的值就是答案了，例如我们计算12+34+/这个运算式（也就是(1+2)/(3+4)）： 读取 堆叠 1 1 2 1 2 + 3 // 1+2 后存回 3 3 3 4 3 3 4 + 3 7 // 3+4 后存回 / 21 // 3 / 7 后存回</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--QueueByArray/">QueueByArray</a></h3><p class="list-group-item-text">QueueByArrayAlgorithm Gossip: 伫列 - 使用阵列实作
说明
伫列是一种先进先出的资料结构，想像您在管子中放入球，最先放入的球在另一端会最先跑出来，在这边介绍如何使用阵列来实作伫列。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--QueueByLink/">QueueByLink</a></h3><p class="list-group-item-text">QueueByLinkFrom Gossip@caterpillar
Algorithm Gossip: 伫列 - 使用链结实作（C语言动态记忆体宣告）
说明
使用阵列来实作伫列，会有伫列空间的限制，如果使用链结配合动态记忆体宣告，就不会有长度的限制。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--QueueByObject/">QueueByObject</a></h3><p class="list-group-item-text">QueueByObjectAlgorithm Gossip: 伫列 - 使用Java 作物件封装
说明
如果您使用C++或Java等支援物件导向的语言来实作伫列，您可以使用类别的方式来包括伫列的功能，将所有的伫列操作由堆叠物件来处理，一旦包装完成，则使用伫列物件的时候，只要呼叫加入、删除等方法，而无需处理伫列的front、rear或判断是否为空等细节。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--QuickSort1/">QuickSort1</a></h3><p class="list-group-item-text">QuickSort1Algorithm Gossip: 快速排序法（一）
说明
快速排序法（quick sort）是目前所公认最快的排序方法之一（视解题的对象而定），虽然快速排序法在最差状况下可以达O(n2)，但是在多数的情况下，快速排序法的效率表现是相当不错的。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--QuickSort2/">QuickSort2</a></h3><p class="list-group-item-text">QuickSort2Algorithm Gossip: 快速排序法（二）
说明
在 快速排序法（一） 中，每次将最左边的元素设为轴，而之前曾经说过，快速排序法的加速在于轴的选择，在这个例子中，只将轴设定为中间的元素，依这个元素作基准进行比较，这可以增加快速排序法的效率。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--QuickSort3/">QuickSort3</a></h3><p class="list-group-item-text">QuickSort3Algorithm Gossip: 快速排序法（三）
说明
之前说过轴的选择是快速排序法的效率关键之一，在这边的快速排序法的轴选择方式更加快了快速排序法的效率，它是来自演算法名书 Introduction to Algorithms 之中。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--Quine/">Quine</a></h3><p class="list-group-item-text">QuineAlgorithm Gossip: 自产生程式（quine）
说明
自产生程式（quine）就是要写一个程式，这个程式的目的就是描述它自己，简单的说，如果您写了一个.java，编译它后产生一个.class档，然后 您将.java档案删除，您的.class档不需要.java档，它也可以印出.java档的内容。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--RadixSort/">RadixSort</a></h3><p class="list-group-item-text">RadixSortAlgorithm Gossip: 基数排序法
说明
在之前所介绍过的排序方法，都是属于“比较性”的排序法，也就是每次排序时 ，都是比较整个键值的大小以进行排序。
这边所要介绍的“基数排序法”（radix sort）则是属于“分配式排序”（distribution sort），基数排序法又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的比较性排序法。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--ScoreRank/">ScoreRank</a></h3><p class="list-group-item-text">ScoreRankAlgorithm Gossip: 得分排行
说明
假设有一教师依学生座号输入考试分数，现希望在输入完毕后自动显示学生分数的排行，当然学生的分数可能相同。

解法
这个问题基本上要解不难，只要使用额外的一个排行阵列走访分数阵列就可以了，直接使用下面的程式片段作说明：</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--SelectionInsertionBubble/">SelectionInsertionBubble</a></h3><p class="list-group-item-text">SelectionInsertionBubbleAlgorithm Gossip: 选择、插入、气泡排序
说明
选择排序（Selection sort）、插入排序（Insertion sort）与气泡排序（Bubble sort）这三个排序方式是初学排序所必须知道的三个基本排序方式，它们由于速度不快而不实用（平均与最快的时间复杂度都是O(n2)），然而它们排序的方式确是值得观察与探讨的。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--SeparateNumber/">SeparateNumber</a></h3><p class="list-group-item-text">SeparateNumberAlgorithm Gossip: 数字拆解
说明
这个题目来自于 数字拆解，我将之改为C语言的版本，并加上说明。
题目是这样的：
3 = 2+1 = 1+1+1 所以3有三种拆法</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--ShakerSort/">ShakerSort</a></h3><p class="list-group-item-text">ShakerSortAlgorithm Gossip: Shaker 排序法 - 改良的气泡排序
说明
请看看之前介绍过的气泡排序法：
     for(i = 0; i &lt; MAX-1 &amp;&amp; flag == 1; i++) {</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--ShellSort/">ShellSort</a></h3><p class="list-group-item-text">ShellSortAlgorithm Gossip: Shell 排序法 - 改良的插入排序
说明
插入排序法由未排序的后半部前端取出一个值，插入已排序前半部的适当位置，概念简单但速度不快。
排序要加快的基本原则之一，是让后一次的排序进行时，尽量利用前一次排序后的结果，以加快排序的速度，Shell排序法即是基于此一概念来改良插入排序法。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--ShuffleCard/">ShuffleCard</a></h3><p class="list-group-item-text">ShuffleCardAlgorithm Gossip: 洗扑克牌（乱数排列）
说明
洗扑克牌的原理其实与乱数排列是相同的，都是将一组数字（例如1～N）打乱重新排列，只不过洗扑克牌多了一个花色判断的动作而已。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--StackByArray/">StackByArray</a></h3><p class="list-group-item-text">StackByArrayAlgorithm Gossip: 堆叠 - 使用阵列实作
说明
堆叠是一种先进后出的资料结构，就如同您将书本放入箱子，最先放进的书本在最后才能拿出来，所有资料的加入与删除都在堆叠顶端完成。堆叠的使用很广，递回 就是一种堆叠，在之前介绍中序式转后序式时，也使用到堆叠的结构。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--StackByLink/">StackByLink</a></h3><p class="list-group-item-text">StackByLinkAlgorithm Gossip: 堆叠 - 使用链结实作（C 语言动态记忆体宣告）
说明
使用阵列实作堆叠，会受到阵列大小必须事先宣告好的限制，我们可以使用链结（link）的方式来实作堆叠，以动态记忆体宣告的方式来新增每一个元素。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--StackByObject/">StackByObject</a></h3><p class="list-group-item-text">StackByObjectAlgorithm Gossip: 堆叠 - 使用 Java 作物件封装
说明
如果您使用C++或Java等支援物件导向的语言来实作堆叠，您可以使用类别的方式来包括堆叠的功能，将所有的堆叠操作由堆叠物件来处理，一旦包装完成，则使用堆叠物件的时候，只要呼叫加入、删除等方法，而无需处理堆叠的top或判断是否为空等细节。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--ThreeColorsFlags/">ThreeColorsFlags</a></h3><p class="list-group-item-text">ThreeColorsFlagsAlgorithm Gossip: 三色棋
说明
三色旗的问题最早由E.W.Dijkstra所提出，他所使用的用语为Dutch Nation Flag(Dijkstra为荷兰人)，而多数的作者则使用Three-Color Flag来称之。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:54:44.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--TwoNOneArray/">TwoNOneArray</a></h3><p class="list-group-item-text">TwoNOneArrayAlgorithm Gossip: 2(2N+1) 魔方阵
说明
方阵的维度整体来看是偶数，但是其实是一个奇数乘以一个偶数，例如6X6，其中6=2X3，我们也称这种方阵与单偶数方阵。</p><li class="list-group-item"><h3><time datetime="2014-02-02T01:25:06.000Z">feb. 2 2014</time>  <a href="/2014/02/02/2014-02-02-AlgorithmGossip-AlgorithmGossip--NOfM/">NOfM</a></h3><p class="list-group-item-text">NOfM[Algorithm Gossip: m元素集合的n个元素子集]
说明
假设有个集合拥有m个元素，任意的从集合中取出n个元素，则这n个元素所形成的可能子集有那些？

解法
假设有5个元素的集点，取出3个元素的可能子集如下：</p>

</div></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-04-07 17:30:41</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
