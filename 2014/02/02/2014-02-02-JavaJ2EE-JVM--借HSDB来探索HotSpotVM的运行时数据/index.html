
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>借HSDB来探索HotSpot VM的运行时数据 | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="借HSDB来探索HotSpot VM的运行时数据（未经许可请勿转载。希望转载请与我联系。）
（如果打开此页面时浏览器有点卡住的话请耐心等待片刻。大概是ItEye的代码高亮太耗时了…）
几天前在HLLVM群组有人问了个小问题，说">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<meta property="og:title" content="借HSDB来探索HotSpot VM的运行时数据"/>
<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title">借HSDB来探索HotSpot VM的运行时数据</h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--借HSDB来探索HotSpotVM的运行时数据/">feb. 2 2014</a></time></span>      
    </header>
    
    <section id='before_content_widget'></section>
    <div class="entry">
      
        <h1 id="-hsdb-hotspot-vm-">借HSDB来探索HotSpot VM的运行时数据</h1>
<p>（未经许可请勿转载。希望转载请与我联系。）
（如果打开此页面时浏览器有点卡住的话请耐心等待片刻。大概是ItEye的代码高亮太耗时了…）
几天前在<a href="http://hllvm.group.iteye.com/" target="_blank">HLLVM群组</a>有人<a href="http://hllvm.group.iteye.com/group/topic/37542" target="_blank">问了个小问题</a>，说
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class Test {  </li>
<li>static Test2 t1 = new Test2();  </li>
<li>Test2 t2 = new Test2();  </li>
<li>public void fn() {  </li>
<li>Test2 t3 = new Test2();       </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>class Test2 {  </li>
<li></li>
<li>}  </li>
</ol>
<p>public class Test {</p>
<pre><code>static Test2 t1 = new Test2();
       Test2 t2 = new Test2();

public void fn() {
    Test2 t3 = new Test2();    

}
</code></pre><p>}</p>
<p>class Test2 {</p>
<p>}
这个程序的t1、t2、t3三个变量本身（而不是这三个变量所指向的对象）到底在哪里。
TL;DR版回答是：</p>
<ul>
<li>t1在存Java静态变量的地方，概念上在JVM的方法区（method area）里</li>
<li>t2在Java堆里，作为Test的一个实例的字段存在</li>
<li>t3在Java线程的调用栈里，作为Test.fn()的一个局部变量存在
不过就这么简单的回答大家都会，满足不了对JVM的实现感兴趣的同学们的好奇心。说到底，这“方法区”到底是啥？Java堆在哪里？Java线程的调用栈又是啥样的？
那就让我们跑点例子，借助调试器来看看在一个实际运行中的JVM里是啥状况。<h1 id="-https-gist-github-com-rednaxelafx-5392451-https-gist-github-com-rednaxelafx-5392451-">（下文中代码也传了一份到<a href="https://gist.github.com/rednaxelafx/5392451" target="_blank"><a href="https://gist.github.com/rednaxelafx/5392451">https://gist.github.com/rednaxelafx/5392451</a></a>）</h1>
写个启动类来跑上面问题中的代码：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></li>
</ul>
<ol>
<li>public class Main {  </li>
<li>public static void main(String[] args) {  </li>
<li>Test test = new Test();  </li>
<li>test.fn();  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public class Main {</p>
<pre><code>public static void main(String[] args) {
    Test test = new Test();

    test.fn();
}
</code></pre><p>}
（编译这个Main.java和上面的Test.java时最好加上-g参数生成LocalVariableTable等调试信息，以便后面某些情况下可以用到）
接下来如无特别说明本文将使用Windows 7 64-bit, Oracle JDK 1.7.0_09 Server VM, Serial GC的环境中运行所有例子。
之前在GreenTeaJUG在杭州的活动<a href="http://rednaxelafx.iteye.com/blog/1814180" target="_blank">演示Serviceability Agent</a>的时候也讲到过这是个非常便于探索HotSpot VM内部实现的API，而HSDB则是在SA基础上包装起来的一个调试器。这次我们就用HSDB来做实验。
SA的一个限制是它只实现了调试snapshot的功能：要么要让被调试的目标进程完全暂停，要么就调试core dump。所以我们在用HSDB做实验前，得先让我们的Java程序运行到我们关注的点上才行。
理想情况下我们会希望让这Java程序停在Test.java的第6行，也就是Test.fn()中t3局部变量已经进入作用域，而该方法又尚未返回的地方。怎样才能停在这里呢？
其实用个Java层的调试器即可。大家平时可能习惯了在Eclipse、IntelliJ IDEA、NetBeans等Java IDE里使用Java层调试器，但为了减少对外部工具的依赖，本文将使用Oracle JDK自带的jdb工具来完成此任务。
<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html" target="_blank">jdb</a>跟上面列举的IDE里包含的调试器底下依赖着同一套调试API，也就是<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/index.html" target="_blank">Java Platform Debugger Architecture (JPDA)</a>。功能也类似，只是界面是命令行的，表明上看起来不太一样而已。
为了方便后续步骤，启动jdb的时候可以设定让目标Java程序使用serial GC和10MB的Java heap。
启动jdb之后可以用stop in命令在指定的Java方法入口处设置断点，
然后用run命令指定主类名称来启动Java程序，
等跑到断点看看位置是否已经到满足需求，还没到的话可以用step、next之类的命令来向前进。
对jdb命令不熟悉的同学可以在启动jdb之后使用help命令来查看命令列表和说明。
具体步骤如下：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>D:\test&gt;jdb -XX:+UseSerialGC -Xmx10m  </li>
<li>Initializing jdb ...  </li>
<li><blockquote>
<p>stop in Test.fn  </p>
</blockquote>
</li>
<li>Deferring breakpoint Test.fn.  </li>
<li>It will be set after the class is loaded.  </li>
<li><blockquote>
<p>run Main  </p>
</blockquote>
</li>
<li>run  Main  </li>
<li>Set uncaught java.lang.Throwable  </li>
<li>Set deferred uncaught java.lang.Throwable  </li>
<li><blockquote>
</blockquote>
</li>
<li>VM Started: Set deferred breakpoint Test.fn  </li>
<li></li>
<li>Breakpoint hit: &quot;thread=main&quot;, Test.fn(), line=5 bci=0  </li>
<li>5            Test2 t3 = new Test2();  </li>
<li></li>
<li>main[1] next  </li>
<li></li>
<li>Step completed: &gt; &quot;thread=main&quot;, Test.fn(), line=6 bci=8  </li>
<li>6        }  </li>
<li></li>
<li>main[1]   </li>
</ol>
<p>D:\test&gt;jdb -XX:+UseSerialGC -Xmx10m</p>
<p>Initializing jdb ...</p>
<blockquote>
<p>stop in Test.fn</p>
</blockquote>
<p>Deferring breakpoint Test.fn.
It will be set after the class is loaded.</p>
<blockquote>
<p>run Main
run  Main</p>
</blockquote>
<p>Set uncaught java.lang.Throwable
Set deferred uncaught java.lang.Throwable</p>
<p>&gt;
VM Started: Set deferred breakpoint Test.fn</p>
<p>Breakpoint hit: &quot;thread=main&quot;, Test.fn(), line=5 bci=0</p>
<p>5            Test2 t3 = new Test2();</p>
<p>main[1] next</p>
<p>Step completed: &gt; &quot;thread=main&quot;, Test.fn(), line=6 bci=8
6        }</p>
<p>main[1]
按照上述步骤执行完最后一个next命令之后，我们就来到了最初想要的Test.java的第6行，也就是Test.fn()返回前的位置。
接下来把这个jdb窗口放一边，另开一个命令行窗口用<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html" target="_blank">jps</a>命令看看我们要调试的Java进程的pid是多少：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>D:\test&gt;jps  </li>
<li>4328 Main  </li>
<li>9064 Jps  </li>
<li>7716 TTY  </li>
</ol>
<p>D:\test&gt;jps</p>
<p>4328 Main
9064 Jps</p>
<p>7716 TTY
可以看到是4328。把这个pid记下来待会儿用。
然后启动HSDB：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>D:\test&gt;java -cp .;%JAVA_HOME%/lib/sa-jdi.jar sun.jvm.hotspot.HSDB  </li>
</ol>
<p>D:\test&gt;java -cp .;%JAVA_HOME%/lib/sa-jdi.jar sun.jvm.hotspot.HSDB
（要留意Linux和Solaris在Oracle/Sun JDK6就可以使用HSDB了，但Windows上要到Oracle JDK7才可以用HSDB）
启动HSDB之后，把它连接到目标进程上。从菜单里选择File -&gt; Attach to HotSpot process：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
在弹出的对话框里输入刚才记下的pid然后按OK：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
这会儿就连接到目标进程了：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
刚开始打开的窗口是Java Threads，里面有个线程列表。双击代表线程的行会打开一个Oop Inspector窗口显示HotSpot VM里记录线程的一些基本信息的C++对象的内容。
不过这里我们更可能会关心的是线程栈的内存数据。先选择main线程，然后点击Java Threads窗口里的工具栏按钮从左数第2个可以打开Stack Memory窗口来显示main线程的栈：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
Stack Memory窗口的内容有三栏：
左起第1栏是内存地址，请让我提醒一下本文里提到“内存地址”的地方都是指虚拟内存意义上的地址，<strong>不是</strong>“物理内存地址”，请不要弄混了这俩概念；
第2栏是该地址上存的数据，以字宽为单位，本文例子中我是在Windows 7 64-bit上跑64位的JDK7的HotSpot VM，字宽是64位（8字节）；
第3栏是对数据的注释，竖线表示范围，横线或斜线连接范围与注释文字。
现在看不懂这个窗口里的数据没关系，先放一边，后面再回过头来看。
现在让我们打开HSDB里的控制台，以便用命令来了解更多信息。
在菜单里选择Windows -&gt; Console：
<img src="" alt="">
然后会得到一个空白的Command Line窗口。在里面敲一下回车就会出现hsdb&gt;提示符。
（用过CLHSDB的同学可能会发现这就是把CLHSDB嵌入在了HSDB的图形界面里）
不知道有什么命令可用的同学可以先用help命令看看命令列表。
可以用universe命令来查看GC堆的地址范围和使用情况：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; universe  </li>
<li>Heap Parameters:  </li>
<li>Gen 0:   eden [0x00000000fa400000,0x00000000fa4aad68,0x00000000fa6b0000) space capacity = 2818048, 24.831088753633722 used  </li>
<li>from [0x00000000fa6b0000,0x00000000fa6b0000,0x00000000fa700000) space capacity = 327680, 0.0 used  </li>
<li>to   [0x00000000fa700000,0x00000000fa700000,0x00000000fa750000) space capacity = 327680, 0.0 usedInvocations: 0  </li>
<li></li>
<li>Gen 1:   old  [0x00000000fa750000,0x00000000fa750000,0x00000000fae00000) space capacity = 7012352, 0.0 usedInvocations: 0  </li>
<li></li>
<li>perm [0x00000000fae00000,0x00000000fb078898,0x00000000fc2c0000) space capacity = 21757952, 11.90770160721009 usedInvocations: 0  </li>
</ol>
<p>hsdb&gt; universe</p>
<p>Heap Parameters:
Gen 0:   eden [0x00000000fa400000,0x00000000fa4aad68,0x00000000fa6b0000) space capacity = 2818048, 24.831088753633722 used</p>
<p>  from [0x00000000fa6b0000,0x00000000fa6b0000,0x00000000fa700000) space capacity = 327680, 0.0 used
  to   [0x00000000fa700000,0x00000000fa700000,0x00000000fa750000) space capacity = 327680, 0.0 usedInvocations: 0</p>
<p>Gen 1:   old  [0x00000000fa750000,0x00000000fa750000,0x00000000fae00000) space capacity = 7012352, 0.0 usedInvocations: 0</p>
<p>  perm <a href="&quot;复制代码&quot;">0x00000000fae00000,0x00000000fb078898,0x00000000fc2c0000) space capacity = 21757952, 11.90770160721009 usedInvocations: 0
这里用的是HotSpot VM的serial GC。GC堆由young gen = DefNewGeneration（包括eden和两个survivor space）、old gen = TenuredGeneration和perm gen = PermGen构成。
其中young gen和old gen构成了这种配置下HotSpot VM里的Java堆（Java heap），而perm gen不属于Java heap的一部分，它存储的主要是元数据或者叫反射信息，主要用于实现JVM规范里的“方法区”概念。
在我们的Java代码里，执行到Test.fn()末尾为止应该创建了3个Test2的实例。它们必然在GC堆里，但都在哪里呢？用scanoops命令来看：
Hsdb代码 [<img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; scanoops 0x00000000fa400000 0x00000000fc2c0000 Test2  </li>
<li>0x00000000fa49a710 Test2  </li>
<li>0x00000000fa49a730 Test2  </li>
<li>0x00000000fa49a740 Test2  </li>
</ol>
<p>hsdb&gt; scanoops 0x00000000fa400000 0x00000000fc2c0000 Test2</p>
<p>0x00000000fa49a710 Test2
0x00000000fa49a730 Test2</p>
<p>0x00000000fa49a740 Test2
scanoops接受两个必选参数和一个可选参数：必选参数是要扫描的地址范围，一个是起始地址一个是结束地址；可选参数用于指定要扫描什么类型的对象实例。实际扫描的时候会扫出指定的类型及其派生类的实例。
这里可以看到确实扫出了3个Test2的实例。内容有两列：左边是对象的起始地址，右边是对象的实际类型。
从它们所在的地址，对照前面universe命令看到的GC堆的地址范围，可以知道它们都在eden里。
通过whatis命令可以进一步知道它们都在eden之中分配给main线程的thread-local allocation buffer (TLAB)中：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; whatis 0x00000000fa49a710  </li>
<li>Address 0x00000000fa49a710: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)  </li>
<li></li>
<li>hsdb&gt; whatis 0x00000000fa49a730  </li>
<li>Address 0x00000000fa49a730: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)  </li>
<li></li>
<li>hsdb&gt; whatis 0x00000000fa49a740  </li>
<li>Address 0x00000000fa49a740: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)  </li>
<li></li>
<li>hsdb&gt;   </li>
</ol>
<p>hsdb&gt; whatis 0x00000000fa49a710</p>
<p>Address 0x00000000fa49a710: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)</p>
<p>hsdb&gt; whatis 0x00000000fa49a730
Address 0x00000000fa49a730: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)</p>
<p>hsdb&gt; whatis 0x00000000fa49a740</p>
<p>Address 0x00000000fa49a740: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)</p>
<p>hsdb&gt;
还可以用inspect命令来查看对象的内容：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fa49a710  </li>
<li>instance of Oop for Test2 @ 0x00000000fa49a710 @ 0x00000000fa49a710 (size = 16)  </li>
<li>_mark: 1  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fa49a710</p>
<p>instance of Oop for Test2 @ 0x00000000fa49a710 @ 0x00000000fa49a710 (size = 16)
_mark: 1
可见一个Test2的实例要16字节。因为Test2类没有任何Java层的实例字段，这里就没有任何Java实例字段可显示。不过本来这里还应该显示一行：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>_metadata._compressed_klass: InstanceKlass for Test2 @ 0x00000000fb078608  </li>
</ol>
<p>_metadata._compressed_klass: InstanceKlass for Test2 @ 0x00000000fb078608
不幸因为这个版本的HotSpot VM里带的SA有bug所以没显示出来。此bug在新版里已修。
还想看到更裸的数据的同学可以用mem命令来看实际内存里的数据长啥样：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; mem 0x00000000fa49a710 2  </li>
<li>0x00000000fa49a710: 0x0000000000000001   </li>
<li>0x00000000fa49a718: 0x00000000fb078608   </li>
</ol>
<p>hsdb&gt; mem 0x00000000fa49a710 2</p>
<p>0x00000000fa49a710: 0x0000000000000001
0x00000000fa49a718: 0x00000000fb078608
mem命令接受的两个参数都必选，一个是起始地址，另一个是以字宽为单位的“长度”。我们知道一个Test2实例有16字节，所以给定长度为2来看。
上面的数字都是啥来的呢？
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0x00000000fa49a710:  _mark:                        0x0000000000000001   </li>
<li>0x00000000fa49a718:  _metadata._compressed_klass:  0xfb078608  </li>
<li>0x00000000fa49a71c:  (padding):                    0x00000000  </li>
</ol>
<p>0x00000000fa49a710:  _mark:                        0x0000000000000001</p>
<p>0x00000000fa49a718:  _metadata._compressed_klass:  0xfb078608
0x00000000fa49a71c:  (padding):                    0x00000000
一个Test2的实例包含2个给VM用的隐含字段作为对象头，和0个Java字段。
对象头的第一个字段是mark word，记录该对象的GC状态、同步状态、identity hash code之类的多种信息。
对象头的第二个字段是个类型信息指针，klass pointer。这里因为默认开启了压缩指针，所以本来应该是64位的指针存在了32位字段里。
最后还有4个字节是为了满足对齐需求而做的填充（padding）。
以前在另一帖里也介绍过这部分内容，可以参考：<a href="http://rednaxelafx.iteye.com/blog/730461" target="_blank">借助HotSpot SA来一窥PermGen上的对象</a>
顺带发张Inspector的截图来展示HotSpot VM里描述Test2类的VM对象长啥样吧。
在菜单里选Tools -&gt; Inspector，在地址里输入前面看到的klass地址：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
InstanceKlass存着Java类型的名字、继承关系、实现接口关系，字段信息，方法信息，运行时常量池的指针，还有内嵌的虚方法表（vtable）、接口方法表（itable）和记录对象里什么位置上有GC会关心的指针（oop map）等等。
留意到这个InstanceKlass是给VM内部用的，并不直接暴露给Java层；InstanceKlass不是java.lang.Class的实例。
在HotSpot VM里，java.lang.Class的实例被称为“Java mirror”，意思是它是VM内部用的klass对象的“镜像”，把klass对象包装了一层来暴露给Java层使用。
在InstanceKlass里有个_java_mirror字段引用着它对应的Java mirror，而mirror里也有个隐藏字段指向其对应的InstanceKlass。
所以当我们写obj.getClass()，在HotSpot VM里实际上经过了两层间接引用才能找到最终的Class对象：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>obj-&gt;_klass-&gt;_java_mirror  </li>
</ol>
<p>obj-&gt;_klass-&gt;_java_mirror
在Oracle JDK7之前，Oracle/Sun JDK的HotSpot VM把Java类的静态变量存在InstanceKlass结构的末尾；从Oracle JDK7开始，为了配合PermGen移除的工作，Java类的静态变量被挪到Java mirror（Class对象）的末尾了。</p>
<h1 id="-jdk7-java-mirror-permgen-jdk7-java-mirror-java-eden-permgen-jdk8-permgen-klass-gc-java-mirror-jdk7-">还有就是，在JDK7之前Java mirror存放在PermGen里，而从JDK7开始Java mirror默认也跟普通Java对象一样先从eden开始分配而不放在PermGen里。到JDK8则进一步彻底移除了PermGen，把诸如klass之类的元数据都挪到GC堆之外管理，而Java mirror的处理则跟JDK7一样。</h1>
<p>前面对HSDB的操作和HotSpot VM里的一些内部数据结构有了一定的了解，现在让我们回到主题：找指针！
HotSpot VM内部使用直接指针来实现Java引用。在64位环境中有可能启用“压缩指针”的功能把64位指针压缩到只用32位来存。压缩指针与非压缩指针直接有非常简单的1对1对应关系，前者可以看作后者的特例。
于是我们要找t1、t2、t3这三个变量，等同于找出存有指向上述3个Test2实例的地址的存储位置。
不嫌麻烦的话手工扫描内存去找也能找到，不过幸好HSDB内建了revptrs命令，可以找出“反向指针”——如果a变量引用着b对象，那么对b对象来说a就是一个“反向指针”。
先拿第一个Test2的实例试试看：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; revptrs 0x00000000fa49a710  </li>
<li>Computing reverse pointers...  </li>
<li>Done.  </li>
<li>null  </li>
<li>Oop for java/lang/Class @ 0x00000000fa499b00  </li>
</ol>
<p>hsdb&gt; revptrs 0x00000000fa49a710</p>
<p>Computing reverse pointers...
Done.</p>
<p>null
Oop for java/lang/Class @ 0x00000000fa499b00
还真的找到了一个包含指向Test2实例的指针，在一个java.lang.Class的实例里。
用whatis命令来看看这个Class对象在哪里：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; whatis 0x00000000fa499b00  </li>
<li>Address 0x00000000fa499b00: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)  </li>
<li></li>
</ol>
<p>hsdb&gt; whatis 0x00000000fa499b00</p>
<p>Address 0x00000000fa499b00: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)</p>
<p>可以看到这个Class对象也在eden里，具体来说在main线程的TLAB里。
这个Class对象是如何引用到Test2的实例的呢？再用inspect命令：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fa499b00  </li>
<li>instance of Oop for java/lang/Class @ 0x00000000fa499b00 @ 0x00000000fa499b00 (size = 120)  </li>
<li>&lt;<Reverse pointers>&gt;:   </li>
<li>t1: Oop for Test2 @ 0x00000000fa49a710 Oop for Test2 @ 0x00000000fa49a710  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fa499b00</p>
<p>instance of Oop for java/lang/Class @ 0x00000000fa499b00 @ 0x00000000fa499b00 (size = 120)
&lt;<Reverse pointers>&gt;:</p>
<p>t1: Oop for Test2 @ 0x00000000fa49a710 Oop for Test2 @ 0x00000000fa49a710
可以看到，这个Class对象里存着Test类的静态变量t1，指向着第一个Test2实例。
<strong>成功找到t1了！这个有点特别，本来JVM规范里也没明确规定静态变量要存在哪里，通常认为它应该在概念中的“方法区”里；但现在在JDK7的HotSpot VM里它实质上也被放在Java heap里了。可以把这种特例看作是HotSpot VM把方法区的一部分数据也放在Java heap里了。
前面也已经提过，在JDK7之前的Oracle/Sun JDK里的HotSpot VM把静态变量存在InstanceKlass末尾，存在PermGen里。那个时候的PermGen更接近于完整的方法区一些。</strong>
关于PermGen移除计划的一些零星笔记可以参考<a href="http://rednaxelafx.iteye.com/blog/905273" target="_blank">我以前一老帖</a>。
再接再厉，用revptrs看看第二个Test2实例有谁引用：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; revptrs 0x00000000fa49a730  </li>
<li>Oop for Test @ 0x00000000fa49a720  </li>
</ol>
<p>hsdb&gt; revptrs 0x00000000fa49a730</p>
<p>Oop for Test @ 0x00000000fa49a720
找到了一个Test实例。同样用whatis来看看它在哪儿：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; whatis 0x00000000fa49a720  </li>
<li>Address 0x00000000fa49a720: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)  </li>
<li></li>
</ol>
<p>hsdb&gt; whatis 0x00000000fa49a720</p>
<p>Address 0x00000000fa49a720: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)</p>
<p>果然也在main线程的TLAB里。
然后看这个Test实例的内容：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fa49a720  </li>
<li>instance of Oop for Test @ 0x00000000fa49a720 @ 0x00000000fa49a720 (size = 16)  </li>
<li>&lt;<Reverse pointers>&gt;:   </li>
<li>_mark: 1  </li>
<li>t2: Oop for Test2 @ 0x00000000fa49a730 Oop for Test2 @ 0x00000000fa49a730  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fa49a720</p>
<p>instance of Oop for Test @ 0x00000000fa49a720 @ 0x00000000fa49a720 (size = 16)
&lt;<Reverse pointers>&gt;:</p>
<p>_mark: 1
t2: Oop for Test2 @ 0x00000000fa49a730 Oop for Test2 @ 0x00000000fa49a730
可以看到这个Test实例里有个成员字段t2，指向了第二个Test2实例。
<strong>于是t2也找到了！在Java堆里，作为Test的实例的成员字段存在。</strong>
那么赶紧试试用revptrs命令看第三个Test2实例：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; revptrs 0x00000000fa49a740  </li>
<li>null  </li>
</ol>
<p>hsdb&gt; revptrs 0x00000000fa49a740</p>
<p>null
啥？没找到？！SA这也太弱小了吧。明明就在那里…
回头我会做个补丁让新版HotSpot VM的SA能处理这种情况。
这个时候的HSDB界面全貌：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
0x00000000fa49a740看起来有没有点眼熟？
回到前面打开的Stack Memory窗口看，仔细看会发现那个窗口里正好就有0x00000000fa49a740这数字，位于0x000000000287f858地址上。
实际情况是，下面这张图里红色框住的部分就是main线程上Test.fn()的调用对应的栈帧：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
如果图里看得不清楚的话，我再用文字重新写一遍（两道横线之间的是Test.fn()的栈帧内容，前后的则是别的东西）：
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0x000000000287f7f0: 0x0000000002886298   </li>
<li>0x000000000287f7f8: 0x0000000002893ca5   </li>
<li>0x000000000287f800: 0x0000000002893ca5   </li>
<li><hr>
</li>
<li>Stack frame for Test.fn() @bci=8, line=6, pc=0x0000000002893ca5, methodOop=0x00000000fb077f78 (Interpreted frame)  </li>
<li>0x000000000287f808: 0x000000000287f808 expression stack bottom          &lt;- rsp  </li>
<li>0x000000000287f810: 0x00000000fb077f58 bytecode pointer    = 0x00000000fb077f50 (base) + 8 (bytecode index) in PermGen  </li>
<li>0x000000000287f818: 0x000000000287f860 pointer to locals  </li>
<li>0x000000000287f820: 0x00000000fb078360 constant pool cache = ConstantPoolCache for Test in PermGen  </li>
<li>0x000000000287f828: 0x0000000000000000 method data oop     = null  </li>
<li>0x000000000287f830: 0x00000000fb077f78 method oop          = Method for Test.fn()V in PermGen  </li>
<li>0x000000000287f838: 0x0000000000000000 last Java stack pointer (not set)  </li>
<li>0x000000000287f840: 0x000000000287f860 old stack pointer (saved rsp)  </li>
<li>0x000000000287f848: 0x000000000287f8a8 old frame pointer (saved rbp)    &lt;- rbp  </li>
<li>0x000000000287f850: 0x0000000002886298 return address      = in interpreter codelet &quot;return entry points&quot; [0x00000000028858b8, 0x00000000028876c0)  7688 bytes  </li>
<li>0x000000000287f858: 0x00000000fa49a740 local[1] &quot;t3&quot;       = Oop for Test2 in NewGen  </li>
<li>0x000000000287f860: 0x00000000fa49a720 local[0] &quot;this&quot;     = Oop for Test in NewGen  </li>
<li><hr>
</li>
<li>0x000000000287f868: 0x000000000287f868   </li>
<li>0x000000000287f870: 0x00000000fb077039   </li>
<li>0x000000000287f878: 0x000000000287f8c0   </li>
<li>0x000000000287f880: 0x00000000fb077350   </li>
<li>0x000000000287f888: 0x0000000000000000   </li>
<li>0x000000000287f890: 0x00000000fb077060   </li>
<li>0x000000000287f898: 0x000000000287f860   </li>
<li>0x000000000287f8a0: 0x000000000287f8c0   </li>
<li>0x000000000287f8a8: 0x000000000287f9a0   </li>
<li>0x000000000287f8b0: 0x000000000288062a   </li>
<li>0x000000000287f8b8: 0x00000000fa49a720   </li>
<li>0x000000000287f8c0: 0x00000000fa498ea8   </li>
<li>0x000000000287f8c8: 0x0000000000000000   </li>
<li>0x000000000287f8d0: 0x0000000000000000   </li>
<li>0x000000000287f8d8: 0x0000000000000000   </li>
</ol>
<p>0x000000000287f7f0: 0x0000000002886298</p>
<p>0x000000000287f7f8: 0x0000000002893ca5
0x000000000287f800: 0x0000000002893ca5</p>
<hr>
<p>Stack frame for Test.fn() @bci=8, line=6, pc=0x0000000002893ca5, methodOop=0x00000000fb077f78 (Interpreted frame)</p>
<p>0x000000000287f808: 0x000000000287f808 expression stack bottom          &lt;- rsp
0x000000000287f810: 0x00000000fb077f58 bytecode pointer    = 0x00000000fb077f50 (base) + 8 (bytecode index) in PermGen</p>
<p>0x000000000287f818: 0x000000000287f860 pointer to locals
0x000000000287f820: 0x00000000fb078360 constant pool cache = ConstantPoolCache for Test in PermGen</p>
<p>0x000000000287f828: 0x0000000000000000 method data oop     = null
0x000000000287f830: 0x00000000fb077f78 method oop          = Method for Test.fn()V in PermGen</p>
<p>0x000000000287f838: 0x0000000000000000 last Java stack pointer (not set)
0x000000000287f840: 0x000000000287f860 old stack pointer (saved rsp)</p>
<p>0x000000000287f848: 0x000000000287f8a8 old frame pointer (saved rbp)    &lt;- rbp
0x000000000287f850: 0x0000000002886298 return address      = in interpreter codelet &quot;return entry points&quot; [0x00000000028858b8, 0x00000000028876c0)  7688 bytes</p>
<p>0x000000000287f858: 0x00000000fa49a740 local[1] &quot;t3&quot;       = Oop for Test2 in NewGen
0x000000000287f860: 0x00000000fa49a720 local[0] &quot;this&quot;     = Oop for Test in NewGen</p>
<hr>
<p>0x000000000287f868: 0x000000000287f868</p>
<p>0x000000000287f870: 0x00000000fb077039
0x000000000287f878: 0x000000000287f8c0</p>
<p>0x000000000287f880: 0x00000000fb077350
0x000000000287f888: 0x0000000000000000</p>
<p>0x000000000287f890: 0x00000000fb077060
0x000000000287f898: 0x000000000287f860</p>
<p>0x000000000287f8a0: 0x000000000287f8c0
0x000000000287f8a8: 0x000000000287f9a0</p>
<p>0x000000000287f8b0: 0x000000000288062a
0x000000000287f8b8: 0x00000000fa49a720</p>
<p>0x000000000287f8c0: 0x00000000fa498ea8
0x000000000287f8c8: 0x0000000000000000</p>
<p>0x000000000287f8d0: 0x0000000000000000
0x000000000287f8d8: 0x0000000000000000
回顾<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.6" target="_blank">JVM规范里所描述的Java栈帧结构</a>，包括：
[ 操作数栈  (operand stack)   ]</p>
<p>[ 栈帧信息  (dynamic linking) ]
[ 局部变量区 (local variables) ]
上张<a href="http://www.valleytalk.org/2011/07/28/java-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%EF%BC%8C%E5%8A%A0%E8%BD%BD-%E5%92%8C-%E6%89%A7%E8%A1%8C/" target="_blank">我以前做的投影稿</a>里的图：
<img src="" alt="">
再跟HotSpot VM的解释器所使用的栈帧布局对比看看，是不是正好能对应上？局部变量区（locals）有了，VM所需的栈帧信息也有了；执行到这个位置operand stack正好是空的所以看不到它。
（HotSpot VM里把operand stack叫做expression stack。这是因为operand stack通常只在表达式求值过程中才有内容）
<strong>从Test.fn()的栈帧中我们可以看到t3变量就在locals[1]的位置上。t3变量也找到了！大功告成！</strong>
栈帧信息里具体都是些啥，以后有机会再展开讲吧。
都看到这里了，干脆把main方法的栈帧也如法炮制分析一下。先上图：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
然后再用文字写一次：
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>0x000000000287f7f0: 0x0000000002886298   </li>
<li>0x000000000287f7f8: 0x0000000002893ca5   </li>
<li>0x000000000287f800: 0x0000000002893ca5   </li>
<li>0x000000000287f808: 0x000000000287f808   </li>
<li>0x000000000287f810: 0x00000000fb077f58   </li>
<li>0x000000000287f818: 0x000000000287f860   </li>
<li>0x000000000287f820: 0x00000000fb078360   </li>
<li>0x000000000287f828: 0x0000000000000000   </li>
<li>0x000000000287f830: 0x00000000fb077f78   </li>
<li>0x000000000287f838: 0x0000000000000000   </li>
<li>0x000000000287f840: 0x000000000287f860   </li>
<li>0x000000000287f848: 0x000000000287f8a8   </li>
<li>0x000000000287f850: 0x0000000002886298   </li>
<li>0x000000000287f858: 0x00000000fa49a740   </li>
<li><hr>
</li>
<li>Stack frame for Main.main(java.lang.String[]) @bci=9, line=4, pc=0x0000000002886298, methodOop=0x00000000fb077060 (Interpreted frame)  </li>
<li>0x000000000287f860: 0x00000000fa49a720 expression stack[0] = Oop for Test in NewGen  </li>
<li>0x000000000287f868: 0x000000000287f868 expression stack bottom  </li>
<li>0x000000000287f870: 0x00000000fb077039 bytecode pointer    = 0x00000000fb077030 (base) + 9 (bytecode index) in PermGen  </li>
<li>0x000000000287f878: 0x000000000287f8c0 pointer to locals  </li>
<li>0x000000000287f880: 0x00000000fb077350 constant pool cache = ConstantPoolCache for Main in PermGen  </li>
<li>0x000000000287f888: 0x0000000000000000 method data oop     = null  </li>
<li>0x000000000287f890: 0x00000000fb077060 method oop          = Method for Main.main([Ljava/lang/String;)V in PermGen  </li>
<li>0x000000000287f898: 0x000000000287f860 last Java stack pointer  </li>
<li>0x000000000287f8a0: 0x000000000287f8c0 old stack pointer  </li>
<li>0x000000000287f8a8: 0x000000000287f9a0 old frame pointer  </li>
<li>0x000000000287f8b0: 0x000000000288062a return address      = in StubRoutines  </li>
<li>0x000000000287f8b8: 0x00000000fa49a720 local[1] &quot;test&quot;     = Oop for Test in NewGen  </li>
<li>0x000000000287f8c0: 0x00000000fa498ea8 local[0] &quot;args&quot;     = Oop for java.lang.String[] in NewGen  </li>
<li><hr>
</li>
<li>0x000000000287f8c8: 0x0000000000000000   </li>
<li>0x000000000287f8d0: 0x0000000000000000   </li>
<li>0x000000000287f8d8: 0x0000000000000000   </li>
</ol>
<p>0x000000000287f7f0: 0x0000000002886298</p>
<p>0x000000000287f7f8: 0x0000000002893ca5
0x000000000287f800: 0x0000000002893ca5</p>
<p>0x000000000287f808: 0x000000000287f808
0x000000000287f810: 0x00000000fb077f58</p>
<p>0x000000000287f818: 0x000000000287f860
0x000000000287f820: 0x00000000fb078360</p>
<p>0x000000000287f828: 0x0000000000000000
0x000000000287f830: 0x00000000fb077f78</p>
<p>0x000000000287f838: 0x0000000000000000
0x000000000287f840: 0x000000000287f860</p>
<p>0x000000000287f848: 0x000000000287f8a8
0x000000000287f850: 0x0000000002886298</p>
<h2 id="0x000000000287f858-0x00000000fa49a740">0x000000000287f858: 0x00000000fa49a740</h2>
<p>Stack frame for Main.main(java.lang.String[]) @bci=9, line=4, pc=0x0000000002886298, methodOop=0x00000000fb077060 (Interpreted frame)
0x000000000287f860: 0x00000000fa49a720 expression stack[0] = Oop for Test in NewGen</p>
<p>0x000000000287f868: 0x000000000287f868 expression stack bottom
0x000000000287f870: 0x00000000fb077039 bytecode pointer    = 0x00000000fb077030 (base) + 9 (bytecode index) in PermGen</p>
<p>0x000000000287f878: 0x000000000287f8c0 pointer to locals
0x000000000287f880: 0x00000000fb077350 constant pool cache = ConstantPoolCache for Main in PermGen</p>
<p>0x000000000287f888: 0x0000000000000000 method data oop     = null
0x000000000287f890: 0x00000000fb077060 method oop          = Method for Main.main([Ljava/lang/String;)V in PermGen</p>
<p>0x000000000287f898: 0x000000000287f860 last Java stack pointer
0x000000000287f8a0: 0x000000000287f8c0 old stack pointer</p>
<p>0x000000000287f8a8: 0x000000000287f9a0 old frame pointer
0x000000000287f8b0: 0x000000000288062a return address      = in StubRoutines</p>
<p>0x000000000287f8b8: 0x00000000fa49a720 local[1] &quot;test&quot;     = Oop for Test in NewGen
0x000000000287f8c0: 0x00000000fa498ea8 local[0] &quot;args&quot;     = Oop for java.lang.String[] in NewGen</p>
<hr>
<p>0x000000000287f8c8: 0x0000000000000000</p>
<p>0x000000000287f8d0: 0x0000000000000000
0x000000000287f8d8: 0x0000000000000000
main的栈帧的operand stack就不是空的了，有一个元素，用来传递参数给其调用的Test.fn()方法（作为“this”）。
仔细的同学可能发现了，0x000000000287f860这个地址前面不是说是调用Test.fn()产生的栈帧么？怎么这里又变成调用main()方法的栈帧的一部分了呢？
其实栈帧直接可以有重叠：（再上一张以前做的投影稿里的图）
<img src="&quot;点击查看原始大小图片&quot;" alt="">
这样可以减少传递参数所需的数据拷贝，也节省了空间。
回到HSDB，我们换个方式来把t3变量找出来。这里就需要编译Test.java时给的-g参数所生成的LocalVariableTable的信息了：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>hsdb&gt; jseval &quot;ts = jvm.threads&quot;  </li>
<li>[Thread (address=0x00000000fa48fb38, name=Service Thread), Thread (address=0x00000000fa48fa18, name=C2 CompilerThread1), Thread (address=0x00000000fa48f8f8, name=C2 CompilerThread0), Thread (address=0x00000000fa49d178, name=JDWP Command Reader), Thread (address=0x00000000fa48f820, name=JDWP Event Helper Thread), Thread (address=0x00000000fa48f6d8, name=JDWP Transport Listener: dt_shmem), Thread (address=0x00000000fa48dc88, name=Attach Listener), Thread (address=0x00000000fa48db68, name=Signal Dispatcher), Thread (address=0x00000000fa405828, name=Finalizer), Thread (address=0x00000000fa4053a0, name=Reference Handler), Thread (address=0x00000000fa404860, name=main)]   </li>
<li>hsdb&gt; jseval &quot;t = ts[ts.length - 1]&quot;  </li>
<li>Thread (address=0x00000000fa404860, name=main)   </li>
<li>hsdb&gt; jseval &quot;fs = t.frames&quot;  </li>
<li>[Frame (method=Test.fn(), bci=8, line=6), Frame (method=Main.main(java.lang.String[]), bci=9, line=4)]   </li>
<li>hsdb&gt; jseval &quot;f0 = fs[0]&quot;  </li>
<li>Frame (method=Test.fn(), bci=8, line=6)   </li>
<li>hsdb&gt; jseval &quot;f1 = fs[1]&quot;  </li>
<li>Frame (method=Main.main(java.lang.String[]), bci=9, line=4)   </li>
<li>hsdb&gt; jseval &quot;f0.locals&quot;  </li>
<li>{t3=Object 0x00000000fa49a740}   </li>
<li>hsdb&gt;   </li>
</ol>
<p>hsdb&gt; jseval &quot;ts = jvm.threads&quot;</p>
<p>[Thread (address=0x00000000fa48fb38, name=Service Thread), Thread (address=0x00000000fa48fa18, name=C2 CompilerThread1), Thread (address=0x00000000fa48f8f8, name=C2 CompilerThread0), Thread (address=0x00000000fa49d178, name=JDWP Command Reader), Thread (address=0x00000000fa48f820, name=JDWP Event Helper Thread), Thread (address=0x00000000fa48f6d8, name=JDWP Transport Listener: dt_shmem), Thread (address=0x00000000fa48dc88, name=Attach Listener), Thread (address=0x00000000fa48db68, name=Signal Dispatcher), Thread (address=0x00000000fa405828, name=Finalizer), Thread (address=0x00000000fa4053a0, name=Reference Handler), Thread (address=0x00000000fa404860, name=main)]
hsdb&gt; jseval &quot;t = ts[ts.length - 1]&quot;</p>
<p>Thread (address=0x00000000fa404860, name=main)
hsdb&gt; jseval &quot;fs = t.frames&quot;</p>
<p>[Frame (method=Test.fn(), bci=8, line=6), Frame (method=Main.main(java.lang.String[]), bci=9, line=4)]
hsdb&gt; jseval &quot;f0 = fs[0]&quot;</p>
<p>Frame (method=Test.fn(), bci=8, line=6)
hsdb&gt; jseval &quot;f1 = fs[1]&quot;</p>
<p>Frame (method=Main.main(java.lang.String[]), bci=9, line=4)
hsdb&gt; jseval &quot;f0.locals&quot;</p>
<p>{t3=Object 0x00000000fa49a740}</p>
<h1 id="hsdb-">hsdb&gt;</h1>
<p>上面讲栈帧布局的时候出现了“bytecode pointer”字眼。既然之前被不少好奇的同学问过“JVM里字节码存在哪里”，这里就一并回答掉好了。
强调一点：“字节码”只是元数据的一部分。它只负责描述运行逻辑，而其它信息像是类型名、成员的个数、类型、名字等等都<strong>不是字节码</strong>。在Class文件里是如此，到运行时在JVM里仍然是如此。
HotSpot VM里有一套对象专门用来存放元数据，它们包括：</p>
<ul>
<li>Klass系对象。元数据的最主要入口。用于描述类型的总体信息</li>
<li>ConstantPool/ConstantPoolCache对象。每个InstanceKlass关联着一个ConstantPool，作为该类型的运行时常量池。这个常量池的结构跟Class文件里的常量池基本上是对应的。可以参考<a href="http://hllvm.group.iteye.com/group/topic/26412#post-187861" target="_blank">我以前的一个回帖</a>。ConstantPoolCache主要用于存储某些字节码指令所需的解析（resolve）好的常量项，例如给[get|put]static、[get|put]field、invoke[static|special|virtual|interface|dynamic]等指令对应的常量池项用。</li>
<li>Method对象，用来描述Java方法的总体信息，像是方法入口地址、调用/循环计数器等等</li>
<li>ConstMethod对象，记录着Java方法的不变的描述信息，包括方法名、方法的访问修饰符、<strong>字节码</strong>、行号表、局部变量表等等。注意了，字节码就嵌在这ConstMethod对象里面。</li>
<li>Symbol对象，对应Class文件常量池里的JVM_CONSTANT_Utf8类型的常量。有一个VM全局的SymbolTable管理着所有Symbol。Symbol由所有Java类所共享。</li>
<li>MethodData对象，记录着Java方法执行时的profile信息，例如某方法里的某个字节码之类是否从来没遇到过null，某个条件跳转是否总是走同一个分支，等等。这些信息在解释器（多层编译模式下也在低层的编译生成的代码里）收集，然后供给HotSpot Server Compiler用于做激进优化。
在PermGen移除前，上述元数据对象都在PermGen里，直接被GC管理着。
JDK8彻底移除PermGen后，这些对象被挪到GC堆外的一块叫做Metaspace的空间里做特殊管理，仍然间接的受GC管理。
介绍了背景，让我们回到HSDB里。前面不是说“bytecode pointer (bcp)”嘛，从背景介绍可以知道字节码存在ConstMethod对象里，那就让我们用Test.fn()栈帧里存的bcp来验证一下是否真的如此。
还是用whatis命令：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></li>
</ul>
<ol>
<li>hsdb&gt; whatis 0x00000000fb077f58  </li>
<li>Address 0x00000000fb077f58: In perm generation   perm [0x00000000fae00000,0x00000000fb078898,0x00000000fc2c0000) space capacity = 21757952, 11.90770160721009 used   </li>
</ol>
<p>hsdb&gt; whatis 0x00000000fb077f58</p>
<p>Address 0x00000000fb077f58: In perm generation   perm <a href="&quot;复制代码&quot;">0x00000000fae00000,0x00000000fb078898,0x00000000fc2c0000) space capacity = 21757952, 11.90770160721009 used
这地址确实在PermGen里了。那么inspect一下看看？
Hsdb代码 [<img src="" alt="复制代码"></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fb077f58  </li>
<li>Error: sun.jvm.hotspot.debugger.UnalignedAddressException: 100011  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fb077f58</p>
<p>Error: sun.jvm.hotspot.debugger.UnalignedAddressException: 100011
呃，这样不行。inspect命令只能接受对象的起始地址，但字节码是嵌在ConstMethod对象中间的。
那换条路子。栈帧里还有method oop，指向该栈帧对应的Method对象。先从它入手：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fb077f78  </li>
<li>instance of Method fn()V@0x00000000fb077f78 @ 0x00000000fb077f78 @ 0x00000000fb077f78 (size = 136)  </li>
<li>_mark: 1  </li>
<li>_constMethod: ConstMethod fn()V@0x00000000fb077f08 @ 0x00000000fb077f08 Oop @ 0x00000000fb077f08  </li>
<li>_constants: ConstantPool for Test @ 0x00000000fb077c68 Oop @ 0x00000000fb077c68  </li>
<li>_method_size: 17  </li>
<li>_max_stack: 2  </li>
<li>_max_locals: 2  </li>
<li>_size_of_parameters: 1  </li>
<li>_access_flags: 1  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fb077f78</p>
<p>instance of Method fn()V@0x00000000fb077f78 @ 0x00000000fb077f78 @ 0x00000000fb077f78 (size = 136)
_mark: 1</p>
<p>_constMethod: ConstMethod fn()V@0x00000000fb077f08 @ 0x00000000fb077f08 Oop @ 0x00000000fb077f08
_constants: ConstantPool for Test @ 0x00000000fb077c68 Oop @ 0x00000000fb077c68</p>
<p>_method_size: 17
_max_stack: 2</p>
<p>_max_locals: 2
_size_of_parameters: 1</p>
<p>_access_flags: 1
这样就找到了Test.fn()的Method对象，看到里面的_constMethod字段所指向的ConstMethod对象：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fb077f08  </li>
<li>instance of ConstMethod fn()V@0x00000000fb077f08 @ 0x00000000fb077f08 @ 0x00000000fb077f08 (size = 112)  </li>
<li>_mark: 1  </li>
<li>_method: Method fn()V@0x00000000fb077f78 @ 0x00000000fb077f78 Oop @ 0x00000000fb077f78  </li>
<li>_exception_table: [I @ 0x00000000fae01d50 Oop for [I @ 0x00000000fae01d50  </li>
<li>_constMethod_size: 14  </li>
<li>_flags: 5  </li>
<li>_code_size: 9  </li>
<li>_name_index: 18  </li>
<li>_signature_index: 12  </li>
<li>_generic_signature_index: 0  </li>
<li>_code_size: 9  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fb077f08</p>
<p>instance of ConstMethod fn()V@0x00000000fb077f08 @ 0x00000000fb077f08 @ 0x00000000fb077f08 (size = 112)
_mark: 1</p>
<p>_method: Method fn()V@0x00000000fb077f78 @ 0x00000000fb077f78 Oop @ 0x00000000fb077f78
_exception_table: [I @ 0x00000000fae01d50 Oop for [I @ 0x00000000fae01d50</p>
<p>_constMethod_size: 14
_flags: 5</p>
<p>_code_size: 9
_name_index: 18</p>
<p>_signature_index: 12
_generic_signature_index: 0</p>
<p>_code_size: 9
这个ConstMethod对象从0x00000000fb077f08开始，长度112字节，也就是这个对象的范围是<a href="&quot;复制代码&quot;">0x00000000fb077f08, 0x00000000fb077f78)。bcp指向0x00000000fb077f58，确实在这个ConstMethod范围内。
通过经验可以知道实际上这里字节码的起始地址是0x00000000fb077f50。通过ConstMethod的_code_size字段可以知道该方法的字节码有9字节。找出来用mem命令看看内存里的数据：
Hsdb代码 [<img src="" alt="复制代码"></a></p>
<ol>
<li>hsdb&gt; mem 0x00000000fb077f50 2  </li>
<li>0x00000000fb077f50: 0x4c0001b7590200ca   </li>
<li>0x00000000fb077f58: 0x00000000004105b1   </li>
</ol>
<p>hsdb&gt; mem 0x00000000fb077f50 2</p>
<p>0x00000000fb077f50: 0x4c0001b7590200ca
0x00000000fb077f58: 0x00000000004105b1
这串数字是什么东西呢？展开来写清楚一点就是：
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>0x00000000fb077f50:  bb 00 02  new <cp index /#2> [Class Test2]  </li>
<li>0x00000000fb077f53:  59        dup  </li>
<li>0x00000000fb077f54:  b7 01 00  invokespecial <cp cache index /#1> [Method Test2.<init>()V]  </li>
<li>0x00000000fb077f57:  4c        astore_1  </li>
<li>0x00000000fb077f58:  b1        return  </li>
</ol>
<p>0x00000000fb077f50:  bb 00 02  new <cp index /#2> [Class Test2]</p>
<p>0x00000000fb077f53:  59        dup
0x00000000fb077f54:  b7 01 00  invokespecial <cp cache index /#1> [Method Test2.<init>()V]</p>
<p>0x00000000fb077f57:  4c        astore_1
0x00000000fb077f58:  b1        return
眼尖的同学要吐槽了：在0x00000000fb077f50的字节不是0xca么，怎么变成0xbb了？
其实0xca是JVM规范里有描述的一个可选字节码指令，<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.2" target="_blank">breakpoint</a>
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>0x00000000fb077f50:  ca 00 02  breakpoint // 00 02 not used  </li>
</ol>
<p>0x00000000fb077f50:  ca 00 02  breakpoint // 00 02 not used
还记得本文的实验一开始用了jdb在Test.fn()的入口设置了断点吗？这就是结果——入口处的字节码指令被改写为breakpoint了。当然，原本的字节码指令也还在别的地方存着，等断点解除之后这个位置就会被恢复成原本的0xbb指令。
把ConstMethod里存的字节码跟Class文件里存的比较一下看看。用<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javap.html" target="_blank">javap</a>工具来看Class文件的内容：
Javap代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>public void fn();  </li>
<li>Code:  </li>
<li>stack=2, locals=2, args_size=1  </li>
<li>0:  bb 00 02  new           /#2                  // class Test2  </li>
<li>3:  59        dup  </li>
<li>4:  b7 00 03  invokespecial /#3                  // Method Test2.&quot;<init>&quot;:()V  </li>
<li>7:  4c        astore_1  </li>
<li><p>8:  b1        return  </p>
<p>public void fn();</p>
<p>Code:
stack=2, locals=2, args_size=1</p>
<p>0:  bb 00 02  new           /#2                  // class Test2
3:  59        dup</p>
<p>4:  b7 00 03  invokespecial /#3                  // Method Test2.&quot;<init>&quot;:()V
7:  4c        astore_1</p>
<p>8:  b1        return
几乎一模一样。唯一的不同也是个有趣的小细节：invokespecial的参数的常量池号码不一样了。HotSpot VM执行new指令的时候用的还是Class文件里的常量池号和字节序。而在执行invokespecial时，光是ConstantPool里的的常量项不够地方放解析（resolve）出来的信息，所以把这些信息放在ConstantPoolCache里，然后也把invokespecial指令里的参数改写过来，顺带变成了平台相关的字节序。
同样也看看Main.main()方法。内存内容：
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
</li>
<li><p>hsdb&gt; mem 0x00000000fb077030 2  </p>
</li>
<li>0x00000000fb077030: 0x4c0001b7590200bb   </li>
<li>0x00000000fb077038: 0x214103b10002b62b   </li>
</ol>
<p>hsdb&gt; mem 0x00000000fb077030 2</p>
<p>0x00000000fb077030: 0x4c0001b7590200bb
0x00000000fb077038: 0x214103b10002b62b
展开来注解：
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>0x00000000fb077030:  bb 00 02  new <cp index /#2> [Class Test]  </li>
<li>0x00000000fb077033:  59        dup  </li>
<li>0x00000000fb077034:  b7 01 00  invokespecial <cp cache index /#1> [Method Test.<init>()V]  </li>
<li>0x00000000fb077037:  4c        astore_1  </li>
<li>0x00000000fb077038:  2b        aload_1  </li>
<li>0x00000000fb077039:  b6 02 00  invokevirtual <cp cache index /#2> [Method Test.fn()V]  </li>
<li>0x00000000fb07703c:  b1        return  </li>
</ol>
<p>0x00000000fb077030:  bb 00 02  new <cp index /#2> [Class Test]</p>
<p>0x00000000fb077033:  59        dup
0x00000000fb077034:  b7 01 00  invokespecial <cp cache index /#1> [Method Test.<init>()V]</p>
<p>0x00000000fb077037:  4c        astore_1
0x00000000fb077038:  2b        aload_1</p>
<p>0x00000000fb077039:  b6 02 00  invokevirtual <cp cache index /#2> [Method Test.fn()V]
0x00000000fb07703c:  b1        return
对应的javap输出：
Javap代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>public static void main(java.lang.String[]);  </li>
<li>Code:  </li>
<li>stack=2, locals=2, args_size=1  </li>
<li>0:  bb 00 02  new           /#2                  // class Test  </li>
<li>3:  59        dup  </li>
<li>4:  b7 00 03  invokespecial /#3                  // Method Test.&quot;<init>&quot;:()V  </li>
<li>7:  4c        astore_1  </li>
<li>8:  2b        aload_1  </li>
<li>9:  b6 00 04  invokevirtual /#4                  // Method Test.fn:()V  </li>
<li><p>12:  b1        return  </p>
<p>public static void main(java.lang.String[]);</p>
<p>Code:
stack=2, locals=2, args_size=1</p>
<p>0:  bb 00 02  new           /#2                  // class Test
3:  59        dup</p>
<p>4:  b7 00 03  invokespecial /#3                  // Method Test.&quot;<init>&quot;:()V
7:  4c        astore_1</p>
<p>8:  2b        aload_1
9:  b6 00 04  invokevirtual /#4                  // Method Test.fn:()V</p>
<p>12:  b1        return
好，今天就写到这里吧～</p>
</li>
</ol>

      
    </div>
    <section id='after_content_widget'><div class="widget" id="widget_after_content_wumiiRelatedItems>">
<script type="text/javascript" id="wumiiRelatedItems"></script>
</div><div class="widget" id="widget_after_content_post_footer_info>">
<div class="panel panel-success">
    <div class="panel-heading" align="center">希望本站内容对您有点用处,有什么疑问或建议请在后面留言评论</div>
    <div align="center" class="panel-body">转载请注明作者(<a href="http://itsolife.com/about/">RobinChia</a>)和出处 <a href="http://itsolife.com">It so life</a> ，请勿用于任何商业用途</div>
    <div class="panel-body">本文链接: <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--借HSDB来探索HotSpotVM的运行时数据/">借HSDB来探索HotSpot VM的运行时数据</a></div>
</div>
</div></section>
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--借HSDB来探索HotSpotVM的运行时数据/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--借HSDB来探索HotSpotVM的运行时数据" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>


    <section id='after_post_widget'><div class="widget" id="widget_after_post_post_pageNav>">
<ul class="pager">
  
  <li class="previous"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--两个OOMCases排查过程的分享/" title="两个OOM Cases排查过程的分享">&larr; 两个OOM Cases排查过程的分享</a></li>
  
  
  <li class="next"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--动态跟踪Java代码的执行状况工具--BTrace/" title="动态跟踪Java代码的执行状况工具">动态跟踪Java代码的执行状况工具 &rarr;</a></li>
  
</ul></div><div class="widget" id="widget_after_post_related_posts>">
<ul class="list-group"><li class="list-group-item"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（三）-基本垃圾回收算法/">JVM调优总结（三）</a></li><li class="list-group-item"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_常用--javaenum/">java enum</a></li><li class="list-group-item"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_集合--13_7_5key可以重复的Map集合：IdentityHashMap/">13_7_5 key可以重复的Map集合：IdentityHashMap</a></li><li class="list-group-item"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_集合--java集合类总结/">java集合类总结</a></li><li class="list-group-item"><a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--JDKJREJVM区别/">JDKJREJVM区别</a></li><li class="list-group-item"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--BTrace使用简介/">BTrace使用简介</a></li><li class="list-group-item"><a href="/2014/02/02/2014-02-02-JavaJ2EE-内存分析--jstack命令JavaStackTrace/">jstack命令(Java Stack Trace)</a></li><li class="list-group-item"><a href="/2014/02/02/2014-02-02-JavaJ2EE-IO--说说IO（一）-IO的分层/">说说IO（一）</a></li></ul></div></section>    
	<div id="comments"><!-- Duoshuo Comment BEGIN -->

<div class="ds-thread"  data-thread-key="2014-02-02-JavaJ2EE-JVM--借HSDB来探索HotSpotVM的运行时数据"  data-url="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--借HSDB来探索HotSpotVM的运行时数据/" data-title="借HSDB来探索HotSpot VM的运行时数据"></div>

		

<!-- Duoshuo Comment END -->

</div></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-03-07 09:54:42</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->

<script type="text/javascript">
    var wumiiPermaLink = "http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--借HSDB来探索HotSpotVM的运行时数据/";
    var wumiiTitle = "借HSDB来探索HotSpot VM的运行时数据";
    var wumiiTags = "JVM,Java&J2EE";
    var wumiiCategories = ["Java&J2EE","Java&J2EE","JVM"];
    var wumiiSitePrefix = "http://itsolife.com";
    var wumiiParams = "&num=5&mode=3&pf=JAVASCRIPT";
    _js2load.push({src:'http://widget.wumii.cn/ext/relatedItemsWidget'});
</script>
<a href="http://www.wumii.com/widget/relatedItems" style="border:0;">
<img src="http://static.wumii.cn/images/pixel.png" alt="无觅关联推荐，快速提升流量" style="border:0;padding:0;margin:0;" />
</a>
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
