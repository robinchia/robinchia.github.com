
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>线性表分析及Java实现 | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="线性表分析及Java实现线性表分析及Java实现

文章分类**:综合技术**
   **自己实现线性表之顺序表**
  具体实现代码如下
Java**代码  [**

/// 

/* 自己用数组实现的线性表">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<meta property="og:title" content="线性表分析及Java实现"/>
<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title">线性表分析及Java实现</h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--线性表分析及Java实现/">feb. 2 2014</a></time></span>      
    </header>
    
    <section id='before_content_widget'></section>
    <div class="entry">
      
        <h1 id="-java-">线性表分析及Java实现</h1>
<p><strong><a href="http://java-mzd.iteye.com/blog/826059" target="_blank">线性表分析及Java实现</a></strong></p>
<p><strong>文章分类**</strong>:<a href="http://www.iteye.com/blogs/category/tech" target="_blank">综合技术</a>**</p>
<pre><code>  数据结构中的线性表，对应着Collection中的List接口。

  在本节中，我们将做以下三件事

        第一。我们先来看看线性表的特征

        第二，自己用JAVA实现List

        第三，对比的线性表、链式表性能，以及自己的List性能与JDKList性能对比



** ****线性表特征：**** **

        第一，一个特定的线性表，应该是用来存放特定的某一个类型的元素的（元素的“同一性”）

        第二， 除第一个元素外，其他每一个元素有且仅有一个直接前驱；除最后一个元素外，其他每一个元素有且仅有一个             直接后继（元素的“序偶性”）

        第二， 元素在线性表中的“下标”唯一地确定该元素在表中的相对位置（元素的“索引性”）

   又，一.线性表只是数据的一种逻辑结构，其具体存储结构可以为顺序存储结构和链式储存结构来完成，对应可以得到顺序表和链表，

        二.对线性表的入表和出表顺序做一定的限定，可以得到特殊的线性表，栈(FILO)和队列（FIFO）
</code></pre><p><strong>   **</strong>自己实现线性表之顺序表**</p>
<pre><code>         思路：

            1. 顺序表因为采用顺序存储形式，所以内部使用数组来存储数据

            2.因为存储的具体对象类型不一定，所以采用泛型操作

            3.数组操作优点：1.通过指针快速定位到下表，查询快速

                           缺点：1.数组声明时即需要确定数组大小。当操作中超过容量时，则需要重新声明数组，并且复制当前所有数据

                                    2.当需要在中间进行插入或者删除时，则需要移动大量元素（size-index个）
</code></pre><p>  具体实现代码如下</p>
<p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 自己用数组实现的线性表 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>class</strong> ArrayList<E> {  </p>
</li>
<li><p>Object[] data = <strong>null</strong>;// 用来保存此队列中内容的数组  </p>
</li>
<li><p><strong>int</strong> current;// 保存当前为第几个元素的指标  </p>
</li>
<li><p><strong>int</strong> capacity;// 表示数组大小的指标  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 如果初始化时，未声明大小，则默认为10 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> ArrayList() {  </p>
</li>
<li><p><strong>this</strong>(10);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 初始化线性表，并且声明保存内容的数组大小 </p>
</li>
<li><p>/* @param initalSize </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> ArrayList(<strong>int</strong> initalSize) {  </p>
</li>
<li><p><strong>if</strong> (initalSize &lt; 0) {  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> RuntimeException(&quot;数组大小错误:&quot; + initalSize);  </p>
</li>
<li><p>} <strong>else</strong> {  </p>
</li>
<li><p><strong>this</strong>.data = <strong>new</strong> Object[initalSize];  </p>
</li>
<li><p><strong>this</strong>.current = 0;  </p>
</li>
<li><p>capacity = initalSize;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 添加元素的方法 添加前，先确认是否已经满了 </p>
</li>
<li><p>/* @param e </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>boolean</strong> add(E e) {  </p>
</li>
<li><p>ensureCapacity(current);// 确认容量  </p>
</li>
<li><p><strong>this</strong>.data[current] = e;  </p>
</li>
<li><p>current++;  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 确认系统当前容量是否满足需要,如果满足，则不执行操作 如果不满足，增加容量 </p>
</li>
<li><p>/* @param cur 当前个数 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>private</strong> <strong>void</strong> ensureCapacity(<strong>int</strong> cur) {  </p>
</li>
<li><p><strong>if</strong> (cur == capacity) {  </p>
</li>
<li><p>// 如果达到容量极限，增加10的容量，复制当前数组  </p>
</li>
<li><p><strong>this</strong>.capacity = <strong>this</strong>.capacity + 10;  </p>
</li>
<li><p>Object[] newdata = <strong>new</strong> Object[capacity];  </p>
</li>
<li><p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; cur; i++) {  </p>
</li>
<li><p>newdata[i] = <strong>this</strong>.data[i];  </p>
</li>
<li><p>}  </p>
</li>
<li><p><strong>this</strong>.data = newdata;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 得到指定下标的数据 </p>
</li>
<li><p>/* @param index </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> E get(<strong>int</strong> index) {  </p>
</li>
<li><p>validateIndex(index);  </p>
</li>
<li><p><strong>return</strong> (E) <strong>this</strong>.data[index];  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 返回当前队列大小 </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>int</strong> size() {  </p>
</li>
<li><p><strong>return</strong> <strong>this</strong>.current;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 更改指定下标元素的数据为e </p>
</li>
<li><p>/* @param index  </p>
</li>
<li><p>/* @param e </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>boolean</strong> set(<strong>int</strong> index, E e) {  </p>
</li>
<li><p>validateIndex(index);  </p>
</li>
<li><p><strong>this</strong>.data[index] = e;  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/*  验证当前下标是否合法，如果不合法，抛出运行时异常 </p>
</li>
<li><p>/* @param index 下标 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>private</strong> <strong>void</strong> validateIndex(<strong>int</strong> index) {  </p>
</li>
<li><p><strong>if</strong> (index &lt; 0 || index &gt; current) {  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> RuntimeException(&quot;数组index错误：&quot; + index);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 在指定下标位置处插入数据e </p>
</li>
<li><p>/* @param index 下标 </p>
</li>
<li><p>/* @param e 需要插入的数据 </p>
</li>
<li><p>/* @return  </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>boolean</strong> insert(<strong>int</strong> index, E e) {  </p>
</li>
<li><p>validateIndex(index);  </p>
</li>
<li><p>Object[] tem = <strong>new</strong> Object[capacity];// 用一个临时数组作为备份  </p>
</li>
<li><p>//开始备份数组  </p>
</li>
<li><p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; current; i++) {  </p>
</li>
<li><p><strong>if</strong> (i &lt; index) {  </p>
</li>
<li><p>tem[i] = <strong>this</strong>.data[i];  </p>
</li>
<li><p>}<strong>else</strong> <strong>if</strong>(i==index){  </p>
</li>
<li><p>tem[i]=e;  </p>
</li>
<li><p>}<strong>else</strong> <strong>if</strong>(i&gt;index){  </p>
</li>
<li><p>tem[i]=<strong>this</strong>.data[i-1];  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p><strong>this</strong>.data=tem;  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li><p><br><br>//<em>/</em><br>  /<em> 删除指定下标出的数据<br>    /</em> @param index<br>  /<em> @return<br>   /</em>/<br> <strong>public</strong> <strong>boolean</strong> delete(<strong>int</strong> index){<br>       validateIndex(index);<br>       Object[] tem = <strong>new</strong> Object[capacity];// 用一个临时数组作为备份<br>      //开始备份数组<br>        for (int i = 0; i &lt; current; i++) {<br>          if (i &lt; index) {<br>             tem[i] = this.data[i];<br>          }else if(i==index){<br>             tem[i]=this.data[i+1];<br>          }else if(i&gt;index){<br>               tem[i]=this.data[i+1];<br>          }<br>       }<br>       this.data=tem;<br>      return true;<br>    }<br><br>}  </p>
</li>
</ol>
<p>  <strong> **</strong>自己实现线性表之链表**</p>
<pre><code>     思路：1.链表采用链式存储结构，在内部只需要将一个一个结点链接起来。（每个结点中有关于此结点下一个结点的引用）

     链表操作优点：1.，因为每个结点记录下个结点的引用，则在进行插入和删除操作时，只需要改变对应下标下结点的引用即可

                 缺点：1.要得到某个下标的数据，不能通过下标直接得到，需要遍历整个链表。
</code></pre><p>  实现代码如下</p>
<p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 自己用链式存储实现的线性表 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>class</strong> LinkedList<E> {  </p>
</li>
<li></li>
<li><p><strong>private</strong> Node<E> header = <strong>null</strong>;// 头结点  </p>
</li>
<li><p><strong>int</strong> size = 0;// 表示数组大小的指标  </p>
</li>
<li></li>
<li><p><strong>public</strong> LinkedList() {  </p>
</li>
<li><p><strong>this</strong>.header = <strong>new</strong> Node<E>();  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p><strong>public</strong> <strong>boolean</strong> add(E e) {  </p>
</li>
<li><p><strong>if</strong> (size == 0) {  </p>
</li>
<li><p>header.e = e;  </p>
</li>
<li><p>} <strong>else</strong> {  </p>
</li>
<li><p>// 根据需要添加的内容，封装为结点  </p>
</li>
<li><p>Node<E> newNode = <strong>new</strong> Node<E>(e);  </p>
</li>
<li><p>// 得到当前最后一个结点  </p>
</li>
<li><p>Node<E> last = getNode(size-1);  </p>
</li>
<li><p>// 在最后一个结点后加上新结点  </p>
</li>
<li><p>last.addNext(newNode);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>size++;// 当前大小自增加1  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p><strong>public</strong> <strong>boolean</strong> insert(<strong>int</strong> index, E e) {  </p>
</li>
<li><p>Node<E> newNode = <strong>new</strong> Node<E>(e);  </p>
</li>
<li><p>// 得到第N个结点  </p>
</li>
<li><p>Node<E> cNode = getNode(index);  </p>
</li>
<li><p>newNode.next = cNode.next;  </p>
</li>
<li><p>cNode.next = newNode;  </p>
</li>
<li><p>size++;  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 遍历当前链表，取得当前索引对应的元素 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>private</strong> Node<E> getNode(<strong>int</strong> index) {  </p>
</li>
<li><p>// 先判断索引正确性  </p>
</li>
<li><p><strong>if</strong> (index &gt; size || index &lt; 0) {  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> RuntimeException(&quot;索引值有错：&quot; + index);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Node<E> tem = <strong>new</strong> Node<E>();  </p>
</li>
<li><p>tem = header;  </p>
</li>
<li><p><strong>int</strong> count = 0;  </p>
</li>
<li><p><strong>while</strong> (count != index) {  </p>
</li>
<li><p>tem = tem.next;  </p>
</li>
<li><p>count++;  </p>
</li>
<li><p>}  </p>
</li>
<li><p><strong>return</strong> tem;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 根据索引，取得该索引下的数据 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param index </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> E get(<strong>int</strong> index) {  </p>
</li>
<li><p>// 先判断索引正确性  </p>
</li>
<li><p><strong>if</strong> (index &gt;= size || index &lt; 0) {  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> RuntimeException(&quot;索引值有错：&quot; + index);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Node<E> tem = <strong>new</strong> Node<E>();  </p>
</li>
<li><p>tem = header;  </p>
</li>
<li><p><strong>int</strong> count = 0;  </p>
</li>
<li><p><strong>while</strong> (count != index) {  </p>
</li>
<li><p>tem = tem.next;  </p>
</li>
<li><p>count++;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>E e = tem.e;  </p>
</li>
<li><p><strong>return</strong> e;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p><strong>public</strong> <strong>int</strong> size() {  </p>
</li>
<li><p><strong>return</strong> size;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 设置第N个结点的值 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param x </p>
</li>
<li><p>/* @param e </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>boolean</strong> set(<strong>int</strong> index, E e) {  </p>
</li>
<li><p>// 先判断索引正确性  </p>
</li>
<li><p><strong>if</strong> (index &gt; size || index &lt; 0) {  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> RuntimeException(&quot;索引值有错：&quot; + index);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Node<E> newNode = <strong>new</strong> Node<E>(e);  </p>
</li>
<li><p>// 得到第x个结点  </p>
</li>
<li><p>Node<E> cNode = getNode(index);  </p>
</li>
<li><p>cNode.e = e;  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 用来存放数据的结点型内部类 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>class</strong> Node<e> {  </p>
</li>
<li><p><strong>private</strong> E e;// 结点中存放的数据  </p>
</li>
<li></li>
<li><p>Node() {  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>Node(E e) {  </p>
</li>
<li><p><strong>this</strong>.e = e;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>Node<E> next;// 用来指向该结点的下一个结点  </p>
</li>
<li></li>
<li><p>// 在此结点后加一个结点  </p>
</li>
<li><p><strong>void</strong> addNext(Node<E> node) {  </p>
</li>
<li><p>next = node;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
</ol>
<p><strong>自己实现线性表之栈</strong></p>
<pre><code>     栈是限定仅允许在表的同一端（通常为“表尾”）进行插入或删除操作的线性表。

     允许插入和删除的一端称为栈顶(top)，另一端称为栈底(base)
     特点：后进先出 (LIFO)或，先进后出（FILO）



     因为栈是限定线的线性表，所以，我们可以调用前面两种线性表，只需要对出栈和入栈操作进行设定即可

具体实现代码
</code></pre><p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 自己用数组实现的栈 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>class</strong> ArrayStack<E> {  </p>
</li>
<li><p><strong>private</strong> ArrayList<E> list=<strong>new</strong> ArrayList<E>();//用来保存数据线性表<br>    private  int size;//表示当前栈元素个数  </p>
</li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 入栈操作 </p>
</li>
<li><p>/* @param e </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>void</strong> push(E e){  </p>
</li>
<li><p>list.add(e);  </p>
</li>
<li><p>size++;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 出栈操作 </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> E pop(){  </p>
</li>
<li><p>E e= list.get(size-1);  </p>
</li>
<li><p>size--;  </p>
</li>
<li><p><strong>return</strong> e;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
</ol>
<p> 至于用链表实现栈，则只需要把保存数据的顺序表改成链表即可，此处就不给出代码了</p>
<p><strong>自己实现线性表之队列</strong></p>
<pre><code>    与栈类似

    队列是只允许在表的一端进行插入，而在另一端删除元素的线性表。

    在队列中，允许插入的一端叫队尾（rear），允许删除的一端称为队头(front)。
    特点：先进先出 (FIFO)、后进后出 (LILO)



   同理，我们也可以调用前面两种线性表，只需要对队列的入队和出队方式进行处理即可
</code></pre><p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p><strong>package</strong> cn.javamzd.collection.List;  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 用数组实现的队列 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>class</strong> ArrayQueue<E> {  </p>
</li>
<li><p><strong>private</strong> ArrayList<E> list = <strong>new</strong> ArrayList<E>();// 用来保存数据的队列  </p>
</li>
<li><p><strong>private</strong> <strong>int</strong> size;// 表示当前栈元素个数  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 入队 </p>
</li>
<li><p>/* @param e </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>void</strong> EnQueue(E e) {  </p>
</li>
<li><p>list.add(e);  </p>
</li>
<li><p>size++;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 出队 </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> E DeQueue() {  </p>
</li>
<li><p><strong>if</strong> (size &gt; 0) {  </p>
</li>
<li><p>E e = list.get(0);  </p>
</li>
<li><p>list.delete(0);  </p>
</li>
<li><p><strong>return</strong> e;  </p>
</li>
<li><p>}<strong>else</strong>{  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> RuntimeException(&quot;已经到达队列顶部&quot;);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
</ol>
<p><strong>对比线性表和链式表</strong>
         前面已经说过顺序表和链式表各自的特点，这里在重申一遍</p>
<pre><code>     数组操作优点：1.通过指针快速定位到下标，查询快速

                 缺点：1.数组声明时即需要确定数组大小。当操作中超过容量时，则需要重新声明数组，并且复制当前所有数据

                          2.当需要在中间进行插入或者删除时，则需要移动大量元素（size-index个）    





     链表操作优点：1.，因为每个结点记录下个结点的引用，则在进行插入和删除操作时，只需要改变对应下标下结点的引用即可

                 缺点：1.要得到某个下标的数据，不能通过下标直接得到，需要遍历整个链表。



     现在，我们通过进行增删改查操作来感受一次其效率的差异

     **思路**：通过两个表，各进行大数据量操作（2W）条数据的操作，记录操作前系统时间，操作后系统时间，得出操作时间
</code></pre><p>  实现代码如下</p>
<p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p><strong>package</strong> cn.javamzd.collection.List;  </p>
</li>
<li></li>
<li><p><strong>public</strong> <strong>class</strong> Test {  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* @param args </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </p>
</li>
<li><p>//测试自己实现的ArrayList类和Linkedlist类添加20000个数据所需要的时间  </p>
</li>
<li><p>ArrayList<String> al = <strong>new</strong> ArrayList<String>();  </p>
</li>
<li><p>LinkedList<String> ll = <strong>new</strong> LinkedList<String>();  </p>
</li>
<li><p>Long aBeginTime=System.currentTimeMillis();//记录BeginTime  </p>
</li>
<li><p><strong>for</strong>(<strong>int</strong> i=0;i&lt;30000;i++){  </p>
</li>
<li><p>al.add(&quot;now&quot;+i);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Long aEndTime=System.currentTimeMillis();//记录EndTime  </p>
</li>
<li><p>System.out.println(&quot;arrylist  add time---&gt;&quot;+(aEndTime-aBeginTime));  </p>
</li>
<li><p>Long lBeginTime=System.currentTimeMillis();//记录BeginTime  </p>
</li>
<li><p><strong>for</strong>(<strong>int</strong> i=0;i&lt;30000;i++){  </p>
</li>
<li><p>ll.add(&quot;now&quot;+i);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Long lEndTime=System.currentTimeMillis();//记录EndTime  </p>
</li>
<li><p>System.out.println(&quot;linkedList add time----&gt;&quot;+(lEndTime-lBeginTime));  </p>
</li>
<li></li>
<li><p>//测试JDK提供的ArrayList类和LinkedList类添加20000个数据所需要的世界  </p>
</li>
<li><p>java.util.ArrayList<String> sal=<strong>new</strong> java.util.ArrayList<String>();  </p>
</li>
<li><p>java.util.LinkedList<String> sll=<strong>new</strong> java.util.LinkedList<String>();  </p>
</li>
<li><p>Long saBeginTime=System.currentTimeMillis();//记录BeginTime  </p>
</li>
<li><p><strong>for</strong>(<strong>int</strong> i=0;i&lt;30000;i++){  </p>
</li>
<li><p>sal.add(&quot;now&quot;+i);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Long saEndTime=System.currentTimeMillis();//记录EndTime  </p>
</li>
<li><p>System.out.println(&quot;JDK arrylist  add time---&gt;&quot;+(saEndTime-saBeginTime));  </p>
</li>
<li><p>Long slBeginTime=System.currentTimeMillis();//记录BeginTime  </p>
</li>
<li><p><strong>for</strong>(<strong>int</strong> i=0;i&lt;30000;i++){  </p>
</li>
<li><p>sll.add(&quot;now&quot;+i);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Long slEndTime=System.currentTimeMillis();//记录EndTime  </p>
</li>
<li><p>System.out.println(&quot;JDK linkedList add time----&gt;&quot;+(slEndTime-slBeginTime));  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>}  </p>
<p>得到测试结果如下： </p>
</li>
</ol>
<p>arrylist add time---&gt;446
linkedList add time----&gt;9767
JDK arrylist add time---&gt;13
JDK linkedList add time----&gt;12</p>
<pre><code>    由以上数据，我们可知：
</code></pre><p><strong>           1.JDK**</strong>中的<strong><strong>ArrayList</strong></strong>何<strong><strong>LinkedList</strong></strong>在添加数据时的性能，其实几乎是没有差异的**</p>
<pre><code>       2.我们自己写的List的性能和JDK提供的List的性能还是存在巨大差异的

       3.我们使用链表添加操作，花费的时间是巨大的，比ArrayList都大几十倍



  第三条显然是跟我们最初的设计不相符的，按照我们最初的设想，链表的添加应该比顺序表更省时

  查看我们写的源码，可以发现：

  我们每次添加一个数据时，都需要遍历整个表，得到表尾，再在表尾添加，这是很不科学的



 ** ****现改进如下**：设立一个Node&lt;E&gt;类的成员变量end来指示表尾，这样每次添加时，就不需要再重新遍历得到表尾

  改进后add()方法如下
</code></pre><p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p><strong>public</strong> <strong>boolean</strong> add(E e) {  </p>
</li>
<li><p><strong>if</strong> (size == 0) {  </p>
</li>
<li><p>header.e = e;  </p>
</li>
<li><p>} <strong>else</strong> {  </p>
</li>
<li><p>// 根据需要添加的内容，封装为结点  </p>
</li>
<li><p>Node<E> newNode = <strong>new</strong> Node<E>(e);  </p>
</li>
<li><p>//在表尾添加元素  </p>
</li>
<li><p>last.addNext(newNode);  </p>
</li>
<li><p>//将表尾指向当前最后一个元素  </p>
</li>
<li><p>last = newNode;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>size++;// 当前大小自增加1  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
</ol>
<pre><code>   ArrayList添加的效率和JDK中对比起来也太低

   分析原因为：

   每次扩大容量时，扩大量太小，需要进行的复制操作太多

   现在改进如下：

   每次扩大，则扩大容量为当前的三倍，此改进仅需要更改ensureCapacity()方法中的一行代码，此处就不列出了。
</code></pre><p>改进后，再次运行添加元素测试代码，结果如下：</p>
<p>arrylist add time---&gt;16
linkedList add time----&gt;8
JDK arrylist add time---&gt;7
JDK linkedList add time----&gt;7</p>
<p> 虽然还有改进的空间，但是显然，我们的效果已经大幅度改进了，而且也比较接近JDK了</p>
<p>接下来测试插入操作的效率</p>
<p>  我们只需要将测试代码中的添加方法(add())改成插入方法(insert(int index,E e)),为了使插入次数尽可能多，我们把index都设置为0</p>
<p>测试结果如下：</p>
<p>arrylist inset time---&gt;17
linkedList inset time----&gt;13
JDK arrylist inset time---&gt;503
JDK linkedList inset time----&gt;11</p>
<p><strong>多次测试，发现我们写的**</strong>ArrayList<strong><strong>在插入方法的效率都已经超过</strong></strong>JDK<strong><strong>了，而且也接近</strong></strong>LinkedLst<strong>**了。撒花！！！</strong></p>
<p>接下来测试删除、得到下标等等操作就不一一列出来了（只需要改变每次调用的方法即可）</p>
<p>恩，本来想今晚把所有的集合框架实现都写一下的</p>
<p>但是不知不觉这都又2点了</p>
<p>明早还得去蓝杰上课</p>
<p>果断先睡吧</p>
<p>敬请大家期待我明日大作------------静态/动态查找表的实现，动态查找表查找/加入算法的JAVA实现，Hash表的实现</p>
<p>good night</p>
<p>url: <a href="http://java-mzd.iteye.com/blog/826059" target="_blank">http://java-mzd.iteye.com/blog/826059</a></p>

      
    </div>
    <section id='after_content_widget'><div class="widget" id="widget_after_content_wumiiRelatedItems>">
<script type="text/javascript" id="wumiiRelatedItems"></script>
</div><div class="widget" id="widget_after_content_post_footer_info>">
<div class="panel panel-success">
    <div class="panel-heading" align="center">希望本站内容对您有点用处,有什么疑问或建议请在后面留言评论</div>
    <div align="center" class="panel-body">转载请注明作者(<a href="http://itsolife.com/about/">RobinChia</a>)和出处 <a href="http://itsolife.com">It so life</a> ，请勿用于任何商业用途</div>
    <div class="panel-body">本文链接: <a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--线性表分析及Java实现/">线性表分析及Java实现</a></div>
</div>
</div></section>
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/java深入分析/">java深入分析</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/java深入分析/" class="label label-success">java深入分析</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--线性表分析及Java实现/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-java深入分析--线性表分析及Java实现" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>


    <section id='after_post_widget'><div class="widget" id="widget_after_post_post_pageNav>">
<ul class="pager">
  
  <li class="previous"><a href="/2014/02/02/2014-02-02-JavaJ2EE-proguard--开源混淆工具ProGuard配置详解及配置实例/" title="开源混淆工具ProGuard配置详解及配置实例">&larr; 开源混淆工具ProGuard配置详解及配置实例</a></li>
  
  
  <li class="next"><a href="/2014/02/02/2014-02-02-JavaJ2EE-内存分析--Java内存泄露监控工具-JVM监控工具介绍jstack-jconsole-jinfo-/" title="Java 内存泄露监控工具">Java 内存泄露监控工具 &rarr;</a></li>
  
</ul></div><div class="widget" id="widget_after_post_related_posts>">
<ul class="list-group"><li class="list-group-item"><a href="/2014/02/02/2014-02-02-JavaJ2EE-json--Jackson框架，轻易转换JSON/">Jackson 框架，轻易转换JSON</a></li><li class="list-group-item"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-内存--缓存算法/">缓存算法</a></li><li class="list-group-item"><a href="/2014/02/02/2014-02-02-JavaJ2EE-算法数组优化-加解密--Java加密技术（一）——BASE64与单向加密算法MD5SHAMAC/">Java加密技术（一）——BASE64与单向加密算法MD5&SHA&MAC</a></li><li class="list-group-item"><a href="/2014/02/02/2014-02-02-JavaJ2EE-算法数组优化-数组集合--淘宝面试题：如何充分利用多核CPU，计算很大的List中所有整数的和/">淘宝面试题：如何充分利用多核CPU，计算很大的List中所有整数的和</a></li><li class="list-group-item"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--Java调用windows程序/">Java调用windows程序</a></li><li class="list-group-item"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（十二）-参考资料/">JVM调优总结（十二）</a></li><li class="list-group-item"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--java实现double的精确计算和四舍五入/">java实现double的精确计算和四舍五入</a></li><li class="list-group-item"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（三）-基本垃圾回收算法/">JVM调优总结（三）</a></li></ul></div></section>    
	<div id="comments"><!-- Duoshuo Comment BEGIN -->

<div class="ds-thread"  data-thread-key="2014-02-02-JavaJ2EE-java深入分析--线性表分析及Java实现"  data-url="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--线性表分析及Java实现/" data-title="线性表分析及Java实现"></div>

		

<!-- Duoshuo Comment END -->

</div></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-03-07 09:54:41</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->

<script type="text/javascript">
    var wumiiPermaLink = "http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--线性表分析及Java实现/";
    var wumiiTitle = "线性表分析及Java实现";
    var wumiiTags = "Java&J2EE,java深入分析";
    var wumiiCategories = ["Java&J2EE","Java&J2EE","java深入分析"];
    var wumiiSitePrefix = "http://itsolife.com";
    var wumiiParams = "&num=5&mode=3&pf=JAVASCRIPT";
    _js2load.push({src:'http://widget.wumii.cn/ext/relatedItemsWidget'});
</script>
<a href="http://www.wumii.com/widget/relatedItems" style="border:0;">
<img src="http://static.wumii.cn/images/pixel.png" alt="无觅关联推荐，快速提升流量" style="border:0;padding:0;margin:0;" />
</a>
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
